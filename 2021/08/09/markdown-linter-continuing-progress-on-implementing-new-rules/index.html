<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Jack De Winter" />

        <meta name="description" content="Summary¶ In my last article, I talked about my efforts to streamline the rule implementation process and how that went. In this article, I talk about how that effort continues to pay dividends for the project. Introduction¶ Having looked at the tasks that I need to complete before I even …
" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="markdown linter, core linter, Software Quality, " />

<meta property="og:title" content="Markdown Linter - Continuing Progress On Implementing New Rules "/>
<meta property="og:url" content="https://jackdewinter.github.io/2021/08/09/markdown-linter-continuing-progress-on-implementing-new-rules/" />
<meta property="og:description" content="Summary¶ In my last article, I talked about my efforts to streamline the rule implementation process and how that went. In this article, I talk about how that effort continues to pay dividends for the project. Introduction¶ Having looked at the tasks that I need to complete before I even …" />
<meta property="og:site_name" content="Jack&#39;s Digital Workbench" />
<meta property="og:article:author" content="Jack De Winter" />
<meta property="og:article:published_time" content="2021-08-09T00:00:00-07:00" />
<meta name="twitter:title" content="Markdown Linter - Continuing Progress On Implementing New Rules ">
<meta name="twitter:description" content="Summary¶ In my last article, I talked about my efforts to streamline the rule implementation process and how that went. In this article, I talk about how that effort continues to pay dividends for the project. Introduction¶ Having looked at the tasks that I need to complete before I even …">

        <title>Markdown Linter - Continuing Progress On Implementing New Rules  · Jack&#39;s Digital Workbench
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://jackdewinter.github.io/theme/css/style.min.css?bec7d543">

        <link href="https://jackdewinter.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jack&#39;s Digital Workbench - Full Atom Feed" />


    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="https://jackdewinter.github.io/"><span class=site-name>Jack's Digital Workbench</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       https://jackdewinter.github.io
                                    >Home</a>
                                </li>
                                <li ><a href="https://jackdewinter.github.io/categories">Categories</a></li>
                                <li ><a href="https://jackdewinter.github.io/tags">Tags</a></li>
                                <li ><a href="https://jackdewinter.github.io/archives">Archives</a></li>
                                <li><form class="navbar-search" action="https://jackdewinter.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="https://jackdewinter.github.io/2021/08/09/markdown-linter-continuing-progress-on-implementing-new-rules/">
                Markdown Linter - Continuing Progress On Implementing New Rules
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#what-is-the-audience-for-this-article">What Is the Audience for This Article?</a></li>
<li><a href="#working-fast-and-efficiently-part-two">Working Fast and Efficiently - Part Two</a></li>
<li><a href="#rules-md039-and-md040-getting-lucky">Rules Md039 and Md040 - Getting Lucky</a><ul>
<li><a href="#design">Design</a></li>
<li><a href="#implementation-and-testing">Implementation and Testing</a></li>
</ul>
</li>
<li><a href="#rule-md042-no-empty-links">Rule Md042 - No Empty Links</a><ul>
<li><a href="#implementation-and-testing_1">Implementation and Testing</a></li>
</ul>
</li>
<li><a href="#rule-md045-alternate-image-text">Rule Md045 - Alternate Image Text</a><ul>
<li><a href="#implementation-and-testing_2">Implementation and Testing</a></li>
</ul>
</li>
<li><a href="#rule-md046-code-block-style">Rule Md046 - Code Block Style</a><ul>
<li><a href="#design_1">Design</a></li>
<li><a href="#implementation-and-testing_3">Implementation and Testing</a></li>
</ul>
</li>
<li><a href="#rule-md048-code-fence-style">Rule Md048 - Code Fence Style</a><ul>
<li><a href="#implementation-and-testing_4">Implementation and Testing</a></li>
</ul>
</li>
<li><a href="#rule-md044-capitalization-of-proper-names">Rule Md044 - Capitalization Of Proper Names</a><ul>
<li><a href="#design_2">Design</a></li>
<li><a href="#implementation-and-testing_5">Implementation and Testing</a></li>
<li><a href="#next-iteration-other-elements">Next Iteration: Other Elements</a></li>
<li><a href="#wrap-up">Wrap Up</a></li>
</ul>
</li>
<li><a href="#rule-md034-base-url-used">Rule Md034 - Base Url Used</a><ul>
<li><a href="#design_3">Design</a><ul>
<li><a href="#a-good-course-change">A Good Course Change</a></li>
</ul>
</li>
<li><a href="#implementation-and-testing_6">Implementation and Testing</a></li>
</ul>
</li>
<li><a href="#rule-md028-blanks-in-block-quotes">Rule Md028 - Blanks In Block Quotes</a><ul>
<li><a href="#design_4">Design</a></li>
<li><a href="#implementation-and-testing_7">Implementation and Testing</a></li>
<li><a href="#an-interesting-side-note">An Interesting Side Note</a></li>
</ul>
</li>
<li><a href="#what-was-my-experience-so-far">What Was My Experience So Far?</a></li>
<li><a href="#what-is-next">What is Next?</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">
            
            
<h2 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">¶</a></h2>
<p>In my
<a href="https://jackdewinter.github.io/2021/08/02/markdown-linter-making-progress-on-new-rules/">last article</a>, I talked
about my efforts to streamline the rule implementation process and how that went.
In this article, I talk about how that effort continues to pay dividends for
the project.</p>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">¶</a></h2>
<p>Having looked at the tasks that I need to complete before I even remotely think
about another beta version release for the
<a href="https://github.com/jackdewinter/pymarkdown">PyMarkdown</a> project,
it was obvious to me that I need to implement more linting rules.  Having completed
a big push over the last six months for foundational work, the foundation of
the project was looking stronger than ever.  But without a good set of rules to
provide a decent linting experience, the project is essentially just a very “expensive”
<a href="https://github.github.com/gfm">GitHub Flavored Markdown</a> parser with
some extra features on top.  From my point of view, it was essential to get
more rules completed.</p>
<p>So now, after a couple of weeks of working on this task and some strict
development rules for myself, just over one third of the remaining rules
are now implemented.  Not bad for two weeks’ worth of work!  But I
had to keep that enthusiasm in check, making sure it did not become
complacency.  It was some good progress, but there are still a lot more
rules that need to be implemented.  So, I wanted to keep my enthusiasm,
but at the same time keep it in check with some solid pragmatism.</p>
<p>Given that, some confidence, and a somewhat clear calendar for the week,
I started to work on more linting rules!</p>
<h2 id="what-is-the-audience-for-this-article">What Is the Audience for This Article?<a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link">¶</a></h2>
<p>While detailed more eloquently in
<a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog">this article</a>,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please consult the commits that occurred between
<a href="https://github.com/jackdewinter/pymarkdown/commit/20509ae5bb5b11ff8a9fce8de1452bb5016d10d9">05 Aug 2021</a>
and
<a href="https://github.com/jackdewinter/pymarkdown/commit/267027d3d6a411accf4944a04d7755c6624f7dec">08 Aug 2021</a>.</p>
<h2 id="working-fast-and-efficiently-part-two">Working Fast and Efficiently - Part Two<a class="headerlink" href="#working-fast-and-efficiently-part-two" title="Permanent link">¶</a></h2>
<p>After adding seven new rules last week, I was eager to get back to work
on the
<a href="https://github.com/jackdewinter/pymarkdown">PyMarkdown</a> project
and see if I could implement another seven rules this week.  I was
confident that I had the energy and the effort, but I was not sure if
the remaining rules would lend themselves to the rapid design and
implementation that made achieving the previous week’s progress possible.</p>
<p>Regardless of what those remaining rules looked like, I wanted to try
and keep to my
<a href="https://jackdewinter.github.io/2021/08/02/markdown-linter-making-progress-on-new-rules/#working-fast-and-efficiently">two personal rules</a>
from last week, the 30 minutes design rule and the 2 hour implementation rule,
to see how many more rules I could implement.  If
nothing else, I knew that I could use small variations of those personal
rules to keep me centered and focused on the tasks at hand.  As
I know that I occasionally have problems with focus, so the
decision to keep with a process that helps me keep focus on
the right tasks was not a difficult one to make.</p>
<p>So, with some optimism in mind, I started working on the
new set of rules for this week!</p>
<h2 id="rules-md039-and-md040-getting-lucky">Rules Md039 and Md040 - Getting Lucky<a class="headerlink" href="#rules-md039-and-md040-getting-lucky" title="Permanent link">¶</a></h2>
<p>Picking up the next rule, <em>Md039 - Spaces inside link text</em>, I was lucky
that I was able to complete the design within five minutes.  When I say
that, I am not being flippant or exaggerating about my design skills…
the design of the rule was just that easy.  It
was easy enough that I decided to look ahead at the following rule <em>Md040 - Fenced code
blocks should have a language specified</em>, to see if it followed the same
pattern.  Luckily enough, it did! In both scenarios, the rule reacts to
information that is completely stored within a single token. Based on that
information, working on these two rules together and get them completed as
a pair just seemed like the correct thing to do.</p>
<h3 id="design">Design<a class="headerlink" href="#design" title="Permanent link">¶</a></h3>
<p>As I mentioned in the last section, the design for these two rules was
trivial compared to other rules.  In the case of Rule Md039, all text
used for the link label is stored within the token’s <code>text_from_blocks</code>
field.  For Rule Md040, the text after the Fenced Block boundary characters
is stored within the token’s <code>extracted_text</code> field.
That made the design simple: look for the specified token and check
the specified field to see if it matches the requirements for triggering the
rules.</p>
<h3 id="implementation-and-testing">Implementation and Testing<a class="headerlink" href="#implementation-and-testing" title="Permanent link">¶</a></h3>
<p>Proper testing of every scenario was the hard part for Rule Md039. Because both
Link elements and Image elements are impacted, along with the four types
of notations allowed for each, I created a total of twenty scenario tests
to cover each possibility.  Compared to that, there was little effort
required to create the four scenarios for Rule Md040.</p>
<p>Once those scenarios were completed, the rest of the implementation went
off without any problems.  For Rule Md039, once a Link element or an Image
element is detected, a simple check is required to see if there are any
spaces on either side of the link label.  With that information stored in
the <code>text_from_blocks</code> variable, the following code provides that check:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_inline_link</span> <span class="ow">or</span> <span class="n">token</span><span class="o">.</span><span class="n">is_inline_image</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">text_from_blocks</span> <span class="o">!=</span> <span class="n">token</span><span class="o">.</span><span class="n">text_from_blocks</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
</pre></div>
<p>Similarly for Rule Md040, given the start of a Fenced Code Block element,
a simple check was added to determine if the <code>extracted_text</code> field contained
any characters after removing any whitespace:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_fenced_code_block</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="o">.</span><span class="n">extracted_text</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
</pre></div>
<p>While I know I will not always get as lucky as with the design and
implementation of these two rules, it was nice to know it could
happen every so often.</p>
<h2 id="rule-md042-no-empty-links">Rule Md042 - No Empty Links<a class="headerlink" href="#rule-md042-no-empty-links" title="Permanent link">¶</a></h2>
<p>From the start, I knew that this rule was going to be another rule that
would be handled with a simple implementation. In this case, I noticed
a lot of similarities with Rule Md039.
But instead of checking for spaces on either side of the link label,
it was checking for a link URI that had not been specified.  This
is a trick that authors often use to ensure that they fill in link
URIs with the proper URLs before publishing a document.
As I use this trick myself, I had a personal stake in making sure
that this rule was working properly.</p>
<h3 id="implementation-and-testing_1">Implementation and Testing<a class="headerlink" href="#implementation-and-testing_1" title="Permanent link">¶</a></h3>
<p>As the design of this rule was so like the designs for both
Rule Md039 and Rule Md040, I leveraged their design instead of creating
a new one.  For the testing of this rule, I was fortunate that this
rule only applies to Inline Link elements and Inline Image elements.<sup id="fnref:inline"><a class="footnote-ref" href="#fn:inline">1</a></sup>
As such, I only needed to provide scenarios that deal with both inline
types of links.</p>
<p>With the information that this rule only fires if there is an empty
URI or an empty URI fragment reference, the code for this rule was
quickly implemented:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_inline_link</span> <span class="ow">or</span> <span class="n">token</span><span class="o">.</span><span class="n">is_inline_image</span><span class="p">:</span>
        <span class="n">stripped_link_uri</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">active_link_uri</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stripped_link_uri</span> <span class="ow">or</span> <span class="n">stripped_link_uri</span> <span class="o">==</span> <span class="s2">"#"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
</pre></div>
<h2 id="rule-md045-alternate-image-text">Rule Md045 - Alternate Image Text<a class="headerlink" href="#rule-md045-alternate-image-text" title="Permanent link">¶</a></h2>
<p>At this point, I was hoping that I would find more of these simple rules
to implement, but also dreading them at the same time.  For whatever
reason, I felt that the more of these rules that I found, the more of a
chance that the other rules would be orders of magnitude more difficult.
However irrational it might seem, I worked through those feelings
as distractions and moved on.</p>
<p>But after looking at this rule, it was obvious that it fell into the same
pattern as the last three rules, and I was grateful for the chance to keep
things going forward.</p>
<h3 id="implementation-and-testing_2">Implementation and Testing<a class="headerlink" href="#implementation-and-testing_2" title="Permanent link">¶</a></h3>
<p>With three scenarios to cover inline Image elements and four scenarios to cover
the other three types of Image elements, the scenario tests were covered, and I was
ready to start implementation.  As the Image element’s link label specifies
the alternate image text stored in the <code>img</code> tag’s <code>alt</code> parameter, the
implementation was just to verify that there is text in the <code>text_from_blocks</code>
field, as follows:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_inline_image</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="o">.</span><span class="n">text_from_blocks</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
</pre></div>
<p>As I looked ahead to the next rule to implement, I breathed a sigh of
relief.  It was not a simple one, but it was not an extremely difficult
one either.  Just a good solid rule to work on, nothing more.</p>
<h2 id="rule-md046-code-block-style">Rule Md046 - Code Block Style<a class="headerlink" href="#rule-md046-code-block-style" title="Permanent link">¶</a></h2>
<p>While not as simple as the last four rules, I quickly found out that this
rule followed the pattern of the <em>style</em> rules that I have implemented before.
Looking into what I did for
<a href="https://github.com/jackdewinter/pymarkdown/blob/main/pymarkdown/plugins/rule_md_003.py">Rule Md003</a>
and
<a href="https://github.com/jackdewinter/pymarkdown/blob/main/pymarkdown/plugins/rule_md_004.py">Rule Md004</a>,
I did not believe I had to do a complete rewrite of a rule, just a massaging
of the previous work from those old rules to form a new rule.  Not as easy as
I had gotten used to, but also not as difficult as some other rules either.</p>
<h3 id="design_1">Design<a class="headerlink" href="#design_1" title="Permanent link">¶</a></h3>
<p>In Rule Md003, there is a lot of extra code to determine what the heading
levels were for both the Atx Heading element and the SetExt Heading element.
But looking at Rule Md004, its implementation was a lot simpler.  In the case
of that rule, most of the rule is
geared towards checking if the applied style is correct, with only
a handful of lines used to look for Unordered List elements and to track
different levels of styles of each level of those elements.  As such, it seemed
prudent to base the design for Rule Md046 on Rule Md004, albeit with a couple of changes.</p>
<p>Those changes were simple and easy to implement.  Instead of tracking Unordered
List elements, Code Block elements were tracked.  And instead of tracking the
multiple levels required for the nesting of List elements, a single field
containing a single style was sufficient for this rule.</p>
<h3 id="implementation-and-testing_3">Implementation and Testing<a class="headerlink" href="#implementation-and-testing_3" title="Permanent link">¶</a></h3>
<p>Going through the permutations in my head, there were only three scenario
tests that I needed to write: two Fenced Code Block elements, two Indented Code
Block elements, and a final test with one of each.  For every other combination of
Code Blocks that I came up with, I was able to reduce the combination into one of
those three base scenarios.  Wanting to be sure that I did not miss a combination,
I worked through each of my scenarios again, and arrived at the same result.  Three
scenarios it was.</p>
<p>As indicated in the design, I copied the source for Rule Md004 into <code>rule_md046.py</code>,
with only a couple of changes being required.  Instead of the five styles available
for Rule Md004, I defined a new set of three styles to use:</p>
<div class="highlight"><pre><span></span>    <span class="n">__consistent_style</span> <span class="o">=</span> <span class="s2">"consistent"</span>
    <span class="n">__fenced_style</span> <span class="o">=</span> <span class="s2">"fenced"</span>
    <span class="n">__indented_style</span> <span class="o">=</span> <span class="s2">"indented"</span>
    <span class="n">__valid_styles</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">__consistent_style</span><span class="p">,</span>
        <span class="n">__fenced_style</span><span class="p">,</span>
        <span class="n">__indented_style</span><span class="p">,</span>
    <span class="p">]</span>
</pre></div>
<p>Then, in the <code>next_token</code> function, instead of tracking Unordered List
elements, I modified the code to track Code Block elements.  With
that done, I only needed to set the <code>current_style</code> variable to the
current style, and the code from the previous function did the rest
of the heavy lifting.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_code_block</span><span class="p">:</span>
        <span class="n">current_style</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">RuleMd046</span><span class="o">.</span><span class="n">__fenced_style</span>
            <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_fenced_code_block</span>
            <span class="k">else</span> <span class="n">RuleMd046</span><span class="o">.</span><span class="n">__indented_style</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__actual_style_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__actual_style_type</span> <span class="o">=</span> <span class="n">current_style</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__actual_style_type</span> <span class="o">!=</span> <span class="n">current_style</span><span class="p">:</span>
            <span class="n">extra_data</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Expected: "</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__actual_style_type</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">"; Actual: "</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_style</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span>
                <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">extra_error_information</span><span class="o">=</span><span class="n">extra_data</span>
            <span class="p">)</span>
</pre></div>
<h2 id="rule-md048-code-fence-style">Rule Md048 - Code Fence Style<a class="headerlink" href="#rule-md048-code-fence-style" title="Permanent link">¶</a></h2>
<p>Having just completed the code for Rule Md046, I was fortunate to look
ahead and find that Rule Md048 was almost identical in composition to
Rule Md046.  The only difference was that instead of verifying the style
of the type of Code Block element, this rule was focusing on verifying
the style of the character used to define the Fenced Code Block element
itself.</p>
<h3 id="implementation-and-testing_4">Implementation and Testing<a class="headerlink" href="#implementation-and-testing_4" title="Permanent link">¶</a></h3>
<p>I am sure that any readers will not experience surprise when they find out
that the implementation and testing of this rule were almost exact copies of
the work done for Rule Md046.  Besides the available style names changing,
the only other code that changed was replacing this code:</p>
<div class="highlight"><pre><span></span>    <span class="n">current_style</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">RuleMd046</span><span class="o">.</span><span class="n">__fenced_style</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_fenced_code_block</span>
        <span class="k">else</span> <span class="n">RuleMd046</span><span class="o">.</span><span class="n">__indented_style</span>
    <span class="p">)</span>
</pre></div>
<p>with this code:</p>
<div class="highlight"><pre><span></span>    <span class="n">current_style</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">RuleMd048</span><span class="o">.</span><span class="n">__backtick_style</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">fence_character</span> <span class="o">==</span> <span class="s2">"`"</span>
        <span class="k">else</span> <span class="n">RuleMd048</span><span class="o">.</span><span class="n">__tilde_style</span>
    <span class="p">)</span>
</pre></div>
<p>But having implemented a handful of these low-cost rules in a row, I
was getting a bit <em>restless</em>.  I did not have any issues in getting these
rules completed, but I just felt like I needed a break to shake things
up a bit.  I did not realize that it would be a longer break than I intended.</p>
<h2 id="rule-md044-capitalization-of-proper-names">Rule Md044 - Capitalization Of Proper Names<a class="headerlink" href="#rule-md044-capitalization-of-proper-names" title="Permanent link">¶</a></h2>
<p>Having kept to my two efficiency rules for a while now, I wanted to give
myself a chance to let loose and pick up a medium difficulty rule.  If
nothing else, every rule in the list needs to be implemented, so the work
was not going to be wasted.  With only a small deviation from my efficiency
path, I thought that this rule would be a good one to shake things up a bit.</p>
<p>Honestly, i did not realize how much it would shake things up until it was
all over, with a total of thirty-one tests required to validate it.  I
was in for quite the surprise.</p>
<h3 id="design_2">Design<a class="headerlink" href="#design_2" title="Permanent link">¶</a></h3>
<p>The thing that drew me in to this rule from the beginning is that if felt
like a “simple” search for proper name strings within another string.  Or
at least that is what I thought it was at the start.  As I read through the rule a
bit more, there was one caveat: a configuration value allowing or disallowing
this rule from looking in Code Blocks.</p>
<p>That caveat was important.  Without that configuration value, this rule was a simple
string-in-string search.  With that configuration value, the design would need to deal
with individual types of elements that may contain the proper names that
are being searched for.  While I knew that list contained the Text element
under certain conditions, I was not sure how many other elements would
require similar treatment.</p>
<p>To combat that uncertainty, I decided to use an iterative design approach.
I started the design process by narrowing my scope to the Text element scenario.
For each additional element that needed the same approach, I planned to revisit
the design to resolve any additional issues that crept up.  It was not ideal,
but unless I wanted to spend a lot of time designing everything up front, I
knew it would work.</p>
<p>The basic design was simple: use a simple <em>search-find-next</em> loop on the
lower-case equivalent of the Text element to find every potential candidate
for examination.  For each candidate, ensure that the candidate is isolated
on both sides by whitespace before checking to see if the capitalization
of the candidate matches the requirements for the specified proper name.
Without the isolation by whitespace, a proper name of <code>AD</code> would trigger
on <code>readme.md</code> for the <code>re</code> before the name was found and the <code>me.md</code> after
the name was found.</p>
<h3 id="implementation-and-testing_5">Implementation and Testing<a class="headerlink" href="#implementation-and-testing_5" title="Permanent link">¶</a></h3>
<p>Working through all the input permutations that I needed to test against
this rule, I ended up with thirty-one different scenario tests.  While nine
of them deal with Paragraph elements, the rest of the tests deal with each
of the other elements that can conceivably contain text that needs to be
scanned.  Of those remaining tests, fifteen of those scenario tests dealt
with the various types of links and how they can be put together.  It was
quite the list of tests that I would have to complete.</p>
<p>Starting with the simple cases, the first iteration of the <code>next_token</code>
function was very simple and just focused on Text elements:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__proper_name_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_text</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_in_code_block</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_in_code_blocks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__search_for_matches</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">token_text</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">is_code_block</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_in_code_block</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">is_code_block_end</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_in_code_block</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>
<p>From there, the applicable text was passed to the <code>__search_for_matches</code> function.
That function performed the <em>search-find-next</em> loop through the text for each
of the proper names:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__search_for_matches</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">string_to_check</span><span class="p">,</span>
    <span class="n">context</span><span class="p">,</span>
    <span class="n">token</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">string_to_check</span> <span class="o">=</span> <span class="n">ParserHelper</span><span class="o">.</span><span class="n">remove_all_from_text</span><span class="p">(</span><span class="n">string_to_check</span><span class="p">)</span>
    <span class="n">string_to_check_lower</span> <span class="o">=</span> <span class="n">string_to_check</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">next_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__proper_name_list</span><span class="p">:</span>
        <span class="n">next_name_lower</span> <span class="o">=</span> <span class="n">next_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">search_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">found_index</span> <span class="o">=</span> <span class="n">string_to_check_lower</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">next_name_lower</span><span class="p">,</span> <span class="n">search_start</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">found_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__check_for_proper_match</span><span class="p">(</span>
                <span class="n">string_to_check</span><span class="p">,</span>
                <span class="n">found_index</span><span class="p">,</span>
                <span class="n">next_name</span><span class="p">,</span>
                <span class="n">context</span><span class="p">,</span>
                <span class="n">token</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">search_start</span> <span class="o">=</span> <span class="n">found_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_name</span><span class="p">)</span>
            <span class="n">found_index</span> <span class="o">=</span> <span class="n">string_to_check_lower</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">next_name_lower</span><span class="p">,</span> <span class="n">search_start</span><span class="p">)</span>
</pre></div>
<p>For each candidate found, the <code>__check_for_proper_match</code> function was called
to see if the candidate was properly isolated before checking the capitalization
against the required capitalization:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__check_for_proper_match</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">original_source</span><span class="p">,</span>
    <span class="n">found_index</span><span class="p">,</span>
    <span class="n">required_capitalization</span><span class="p">,</span>
    <span class="n">context</span><span class="p">,</span>
    <span class="n">token</span><span class="p">,</span>
<span class="p">):</span>

    <span class="n">original_found_text</span> <span class="o">=</span> <span class="n">original_source</span><span class="p">[</span>
        <span class="n">found_index</span> <span class="p">:</span> <span class="n">found_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_capitalization</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">after_found_index</span> <span class="o">=</span> <span class="n">found_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_capitalization</span><span class="p">)</span>

    <span class="n">is_character_before_match</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">found_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">is_character_before_match</span> <span class="o">=</span> <span class="n">original_source</span><span class="p">[</span><span class="n">found_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>

    <span class="n">is_character_after_match</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">after_found_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_source</span><span class="p">):</span>
        <span class="n">is_character_after_match</span> <span class="o">=</span> <span class="n">original_source</span><span class="p">[</span><span class="n">after_found_index</span><span class="p">]</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_character_after_match</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_character_before_match</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_found_text</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_capitalization</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">original_found_text</span> <span class="o">!=</span> <span class="n">required_capitalization</span><span class="p">:</span>
            <span class="n">extra_data</span> <span class="o">=</span> <span class="p">(</span> <span class="s2">"Expected: "</span> <span class="o">+</span> <span class="n">required_capitalization</span>
                <span class="o">+</span> <span class="s2">"; Actual: "</span> <span class="o">+</span> <span class="n">original_found_text</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span>
                <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span>
                <span class="n">extra_error_information</span><span class="o">=</span><span class="n">extra_data</span><span class="p">,</span>
            <span class="p">)</span>
</pre></div>
<p>After checking the simple scenario tests involving Text elements and making
sure they were all working, I knew it was time to move on to the other
elements.  But how hard were they going to be to implement?  That I did not
know.</p>
<h3 id="next-iteration-other-elements">Next Iteration: Other Elements<a class="headerlink" href="#next-iteration-other-elements" title="Permanent link">¶</a></h3>
<p>Starting with the Code Span element, I was quickly able to add the required
code to search for any matches.  The only issue was that the line/column number
for any failures pointed to the start of the token, not where the failure occurred.
To adjust for those failures, I added the <code>same_line_offset</code> parameter to the
<code>__search_for_matches</code>.  While I knew it would not handle any cases where the
source data has newlines in it, it was a quick way to adjust the line/column
number in the simple cases without newlines.  For the Code Span element,
I set this parameter to the parts of the element that occur in Markdown
before the text:</p>
<div class="highlight"><pre><span></span>    <span class="n">same_line_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">extracted_start_backticks</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">leading_whitespace</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__search_for_matches</span><span class="p">(</span>
        <span class="n">token</span><span class="o">.</span><span class="n">span_text</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">same_line_offset</span><span class="p">)</span>
</pre></div>
<p>Once the Code Span element was working, the other elements were somewhat easy
to add.  For the Link element, the text in the Link Label is already represented
with a Text element, so I just had to worry about other text that was exposed.
After checking out all four types of links, only the Inline link type has
a component that needs to be checked, the <code>active_link_title</code> field.</p>
<p>That required a bit of work to set up, as there are plenty of scenarios where
an inline Link element has newlines in it.  Taking a slightly different approach,
I created the <code>__adjust_for_newlines_and_search</code> function to compute any offsets
for newlines before performing the search.  That function heavily relies on
the <code>__adjust_for_newlines</code> function to accurately compute the proper offsets
for the line/column number to indicate where the failure occurred.  But having
created those functions, I was able to quickly calculate the variables to represent
the text that occurs in the Link element before the Link Title field.  Not without
some testing errors that I had to resolve, but the changes were quick to
implement and test.</p>
<p>Once the Inline Link element was up and working, adding the cases for both
the Inline Image element and the Link Reference Definition element were quickly
completed.  In both cases, it was the same recipe as with Inline Link elements:
perform the calculations of what the Markdown element looks like before the
specified element and pass it in to the <code>__adjust_for_newlines_and_search</code> function.</p>
<h3 id="wrap-up">Wrap Up<a class="headerlink" href="#wrap-up" title="Permanent link">¶</a></h3>
<p>This rule was not difficult because of any of the individual tasks required
to create this rule.  This rule was difficult to implement because of its
breadth and the adjustments required for the line/column number.  Maybe it
was because of the late hours that I used to work on this rule, but the
line/column adjustments in the <code>__search_for_matches</code> always seemed to have
a glitch that i needed to work out.</p>
<p>It was only after I sat down with my trusty paper and pen, sketching out every
scenario that I was able to clearly see the complexities.  Getting the proper
line number was easy.  But because the reporting code uses a column number of
<code>3</code> to mean <code>add 3 to the column</code> and <code>-3</code> to mean <code>absolute column 3</code>, I had
to do some coding gymnastics.  Not sure if I am going to try and clear that
up in the future, but it is something to consider.</p>
<h2 id="rule-md034-base-url-used">Rule Md034 - Base Url Used<a class="headerlink" href="#rule-md034-base-url-used" title="Permanent link">¶</a></h2>
<p>After the ease of many of the previous rules and the difficulty
of the last rule, it was nice to get a rule that seemed like it
had a medium difficulty. But honestly speaking, from the description that
I read of this rule, I had more questions than answers.</p>
<p>There was one interesting question that I needed to answer, as the documentation added to
<a href="https://github.com/jackdewinter/pymarkdown/blob/main/docs/rules/rule_md034.md">Rule Md034</a>
notes: what is an URL?  Following the proper definition of URLs, they
can be anything from <code>https://google.com</code> to <code>#fragment</code> and everything
in between.  It all depends on the given context as to which definition of
an URL is most applicable to that context.  Even once
that decision is made, trying to come up with anything resembling a complete
algorithm for detecting all valid URLs can be troublesome at best.  I
needed to narrow down the URL context that I was looking for if I had any hope
of being able to create a decent algorithm to find those URLs.
Otherwise, I would need to deal with a nasty Regular Expression
<a href="https://github.com/jhermsmeier/uri.regex/blob/master/pattern.js">like this one</a>.
I wanted to avoid that at all costs.</p>
<p>I experimented with Visual Code and the
<a href="https://github.com/markdownlint/markdownlint">Markdown Lint</a> plugin for
about an hour, trying to get more information on what it considered valid
URLs to be.  My best guess is that the original rule is very tightly focused
on two specific types of URLs: base URLs for HTTP and FTP.  Every other
type of URL that I tried to get the rule to recognize failed. However, almost
every <code>http</code> URL that I tried worked, even some of the wacky <code>http</code> URLs.
Either way, I needed a good place to start from and I felt that the information
helped me find that starting point. So off I went into my design phase.</p>
<h3 id="design_3">Design<a class="headerlink" href="#design_3" title="Permanent link">¶</a></h3>
<p>Since I found the original rule too difficult to read clearly, I
decided to approach the design for this rule from a more foundational
viewpoint.  I would take cues from the original rule, but I
needed to be able to design a rule that had clear goals and
triggering conditions that I could easily defend in the documentation.</p>
<p>Starting at the beginning, the first part of this design
was easy: eliminate this rule firing
within a Code Block element, an HTML Block element, or a Link element.
Within those elements, it did not make sense to look for Bare URLs,
as text within those types of elements intrinsically meant something
different than a normal section of text.  It is those normal blocks
of text that I needed the design to focus on.</p>
<p>Once I had a method to eliminate scanning those types of Text elements,
I had to design a way to properly scan text for a series of characters
that represented an URL.  After having done
that research noted in the previous section, I had <em>an</em> answer. I
was not sure it was the right one, but I had the confidence that it
was a decent answer to start with.  For this rule, URLs were only going
to be HTTP and FTP URLs specifying a path to a resource.
Basically, the rule will recognize what most people using a browser
consider URLs, but only the ones starting with <code>http:</code>, <code>https:</code>, <code>ftp:</code>,
or <code>ftps:</code>.</p>
<p>I felt that the best option to find these URLs was a simple
<em>search-find-next</em> loop.  While I would have liked to avoid having to repeat
the loop for every valid base URL, I did not see any way to avoid it. Small
optimizations like looking for <code>http</code> and then looking for either <code>:</code> or
<code>s:</code> had their merits, but I did not believe they would increase the
performance of the algorithm at all.  So, if any one of those bases matched,
I would pass on that information to another function that would further
evaluate the URL.  Primarily, it would look for the sequence <code>//</code> after
the base URL prefix and proceed from there.</p>
<h4 id="a-good-course-change">A Good Course Change<a class="headerlink" href="#a-good-course-change" title="Permanent link">¶</a></h4>
<p>This is the point after which the “course” of this rule changed more
than any other part of the design. Instead of the previous rule’s
complicated sets of boundary conditions, I decided to create a simpler
set of boundary conditions.  The first condition is that any existing
character before the base URL’s prefix must be a whitespace character. The
second is that the base URL’s prefix must be followed by the sequence <code>//</code>
and at least one non-whitespace character.</p>
<p>I did this for a few reasons, but the most basic reason was for
simplicity.  Explaining the above triggering conditions for this rule
was simple and required two sentences of documentation. By keeping
the triggering conditions simple, I will hopefully also make the
implementation of detecting those triggering conditions simple.
A win for the rule and a win for the user.  I can live with that.</p>
<h3 id="implementation-and-testing_6">Implementation and Testing<a class="headerlink" href="#implementation-and-testing_6" title="Permanent link">¶</a></h3>
<p>Coming up with the scenarios required to test this rule was like
peeling back the layers on an onion.
I started with the scenario of a valid URL within
a Paragraph’s Text element and worked outward from there.  I just
asked myself how the URL could not be detected properly and worked
through each scenario in turn.  When I exhausted those variations,
I made sure that the URLs would only be detected in normal Text elements
by creating scenarios with a valid URL inside of non-normal elements,
such as Code Blocks.  When I was done, I had fourteen scenarios ready
to go.</p>
<p>Moving on to the implementation, it proceeded rather quickly.  After
eliminating any Text elements within Code Block elements, Html Block
elements or Link elements, a simple <em>search-find-next</em> loop was added
to look for multiple occurrences of a base URL prefix within the
provided text.  Once an occurrence was found, it was handed off to
the unwritten <code>__evaluate_possible_url</code> function for evaluation.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">token</span><span class="o">.</span><span class="n">is_text</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__in_code_block</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__in_html_block</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__in_link</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">url_prefix</span> <span class="ow">in</span> <span class="n">RuleMd034</span><span class="o">.</span><span class="n">__valid_uri_types</span><span class="p">:</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">found_index</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">token_text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">url_prefix</span><span class="p">,</span> <span class="n">start_index</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">found_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__evaluate_possible_url</span><span class="p">(</span>
                    <span class="n">token</span><span class="o">.</span><span class="n">token_text</span><span class="p">,</span> <span class="n">url_prefix</span><span class="p">,</span> <span class="n">found_index</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span>
                <span class="p">)</span>
                <span class="n">start_index</span> <span class="o">=</span> <span class="n">found_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">url_prefix</span><span class="p">)</span>
                <span class="n">found_index</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">token_text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">url_prefix</span><span class="p">,</span> <span class="n">start_index</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">is_code_block</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__in_code_block</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">is_code_block_end</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__in_code_block</span> <span class="o">=</span> <span class="bp">False</span>
<span class="o">...</span>
</pre></div>
<p>Following the design, the <code>__evaluate_possible_url</code> function was easy to code.  If there is
no character preceding the location of base URL prefix or if it
is a whitespace character, then the algorithm continues.  From there,
it grabs the next three characters after the found base URL prefix,
verifying that the next two characters are <code>//</code>.  Given that verification,
the only thing left was to make sure that the character after the
sequence <code>//</code> is a non-whitespace character, which was added with ease.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__evaluate_possible_url</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">source_text</span><span class="p">,</span> <span class="n">url_prefix</span><span class="p">,</span> <span class="n">found_index</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">token</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">found_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">source_text</span><span class="p">[</span><span class="n">found_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">):</span>
        <span class="n">url_start_sequence</span> <span class="o">=</span> <span class="n">source_text</span><span class="p">[</span><span class="n">found_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">url_prefix</span><span class="p">)</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">url_start_sequence</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span>
            <span class="ow">and</span> <span class="n">url_start_sequence</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"//"</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">url_start_sequence</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="p">(</span>
                <span class="n">column_number_delta</span><span class="p">,</span> <span class="n">line_number_delta</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">ParserHelper</span><span class="o">.</span><span class="n">adjust_for_newlines</span><span class="p">(</span><span class="n">source_text</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">found_index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span>
                <span class="n">context</span><span class="p">,</span>
                <span class="n">token</span><span class="p">,</span>
                <span class="n">line_number_delta</span><span class="o">=</span><span class="n">line_number_delta</span><span class="p">,</span>
                <span class="n">column_number_delta</span><span class="o">=</span><span class="n">column_number_delta</span><span class="p">,</span>
            <span class="p">)</span>
</pre></div>
<p>In verifying that all scenario tests were passing for this rule, I quickly
noticed that while the rule portion was triggering the rules properly, it
triggered them with the wrong line/column pair.  Having written the
<code>__adjust_for_newlines</code> function as part of the work for Rule Md044, it
seemed wasteful to have to write that rule again.  As such, I refactored
that function into the <code>parser_helper.py</code> module to make it accessible
to both rules.</p>
<p>And as it was Sunday morning when I finished this rule, I hoped I had enough
time to work on another rule before starting to write this article.  As such,
I started with Rule Md028.</p>
<h2 id="rule-md028-blanks-in-block-quotes">Rule Md028 - Blanks In Block Quotes<a class="headerlink" href="#rule-md028-blanks-in-block-quotes" title="Permanent link">¶</a></h2>
<p>No matter how many times I am asked the question about what the most important
construct or algorithm that I have learned is, the answer is always the same:
the finite state machine.  While there are a lot of second places finishes
for that title, I have just found that my learning and my experience with
finite state machines have paid for itself many times over.  Even though the
heart of a finite state machine is the simple concept of tracking transitions,
it is a useful tool in my toolbox.  And sometimes the most useful tools are
the simple tools applied properly.</p>
<p>It was with a bit of a smile on my face that I looked at this rule and
determine right from the start that it was going to need a finite state machine.</p>
<h3 id="design_4">Design<a class="headerlink" href="#design_4" title="Permanent link">¶</a></h3>
<p>Perhaps it is the many parsers and other systems that I have written over
the years, but I instinctively knew that this problem would require a finite
state machine.  To properly detect this scenario, the rule needed to first
look for an end Block Quote token, then one or more Blank Line tokens, and
finally a start Block Quote token.  If at any point it does not find the
type of token it needs to move on, the rule needs to reset its state to look
for the end Block Quote token again.  To me, those all looked like simple
state transitions that needed something to guide them.  A finite state machine
it was.</p>
<h3 id="implementation-and-testing_7">Implementation and Testing<a class="headerlink" href="#implementation-and-testing_7" title="Permanent link">¶</a></h3>
<p>Knowing that this rule would require a finite state machine made the task
of creating the scenario tests easier.  Like my approach with
the last rule, I started with the simple case and worked outwards, following
the transitions in the state machine.  When
I was done, I had eleven scenario tests, including a couple of tests that
included nesting with Block Quotes and Block Quote and Block Quotes and
Lists.</p>
<p>As with all finite state machines, the implementation was all about
transitions:</p>
<div class="highlight"><pre><span></span><span class="n">__look_for_end_of_block_quote</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">__look_for_blank_lines</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">__look_for_start_of_block_quote</span> <span class="o">=</span> <span class="mi">2</span>

<span class="o">...</span>

<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">==</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_end_of_block_quote</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_block_quote_end</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">=</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_blank_lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__found_blank_lines</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">==</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_blank_lines</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_blank_line</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">=</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_start_of_block_quote</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__found_blank_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">token</span><span class="o">.</span><span class="n">is_block_quote_end</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">=</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_end_of_block_quote</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">==</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_start_of_block_quote</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">is_block_quote_start</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">next_blank_lines</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__found_blank_lines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_next_token_error</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">next_blank_lines</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">=</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_end_of_block_quote</span>
    <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">is_blank_line</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__found_blank_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_state</span> <span class="o">=</span> <span class="n">RuleMd028</span><span class="o">.</span><span class="n">__look_for_end_of_block_quote</span>
</pre></div>
<p>This implementation followed my design to the letter, with some tweaks
added in later to address nested Block Quotes: look for the end of a
Block Quote, then one or more Blank Lines, and then the start of another
Block Quote.  If anything fails, reset to looking for the end of a Block
Quote.</p>
<p>The tweak that I added to my design was to allow for multiple blanks lines
to be detected and stored in the list <code>__found_blank_lines</code>.  Then,
if a Block Quote start is found after those Blank Lines, the reporting
of the rule failure can be reported using the tokens for the Blank Lines
instead of the start Block Quote token.  Nothing too big, but a good
tweak to ensure the reporting was clear as to where the failure was.</p>
<p>Nice and simple.  Did I mention I love finite state machines?</p>
<h3 id="an-interesting-side-note">An Interesting Side Note<a class="headerlink" href="#an-interesting-side-note" title="Permanent link">¶</a></h3>
<p>During the implementation process, an interesting thing happened: I
found a parser bug with nesting Lists and Block Quotes.</p>
<div class="highlight"><pre><span></span><span class="o">-</span> <span class="o">&gt;</span> <span class="n">This</span> <span class="k">is</span> <span class="n">one</span> <span class="n">section</span> <span class="k">of</span> <span class="n">a</span> <span class="n">block</span> <span class="n">quote</span>

  <span class="o">&gt;</span> <span class="n">This</span> <span class="k">is</span> <span class="n">the</span> <span class="n">other</span> <span class="n">section</span><span class="p">.</span>
</pre></div>
<p>Thinking that the rule not firing was because of something in the rule,
I added debug information to figure things out.  For whatever reason,
when that Markdown document is parsed, it ends up creating a Block
Quote element that is empty, followed by a Paragraph element.  I added
that one to the Issues List and wrapped up things for the week.</p>
<h2 id="what-was-my-experience-so-far">What Was My Experience So Far?<a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link">¶</a></h2>
<p>Wow! This article went on quite a bit longer than I thought it would.
Believe it or not, when I started writing this article, I was worried
that I would not have enough content for a proper article.</p>
<p>But the reality is that in the last week, I was able to knock 9 rules
off the To-Do list.  That brings the totals from 10 rules completed
to 19 rules completed and from 21 rules left to implement down to 10
rules left to implement.  That honestly is a lot more rules than I
expected out of this last week.  It was a good surprise though, and it
just feels good to be making more progress!</p>
<p>Nothing more than that this week… just trying to chew through the
list of rules to implement as fast and efficiently as possible.</p>
<h2 id="what-is-next">What is Next?<a class="headerlink" href="#what-is-next" title="Permanent link">¶</a></h2>
<p>I must be honest dear readers… the fact that I passed on Rule Md027
last week is starting to get to me.  I think I will try and work on that
this week.  Stay tuned!</p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:inline">
<p>For the other three types of links, a Link Reference Definition element must be used.  As a Link Referenced Definition element must contain a URI, and only an Inline Link element does not require one, only the Inline Link element was required for testing. <a class="footnote-backref" href="#fnref:inline" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>


             
 
                <p id="post-share-links">
    Like this post? Share on:
    <a href="https://twitter.com/intent/tweet?text=Markdown%20Linter%20-%20Continuing%20Progress%20On%20Implementing%20New%20Rules&url=https%3A//jackdewinter.github.io/2021/08/09/markdown-linter-continuing-progress-on-implementing-new-rules/&hashtags=markdown-linter,core-linter" target="_blank" rel="nofollow noopener noreferrer" title="Share on Twitter">Twitter</a>
    ❄
    <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A//jackdewinter.github.io/2021/08/09/markdown-linter-continuing-progress-on-implementing-new-rules/" target="_blank" rel="nofollow noopener noreferrer" title="Share on Facebook">Facebook</a>
    ❄
    <a href="mailto:?subject=Markdown%20Linter%20-%20Continuing%20Progress%20On%20Implementing%20New%20Rules&amp;body=https%3A//jackdewinter.github.io/2021/08/09/markdown-linter-continuing-progress-on-implementing-new-rules/" target="_blank" rel="nofollow noopener noreferrer" title="Share via Email">Email</a>
    </p>

            
            






<section>
    <h6 style="display:none;">Comments</h6>
    <p id="comment-message">So what do you think? Did I miss something? Is any part unclear? Leave your comments below. </p>

    <div class="accordion" id="accordion2">
        <div class="accordion-group">
            <div class="accordion-heading">
                <a class="accordion-toggle disqus-comment-count comment-count"
                   data-toggle="collapse"
                   data-parent="#accordion2"
                   href="https://jackdewinter.github.io/2021/08/09/markdown-linter-continuing-progress-on-implementing-new-rules/#comment_thread"
                   id="comment-accordion-toggle">
                    Comments
                </a>
            </div>
            <div id="comment_thread" class="accordion-body collapse">
                <div class="accordion-inner">
                    <div class="comments">

                        <script src="https://utteranc.es/client.js"
        data-repo="jackdewinter/jackdewinter.github.io"
        data-issue-term="markdown-linter-beta-release-f"
        data-label="Comments"
        data-theme="github-light"
        crossorigin="anonymous"
        async>
</script>

                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

            <hr/>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="https://jackdewinter.github.io/2021/08/02/markdown-linter-making-progress-on-new-rules/" title="Previous: Markdown Linter - Making Progress On New Rules">Markdown Linter - Making Progress On New Rules</a></li>
                <li class="next-article"><a href="https://jackdewinter.github.io/2021/08/16/markdown-linter-dealing-with-rule-md027/" title="Next: Markdown Linter - Dealing With Rule Md027">Markdown Linter - Dealing With Rule Md027</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section id="article-sidebar" class="span2">
    <h4>Reading Time</h4>
    <p>~22 min read</p>
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2021-08-09T00:00:00-07:00">Aug 9, 2021</time>
        <h4>Markdown Linter Beta Release</h4>
    <ul class="multi-parts-list">
            <li >
            <a href="https://jackdewinter.github.io/2021/06/14/markdown-linter-getting-stuff-done/" title="Markdown Linter - Getting Stuff Done">Part 1: Markdown Linter - Getting Stuff Done</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/06/21/markdown-linter-elevating-extensions/" title="Markdown Linter - Elevating Extensions">Part 2: Markdown Linter - Elevating Extensions</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/06/28/markdown-linter-sometimes-you-have-to-go-backwards/" title="Markdown Linter - Sometimes You Have To Go Backwards...">Part 3: Markdown Linter - Sometimes You Have To Go Backwards...</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/07/12/markdown-linter-full-of-sound-and-fury/" title="Markdown Linter - Full Of Sound And Fury">Part 4: Markdown Linter - Full Of Sound And Fury</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/08/02/markdown-linter-making-progress-on-new-rules/" title="Markdown Linter - Making Progress On New Rules">Part 5: Markdown Linter - Making Progress On New Rules</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/07/26/markdown-linter-getting-back-to-new-rules/" title="Markdown Linter - Getting Back To New Rules">Part 6: Markdown Linter - Getting Back To New Rules</a>
            </li>
            <li  class="active-part">
            Part 7: Markdown Linter - Continuing Progress On Implementing New Rules
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/08/16/markdown-linter-dealing-with-rule-md027/" title="Markdown Linter - Dealing With Rule Md027">Part 8: Markdown Linter - Dealing With Rule Md027</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/08/23/markdown-linter-three-more-rules/" title="Markdown Linter - Three More Rules">Part 9: Markdown Linter - Three More Rules</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/08/30/markdown-linter-another-three-done/" title="Markdown Linter - Another Three Done!">Part 10: Markdown Linter - Another Three Done!</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/09/13/markdown-linter-back-to-work/" title="Markdown Linter - Back To Work!">Part 11: Markdown Linter - Back To Work!</a>
            </li>
            <li >
            <a href="https://jackdewinter.github.io/2021/09/20/markdown-linter-race-to-the-finish/" title="Markdown Linter - Race To The Finish">Part 12: Markdown Linter - Race To The Finish</a>
            </li>
    </ul>
            <h4>Category</h4>
            <a class="category-link" href="https://jackdewinter.github.io/categories#software-quality-ref">Software Quality</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://jackdewinter.github.io/tags#core-linter-ref">core linter
                    <span>80</span>
</a></li>
                <li><a href="https://jackdewinter.github.io/tags#markdown-linter-ref">markdown linter
                    <span>98</span>
</a></li>
            </ul>
<h4>Stay in Touch</h4>
<div id="sidebar-social-link">
    <a href="https://github.com/jackdewinter" title="github-alt" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
    <a href="https://www.linkedin.com/in/jackdewinter/" title="linkedin" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="LinkedIn" role="img" viewBox="0 0 512 512" fill="#fff"><rect width="512" height="512" rx="15%" fill="#0077b5"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
    </a>
    <a href="https://jackdewinter.github.io/feeds/all.atom.xml" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="RSS" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#f80"/><circle cx="145" cy="367" r="35" fill="#fff"/><path fill="none" stroke="#fff" stroke-width="60" d="M109 241c89 0 162 73 162 162M109 127c152 0 276 124 276 276"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>
    <div>
        
&copy; Copyright 2021 by Jack De Winter and licensed under a <a rel="license"
  href="http://creativecommons.org/licenses/by/4.0/">
  <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
  Creative Commons Attribution 4.0 International License</a>.

    </div>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>