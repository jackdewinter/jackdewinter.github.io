<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jack's Digital Workbench - Software Quality</title><link href="https://jackdewinter.github.io/" rel="alternate"></link><link href="https://jackdewinter.github.io/feeds/software-quality.atom.xml" rel="self"></link><id>https://jackdewinter.github.io/</id><updated>2020-12-14T00:00:00-08:00</updated><entry><title>Markdown Linter - Delving Into the Issues - 12</title><link href="https://jackdewinter.github.io/2020/12/14/markdown-linter-delving-into-the-issues-12/" rel="alternate"></link><published>2020-12-14T00:00:00-08:00</published><updated>2020-12-14T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-12-14:/2020/12/14/markdown-linter-delving-into-the-issues-12/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/07/markdown-linter-delving-into-the-issues-11/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
worked hard to deal with the 33 scenario tests that I skipped in the last set of commits
due to time constraints.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Pure and simple, this week …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/07/markdown-linter-delving-into-the-issues-11/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
worked hard to deal with the 33 scenario tests that I skipped in the last set of commits
due to time constraints.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Pure and simple, this week was all about resolving the 33 scenario tests that I marked
as disabled from last week.  I was mostly confident at the time that the right decision
was to mark these tests as disabled and commit the changes I had already made.  The
question was whether I could fix this issues in five minutes, five hours, or five days.
If the answer was anything except five minutes, then disabling the tests was the right
thing to do.  Otherwise, it would not be the wrong thing to do, I would just feel
foolish that it could have been dealt with quickly instead of disabling the tests.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/b9b0e9707355c5e174e89588b4085eac912ada5f"&gt;03 Dec 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7137522b730ee7875020e495a39b45f9de2b2866"&gt;06 Dec 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="cleaning-up-from-last-week"&gt;Cleaning Up from Last Week&lt;a class="headerlink" href="#cleaning-up-from-last-week" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the end of the work that I covered in the last article, I marked 33 scenario test
functions as disabled.  While I felt comfortable in disabling them for a bit, I did
not feel comfortable leaving them disabled for too long.  It was time to tackle them and
get them resolved!&lt;/p&gt;
&lt;h3 id="starting-with-html-blocks"&gt;Starting with Html Blocks&lt;a class="headerlink" href="#starting-with-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I needed to start somewhere, and HTML Block elements just seemed like the best place
to start.  There was no real good reason to choose them other than, in my mind, they
were a simple block type.  The text in HTML Block is translated
to HTML with no changes or interpretation, and the start and the stop sequences for
HTML Block are very constrained, but also very simple.  It just seemed like the
simplest place to start for something that I was concerned about.  My concerns?
That solving the problems with all 33 failures were going to be a very difficult task
to accomplish.&lt;/p&gt;
&lt;p&gt;It was during my usual task of research though debugging that I was able to make a
quick breakthrough in diagnosing the problem.  As a lucky observation, I noticed that
when one of the Series M test functions was executed, the test’s Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1. 1.
&lt;span class="nt"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
foo
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resulted in an HTML Block element that started between the end of the sublist and
the end of the list.  When the end of that list occurred, it caused the HTML Block
element to be closed, leaving the last two lines to be interpreted as a Paragraph
containing the text &lt;code&gt;foo&lt;/code&gt; and a Raw HTML element of &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;.  By looking at the
Markdown text above, I believed that both lists should have been closed.  The
HTML Block start element should have closed both Ordered List blocks as the HTML
Block was not indented enough to keep either List block open.  But how was the code
interpreting that Markdown, that was the real question.&lt;/p&gt;
&lt;p&gt;Digging into the code a bit, adding extra debug as I went, I was able to soon figure
out that the parser was trying to close the list, but the right type of close was not
occurring.
As I dug into that code, I noticed that I had found a similar problem with the
Thematic Break element and list closures at some point in the past.  To solve the
problem with Thematic Breaks, I added Thematic Break specific code in the
&lt;code&gt;__check_for_list_closures&lt;/code&gt; function that properly closes the right amount of List
elements if a Thematic Break element occurred within a List element.  After going
through this code and the data from the scenario test’s log, I had a theory that
I had another instance where I needed to follow this pattern.&lt;/p&gt;
&lt;p&gt;To test that theory, I quickly changed the code in the &lt;code&gt;HtmlHelper&lt;/code&gt; class that
checks for the type of HTML block to break out the “is it a HTML start” code from the
“what kind of HTML start is it”.  By creating this new &lt;code&gt;is_html_block&lt;/code&gt; function,
it allowed me to change the &lt;code&gt;__check_for_list_closures&lt;/code&gt; function in the
&lt;code&gt;ListBlockProcessor&lt;/code&gt; class to calculate whether the current line was indeed the
start of a HTML Block, storing that value in the &lt;code&gt;is_html_block&lt;/code&gt; variable.
With that completed, I changed code that specified &lt;code&gt;is_theme_break&lt;/code&gt; as part
of two &lt;code&gt;if&lt;/code&gt; conditions to &lt;code&gt;is_theme_break or is_html_block&lt;/code&gt; and I was ready to go.&lt;/p&gt;
&lt;p&gt;Following my usual pattern of validation scenario tests, I was able to get the
new and changed tokens validated quickly, producing the HTML output that I
expected.  With no other changes, I was able to get all four disabled scenario
tests that dealt with HTML Blocks working again.&lt;/p&gt;
&lt;p&gt;With those four tests no longer being disabled, the total count of scenario tests
to fix was down 4 scenario tests from 33 to 29.  It was a good start, but I still
had a long way to go.  But with momentum on my side, I carried on!&lt;/p&gt;
&lt;h3 id="maintaining-the-momentum-with-fenced-code-blocks"&gt;Maintaining the Momentum with Fenced Code Blocks&lt;a class="headerlink" href="#maintaining-the-momentum-with-fenced-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I had a pattern that worked for one type of block, I decided to try that same pattern
out on the next type of blocks: Fenced Code Blocks. When I did that, I was
pleasantly surprised that following the same pattern led to the same results, with
one exception.  In this case, the “is this a Fenced Code Block start” function
already existed as &lt;code&gt;LeafBlockProcessor.is_fenced_code_block&lt;/code&gt;, so it was easy to
wire it into the &lt;code&gt;__check_for_list_closures&lt;/code&gt; function after assigning it to the
&lt;code&gt;is_fenced_block&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;The one exception was that there was a small failure in the rendering of the Fenced
Code Block tokens to HTML.
In cases where an empty Fenced Code Block element was present, any extra whitespace
in the Blank Line was being added to the HTML output after the newline character,
instead of just adding the newline character.  As this was the only failure, and
(at least to me) it was obvious that this was the issue, I was able to fix it
by adding the &lt;code&gt;exclusion_condition&lt;/code&gt; variable and keying off of that variable.  The
testing for that change happened almost as quickly as the coding did, and I was
able to resolve that group of four failing scenario tests.&lt;/p&gt;
&lt;p&gt;With another 4 tests that were no longer disabled, the disabled test count was now
down to 25.&lt;/p&gt;
&lt;h3 id="atx-headings-for-the-three-peat"&gt;Atx Headings for The Three-peat?&lt;a class="headerlink" href="#atx-headings-for-the-three-peat" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Deciding to work on Atx Headings next, I applied the same pattern and got a very good
result.  Other than that changes required to isolate the “is this an Atx Heading start”
code into its own function (and its inclusion into the &lt;code&gt;__check_for_list_closures&lt;/code&gt;
function), no other Atx Heading code required changes.  After validating and modifying
the tokens for the scenarios, all the tests just passed.  It was so weird to have
that happen, that I ran the scenario tests again just to be sure, and they were
indeed passing.&lt;/p&gt;
&lt;p&gt;To be clear, it was not that I was doubting myself, I just expected a lot more
difficulty in resolving these issues.  But, with a little bit of work, another 3 tests
were removed from the disabled list, bringing the disabled test count down to 22 tests.&lt;/p&gt;
&lt;h3 id="cleaning-up-the-html-indented-code-blocks"&gt;Cleaning Up The HTML: Indented Code Blocks&lt;a class="headerlink" href="#cleaning-up-the-html-indented-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After looking at the disabled tests dealing with Indented Code Block elements,
it was almost immediately obvious the same pattern would not work with these tests.
As far as I
could tell from my initial look, the problem was not with the tokens, but in
the determination of the looseness of the Lists.  In each of the failures, the
only difference was whether the items in the List blocks were surrounded
by HTML’s Paragraph tags or not.  The problem definitely had something to do with
looseness.&lt;/p&gt;
&lt;p&gt;The GFM Specification’s
&lt;a href="https://github.github.com/gfm/#loose"&gt;definition of looseness&lt;/a&gt; states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A list is loose if any of its constituent list items are separated by blank lines, or if any of its constituent list items directly contain two block-level elements with a blank line between them. Otherwise a list is tight. (The difference in HTML output is that paragraphs in a loose list are wrapped in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags, while paragraphs in a tight list are not.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And whether I liked it or not, the HTML output was just a &lt;em&gt;little&lt;/em&gt; bit off.  Not much,
but enough.  Specifically, it was cases in which the Blank Line token was appearing
right after an end List Block token, a case that I felt should not be marked as loose.&lt;/p&gt;
&lt;p&gt;Adding a lot of debug and scanning through the log files, I decided to take an approach
of removing the one set of cases that were producing bad results, rather than redesign
the &lt;code&gt;__calculate_list_looseness&lt;/code&gt; function from the ground up.  As far as I could tell,
everything else was working, just this one case was failing.  Therefore, I created the
new &lt;code&gt;__correct_for_me&lt;/code&gt; function where I looked for Blank Line tokens, looked for the
end List Block tokens directly before it.  At that point, being within the proper list,
the code was then able to make the right determination on the looseness of the list.&lt;/p&gt;
&lt;p&gt;Testing that theory took a while to code up, but the testing went by quickly.  It
was during that testing when I noticed that the whitespace in the Paragraph Block
tokens was off by one.  As the HTML output is checked before the Markdown rehydration
is checked, the issues with the HTML output prevented this issue from being seen.
However, due to the extensive logging I have in place, I was able to quickly deduce
that I had mixed up the passing of the &lt;code&gt;leading_space_length&lt;/code&gt; variable to the
&lt;code&gt;__adjust_line_for_list_in_process&lt;/code&gt; function with the &lt;code&gt;before_ws_length&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;After a quick fix and some retesting, everything was now working, and the count of
failing tests had fallen by another 2 tests down to 20 failing tests.&lt;/p&gt;
&lt;h3 id="the-long-slog-setext-headings"&gt;The Long Slog: SetExt Headings&lt;a class="headerlink" href="#the-long-slog-setext-headings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Working through the previous scenario tests, I was confident looking at the two
tests that deal with SetExt Heading elements that I would be able to deal with
them quickly.  If someone is right with their confidence on something like this, they
are told they are right.  If they are not right, they are usually told that they had
too much hubris.  That day, hubris was having a fun time laughing at me.&lt;/p&gt;
&lt;p&gt;As it was a Saturday, I was doing things around the house and getting them off our
house’s to-do list.  In between each of these tasks, I would sit down and work on trying
to figure out what the issue was with these tests and how to properly identify them.
I was fairly convinced that I needed to be able to detect the start of a SetExt Heading
element.  I was failing miserably on trying to figure out how to perform that
detection. I tried to be smart about the detection, and it failed.  I tried to be
simple about the detection, and that too failed.  And with each attempt, I was just
getting more frustrated.&lt;/p&gt;
&lt;p&gt;It was mainly as a joke that I decided to add &lt;code&gt;or True&lt;/code&gt; to the end of one of the
&lt;code&gt;if&lt;/code&gt; statements.  At the very most, I thought I might possibly find some information
related to the “detecting the start of a SetExt Heading” issue that I was working on.
I was flabbergasted when the scenario tests I was debugging just started working.&lt;/p&gt;
&lt;p&gt;In retrospect, it somewhat makes sense, though I want to dig into that function some
more in the future to verify it.  I believe that it worked because SetExt Heading
elements and Paragraph elements are related.  To get a SetExt Heading, you start with
a Paragraph element, and you transform it into the SetExt Heading element once the
SetExt Heading sequence is seen after that paragraph on its own line.  As such, I
didn’t need to add any extra processing above that of the Paragraph processing to
the first &lt;code&gt;if&lt;/code&gt; statement in the &lt;code&gt;__check_for_list_closures&lt;/code&gt; function, as the Paragraph
element processing was already sufficient.  &lt;/p&gt;
&lt;p&gt;In the case of the second &lt;code&gt;if&lt;/code&gt; statement, all the other types of Leaf Block element had
already been added, so adding &lt;code&gt;or True&lt;/code&gt; just included the one or two remaining types
of leaf blocks that had been missed.  As far as I can tell, it was nothing more than
a shortcut.&lt;/p&gt;
&lt;p&gt;Regardless of whether my guess is correct or not, the count was now down from 20
disabled scenario tests to 18 scenario tests… and these ones were going to take
some time to figure out.&lt;/p&gt;
&lt;h2 id="the-last-18"&gt;The Last 18&lt;a class="headerlink" href="#the-last-18" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I was then down to the last eighteen scenario tests that I needed to get working, and
I knew some serious work was going to be involved.  I had already been thinking about
this for a while, even going as far to contact the
&lt;a href="https://talk.commonmark.org/"&gt;CommonMark Discussion List&lt;/a&gt;
to help understand some of the thorny issues.&lt;/p&gt;
&lt;h3 id="understanding-the-scope-of-the-problem"&gt;Understanding the Scope Of The Problem&lt;a class="headerlink" href="#understanding-the-scope-of-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When all was said and done, these last
scenario tests were failing due to my lack of understanding and implementation of the
following section of the GFM specification:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exceptions:
1. When the first list item in a list interrupts a paragraph—that is, when it starts on a line that would otherwise count as paragraph continuation text—then
(a) the lines Ls must not begin with a blank line, and
(b) if the list item is ordered, the start number must be 1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It took me a bit to work through it, but here is how I think about it.  Take the
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first line clearly starts a list, but it also opens a paragraph block with the text
&lt;code&gt;abc&lt;/code&gt; in it.  Because of that open paragraph, the text in line 2 needs to be handled
carefully, as the previously noted exceptions come into play.  In this case, because of
section (a) of the exceptions, this Markdown will be interpreted as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc
1.&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If there is even 1 non-whitespace character on that second line after the list start
identifier, say the Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then that section of the exceptions is no longer in play, allowing the second line to
be a valid list start:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;a&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, the harder one for me to understand was section (b) of the exceptions.  The
impact of that exception is that while the above example works as I would expect, the
following Markdown did not:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
   &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;producing the following HTML&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc
2. a&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But why?&lt;/p&gt;
&lt;h3 id="everything-is-not-perfect"&gt;Everything Is Not Perfect&lt;a class="headerlink" href="#everything-is-not-perfect" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I could give many different examples of what is and is not a proper
translation, but the example from the discussion forum that sticks in my head a lot is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt; &lt;span class="n"&gt;risked&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt;
   &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;deadline&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;March&lt;/span&gt;
   &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;meeting&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="k"&gt;called&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;architect&lt;/span&gt; &lt;span class="n"&gt;would&lt;/span&gt; &lt;span class="n"&gt;take&lt;/span&gt; &lt;span class="n"&gt;flight&lt;/span&gt;
   &lt;span class="mi"&gt;457&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;It&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="n"&gt;eye&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;She&lt;/span&gt; &lt;span class="n"&gt;would&lt;/span&gt; &lt;span class="n"&gt;stay&lt;/span&gt; &lt;span class="k"&gt;at&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;Hilton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;room&lt;/span&gt;
   &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;It&lt;/span&gt; &lt;span class="n"&gt;had&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;ocean&lt;/span&gt; &lt;span class="k"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First off, this example is plainly an example based in the English language, and I
assumed that equally valid examples could be constructed for any language.  Given that
assumption, when I read that Markdown for the first item in the list, it is obvious to
me that the end of the first item in the list refers to &lt;code&gt;March 13.&lt;/code&gt;, not a sublist
starting at &lt;code&gt;13&lt;/code&gt; with the contents of &lt;code&gt;A meeting was called.&lt;/code&gt;.  The context of the rest
of the sentence leaves me with little doubt that the sentence was written that way.
And each of the other two list items left me with the same confidence.  Those numbers
were part of the sentences, and thus the paragraphs that the sentences were in, not
the starts of new lists.&lt;/p&gt;
&lt;p&gt;But how should the specification handle the codification of this?  The concepts of
“sentence context” and “looks right” do not apply to the specification.  For something
to apply to the specification, there needs to be a solid rule that can be followed
without fail.  In this case, the second exception comes into play:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(b) if the list item is ordered, the start number must be 1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While it is not perfect, this exception allows the specification to handle the above
cases in a way that it has a solid rule to follow, and hence predictable results. No
guesswork or “sentence context” involved.  I believe that &lt;code&gt;@jgm&lt;/code&gt; from the discussion
board put it best:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If we were inventing a light markup language from scratch, I’d want to require a blank line before a list or sublist (see Beyond Markdown), for this and many other reasons.&lt;/p&gt;
&lt;p&gt;But we’re not, so we need to find a compromise that works.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that indeed is a viable solution for starting sublists with any number as the
list’s start number.  Therefore, if you the previous example with a non-one sublist
start of &lt;code&gt;2.&lt;/code&gt; to be rendered properly, you need to add a newline:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;

   &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;producing the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt; &lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"2"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;a&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As &lt;code&gt;@jgm&lt;/code&gt; said, and as I agree with, it is a solid compromise.&lt;/p&gt;
&lt;h3 id="attacking-the-problem"&gt;Attacking the Problem&lt;a class="headerlink" href="#attacking-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first thing that I did was to validate that this issue applied to both Ordered Lists
and Unordered Lists, which was quickly accomplished.  To me, this indicated that I was
going to be making near identical changes to the &lt;code&gt;is_olist_start&lt;/code&gt; function and the
&lt;code&gt;is_ulist_start&lt;/code&gt; function.  As the Order List changes were the most complicated, I
decided to start with those.&lt;/p&gt;
&lt;p&gt;The first part of detecting the condition described above was deciding that the current
line being parsed was already marked for a list start.  This was already being
performed in the function, so it was an easy change to do some extra processing if the
&lt;code&gt;is_start&lt;/code&gt; variable was set.  In that case, to narrow down the things that need to be
checked, the first two changes were to set the &lt;code&gt;is_in_paragraph&lt;/code&gt; variable to indicate
whether a paragraph block was open, and the &lt;code&gt;at_end_of_line&lt;/code&gt; variable to indicate
that there was no more data to process on the line (hence, a blank line).&lt;/p&gt;
&lt;p&gt;With those easy changes out of the way, the variable &lt;code&gt;is_first_item_in_list&lt;/code&gt; needed to
be set to indicate whether or not the proposed Ordered List start sequence actually
indicated a new List item or a brand-new List block.  While lengthy in its description,
the next part of
the algorithm checked, in order, to see if a parent List block contained the Paragraph
element, if it was the same type of List element, if it had the same List character,
and if the start index for the proposed List element was greater than that of a matching
List element already in progress.  If any one of those checks failed, the proposed List
start was stored as &lt;code&gt;True&lt;/code&gt; in the &lt;code&gt;is_first_item_in_list&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;From there, the check was relatively easy.  After an additional change to set the
&lt;code&gt;is_not_one&lt;/code&gt; variable to indicate whether the &lt;code&gt;olist_index_number&lt;/code&gt; variable was not
the string &lt;code&gt;1&lt;/code&gt;, the calculation was easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;is_in_paragraph&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;at_end_of_line&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_not_one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;is_first_item_in_list&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;is_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Following the exceptions detailed earlier, when a new list start occurs within an
ongoing paragraph (&lt;code&gt;is_first_item_in_list&lt;/code&gt; and &lt;code&gt;is_in_paragraph&lt;/code&gt;), a further check
is done to to see if the List element would begin with a blank line (&lt;code&gt;at_end_of_line&lt;/code&gt;)
or is an Order List start sequence where the start number is not &lt;code&gt;1&lt;/code&gt; (&lt;code&gt;is_not_one&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id="how-well-did-this-work"&gt;How Well Did This Work?&lt;a class="headerlink" href="#how-well-did-this-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The changes documented in the last section were the bulk of the work, and after that
the remaining changes were easy to figure out and work on.  With the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_theme_break&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_html_block&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_fenced_block&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_atx_heading&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resolving to True in all cases, I removed that line to make things clearer.  While
it makes a mess of any displayed differences, it really is only removing that line and
shifting all text text that was under that &lt;code&gt;if&lt;/code&gt; statement to the left by four spaces.
After running through some tests, there were some failures with the translation to
HTML.  Those failures were all fixed with two lines of code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newline_character&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;output_html&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newline_character&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that completed, all the scenarios were running except scenario test function
&lt;code&gt;test_list_items_282&lt;/code&gt;.  After working on that for a while, I marked that scenario test
as disabled, to research it and work on it later.  Along the way, I also added two
variations of test function &lt;code&gt;test_list_blocks_263&lt;/code&gt; to test specific cases that I thought
would be a problem, both working without any problems.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first thing that came to mind is that I did have an answer to my question from
the Introduction section.  It took me five days to resolve those disabled tests.  More
than anything else, that really cemented my feeling that I made the right decision in
committing that block of work I had from the previous week, with tests disabled.&lt;/p&gt;
&lt;p&gt;While I was still a bit tired after my sinus cold from the previous two weeks,
it felt good to get some real solid debugging work done and out of the way.  The
contrast between this one week’s work and the previous two week’s work was just
staggering.  It was a real good feeling to get back up to a speed that I know I
can easily achieve.&lt;/p&gt;
&lt;p&gt;And given that non-cold increase in momentum, along with the recent reduction of
items in the issues list, it was nice to see that the finish line is getting visibly
closer.  While I don’t want to jinx myself by setting a date, and then missing it,
I am guessing that I am going to be ready sometime in early 2021, and that is good with
me. Believe it or not, I am very much looking forward to it!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With some of the hard issues out of the way, I wanted to finish up all the List Block
issues and get started on the Block Quotes issues.  Here is hoping that I would be able
to do that!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 11</title><link href="https://jackdewinter.github.io/2020/12/07/markdown-linter-delving-into-the-issues-11/" rel="alternate"></link><published>2020-12-07T00:00:00-08:00</published><updated>2020-12-07T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-12-07:/2020/12/07/markdown-linter-delving-into-the-issues-11/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/30/markdown-linter-delving-into-the-issues-10/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I jokingly referred to this week as the week …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/30/markdown-linter-delving-into-the-issues-10/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I jokingly referred to this week as the week from hell.  It was hellish in
nature because of a bad cold that got into my sinuses and would not leave, no matter
what I tried to get rid of it.  As such, I felt that I got approximately half the work
done that I had wanted to.  Therefore, I felt that it was appropriate to talk about the
work done during the two-week period that I had the sinus cold instead of just my usual
one week period.  Even though my brain was fogging with the sinus cold for a good
solid two weeks, I was able to get some good work done, even if it was not at the
pace that I am used to having.&lt;/p&gt;
&lt;p&gt;The big focus at this point in the project was on reducing the number of items on the
issues list that dealt with List elements.  Having taken a significant amount of time
working on
the leaf block elements and getting those items resolved, I was hoping to get a good
chunk of the list issues dealt with.  But I also knew that the impending American
Thanksgiving holiday and a nasty sinus cold were going to slow me down.  It was just
a matter of being honest with myself about what I could accomplish during this period.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/57ba5d7777602b3d67cbea901cc289db539cf0d2"&gt;17 Nov 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/307bbc4ebf6b6f764a88731a1739a2ec895f5fbf"&gt;29 Nov 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="indented-code-blocks-and-list-blocks"&gt;Indented Code Blocks and List Blocks&lt;a class="headerlink" href="#indented-code-blocks-and-list-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Up to that point, I had a good variety of cases for each leaf block type in Markdown
save for one: Indented Code Blocks.  Hence, I had logged this issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt;, &lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;computing&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="nv"&gt;properly&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;empty&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;indented&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I gave a good solid first try at getting them working, but in my mind, Indented Code
Blocks were different enough that they posed additional difficulty.  As such, I left
them for last.  The example that gave me the trouble was an additional test that I
added, function &lt;code&gt;test_list_blocks_256i&lt;/code&gt; or function &lt;code&gt;test_list_blocks_256ix&lt;/code&gt; as I
renamed it.  The Markdown for the example was simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the list start indented to the maximum with three leading spaces, the indentation
of the text &lt;code&gt;foo&lt;/code&gt; should have been enough to make it eligible for an Indented Code Block
with four leading spaces.   Instead, it was just getting captured as part of the text
for the List Item element.&lt;/p&gt;
&lt;h3 id="working-through-it"&gt;Working Through It&lt;a class="headerlink" href="#working-through-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Granted, my cold was raging in my head, and I was not thinking clearly, but eventually I
looked at the tokens long enough and something stuck out at me.   The start List Block
token for line 1 was &lt;code&gt;[olist(1,3):.:1:3:  :   ]&lt;/code&gt; which did not look weird to me at
first.  Looking at the end of the token, where I usually look, everything was fine.
There were three leading spaces before the start List element, and there were three
spaces registered for that token.  Exactly as it should be!  And it was an start
Ordered List token with a single digit start number, so the &lt;code&gt;indent_level&lt;/code&gt; for that
list should be 3: 1 for the single digit, 1 for the list character &lt;code&gt;.&lt;/code&gt;, and one for the
whitespace after it.  Check!  &lt;/p&gt;
&lt;p&gt;Then it dawned on me.  While the three leading spaces were appearing in the token
itself, they were not being accounted for in the &lt;code&gt;indent_level&lt;/code&gt;.  As such, when the
parser got to the second line, the &lt;code&gt;indent_level&lt;/code&gt; was set to &lt;code&gt;3&lt;/code&gt;, and it looked like the
that line was only indented by one character, not enough to start an Indented Code
Block.  After making some changes to pass through the &lt;code&gt;extracted_whitespace&lt;/code&gt; variable
from the first line, the &lt;code&gt;indent_level&lt;/code&gt; was adjusted by the length of the
&lt;code&gt;extracted_whitespace&lt;/code&gt; variable, resulting in an &lt;code&gt;indent_level&lt;/code&gt; of 6.  As the four
leading spaces on the second line was less than that value, it was properly interpreted
as an Indented Code Block element.&lt;/p&gt;
&lt;p&gt;After adding some additional variations to test and make sure that the change was the
right change, I was happy to resolve this issue, and get some rest.&lt;/p&gt;
&lt;h2 id="the-birth-of-series-m"&gt;The Birth of Series M&lt;a class="headerlink" href="#the-birth-of-series-m" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having documented this process before for the other series, I will not take the time to
go through all the steps performed to move these scenario tests over.  I will point out
that for me, with a sinus cold that was not letting up, it was the perfect thing for me
to work on.  It was a lot of moving tests over two days, but it was slow, and it was
methodical.  More importantly, it had built in error checking.  A good thing to have
when you are not 100% sure of how clearly you are thinking.&lt;/p&gt;
&lt;p&gt;As this series was genuinely moving scenario tests over from their origin module
&lt;code&gt;test_markdown_list_blocks.py&lt;/code&gt;, I did not expect any issues and there were none.  Due
to some clarity in thinking when setting up this work, any errors that I did make during
that process were caught and recovered from right away.  Other than that, the entire
process was a blur.&lt;/p&gt;
&lt;h2 id="weird-list-contents"&gt;“Weird” List Contents&lt;a class="headerlink" href="#weird-list-contents" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Mostly due to the sinus cold, which was finally starting to ease up, it took me another
couple of days to get the next issue resolved.  Mentally, I realized that I could either
push myself hard and perhaps prolong the cold, or I could take more breaks and have that
energy go towards resolving the cold.  Whether it was the positive thinking or the
natural course of the cold, I will never be sure which one helped more.  But by noon on
Saturday, I was starting to feel better, and I started to tackle these issues:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;span&lt;/span&gt; &lt;span class="n"&gt;inside&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;multi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="n"&gt;inside&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first issue was easy.  I started with something simple, adding the function
&lt;code&gt;test_list_blocks_extra_2a&lt;/code&gt; to test split paragraphs with the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
&lt;span class="n"&gt;def&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;ghi&lt;/span&gt;
&lt;span class="n"&gt;jkl&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there, I made a small modification to test for Code Spans by using the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;`one`&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;``&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="ss"&gt;``&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;`two`&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;``&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="ss"&gt;``&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the Code Spans dealt with, I moved on to links, using Inline Link elements and
splitting them between two lines are various points in the link itself.  While not
that interesting, it was a good solid scenario that I wanted to make sure was working:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;me&lt;/span&gt;
&lt;span class="s"&gt;"out"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;really&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;me&lt;/span&gt;
&lt;span class="s"&gt;"out"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="tracking-down-the-issues"&gt;Tracking Down the Issues&lt;a class="headerlink" href="#tracking-down-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After coding those new tests, I started executing the tests and everything within the
changing parts of the lists looked fine.  However, on the third line of each example,
when the next item of the base list was defined, some of the tests emitted their text
surrounded by a Paragraph tag.  As this relates to
&lt;a href="https://github.github.com/gfm/#loose"&gt;whether a List is considered loose&lt;/a&gt;,
I took some time to poke around and debug through it.&lt;/p&gt;
&lt;p&gt;Looking at the debug, I realized that I had some issues with the function
&lt;code&gt;__reset_list_looseness&lt;/code&gt; in the &lt;code&gt;transform_to_gfm.py&lt;/code&gt; module.  In trying to be smart
about locating the end of the relevant tokens belonging to a given list, I was going
forward from the start List token looking for the matching end List token.  The problem
was that I was not being selective about which end List token I found, just that I found
a token.&lt;/p&gt;
&lt;p&gt;A short while later, I had some changes coded up that kept track of the &lt;code&gt;stack_count&lt;/code&gt;
associated with the start List tokens and end List tokens that were seen.  The start
List tokens bumped the count by one and the end List tokens reduced the count by one.
If the &lt;code&gt;stack_count&lt;/code&gt; variable was ever zero, it meant that the algorithm had found
the matching end List token, and it broke out of the loop.&lt;/p&gt;
&lt;p&gt;After I finished executing the tests and verifying the results, it was clear to me that
I had found and remedied the issue.  While it was not a big issue to fix, it
was a sneaky one to find, and I was happy to resolve it.&lt;/p&gt;
&lt;h2 id="sometimes-it-is-not-obvious"&gt;Sometimes It Is Not Obvious&lt;a class="headerlink" href="#sometimes-it-is-not-obvious" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Feeling good from my success and solving the last issue, and with the sinus cold
allowing, I started to work on another issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;242&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;variations&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;blank&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="k"&gt;are&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While I remembered adding this item to the issues list, I could not remember anything
around the reason that made me add this to the list.  As I was not aware of the
reasoning
behind the inclusion of this item into the list, and I could not figure out from the
item, I decided to make copies of function &lt;code&gt;test_list_blocks_242&lt;/code&gt; and experiment with
the positioning and number of blank lines within the document.  What I found was
interesting.&lt;/p&gt;
&lt;p&gt;It was a time where I was very happy that I had taken the time to add consistency
checks, as they caught this problem right away, where the output HTML comparison tests
did not.  The problem?  In cases where the &lt;code&gt;__remove_top_element_from_stack&lt;/code&gt; function
in the blank line handling of the &lt;code&gt;tokenized_markdown.py&lt;/code&gt; module were removing
blank lines to be added to the document, it was doing so in reverse order.  That reverse
order meant that in cases with multiple blank lines, the latest blank line would be
added first, messing up the ordering in the document.  &lt;/p&gt;
&lt;p&gt;Once again, a quick fix, and with a couple of iterations of testing to make sure other
functions were not impacted by that side effect (and mitigating those), things were
taken care of.  Another issue solved and resolved.&lt;/p&gt;
&lt;h2 id="variation-on-example-297"&gt;Variation on Example 297&lt;a class="headerlink" href="#variation-on-example-297" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I had some energy left from fighting my cold, and some time left before the American
Thanksgiving holiday started, so I figured I could work on something light.  Hopefully
picking something easy, I picked this task off the list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;296&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;297&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;added&lt;/span&gt; &lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;case&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;LRD&lt;/span&gt;, &lt;span class="nv"&gt;but&lt;/span&gt; &lt;span class="nv"&gt;need&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt;:
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;other&lt;/span&gt; &lt;span class="nv"&gt;types&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;blocks&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt;, &lt;span class="nv"&gt;blank&lt;/span&gt;, &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="nv"&gt;multiple&lt;/span&gt; &lt;span class="nv"&gt;blocks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After a quick look at the Markdown for
&lt;a href="https://github.github.com/gfm/#example-297"&gt;example 297&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I had a good feeling that I would be able to deal with this issue in a couple of hours
or less. To deal with this issue properly, I quickly created variations on function
&lt;code&gt;test_list_items_297&lt;/code&gt; to
test those different scenarios.  Instead of a Link Reference Definition in each
variation, I used an Atx Heading element, a SetExt Heading element, a HTML Block
element, an Indented Code Block element, and a Fenced Code Block element.  Just for
good measure, I added an extra scenario test that had a Fenced Code Block element
followed by a HTML Block element.&lt;/p&gt;
&lt;p&gt;After adding those scenario test and executing them, I was greeted by
the good news which was that the tokens and the output HTML matched what was expected
of each test.  The only issue was in the Markdown generator where the original Markdown
was being reconstructed from the tokens.  After a quick bit of debugging was done
around the processing of the Html Block token, a small change was needed in the function
&lt;code&gt;__merge_with_container_data&lt;/code&gt; to allow the &lt;code&gt;remove_trailing_newline&lt;/code&gt; variable to be set
if the block ends with a newline character.  With those small changes in place, the
newly added scenarios worked fine, generating the correct Markdown to match the
original Markdown.&lt;/p&gt;
&lt;h2 id="fun-with-list-elements"&gt;Fun with List Elements&lt;a class="headerlink" href="#fun-with-list-elements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I do not have any notes on why I picked this task:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;test_link_reference_definitions_185f&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;test_link_reference_definitions_183f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;but it was a fairly interesting task to pick.  Previously, I had disabled both
tests as I was not able to get them working previously.  And it was not
much, but I somewhat remembered working on both these items for at least a couple
of hours each, and not making much progress.  As I said, this was going to be
interesting.&lt;/p&gt;
&lt;p&gt;The good news was that, after a small amount of debugging, I was convinced that I
was looking at two separate issues.   While I did not have any concrete information,
I had a strong feeling that the &lt;code&gt;test_link_reference_definitions_183f&lt;/code&gt; function
failures were due to the Block Quote element in the Markdown, while the
&lt;code&gt;test_link_reference_definitions_185f&lt;/code&gt; function was simply an issue of getting
the Markdown generator adjusted properly.&lt;/p&gt;
&lt;h3 id="debugging-the-issues"&gt;Debugging the Issues&lt;a class="headerlink" href="#debugging-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Picking what I thought was the easy issue to solve, I decided to start working on
the problem with the handling of the Block Quote element.  This happened to be a good
choice as some simple debugging showed me that the issue was a simple one of
not closing off an active List before starting off the Block Quote element.  I
quickly fixed that by adding a simple loop in the &lt;code&gt;__ensure_stack_at_level&lt;/code&gt; function of
the &lt;code&gt;BlockQuoteProcessor&lt;/code&gt; class to ensure that occurs before the Block Quote itself
is started.&lt;/p&gt;
&lt;p&gt;With that part of the issue fixed, my focus shifted to dealing with ensuring that
the Markdown was being properly generated.  After a couple of hours of debugging,
I finally figured out that the failures were being caused when the already transformed
data ends with a newline character, and the next token to transform is either a normal
text token, or one of the &lt;code&gt;SpecialTextToken&lt;/code&gt; related tokens:  Links, Images, and
Emphasis tokens.  In each case, these tokens somehow interrupted the accumulated text,
leaving it ending with a newline character.  To properly add any more text to that
accumulated text, the new data to be added needs to be processed differently to
accommodate that break.&lt;/p&gt;
&lt;p&gt;Like one of the previous sections, the first issue was relatively quick to fix,
while the second issue took hours.  Working through the debugging with a sinus cold
was a bit of a slog, but it was a good issue to take off the list.&lt;/p&gt;
&lt;h2 id="bulking-up-the-series-m-tests"&gt;Bulking Up the Series M Tests&lt;a class="headerlink" href="#bulking-up-the-series-m-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It was Saturday afternoon and I had finished doing some work around my house.  While
I was a bit fatigued, I felt that the
sinus cold was letting up enough that I could spend some weekend time making some
progress on getting more depth to the Series M scenarios.  To do that, I basically
started by placing each of the tests in Series M of the scenario tests into their own
tables.  Having over 45 tests at that point, that separation was equal parts necessity
for my sanity to keep each table separate and readability for anyone looking at them.&lt;/p&gt;
&lt;p&gt;Adding 60 scenario tests to the series, I added 10 scenario tests in each of the six
groups within the series.  While there were small variations to each group of tests,
the underlying tests were essentially the same 10 tests added each time.  And just
as I have mentioned before, the process was a long one: adding the rough form of
the specific test to the table, adding a scenario test to match that rough form,
and then dialing in the example, the token list, and cleaning up the final form of the
entry in the table.  And as usually, it was a long, grueling process.&lt;/p&gt;
&lt;h3 id="powering-through-the-scenarios"&gt;Powering Through the Scenarios&lt;a class="headerlink" href="#powering-through-the-scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The bad news was that I did not get everything done.  After working hard to
get all tests passing, there were 35 tests that for one reason or another were not
passing.  Between the scope of the changes and the last vestiges of my sinus cold,
I did not think twice of marking those failed tests with &lt;code&gt;@pytest.mark.skip&lt;/code&gt;, to be
handled in the following week.  I had a feeling that this task was more than I
could handle in the time allotted with the energy I had, and I was right. Regardless,
I had 25 new scenario tests passing where I did not have them before.&lt;/p&gt;
&lt;p&gt;The good news was that in those 25 new scenario tests, I only found two issues that
I needed to fix and was able to fix.  The most obvious one was in the case of two
empty start List elements, nested together on the same line.  Following through the
code and the log files for that scenario test, it was immediately obvious to me that
assigning the first element of the result from the function
&lt;code&gt;parse_line_for_container_blocks&lt;/code&gt; to &lt;code&gt;_&lt;/code&gt; (in essence, throwing it away), was the
wrong thing to do.   Assigning that first element to the &lt;code&gt;produced_inner_tokens&lt;/code&gt;
variable and adding the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;produced_inner_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fixed that problem. One down, one to go.&lt;/p&gt;
&lt;h3 id="digging-deep-into-the-issue"&gt;Digging Deep into The Issue&lt;a class="headerlink" href="#digging-deep-into-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The other issue that I found was in dealing with empty
list starts in the &lt;code&gt;__pre_list&lt;/code&gt; function.  In one of the first iterations of this
function, I added code in the &lt;code&gt;True&lt;/code&gt; evaluation of
&lt;code&gt;if after_marker_ws_index == len(line_to_parse):&lt;/code&gt; to handle those empty list items.
After a lot of work to come up with the correct formula, I had settled on the code
in that function, part of it for empty list items, and the other part of it for the
non-empty list items.  And that worked well.&lt;/p&gt;
&lt;p&gt;That is until I started looking at it considering the new examples added during these
tasks.  Looking at why scenario tests with empty list items were failing, I kept on
looking at this &lt;code&gt;__pre_list&lt;/code&gt; function.  And with each debugging session that I came
back to that function, the surer I was that I missed something pivotal.  And that
feeling was getting stronger each time.&lt;/p&gt;
&lt;p&gt;Given that feeling, I spent a couple of hours taking that &lt;code&gt;if&lt;/code&gt; statement apart and
putting it back together.  Ultimately, I left the &lt;code&gt;True&lt;/code&gt; case of the &lt;code&gt;if&lt;/code&gt; statement
as it was, but I changed the condition to
&lt;code&gt;after_marker_ws_index == len(line_to_parse) and ws_after_marker&lt;/code&gt;.  As for the cases
where &lt;code&gt;ws_after_marker&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, I added the following code to the &lt;code&gt;False&lt;/code&gt; case to
handle that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;after_marker_ws_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ws_after_marker&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ws_after_marker&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After my experimentation, it just seemed like the right thing to do.  I did find other
solutions that were way more complicated than this one, but those solutions were a lot
more convoluted.  This one was simple.  Instead of doing a complicated calculation and
having lots of &lt;code&gt;if&lt;/code&gt; statements, this just added a slight adjustment to the variable
&lt;code&gt;ws_after_marker&lt;/code&gt;, after which the rest of the &lt;code&gt;False&lt;/code&gt; part of the &lt;code&gt;if&lt;/code&gt; statement was
executed without change.&lt;/p&gt;
&lt;p&gt;While the first solution with the tokens took less than a half an hour to code and
test, when all was said and done, more than five hours had been spent on the task.
But even though it took a while, I was pleased with the result, and I am confident
that the time was well spent in upgrading those solutions.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the beginning of this project, having those 35 scenario tests marked as skipped
would have hung heavily over me.  But at this stage of the project, I recognized that
it was a necessary tool at my disposal.  Instead of waiting until all 60 new scenario
tests were working 100%, it was better to chip away at those tests, committing those
changes to the repository as I went.  Having worked on this project for almost a
year at this point, I knew there were going to be things that ended up running away
from me.  I also knew that while I try and break bigger issues into smaller issues,
there are times that is not possible, for one reason or another.  In this case, I
was concerned that if I did not add all 60 scenarios at once, I would miss one and
it would be hard to detect.  It just meant I would have to adjust.&lt;/p&gt;
&lt;p&gt;And for me, both in my professional life and with this project, is the big takeaway
that I have learned in the last couple of years.  It is extremely important to
set expectations at a healthy level that can be sustained.  Too little, and you can
be viewed as taking it easy.  Too much, and you may be expected to sustain that level
of output for months or years.  I have found great success in clearly stating my
goals and how I plan to achieve them, and resetting expectations on a weekly or
daily basis.  It just makes sense to me.  Well, it does now.  That was not always the
case.&lt;/p&gt;
&lt;p&gt;From my point of view, I could not see a clear way to break up that big issue without
sacrificing the quality in the Series M group changes.  So, I reset my own expectations
for resolving that issue, promising myself that I would address each of those skipped
tests in the next week.  And I was at peace with my decision to do that.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Leaving 35 scenario tests marked as skipped because I could not figure them out
did not sit well with me, so I made them the priority for the following week.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 10</title><link href="https://jackdewinter.github.io/2020/11/30/markdown-linter-delving-into-the-issues-10/" rel="alternate"></link><published>2020-11-30T00:00:00-08:00</published><updated>2020-11-30T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-30:/2020/11/30/markdown-linter-delving-into-the-issues-10/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/23/markdown-linter-delving-into-the-issues-9/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a specific focus on getting list issues resolved …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/23/markdown-linter-delving-into-the-issues-9/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a specific focus on getting list issues resolved this week, I was hoping to
make some decent headway with the issues list.  From my reading of the list at the
start of the week, there were a fair number of List element related issues, Block Quote
element related issues, and cross-over issues between the two.  It just made sense to
me to pick one and focus on it.  And I picked List elements related issues.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4335e2dea51cafd20b96c54832e2cfc50abd1f01"&gt;11 Nov 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/09fe53af190cf566d6476aa4a382f87e92b5cc76"&gt;15 Nov 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-off-with-an-easy-task"&gt;Starting Off with An Easy Task&lt;a class="headerlink" href="#starting-off-with-an-easy-task" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While not a big task, the task:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;292&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;ordered&lt;/span&gt; &lt;span class="n"&gt;lists&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was a nice easy one to start with.  This task was simply to take the functions
&lt;code&gt;test_list_items_292a&lt;/code&gt; to &lt;code&gt;test_list_items_292c&lt;/code&gt;, copy them to &lt;code&gt;test_list_items_292d&lt;/code&gt;
to &lt;code&gt;test_list_items_292e&lt;/code&gt;, changing them from an Unordered List elements to Ordered
List elements.  Nothing more, nothing less.&lt;/p&gt;
&lt;p&gt;And this was very simple, and similarly, the tests passed without any issues.  A
simple, but a good, solid start.&lt;/p&gt;
&lt;h2 id="double-checking"&gt;Double Checking&lt;a class="headerlink" href="#double-checking" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For these tasks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;269&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;305&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;variations&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;whitespace&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;correct&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;weird&lt;/span&gt; &lt;span class="n"&gt;cases&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;list_in_process&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nothing was changed, but some research was done.&lt;/p&gt;
&lt;p&gt;To start, I went to those
two scenario tests and their variations and looked at the whitespace in the
tests.  While it took me a second to remember why the whitespace looks that way in
the list tokens, there
was nothing wrong with the way it was being stored there.  However, it did take
me a second or two to remember that a paragraph within a list stores part of its leading
whitespace in the List token and the remaining leading whitespace in the paragraph
token.  Maybe that is what caused me to add the item to the issues list?&lt;/p&gt;
&lt;p&gt;I then looked at the code for the &lt;code&gt;list_in_process&lt;/code&gt; function with a similar
exploratory effort, but nothing seemed out
of place.  I even enabled debug for a few of the &lt;code&gt;test_list_items_292&lt;/code&gt; functions,
tracing through the code to look for any issues.  While I did not find anything wrong,
I was happy to take a second look at these areas to put any perceived issues that I
might have had to rest.&lt;/p&gt;
&lt;h2 id="ordered-list-blocks-and-start-numbers"&gt;Ordered List Blocks and Start Numbers&lt;a class="headerlink" href="#ordered-list-blocks-and-start-numbers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once again, I found a small task to get out of the way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;CommonMark&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;how&lt;/span&gt; &lt;span class="nv"&gt;handles&lt;/span&gt; &lt;span class="nv"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;initial&lt;/span&gt; &lt;span class="nv"&gt;cases&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;starts&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To examine this issue, I created two new functions, &lt;code&gt;test_list_blocks_extra_1&lt;/code&gt; and
&lt;code&gt;test_list_blocks_extra_2&lt;/code&gt;.  In the first of these functions, I added a couple of lists
with sub-lists, all starting with the the integer &lt;code&gt;1&lt;/code&gt;.  In the second of these
functions, I changed one of the sub-lists to start with the integer &lt;code&gt;2&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;Checking the PyMarkdown parser HTML output against the BabelMark, everything was fine
for the first function, but there was a slight difference for the second function.
Instead of acknowledging the &lt;code&gt;2.&lt;/code&gt; signifying the start of a sub-list, that &lt;code&gt;2.&lt;/code&gt; text
was combined with the paragraph element from the previous line.  That was curious.&lt;/p&gt;
&lt;p&gt;After combing through the specification for about an hour, I posted a question to
the
&lt;a href="https://talk.commonmark.org/"&gt;CommonMark Discussion Boards&lt;/a&gt;, and waited for a response.
More on that in a later article.&lt;/p&gt;
&lt;h2 id="variations-on-existing-lists"&gt;Variations on Existing Lists&lt;a class="headerlink" href="#variations-on-existing-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Graduating from the simpler tasks, I decided to tackle a task that had a bit more
substance to it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;276&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ulist&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ulist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Starting with the scenario test for
&lt;a href="https://github.github.com/gfm/#example-276"&gt;example 276&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I started generating variations based along different themes. For each of
the main variations, I simply ran through a simple list of combinations of the Ordered
List element and the Unordered List element: Unordered/Ordered, Ordered/Unordered,
Ordered/Ordered, and Unordered/Unordered.  After those combinations were taken care of,
the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; variations of those variations were created by adding an Unordered List
element (for &lt;code&gt;a&lt;/code&gt;) or an Ordered List element (for &lt;code&gt;b&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;While I expected something to happen, it was nice to be proven wrong.  The tests all
passed without any issues.  The reason for my initial doubt on this issue?  I have
had problems with “empty” lists before.  While I do not use them myself, the Markdown
specification allows for a List element that only contains a start List Element text
sequence, say &lt;code&gt;1.&lt;/code&gt;, with no other text on that line.  And from my knowledge of the
GFM Specification, empty list items are covered, but not as completely as the list
item starts followed by text.  Based on that background, it was good to see that so
far, those empty list items were not going to be an issue.&lt;/p&gt;
&lt;h2 id="variations-on-a-theme"&gt;Variations on A Theme&lt;a class="headerlink" href="#variations-on-a-theme" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;On a bit of a roll with some easy wins in the completed task column, I decided to
do a couple of tasks together as a single task:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;extra&lt;/span&gt; &lt;span class="nv"&gt;spaces&lt;/span&gt; &lt;span class="nv"&gt;on&lt;/span&gt; &lt;span class="nv"&gt;blanks&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;other&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;types&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;instead&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;just&lt;/span&gt; &lt;span class="nv"&gt;li&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on previous tasks, it seemed like a good idea to come up with variations to
deal with these tasks.  To do this, I started with the example for
&lt;a href="https://github.github.com/gfm/#example-256"&gt;example 256&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;
  &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
  &lt;span class="n"&gt;bar&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;
      &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the first two variations on &lt;code&gt;test_list_blocks_256&lt;/code&gt;, I modified the example Markdown
to include extra trailing whitespace as part of the empty list items.  From there,
I added a variation which replaced the unordered list item elements with ordered list
item elements.  In addition, I further modified that variation by adding extra blank
lines and by reducing the indent on the Fenced Code Block element from 3 to 2, making
it ineligible for inclusion into the list. Basically, I looked at Example 256
and experimented with what I thought would be good variations to test.&lt;/p&gt;
&lt;p&gt;While a lot of those variations did not result in the discovery of any expected issues,
there was one interesting new issue.  In cases where there is a blank line inside
of a list, there was a weird ordering where the processing of the blank line and the
processing of the blank line to close the list were in the wrong order.  As such,
a small fix was required to make sure that the information is available to make a
proper decision on how to handle that blank line with the correct data.&lt;/p&gt;
&lt;p&gt;That one took a bit of effort to figure out, but it was a good warm up for what I knew
was going to be a bear of a task to follow.&lt;/p&gt;
&lt;h2 id="this-weeks-big-issue"&gt;This Week’s Big Issue&lt;a class="headerlink" href="#this-weeks-big-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there was not an explicit entry in the issues list for this issue, it was an
issue that I had long been concerned about.  As the commit message stated, that issue
was to “add better support for lists that are aborted due to missing leading space in
front of a new block”.  I knew I was opening a can of worms by exploring this issue,
but for me to have confidence in the project, I felt that I needed to explore this, and
explore it now.&lt;/p&gt;
&lt;h3 id="aborted-due-to-missing-leading-space"&gt;Aborted Due to Missing Leading Space?&lt;a class="headerlink" href="#aborted-due-to-missing-leading-space" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Basically, in its simplest form, this issue breaks down into the following scenario:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="c1"&gt;---&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this scenario, the Markdown specifies a simple List element that is created without
any content on that line, an empty list item.  In starting to parse the second line,
the parser must first determine if that newly parsed text will be part of that list or
not.  To ensure that text is added to that List element, the text on the next line must
be indented 3 spaces, matching the indent level
of that List element.  Therefore, when the Thematic Break element on that next line
fails to maintain that level of indentation, the original list is then aborted, and the
Thematic Break element is processed after the list has been closed.&lt;/p&gt;
&lt;p&gt;This reading of the specification is backed by the HTML output generated by
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;BabelMark&lt;/a&gt;
for this scenario:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;hr&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="what-is-the-issue-then"&gt;What Is the Issue Then?&lt;a class="headerlink" href="#what-is-the-issue-then" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I had a specific answer to a specific question regarding how the List element
and the Thematic Break element interacted, I wanted a more generic answer that I
could work with.  As usual, I opened up the
&lt;a href="https://github.github.com/gfm"&gt;GFM Specification&lt;/a&gt;
in my browser and started looking for that generic answer.  Unfortunately, I
did not get an answer that I was satisfied with.&lt;/p&gt;
&lt;p&gt;The first thing that I looked for
was some variation on the previous example, of which I kind of found a related test
with &lt;a href="https://github.github.com/gfm/#example-27"&gt;example 27&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;***&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it was not exactly what I was looking for, it was something.  When I went to look
for a similar example including an Atx Heading element, I did not find any comparable
example.&lt;/p&gt;
&lt;p&gt;To be clear, I do not believe this is the fault of the GFM Specification. To
be honest, I think the specification has done a great job and specifying the main cases
that people are going to encounter.  But there is always room for improvement, and I am
hoping to contribute to that improvement with the PyMarkdown project’s testing suite.
That is part of the process, and how the specification gets better.&lt;/p&gt;
&lt;p&gt;With that newfound information in mind, I was left with a slightly modified issue.
As I did not have a good set of examples detailing how lists and other leaf blocks
interacted, I therefore did not have a good comprehensive
scenario test suite that I had confidence in.  I was confident that the GFM
Specification was getting me a good 90% of the way there, but I wanted more than that
90%.  Therefore, the newly modified issue that I needed to solve was that I needed to
specifically add more specific tests in this area.&lt;/p&gt;
&lt;h3 id="getting-a-good-view-on-the-issue"&gt;Getting A Good View on The Issue&lt;a class="headerlink" href="#getting-a-good-view-on-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first thing I did to address this issue was to stop and think clearly about what
needed to be done.  From the last bit of work, I knew that the scenario functions
&lt;code&gt;test_list_blocks_256*&lt;/code&gt; were a good start, so I decided to add functions with similar
names more from that point.&lt;/p&gt;
&lt;p&gt;Starting with the example I outlined the function &lt;code&gt;test_list_blocks_256f&lt;/code&gt; with the
following markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="c1"&gt;---&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then I added a variation on that, making test function &lt;code&gt;test_list_blocks_256fa&lt;/code&gt; be the
same thing, just with text after the List Item element.  Once that was done, I basically
copied those scenario tests, replacing the Thematic Break element with an Atx Heading
element, a SetExt Heading element, an Ordered Code Block element, a Fenced Code Block
element, and an HTML Block element.  With scenario test titles going from &lt;code&gt;256f&lt;/code&gt; to
&lt;code&gt;256k&lt;/code&gt;, I went back and used BabelMark to replace the output HTML in each of the
scenario tests.&lt;/p&gt;
&lt;p&gt;Running the newly created scenario tests, I discovered a solid number of issues that
needed to be looked at.  I knew at this point that there was not going to be an easy
solution here.  I rolled up my sleeves and got to work.&lt;/p&gt;
&lt;h3 id="html-blocks"&gt;HTML blocks&lt;a class="headerlink" href="#html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Picking one of the elements to start with, that night I decided to start working with
the HTML Block element and regretted it within hours.  Looking at the failures
from those tests, it was obvious that there was more than one problem with these tests.
The most immediate problem was that the tokens produced by the parser just looked
wrong.&lt;/p&gt;
&lt;p&gt;Taking the time to look at the problem in depth, I quickly discovered that the
HTML Block element was not causing the list to close like it should.  As that was
a major issue to find, everything else after that token was affected in some way.
To address this issue, I created the &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt; function
to allow the parser to clean up in situations like this.  More specifically, it was
for cases where a paragraph had just been closed while in an active list.  In those
cases, the parser thought the lists had been closed, but the proper tokens were not
being emitted.&lt;/p&gt;
&lt;p&gt;But even with those observations in place, there still was something about the tokens
that looked “off”.  However, I know that there was currently too much noise in the
way for me to see that other issue clearly, so I just decided to get it out of the
way first.&lt;/p&gt;
&lt;h3 id="cleaning-up-html-blocks-in-lists"&gt;Cleaning Up HTML Blocks in Lists&lt;a class="headerlink" href="#cleaning-up-html-blocks-in-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To take care of those concerns, I experimented with eight other variations on that list
scenario, including some variations with sub-lists.  While I was mostly pleased with the
results, there were three tests that were failing due to issues in generating the
correct HTML and rehydrated Markdown text.  After some quick investigation, it became
obvious that there was whitespace missing at the start of the HTML blocks.&lt;/p&gt;
&lt;p&gt;Double checking with the other failing tests, the pattern that emerged was that the
spacing between the end of the previous paragraph and the new HTML block needed to
be altered a bit.  To make sure that information could get from the parser to the
HTML generator, I added a new member variable &lt;code&gt;fill_count&lt;/code&gt; to the HTML Block token,
using the &lt;code&gt;add_fill&lt;/code&gt; function to adjust its value.  Once that was added, I was then
able to make small alterations to the &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt; function
to adjust that &lt;code&gt;fill_count&lt;/code&gt; member variable with the difference between the number of
whitespace characters removed and the indentation level of the currently active list.&lt;/p&gt;
&lt;p&gt;With that information now present in the token, the HTML generator was easily changed to
add those extra characters between the start of the HTML Block and the processing of
the text within that block.  With those changes generating HTML properly, the focus
shifted to applying similar changes to the the Markdown generator and the consistency
checks.  While the first part of this issue had taken days to complete and fix, this
part took only half an hour.  At that point, the HTML blocks and all their variations
were working properly.&lt;/p&gt;
&lt;h3 id="moving-on-to-the-other-blocks"&gt;Moving on To The Other Blocks&lt;a class="headerlink" href="#moving-on-to-the-other-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After fixing the HTML Block elements, I took a closer look at the other failing tests
and started to notice similar problems.  While the &lt;code&gt;fill_count&lt;/code&gt; solution was only useful
for the HTML blocks, the &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt; function was useful
in fixing issues with the handling of Fenced Code Block elements and Atx Heading
elements.  In both of those instances, the new element was supposed to abort the
previous list but was not doing so.  The &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt;
function needed a couple of tweaks to make sure it was handling things consistently
across all three scenarios, but they were all easy fixes.&lt;/p&gt;
&lt;p&gt;With the parser generating the tokens properly, the tests were making more progress but
still failed on the output HTML.  While not a big difference, the output HTML was
missing a newline between the end of the previous list and new Fenced Code Block
elements,
Atx Heading elements, and SetExt Heading elements.  That difference was quickly
eliminated by adding two small lines of code to the handle of those elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;lt;/ol&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;lt;/ul&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;output_html&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After crossing my fingers for good luck, and fixing a couple of typing mistakes,
the new tests passed without much fanfare.  It was just a relief.  I knew it would
take a while, but I did not think it would take three days to complete the
implementation and verification of these new scenario tests.&lt;/p&gt;
&lt;h3 id="it-was-a-slog"&gt;It Was A Slog…&lt;a class="headerlink" href="#it-was-a-slog" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Over that three days, I was able to get 18 new scenario tests coded and passing
properly.  To be honest, I was doubtful at certain points that I would get done, as
progress was hard to come by.  While I cannot remember how “on my game” I felt during
that time, I do remember that I felt burdened by the knowledge that this work was
only the starting point, and I would have to repeat it multiple times in the future.&lt;/p&gt;
&lt;p&gt;And to that end, I had my next task already lined up.&lt;/p&gt;
&lt;h2 id="lather-rinse-repeat"&gt;Lather, Rinse, Repeat&lt;a class="headerlink" href="#lather-rinse-repeat" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While it was a tough couple of days getting through that block of work, I felt that it
was a good task to complete, but that it was not yet 100% complete.  With some extra
time left in the evening, I decided to take a shot at replicating the width of tests
that I added for HTML Block elements to the other Leaf Block elements as well.&lt;/p&gt;
&lt;p&gt;Taking a bit of time to setup (copy, paste, alter, repeat… many times), I was
pleasantly surprised with the low number of failures.  For those tests that did fail,
patterns that I was familiar with from the previous issues with HTML Block elements
began to resurface.  As these issues arose in the Atx Heading elements and the Fenced
Code Block elements, the first set of changes I made were to add a &lt;code&gt;fill_count&lt;/code&gt;
member variable to those token class, similar to how I had added them to the Html Block
token class.  As some of those classes were in a bit more of a “raw” state than the
HTML Block class was, I needed to do a bit of extra work to make sure that I could
adjust the &lt;code&gt;fill_count&lt;/code&gt; variable and have it be persisted.  But it was nothing I had
not done multiple times before, so it was quickly accommodated.&lt;/p&gt;
&lt;p&gt;Other than a couple of small changes, the only big change was to the function
&lt;code&gt;__check_for_list_closures&lt;/code&gt;.  Taking a while to get right, I needed to alter
a few of the functions that feed that function to pass the right parameters
around.  While it was not too difficult, I was hoping that I would find time in
the near future to revisit parts of this code and refactor it to make it cleaner.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Getting a fair number of items related to lists taken off the issues list was a
good feeling.  While there were a couple of draining issues in the middle, it was
still good to make that progress forward.  While it was a bit disheartening finding
issues in the parser after a spell without any major issues with the parser, it
was par for the course.  Better for me to discover them now, than to have a consumer
discover them later.  But as long as I was finding these issues, I would have to make
sure to examine the existing tests and identify any potential areas where I can
add extra tests to validate that I had found most of the issues with lists.&lt;/p&gt;
&lt;p&gt;At this point, I thought it would be useful for me to reiterate a point from previous
articles.
I am not trying to make this project perfect.  After years of software development and
years of software automation, I know that eliminating all issues is not possible.  It
always boils down to when the next issue is going to happen, not if.  But for me, it is
very important to make my best effort in getting the quality to a point that I feel
comfortable with.&lt;/p&gt;
&lt;p&gt;Following that, while I know there is a bit left to go before releasing this project,
I know that it is getting nearer with each item I resolve from the issues lists.  And
that is the point.  It is getting closer, and I just need to keep my focus on the prize:
that project release.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Continuing with my efforts to get better scenario tests around lists, I knew
that I had to be more structured about that testing.  As that meant creating
a new test series, it forbade that the next week’s work would be moving this
week’s work into a new series and cleaning it up.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 9</title><link href="https://jackdewinter.github.io/2020/11/23/markdown-linter-delving-into-the-issues-9/" rel="alternate"></link><published>2020-11-23T00:00:00-08:00</published><updated>2020-11-23T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-23:/2020/11/23/markdown-linter-delving-into-the-issues-9/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/16/markdown-linter-delving-into-the-issues-8/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not much of an introduction here, just my usual …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/16/markdown-linter-delving-into-the-issues-8/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not much of an introduction here, just my usual plodding forward.  Having spent time
in the last couple of weeks working on either the scenario cases tables or resolving
items from the issues list, I tried this week to split my time evenly between those two
tasks.  Without further ado, on to the work!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/3ff576dcdbac37f42e176a0db6dd6b3d1933188e"&gt;03 Nov 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fe184f8a312033c2998f76b983b83a74a61a96ee"&gt;08 Nov 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="dismissing-an-easy-issue"&gt;Dismissing an Easy Issue&lt;a class="headerlink" href="#dismissing-an-easy-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Initially, looking at  the following item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;553&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I thought I would have some work to do.  However, when I started looking at this
item, it did not take longer than a couple of minutes before I was able to resolve
this issue.&lt;/p&gt;
&lt;p&gt;Along the way, there are times where I have good ideas on things to check, and then
other times where I just have ideas.  While I think I meant well with this item,
it ended up falling into neither of those two buckets.  Taking a look at the Markdown
for
&lt;a href="https://github.github.com/gfm/#example-553"&gt;example 553&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[bar][foo\\!]&lt;/span&gt;

&lt;span class="na"&gt;[foo!]: /url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I believe I wanted to make sure that I tested other concepts to make sure the lookup
worked properly.  The most obvious of those concepts would usually be inline elements,
so I think it might have made sense from that point of view.  However,
I had missed one little thing.  As function &lt;code&gt;test_reference_links_553&lt;/code&gt; centers around
subtle variations with the link reference, any inline element would be treated as
plain text, without any interpretation.&lt;/p&gt;
&lt;p&gt;Based on that quick research and the fact that I already had tests for inline elements
in the link label, I just resolved it without any changes.  I think while I might have
had something else on my mind when I added that issue to the list, I was unsure of a
good way to honor it in any reasonable form.  It was good to check out though, just
nothing to do to enhance the project with.&lt;/p&gt;
&lt;h2 id="empty-link-labels"&gt;Empty Link Labels&lt;a class="headerlink" href="#empty-link-labels" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Added a long time ago, I spotted two issues that I knew that I could resolve
quickly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="mi"&gt;560&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;full&lt;/span&gt; &lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="mi"&gt;560&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously added at a time when I was not as complete in my knowledge of the
GFM Specification as I am now, both items were indicating confusion as to why an
empty link label wasn’t valid.&lt;/p&gt;
&lt;p&gt;With the experience gained since those items were added, it was easy for me to
reference the GFM Specification on
&lt;a href="https://github.github.com/gfm/#link-reference-definitions"&gt;Link Reference Definitions&lt;/a&gt;,
select the
&lt;a href="https://github.github.com/gfm/#link-label"&gt;link label&lt;/a&gt;
reference in the first line of the first paragraph, and extract the following bit
of text from the definition of a link label:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Between these brackets there must be at least one non-whitespace character.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While that one line escaped me early in the development of the project, I was now
familiar enough with it to be able to locate it in 30 seconds or less.  As I
acknowledge it is a boundary case, I can see why the specification writers added that
text in there to deal with that case.  From my point of view, an empty link label is
just an empty string that needs to be parsed.  But I also understand that there is
plenty of precedence to also look on an empty string as having no value.  I am not
sure if that is the way I would have gone with this, but I was happy to follow along
with the specification with this one.&lt;/p&gt;
&lt;h2 id="bolstering-up-the-scenario-cases"&gt;Bolstering Up the Scenario Cases&lt;a class="headerlink" href="#bolstering-up-the-scenario-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The more I used the new &lt;code&gt;scenario-cases.md&lt;/code&gt; document, the more I was enjoying it and
the confidence it brings to the project.  While it is still early in the document’s
life, I am starting to rely on that document at the same level that I rely on the GFM
Specification examples.  Basically,
if a parser can properly handle either one of those groups of tests, it is a good thing.
If it can properly handle both groups of tests, it is a wonderful thing.&lt;/p&gt;
&lt;p&gt;As such, a certain amount of this week was spent beefing up that important document.&lt;/p&gt;
&lt;h3 id="moving-simple-inline-links"&gt;Moving Simple Inline Links&lt;a class="headerlink" href="#moving-simple-inline-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At the start of this block of work, one of the things that I wanted to do was to move
the non-base &lt;code&gt;test_inline_links_518&lt;/code&gt; functions into the Series F group by moving them
into the &lt;code&gt;test_paragraph_extra_&lt;/code&gt; group.  While this was not a big move, it filled a
hole that I had perceived in the Series F group tests.  And since it was just
moving the tests from one module to the other, the tests were already passing.
That made the duration task seem to fly by.&lt;/p&gt;
&lt;h3 id="adding-links-as-the-last-element-in-the-document"&gt;Adding Links as The Last Element in the Document&lt;a class="headerlink" href="#adding-links-as-the-last-element-in-the-document" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having just moved that small group of tests into the Series F group, I noticed that
all the test cases in that group ended with a Text token, and not a Link element.
As that affects what is checked at the end of a leaf block, I thought it was
prudent to go through the Series F group and add a variation for each case that
tested the base document without any elements after the document.&lt;/p&gt;
&lt;p&gt;That was not a difficult task but was a task that was both tedious and lengthy.  I went
through each of the 16 base tests registered in the Series F group and created a
new variant of that base test.  Once created, I removed any trailing non-link
characters from each test document, double checking that I had not disturbed the Link
element itself.  As usual, I verified the HTML document against
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;Babelmark&lt;/a&gt;,
then running the tests to see if there were any issues.&lt;/p&gt;
&lt;p&gt;When I ran the tests, I was greeted with the good news that the parser itself was
working properly and the consistency checks only required minor changes.  Those changes
were in the &lt;code&gt;__handle_last_token_end_link&lt;/code&gt; function, each of them small adjustments to
handle the various parts of the Link token in its various forms, but nothing that
wasn’t immediately resolvable.&lt;/p&gt;
&lt;h3 id="following-up-with-image-elements"&gt;Following Up with Image Elements&lt;a class="headerlink" href="#following-up-with-image-elements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It should be no surprise that after completing the work documented in the previous two
sections that I decided to follow that work up with ensuring parity for the Image
elements in the Series F group. In total, 29 new scenarios were added to the group,
mirroring the existing Link element tests.&lt;/p&gt;
&lt;p&gt;Due to previous hard work and a bit of luck, there
was only one change required in the &lt;code&gt;__handle_last_token_image&lt;/code&gt; function.  In the
case where the last token is a full Image token, I just needed to add a single line
to properly increase the &lt;code&gt;inline_height&lt;/code&gt; variable by one for each newline in the
&lt;code&gt;text_from_blocks&lt;/code&gt; field of the Image token.  While the verification phase of each
test took a while, the testing phase of these additions went by very successfully and
very quickly.&lt;/p&gt;
&lt;h3 id="moving-scenario-tests-into-their-own-modules"&gt;Moving Scenario Tests into Their Own Modules&lt;a class="headerlink" href="#moving-scenario-tests-into-their-own-modules" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Over the course of the next three commits, I took on the immense chore of moving and
renaming tests belonging to seven of the identified scenario case groups.  Those seven
groups were Series A to Series E, Series H and Series J.  For each group, I created a
new file, such as &lt;code&gt;test_markdown_paragraph_series_a.py&lt;/code&gt; and moved tests in from their
original modules, renaming them as I went.&lt;/p&gt;
&lt;p&gt;As I renamed those functions, I started to come up with a solution for how to identify
each test uniquely.  What I quickly settled on was to start the test name with
the series that it belonged to, followed by a descriptive name based on the contents
of the test document.  In this way, I could easily tell if I repeated a test within
a given group by looking at the name of the function.&lt;/p&gt;
&lt;p&gt;While this work was primarily copying and renaming scenario tests, it was exhausting.
For each test, I needed to make sure that the name of the function matched the
Markdown document contained within the test.  Then I needed to take that Markdown
document and run in through Babelmark to make sure the HTML output was correct.
Repeated on over 100 scenario tests, it took a lot of time and a lot of patience to
get correct.  But in the end, it was satisfying to be able to see the groups
come together, painting a cohesive picture of a group of passing tests along a given
theme.&lt;/p&gt;
&lt;h2 id="better-tests-for-link-reference-definitions"&gt;Better Tests for Link Reference Definitions&lt;a class="headerlink" href="#better-tests-for-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Switching back to resolving items from the issues list, the first thing that caught
my eye was an issue dealing with Link Reference Definitions.
Of all the leaf blocks elements that I have had to design and code for this project,
the Link Reference
Definition element was by far the most difficult to get right.  It was no surprise to
me to find the following item in the issues list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;what&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;bad&lt;/span&gt; &lt;span class="nv"&gt;link&lt;/span&gt; &lt;span class="nv"&gt;definition&lt;/span&gt; &lt;span class="nv"&gt;discovered&lt;/span&gt; &lt;span class="nv"&gt;multiple&lt;/span&gt; &lt;span class="nv"&gt;lines&lt;/span&gt; &lt;span class="nv"&gt;down&lt;/span&gt;, &lt;span class="nv"&gt;how&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;back&lt;/span&gt; &lt;span class="nv"&gt;track&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Starting back in April 2020 when I added support for
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/"&gt;Link Reference Definitions&lt;/a&gt;,
I felt that while the feature was implemented, I knew that there was always going to be
a possibility of a gap in the feature implementation.  Because of the unique multiline
nature of this feature, it is impossible to determine if the element itself is valid
without reading the next line.  As such, I had to implement a “requeue” functionality
to allow the parsing of a possible Link Reference Definition element to be rewound and
attempted again as a different element.  While that has worked well, the bulk of my
concerns over this feature centered around whether that rewinding functionality
dealt with all possible side effects, not just the most common set of them.&lt;/p&gt;
&lt;p&gt;Given that history, I decided to add functions &lt;code&gt;test_link_reference_definitions_166a&lt;/code&gt;
and &lt;code&gt;test_link_reference_definitions_166b&lt;/code&gt; to test for two more cases where an element
was only discovered to be invalid.  In the case of function
&lt;code&gt;test_link_reference_definitions_166a&lt;/code&gt;, I made sure that the title portion starts on
the same line but was not properly terminated.  This was to make sure that the entire
element would be discarded as there was no solution where the Link Reference Definition
could be considered complete under any circumstances.  When I added function
&lt;code&gt;test_link_reference_definitions_166b&lt;/code&gt;, I took the opposite approach, starting the title
on the next line.  As I started it on the next line, the Link Reference Definition could
be completed, just without the title.&lt;/p&gt;
&lt;p&gt;When I ran the tests for these two tests, it was no surprise to me that there was a
failure.  In looking at the tests, the failure was with function
&lt;code&gt;test_link_reference_definitions_166b&lt;/code&gt; which fails due to an extra Blank Line token
being generated before the rewind is reprocessed.  It took me a bit of time to realize
that I needed to add the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;force_ignore_first_as_lrd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lines_to_requeue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;at the end part of the &lt;code&gt;__stop_lrd_continuation&lt;/code&gt; function that dealt with continuations
that were partially successful.  I just had to try different combinations before
figuring out what the correct one was before proceeding.&lt;/p&gt;
&lt;h2 id="dont-judge-a-book"&gt;Don’t Judge A Book…&lt;a class="headerlink" href="#dont-judge-a-book" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Indeed, when I came across this item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;603&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;doesn&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;look&lt;/span&gt; &lt;span class="k"&gt;right&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I agreed that it did not look right.  The Markdown for
&lt;a href="ex-603"&gt;example 603&lt;/a&gt; is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;boolean&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;producing the HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"http://foo.bar.baz/test?q=hello&amp;amp;amp;id=22&amp;amp;amp;boolean"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;http://foo.bar.baz/test?q=hello&lt;span class="ni"&gt;&amp;amp;amp;&lt;/span&gt;id=22&lt;span class="ni"&gt;&amp;amp;amp;&lt;/span&gt;boolean&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I was able to verify it quickly against Babelmark, but it took me a bit to figure out
what the parser did to get to that result.  The big thing that I had to remember for
this case was that it was interpreted as an Autolink, which is meant as a quick way to
provide references.  As such, it makes sense that instead of a literal interpretation
of the
specified link, the processing leans more towards what the user probably intended.  To
that end, it makes sense that the ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;) character in the link is translated
into the named character entity &lt;code&gt;&amp;amp;amp;&lt;/code&gt; for use in both the reference and the text.&lt;/p&gt;
&lt;p&gt;So, after thinking it through and checking it out, the function &lt;code&gt;test_autolinks_603&lt;/code&gt; is
100% correct.  For extra points though, to produce the correct link, I determined that
the following HTML block would be needed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://foo.bar.baz/test?q=hello&amp;amp;id=22&amp;amp;boolean"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;http://foo.bar.baz/test?q=hello&lt;span class="err"&gt;&amp;amp;&lt;/span&gt;id=22&lt;span class="err"&gt;&amp;amp;&lt;/span&gt;boolean&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yeah, I like puzzles, and this was a good one.&lt;/p&gt;
&lt;h2 id="i-really-need-to-be-more-specific"&gt;I Really Need to Be More Specific&lt;a class="headerlink" href="#i-really-need-to-be-more-specific" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I am usually good at adding items to the issues list, this one was cryptic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;620&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;more&lt;/span&gt; &lt;span class="n"&gt;bad&lt;/span&gt; &lt;span class="n"&gt;cases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Huh?  That really was not a lot to go on, but I gave it a shot.  Without more
information in the item, I just got a bit creative.&lt;/p&gt;
&lt;p&gt;Taking a look at function &lt;code&gt;test_autolinks_604&lt;/code&gt;, I took the initial URI autolink of
&lt;code&gt;&amp;lt;irc://foo.bar:2233/baz&amp;gt;&lt;/code&gt;, stripping it down to &lt;code&gt;&amp;lt;irc:foo.bar&amp;gt;&lt;/code&gt; for
function &lt;code&gt;test_autolinks_604a&lt;/code&gt; and expanding the theme to
&lt;code&gt;&amp;lt;my+weird-custom.scheme1:foo.bar&amp;gt;&lt;/code&gt; for function &lt;code&gt;test_autolinks_604b&lt;/code&gt;. Similarly,
I took the email Autolink of &lt;code&gt;&amp;lt;foo+special@Bar.baz-bar0.com&amp;gt;&lt;/code&gt; from function
&lt;code&gt;test_autolinks_613&lt;/code&gt; and reduced it down to &lt;code&gt;&amp;lt;l@f&amp;gt;&lt;/code&gt; for function &lt;code&gt;test_autolinks_613a&lt;/code&gt;.
Having added some good positive tests, I then decided to add negative tests.  For
function &lt;code&gt;test_autolinks_620a&lt;/code&gt; I specified a theme with too few characters, while
function &lt;code&gt;test_autolinks_620b&lt;/code&gt; specified a theme with too many characters. Test
function &lt;code&gt;test_autolinks_613c&lt;/code&gt; specified a scheme with an invalid character in the
theme, while function &lt;code&gt;test_autolinks_613d&lt;/code&gt; had no domain part and function
&lt;code&gt;test_autolinks_613e&lt;/code&gt; had no name part.&lt;/p&gt;
&lt;p&gt;These tests all passed without incident, but it felt good to increase the scenarios
and increase my confidence in the project.  While I was pretty sure that these would
all pass, as they are all based on regular expressions with specific character counts,
it just felt right to explicitly test those limits and make sure they were consistent.&lt;/p&gt;
&lt;h2 id="verifying-link-reference-definitions-with-other-blocks"&gt;Verifying Link Reference Definitions with Other Blocks&lt;a class="headerlink" href="#verifying-link-reference-definitions-with-other-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the same manner as other tests, this one started from the issues list item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;test_link_reference_definitions_183&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;partial&lt;/span&gt; &lt;span class="n"&gt;lrd&lt;/span&gt; &lt;span class="n"&gt;followed&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;bq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;add&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt; &lt;span class="n"&gt;blocks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In test function &lt;code&gt;test_link_reference_definitions_183&lt;/code&gt;, the Link Reference Definition
(or its acronym LRD as used in the item) follows an Atx Heading element.  In the
GFM Specification for this example, it explicitly states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, it can directly follow other block elements, such as headings and thematic breaks, and it need not be followed by a blank line.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While it states that it can follow other block elements, it only gave three examples:
one after an Atx Heading element, one before a Thematic Break element, and one before a
SetExt Heading element.  Those three tests cases, spread out in the three functions
between &lt;code&gt;test_link_reference_definitions_183&lt;/code&gt; and &lt;code&gt;test_link_reference_definitions_185&lt;/code&gt;
were a good start, I felt that better coverage was warranted.  Therefore, I created
functions &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt; for function &lt;code&gt;test_link_reference_definitions_183&lt;/code&gt; and functions
&lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for function &lt;code&gt;test_link_reference_definitions_185&lt;/code&gt; to cover the before and
after cases.&lt;/p&gt;
&lt;p&gt;Except for two of the tests, they all passed without incident.  The two
that did not pass were tests that involved a Link Reference Definition occurring both
before and after a list. As I knew I was going to be finishing up with leaf blocks
and heading to container blocks in the next week or two, I marked those test as
disabled, added an item to the issues list, and kept on going.&lt;/p&gt;
&lt;h2 id="cleaning-up-character-entity-tests"&gt;Cleaning Up Character Entity Tests&lt;a class="headerlink" href="#cleaning-up-character-entity-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At first, when I saw the issues list item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;test_markdown_entity&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;various&lt;/span&gt; &lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="n"&gt;tests&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I thought that I had missed a couple of cases and looked for some missing cases.  It
was during that search that I came across the following text at the end of the
&lt;code&gt;test_markdown_entity_and_numeric_character_references.py&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# TODO&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;amp; and various forms at end of line&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# 327 special parsing for html blocks?&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;lt;a href="&amp;amp;ouml;&amp;amp;ouml;.html" x="&amp;amp;ouml;"&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;lt;x-me foo="&amp;amp;ouml;"&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;# &amp;lt;script&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;amp;ouml; bar="&amp;amp;ouml;" bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Comparing the items in the Python list, I determined that all those cases had already
been covered by other tests, but there were some tests that I thought it was worth
adding.&lt;/p&gt;
&lt;p&gt;While the example for function &lt;code&gt;test_character_references_321&lt;/code&gt; specified that the text
must match that of an entity in the named entities table, I added function
&lt;code&gt;test_character_references_321a&lt;/code&gt; to make it explicit that it was a case-sensitive
lookup.  Similarly, functions &lt;code&gt;test_character_references_322&lt;/code&gt; and
&lt;code&gt;test_character_references_323&lt;/code&gt; mention turning numeric entities into characters, but
only included the special &lt;code&gt;NUL&lt;/code&gt; character &lt;code&gt;0&lt;/code&gt; as a byproduct of the text in an example.
As such, I created the &lt;code&gt;test_character_references_323a&lt;/code&gt; function to call attention to
this special character, also showing that any number of leading zeroes does not matter
for numeric entities.&lt;/p&gt;
&lt;p&gt;In a similar pattern, but at a higher level, I added the &lt;code&gt;test_character_references_336&lt;/code&gt;
series of functions, named &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt;.  While I was okay with the examples showing the
usage of entities in paragraphs, I felt that having explicit cases of entities in each
of the other leaf blocks was useful.  In order, the tests added named entities in each
of an Atx Heading element, a SetExt Heading element, and Indented Code Block element,
a Fenced Code Block element, and a Html Block element.  I also verified that the entity
was interpreted in the first two elements, and not interpreted in the last three
elements, as per the GFM Specification.&lt;/p&gt;
&lt;p&gt;Finally, as a simple set of comprehensive tests, I wanted to have a good example of
specifying
a named entity using all three forms: named, decimal, and hexadecimal.  As such, I
created the &lt;code&gt;test_character_references_extra_&lt;/code&gt; functions with &lt;code&gt;01&lt;/code&gt; using &lt;code&gt;&amp;amp;quot;&lt;/code&gt;,
&lt;code&gt;02&lt;/code&gt; using &lt;code&gt;&amp;amp;#34;&lt;/code&gt;, and &lt;code&gt;03&lt;/code&gt; using &lt;code&gt;&amp;amp;#x22;&lt;/code&gt;.  I know that these functions were going
to pass ahead of time, but it gave me confidence knowing that I had a concrete set of
three tests showing that the form of the entity didn’t matter, as they all produced
the same HTML results.&lt;/p&gt;
&lt;h2 id="closing-things-up"&gt;Closing Things Up&lt;a class="headerlink" href="#closing-things-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Even though I was getting close to writing time on Sunday morning, I wanted to try and
clear one more easy issue from the list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;HTML&lt;/span&gt; &lt;span class="n"&gt;transformer&lt;/span&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;text_from_chars&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;instead&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;field&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;see&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jackdewinter&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;pymarkdown&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a506ddd3bda08a8ca1d97a7b0d68c114325b545e&lt;/span&gt; &lt;span class="ss"&gt;`extra_74`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This was more of a bookkeeping issue than anything else, or at least I hoped it was.
During a previous change on 02 Oct 2020, I thought I had noticed that the HTML
transformer was using the &lt;code&gt;text_from_blocks&lt;/code&gt; field to create the text for the links.
Thankfully, resolving this took a quick look at the &lt;code&gt;__handle_image_token&lt;/code&gt; function
in the &lt;code&gt;transform__to_gfm.py&lt;/code&gt; module to verify it was not using that field.&lt;/p&gt;
&lt;p&gt;When I took a second, this should have been more obvious to me.  While it is possible
to derive the &lt;code&gt;image_alt_text&lt;/code&gt; field from the &lt;code&gt;text_from_blocks&lt;/code&gt; field, it is the last
thing I would have thought about when generating HTML.  But I still felt good that I
verified this and dispelled any doubts about the HTML output being based on the wrong
part of the token out of my mind.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The work went on like it always does, but an interesting milestone was met with
the completion of this work: any outstanding issues clearly identified as being
attributable to a leaf block has been solved.  Short version?  I finished any
issue that was clearly a leaf block issue.&lt;/p&gt;
&lt;p&gt;While the realization of that goal was not a big thing to me, it wasn’t a small one
either.  It still meant that I needed to check how leaf blocks interacted with the two
container blocks, but it reduced the number of things to check to just interactions
with and between container blocks.  That was a good feeling, knowing I had hit that
mark.  It increased my confidence that things were going in the right direction.&lt;/p&gt;
&lt;p&gt;It is still too early to tell, but I am now starting to hope for an initial release
of PyMarkdown as a linter in the early parts of 2021.  That felt good typing that.
Real good.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the work done to verify the leaf blocks, the next week was going to be full of
me trying to reduce the issues specific to list blocks. Closer to the line I get!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 8</title><link href="https://jackdewinter.github.io/2020/11/16/markdown-linter-delving-into-the-issues-8/" rel="alternate"></link><published>2020-11-16T00:00:00-08:00</published><updated>2020-11-16T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-16:/2020/11/16/markdown-linter-delving-into-the-issues-8/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/09/markdown-linter-delving-into-the-issues-7/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
take a bit of time to focus on adding some depth to the scenario cases table.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I get closer to the end of this initial phase …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/09/markdown-linter-delving-into-the-issues-7/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
take a bit of time to focus on adding some depth to the scenario cases table.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I get closer to the end of this initial phase of the PyMarkdown project, I find
myself measuring the project’s success differently than I did at various points in the
past. Initially the success criteria statement was “does it work at all”.
Then it moved on to “is it implemented for most circumstances”.  Finally, in the last
couple of weeks, it has moved on to the “what did I miss” stage.  And wow, does it
seem like it has taken both a couple of weeks and almost a year at the same time.&lt;/p&gt;
&lt;p&gt;While this phase might seem boring to other people, people that are Testers or
Automation Developers&lt;sup id="fnref:SDET"&gt;&lt;a class="footnote-ref" href="#fn:SDET"&gt;1&lt;/a&gt;&lt;/sup&gt; often enjoy times like these because of two words:
exploratory
testing.  Our job is to make sure the thing we are testing is working properly. To
a lot of us, exploratory testing is basically like leaving a kid in a room filled with
hundreds of opened
&lt;a href="https://www.lego.com/"&gt;LEGO&lt;/a&gt;
sets and saying to them “show me what you can build!”  It is in those times that we
get to “play around” and experiment.  We use that time to try and understand where the
issues are, and which scenarios give us the most benefit to test for the least cost.
And as this phase is closing, this type of testing is pivotal in being able to close
out the phase cleanly and with confidence.&lt;/p&gt;
&lt;p&gt;And as I have mentioned before, testing and test automation is not about trying to break
something, it is about reducing the risk that the user of the product will experience
that thing breaking.  That is where my recording of the bulk testing in the scenario
cases tables comes into play.  Instead of looking for one issue at a time, those tables
take a group of concepts and test them as a single group.&lt;/p&gt;
&lt;p&gt;I have found that the benefits of that approach are twofold.  The first benefit that
I have experienced is an increase in confidence.  This is an easy one to
explain, as I can concretely point to a collection of tests along a theme and know that
any scenario along that theme is working properly.  The second benefit is one of
economy.  The cost
of finding an individual issue is expensive.  It takes exploration or debugging to find
the issue in the first place, with the extra debugging and logging to try and figure
out what the issue really is, followed by the extra work required to fix the issue. That
ends up being a lot of time.  By amortizing the work over an entire group of tests,
that cost is drastically reduced.&lt;/p&gt;
&lt;p&gt;Having experienced these benefits on this project, I decided to dedicate a weeks’ worth
of work to adding to the table, to increase my confidence and to accelerate my journey
to having a shippable project.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c467c617da4ca9e03457b18c9795d6fff7dceb65"&gt;27 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/e1d9b9e016b799f5bc11670f21d8008e1c0cd967"&gt;31 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="linksimages-and-other-inline-tokens"&gt;Links/Images and Other Inline Tokens&lt;a class="headerlink" href="#linksimages-and-other-inline-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The easy part about coming up with a theme is the title of the theme itself.  For the
Series J theme, it was easy an easy theme to identify: Link/image elements followed by
various other inline tokens.  In the
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/main/scenario-cases.md"&gt;scenario-cases.md&lt;/a&gt;
file, that description is right there after the name of the series.  But the hard part
of a theme is the act of trying to make sure that each scenario that you want in that
theme is present.  And often, I miss the mark.&lt;/p&gt;
&lt;p&gt;When I originally added Series J to the document, I thought that I had added each of
the qualifying inline elements to the group.  Going through the list in my head, I
thought I had each of those newlines added when I created the group.  But in retrospect,
I did not have the right viewpoint as I missed a large part of that group: internal
versions of the scenarios I had already added.&lt;/p&gt;
&lt;p&gt;I came about this when looking at the J8 test and experimenting by creating two
new tests:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;J9&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="n"&gt;emphasis&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;nnk&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;ndef&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test_paragraph_extra_e1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;J9i&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="n"&gt;emphasis&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;nnk&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;ndef&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test_paragraph_extra_e2&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whereas the other tests in the Series J group focus on the inline elements after the
Link elements and Image elements, I wanted to experiment with performing the same
process on those token’s link labels, inside of the tokens.  And that experimentation
bore fruit.  The J9 test failed in the consistency check with an overcount on the
line number.  After a quick debugging session, I discovered that the &lt;code&gt;rehydration_index&lt;/code&gt;
that I have mentioned in previous articles was being added to, both in the link label
and in the Link’s encapsulated tokens.  It was just a simple fix from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;link_stack&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After that quick fix, the issue was addressed.  But it outlined something to me that I
wanted to get back to before the end of the week: inline elements within the link label.
More on that near the end of this article!&lt;/p&gt;
&lt;h2 id="adding-the-series-l-theme"&gt;Adding the Series L Theme&lt;a class="headerlink" href="#adding-the-series-l-theme" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This work was the major focus of the week, focusing on links or images contained within
the link label section of another link or image.&lt;/p&gt;
&lt;h3 id="origin-story"&gt;Origin Story&lt;a class="headerlink" href="#origin-story" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I came up with the idea for this
group recently, I have been thinking about this topic since at least
31 July 2020.  It was at that time that I did the research that I would document in
a section labelled
&lt;a href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/#example-528"&gt;Example 528&lt;/a&gt;,
followed by the work undertaken to fix that issue, documented in the section
“creatively” labelled
&lt;a href="https://jackdewinter.github.io/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/#fixing-example-528"&gt;“Fixing” Example 528&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That scenario test, encapsulating the GFM Specification’s
&lt;a href="https://github.github.com/gfm/#example-528"&gt;example 528&lt;/a&gt;,
is a bit contrived but a good example nonetheless.  Given the Markdown document:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;[[foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the expected output is the HTML document:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"uri3"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"[foo](uri2)"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The reason I say that this example is contrived is that I can visualize useful cases of
a Link element within an Image element, I have a hard time coming up with a similar
example for a Link element within a Link element.&lt;/p&gt;
&lt;p&gt;A practical instance of this example is the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;![moon&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;nssdc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gsfc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nasa&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gov&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;imgcat&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;midres&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gal_p37329&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gif&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wikipedia&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;wiki&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Moon&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is rendered as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"https://en.wikipedia.org/wiki/Moon"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"https://nssdc.gsfc.nasa.gov/imgcat/midres/gal_p37329.gif"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"moon"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At the visual level, this HTML provides for a picture of a moon from the NASA
archives.  When
that image is clicked on, the browser goes to the Wikipedia article on the moon.&lt;/p&gt;
&lt;p&gt;Useful
element compositions like this is probably why there are multiple examples of a
Link element within an Image element in the GFM Specification.  However, in that same
specification, only the above example provides for a Link element within a Link element
within an Image element.  As the GFM Specification provides a unified interpretation of
Markdown, Example 528 is presented as a recipe on how to handle cases like that.  My
guess was that if that example was anything other than an outside case, there would be
more examples outlining that pattern.&lt;/p&gt;
&lt;h3 id="formulating-the-test-group"&gt;Formulating the Test Group&lt;a class="headerlink" href="#formulating-the-test-group" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the help of
&lt;a href="https://johnmacfarlane.net/"&gt;John McFarlane&lt;/a&gt;,
I was able to figure out the part of the algorithm that I had misunderstood and fixed
the error.  Having invested all that research and work to fix that one issue, I
wondered if there was a better way to handle issues with examples like that.  That was
when I really started thinking about how to cover all the cases that would lead to
having a good group of tests around Example 528.&lt;/p&gt;
&lt;p&gt;The downside about that exercise was that as soon as I thought about how to cover all
those scenario cases, a couple of negative things got in the way.  The first big one was
&lt;a href="https://github.github.com/gfm/#example-583"&gt;example 583&lt;/a&gt;
and the paragraph that follows it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Though this spec is concerned with parsing, not rendering, it is recommended that in rendering to HTML, only the plain string content of the image description be used. Note that in the above example, the alt attribute’s value is &lt;code&gt;foo bar&lt;/code&gt;, not &lt;code&gt;foo [bar](/url)&lt;/code&gt; or &lt;code&gt;foo &amp;lt;a href="/url"&amp;gt;bar&amp;lt;/a&amp;gt;&lt;/code&gt;. Only the plain string content is rendered, without formatting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, given the Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo [bar&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the specification suggests that the only content that should be used is the &lt;code&gt;foo&lt;/code&gt; text
contained at the start of the Image element’s link label, and the &lt;code&gt;bar&lt;/code&gt; from the link
label of inner Link element.  Therefore, after processing, the resultant HTML is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url2"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"foo bar"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The downside of this information is that there are at least 64 “simple” combinations of
links inside of links, images inside of images, links inside of images, and images
inside of links.  Those simple combinations are 4 types of links inside of 4 types of
links inside of 4 combinations of link and image elements.  That lays the groundwork
for determining which combinations should be tested to address scenarios like example
528 but does not address example 528-like scenarios.&lt;/p&gt;
&lt;p&gt;Already taking the work required to create a single test for each combination into
account, the bigger downside was going to be the verification of each of those tests.
Increasing the cost of this downside was the possibility of finding issues that needed
to be addressed while the verification phase of the tests was ongoing.&lt;/p&gt;
&lt;p&gt;It was daunting, but I felt strongly that it needed to be done. So, I started working
on identifying the combinations that were needed, and added them to the
&lt;code&gt;scenario-cases.md&lt;/code&gt; file.  It was then that the hard work for this issue would start.&lt;/p&gt;
&lt;h3 id="working-the-issue"&gt;Working the Issue&lt;a class="headerlink" href="#working-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The bulk of the work on resolving this issue was done over 4 days of lengthy
sessions.  To reduce the cost of completing this work, I decided early on to come up
with a simple strategy to hopefully allow me to copy-and-paste tests where possible,
hopefully avoiding extra work.  To that end, I figured that the combination of Link
elements inside of Link elements was the best combination to start with.  I just hoped
that I could reuse a lot of the test code.&lt;/p&gt;
&lt;p&gt;The table that I created in the &lt;code&gt;scenario-cases.md&lt;/code&gt; file was a good tool to create
the tests from, but it lacked any Markdown that I could use as a template.  Keeping
it simple, I started with the Markdown &lt;code&gt;a[foo [bar](/uri)](/uri)a&lt;/code&gt;, and transformed
the Markdown for each scenario from there.  Once I started working with non-inline
Link elements, I added in a simple Link Reference Definition, including link
referenced to that Link Reference Definition and to a non-existent Link Reference
Definition.&lt;/p&gt;
&lt;p&gt;Following my usual pattern, I executed that new test and manually verified the
tokens, before copying them into the test.  After that, I executed the test again
and copied the HTML output into the test, after once again manually verifying that it
looked right.  Even after that step, I used
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;BabelMark&lt;/a&gt;
against the Markdown for each test, comparing my parser’s output against the
&lt;code&gt;commonmark.js&lt;/code&gt; output.  This process was long, drawn out, and tedious… but it
worked.&lt;/p&gt;
&lt;p&gt;The hard part about mentally processing a lot of these combinations is that because
of the rule that Link elements cannot contain Link elements, I needed to do a lot
of tedious parsing of each combination.  It was not as simple as just looking at
the Markdown and quickly knowing what the answer was.  I kept a copy of the GFM
Specifications
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;implementation guide&lt;/a&gt;
open in another window, just to make sure I was doing things in the right order.
Even then, I double checked, and triple checked each transformation being running the
tests, just to make sure I had things done correctly.&lt;/p&gt;
&lt;p&gt;After a couple of days of work in the evenings, I had finished this first
part.  For the other three parts, I was hoping I could leverage the work heavily
to allow me to shave some time off the process.&lt;/p&gt;
&lt;h3 id="completing-work-on-the-issue"&gt;Completing Work On The Issue&lt;a class="headerlink" href="#completing-work-on-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With Link elements inside of Link elements out of the way and committed to the
repository, I started to work on Image elements inside of Link elements.  The big
change here was that while nested Link elements need to be parsed carefully,
the parsing of Image elements inside of Link elements was more natural to me. The
Link token’s link label field contained the “raw” form of the link label, while the
tokens between that token and the end Link token contained a processed version.
With a decent amount of experience in reading Markdown due to this project, I was able
to gain proficiency at those required changes quickly.  It therefore followed
that the verification part of the process went a lot smoother than with nested Link
elements.&lt;/p&gt;
&lt;p&gt;Moving on to nested Image elements was a relatively easy step to take from there.
As the Image elements create their &lt;code&gt;alt&lt;/code&gt; attribute values by processing the link label
instead of encapsulating it (as with Link elements), the two big changes were
easy to consistently apply across each of the new tests.  The first change was to remove
any tokens that were being encapsulated between the start Link token and the end Link
token, replacing them with a single Image token.  The second change was to look at an
example nested Image element and determine what the &lt;code&gt;alt&lt;/code&gt; attribute was going to be.
After the first two or three tests, I started to get pretty good at doing that before
I started verifying the tokens, saving a lot of time.&lt;/p&gt;
&lt;p&gt;Finally, completing the group with the Link element inside of an Image element was
almost trivial.  As the different between a Link element inside of an Image element
and an Image element inside of an Image element is one character (&lt;code&gt;!&lt;/code&gt;), the link
labels remained constant between the tests.  As such, only minor changes were
required to these tests after copying them from the previous group.&lt;/p&gt;
&lt;h3 id="dealing-with-relatively-minor-issues"&gt;Dealing with Relatively Minor Issues&lt;a class="headerlink" href="#dealing-with-relatively-minor-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To get all the test passing and verified was a chore, but the good news was that most
of the work was contained within the scenario test process that I have already defined.
Considering the scope of the group of tests, the number of issues found in the non-test
parts of the project were very small.&lt;/p&gt;
&lt;p&gt;To be specific, there was only one change required.  When adding the tests for Image
elements within a Link element, the only change that I needed to do was to change the
expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To be blunt, it was both confirming and unsettling at the same time.  The confirming
part of the process was that I had done the work on the project properly, with only
a very slight change required.  And hopefully it does not sound like I lack confidence,
but it was also unsettling.  After working on scenario tests across an entire theme,
taking three to four days in the process, I somewhat expected the new scenario tests
to find something that I missed.&lt;/p&gt;
&lt;p&gt;I was happy that it did not find anything, do not get me wrong.  It just took a bit of
getting used to.  And it was still a validation of the parser code itself, as the change
was only required in the consistency checks.  After some thought, it sank in that
at this late stage of the project’s initial push, I wanted the results to be exactly
this: the parser was being proved as validly constructed, again and again.&lt;/p&gt;
&lt;h2 id="rounding-out-series-j"&gt;Rounding Out Series J&lt;a class="headerlink" href="#rounding-out-series-j" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Based on the research that I did at the start of the week, I wanted to close out
the week by responding to that research by rounding out the Series J group. As
with my recent work in adding the Series L group of tests, I started out by
scribbling down the combinations that I thought needed to be covered, looking for
gaps that I had missed.  While not a big gap, I added tests &lt;code&gt;J2a&lt;/code&gt; and &lt;code&gt;J2ai&lt;/code&gt; to
fix a small gap where I did not have a newline in the Raw Html element.&lt;/p&gt;
&lt;p&gt;With that initial fix made, the rest of the changes were fairly in scope with the
new test that I documented at the start of this article.  Starting with emphasized
text, I added scenario descriptions and scenario tests encompassing a wide range
of inline tokens, including Hard Line Break elements.  I double checked everything
and then began my usual process of executing and verifying the tests.  And boy was
I glad that I did!&lt;/p&gt;
&lt;p&gt;While it was not a lot of code, I made changes to the &lt;code&gt;__collect_text_from_blocks&lt;/code&gt;
function and the &lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function to properly handle
these new cases.  In the case of both functions, most of the inline tokens were
handled, but the two Autolink inline tokens and the Hard Line Break tokens were not
handled.  While the extra code to remedy these issues was relatively small, it was
a good find.  It felt good that these issues were found directly because of this new
group of scenario tests.  It felt like validation of the approach I had taken.&lt;/p&gt;
&lt;p&gt;From a consistency check point of view, there were only a couple of issues that were
found.  Mirroring the change made for split emphasis at the start of this article,
the &lt;code&gt;__verify_next_inline_hard_break&lt;/code&gt; function was changed to only increase
the &lt;code&gt;rehydrate_index&lt;/code&gt; if the token was not inside of an active Link token.  The
other issue was a small, nitpicky thing: adding the text &lt;code&gt;+ 1&lt;/code&gt; to the output
for the main assert in the &lt;code&gt;__verify_next_inline_code_span&lt;/code&gt; function.  Other than
those two changes, the consistency checks had a clean bill of health.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have to admit that I wondered (out loud, to my dog, who did not help in the discussion
one way or the other) whether this was a good investment of time once the week had
ended.  The broad sweeping groups that I added confirmed that the parser code
was in good shape, as were the consistency checks that watched over that code.  Maybe
it was me still thinking I was in the middle part of the “game” of creating the project,
and not the end game where I believe I am currently at.  But as I mentioned above,
I had both positive and negative emotions about the results.  Happy that things were
going well, but not as trusting of those results as the tests had proved out.&lt;/p&gt;
&lt;p&gt;Taking some time to think about it as I am writing this article, I do think my
descriptions of “middle game” and “end game” are appropriate metaphors to where I
am on the project.  After a long time spent in the middle of the project, I
believe it is just taking me some time for me to switch into the mode where I am
wrapping things up to complete this first phase of the project.  As such, I when I
start that week’s work, I believe that I am going to find more issues than I find,
and then I turn out to be happy when I do not find many issues.  I truly
believe that when I properly switch my mentality to an end game mentality, I will
be expecting the tests to verify the work already done.&lt;/p&gt;
&lt;p&gt;Does that mean the project will be properly tested?  Nope.  If you ask any person
experienced with testing a project that question, they will not give you a solid
answer.  That is not due to lack of confidence, but because there is not one to give.
There will always been edge cases that are not thought of and weird things that can
show up.  It is my belief that you can find most of the issues with any given project,
but it is always a question of when that next issue will show up, and who will find
that issue.&lt;/p&gt;
&lt;p&gt;In both professional life and for this project, my goal is the same.  If not to find
that issue before the customer does, then to make sure I have a solid assessment of
the risk outlined and evaluated.  And with these latest changes in the past week,
I see that measure of risk going down, which is a good thing.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a solid weeks’ worth of “big ticket item” issues resolved, I decided to try
and tackle a lot of the smaller issues.  I just started with a couple of easy ones
and kept on going until I stopped.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:SDET"&gt;
&lt;p&gt;Nomenclature can be everything, and changes from job to job.  From my viewpoint, Testers are people that are very methodical and document what they did, in what order, and what the results are.  Automation Developers like me, a SDET or Software Development Engineer in Test, take documented patterns and results, writing test code and test frameworks to make sure that those scenarios can be written as code which can be used to automatically validate the results.  There are exceptions, but the general rule is that most Testers only have a small amount of the skills required for an Automation Developer, while most Automation Developers are very adept at most of the skills required for a Tester.  Both skill sets are very useful on projects from a quality point of view. &lt;a class="footnote-backref" href="#fnref:SDET" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 7</title><link href="https://jackdewinter.github.io/2020/11/09/markdown-linter-delving-into-the-issues-7/" rel="alternate"></link><published>2020-11-09T00:00:00-08:00</published><updated>2020-11-09T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-09:/2020/11/09/markdown-linter-delving-into-the-issues-7/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/02/markdown-linter-delving-into-the-issues-6/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This article is probably going to be a lot shorter than the others in this series.  It …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/02/markdown-linter-delving-into-the-issues-6/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This article is probably going to be a lot shorter than the others in this series.  It
is not the case that I did a lot less work, just that there is just a lot less of that
work to talk about.  The bulk of that work was an effort by me to get the extra
groups of scenario tests more organized.  Sometimes the work I do on the project is
easy to describe and takes a lot of words to explain, as usual.  But in this case,
it is just a lot of work that has a short description.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ef7e569ca0710982fe5c4639c055251875bed5b3"&gt;23 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fa955668b6e2e91a0c9a40efab35bf71769223dc"&gt;25 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="keeping-things-organized"&gt;Keeping Things Organized&lt;a class="headerlink" href="#keeping-things-organized" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For most of the time that I have spent on this project, I have maintained a very good
grasp of where things are and what needs
to be done.  Sure, I use the issues list to keep track of all the little things that
I need to fix or check, but I rarely forget about items on the list.  Usually, within
seconds of reading one of the items on the issues list, I remember a good amount of
information about what the problem is and why I added it.  But since the project has
been going on for a while now, I sometimes forget when I added the item to the list.&lt;/p&gt;
&lt;p&gt;When it comes to the scenario tests, it used to be the case that I had an equally solid
hold on the tests and what they covered.  At first it was easy, one example from the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
equals one scenario test.  Then, as I was working through the validation of the parser,
I added some extra scenarios by adding a letter to the end of the parent scenario and
documenting the change.  At that point, there was still a good link between the example
that spawned the new scenario test and the parent of that test.&lt;/p&gt;
&lt;p&gt;And then came the “extras” scenario tests.  Most of them were added to provide
additional testing for the line/column numbers needed for the linter than for the
parser itself.  As the example provided for in the GFM specification are targeted for
parsers, I felt it was totally reasonable to add extra scenario tests to ensure that
the different in testing between the needs of a parser and the needs of a linter were
covered.&lt;/p&gt;
&lt;p&gt;But what started out as a few scenario tests, rapidly grew to a set of tests that
numbered over 140.  The tests are their contents started to get jumbled up in my head
on a frequent basis.  What group of tests was the
test I was just looking at a part of?  Did I cover all the cases within in the group?
Did I miss one?  If I missed one, how could I tell?  It just got more difficult to
keep things clear with each case I added.&lt;/p&gt;
&lt;h3 id="finding-a-solution"&gt;Finding A Solution&lt;a class="headerlink" href="#finding-a-solution" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently, I had added an item to the issues list to start looking at this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;need&lt;/span&gt; &lt;span class="nv"&gt;comprehensive&lt;/span&gt; &lt;span class="nv"&gt;table&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt; &lt;span class="nv"&gt;that&lt;/span&gt; &lt;span class="nv"&gt;qualify&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;each&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt; &lt;span class="nv"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;.&lt;span class="nv"&gt;e&lt;/span&gt;. &lt;span class="nv"&gt;para_extra&lt;/span&gt;
  &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;different&lt;/span&gt; &lt;span class="nv"&gt;groups&lt;/span&gt;, &lt;span class="nv"&gt;links&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;images&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that I had a few weeks to think about it, I believed a solution was in order.  The
first big decision I need to make was to figure out the medium for this table, with
Markdown being the natural selection.&lt;/p&gt;
&lt;p&gt;Creating the Markdown document &lt;code&gt;scenario-case.md&lt;/code&gt; in the root folder, I tried four
or five formats before settling down on the final format. The first column contains a
unique identifier for that test.  Starting with the letter id for the group of tests,
I made sure that the rest of the identifier clearly described what the scenario test
contained using a common id schema.  Following that identifier column are the columns
that contain a short description of the scenario test, the relevant Markdown from the
test, and the actual function name of the scenario test.  Starting by enumerating the
scenario tests for the
&lt;code&gt;test_markdown_paragraph_extra.py&lt;/code&gt; module, I left space for a trailing column that
would also include the function name of the scenario test for the
&lt;code&gt;test_markdown_setext_headings_extra.py&lt;/code&gt; module.&lt;/p&gt;
&lt;h3 id="i-really-needed-this"&gt;I Really Needed This&lt;a class="headerlink" href="#i-really-needed-this" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I finished creating this document as the result of this multi-day task, it
was extremely obvious why I needed it:  there was a lot of information to process.
There were a solid core of groups in the initial document, and by documenting each
group, I easily
found things that I had missed or not completed.  By clearly delineating each group of
tests, it also became a lot easier to see the patterns in the groups and why they were
important.&lt;/p&gt;
&lt;p&gt;First, there were the basic groups, Series A to Series E.  These were simple
foundational tests for the complete set of inline elements.
Series A tested the inline element at the start of a line, followed by text.
Series B and Series C followed those tests by testing the same inline elements with
text around the inline element and text followed by the inline element.  While they
would not be seen that way naturally, Series D provided tests for each inline element
alone in a document by itself.  Finally, Series E extended the Series D tests by
testing those inline elements that can contain a newline character, rounding out the
foundational tests.&lt;/p&gt;
&lt;p&gt;From there there were 4 groups of tests that I had added that all dealt with link
elements and image elements.  The Series F tests provided for a newline character
in each part of all 4 link types.  The Series G tests provided for the same type of
tests but tested for the inclusion of a backslash escape sequence and character
reference sequences.  Due to some issues I encountered with Code Span elements and
Raw Html elements inside of Link Labels, the Series H tests were added to provide
a thorough testing of those combinations.  Rounding out those tests, the Series J
tests provided for various combinations of Inline elements with Link elements and
Image elements, once again added due to some issues that I ran into.&lt;/p&gt;
&lt;h3 id="the-proof-is-in-the-pudding"&gt;The Proof Is In The Pudding&lt;a class="headerlink" href="#the-proof-is-in-the-pudding" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As they used to say
“&lt;a href="https://idioms.thefreedictionary.com/proof+is+in+the+pudding"&gt;the proof is in the pudding&lt;/a&gt;”.
Basically, the only way that I am going to find out if this works or not is by using
it and judging the results.  However, I can say that this initial task
of putting the table together has already yielded positive results.  There were
tests that were duplicated, and there were new distinct tests that were child
tests of existing tests.  Putting that table together helped me clean up the extra
tests by
fixing up those cases.  In addition, it found a missing scenario that dealt with an
inline link type that did not have a title but had whitespace after the URI.  That
scenario is one that I would not have found otherwise.&lt;/p&gt;
&lt;p&gt;I feel the balance point of this work needs to be mentioned, as the cost of putting
this table together was a couple of days’ worth of work.  That cost would have be
spread out over numerous issues
if it was started at the beginning, but at that point, I am not sure if the benefit of
putting this table together is something that I thought would justify the cost.  As a
matter of personal sanity, I try not to do the “what ifs” too often.  From my point of
view, while it might have been better to do this earlier, it was at this point that
I started seeing that it needed to be done.  After I made that observation, it was only
a couple of weeks before I took the time to create the table.  And that time was spent
thinking about how I wanted to organize the table, so it was not wasted time.&lt;/p&gt;
&lt;p&gt;I guess the thing I am trying to say is this: do not kick yourself and do not rush
things. If you can see something ahead of time, and the benefit is worth the cost to
mitigate the issue, then mitigate.  Otherwise, wait until the benefit becomes worth the
cost, plan it out to make sure you can do it cleanly and clearly, and then work on it.&lt;/p&gt;
&lt;h2 id="is-a-character-entity-the-same-as-a-character"&gt;Is A Character Entity the Same As A Character?&lt;a class="headerlink" href="#is-a-character-entity-the-same-as-a-character" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the section of the GFM on
&lt;a href="https://github.github.com/gfm/#entity-and-numeric-character-references"&gt;Entity References&lt;/a&gt;,
the specification is very clear about how Character Entities are to be used:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Entity and character references cannot stand in place of special characters that define structural elements in [Markdown]. For example, although * can be used in place of a literal * character, * cannot replace * in emphasis delimiters, bullet list markers, or thematic breaks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To be blunt, you cannot get clearer than that.  If you want the Markdown document to
be interpreted properly, your document must use the actual character used to invoke the
behavior you want, not a character reference.&lt;/p&gt;
&lt;p&gt;For the most part, I was very comfortable with that, and I was sure that I had adhered
to that rule throughout the parser.  When it came to the newline character, I
was not as confident.  I was pretty sure that if I tested all the inline elements with
the character entity newline, that the HTML output would look correct.  However, while
I was sure that I properly handled most of the cases, I was not as sure that I had
properly handled all those cases.  Therefore, enter Series K.&lt;/p&gt;
&lt;p&gt;To get this series started, I began with the Link elements.  Starting with the inline
Link element, I enumerated the 7 places where the character entity &lt;code&gt;&amp;amp;#xa;&lt;/code&gt; could be
inserted, followed by the 2 places for the full Link element and 1 a piece for the
shortcut Link element and the Collapsed Link element.  Once that was in place, I
duplicated those scenarios, transforming the Link elements into their equivalent
Image elements.  Finally, I added cases for the Emphasis element, the Code Span element,
the Raw Html element, and both Autolink elements.&lt;/p&gt;
&lt;p&gt;With a total of 27 new scenarios to cover, I started to work on creating these scenario
tests, one at a time.  As with other tests I have documented in previous articles, I
was very precise and meticulous with the creation of those tests.  When each test was
created, I gave it a manual check before testing it against the parser’s HTML output,
but only after running the Markdown against
&lt;a href="https://johnmacfarlane.net/babelmark2"&gt;BabelMark&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the end, 11 of those new scenario tests resulted in failures, with 16 of them passing
right away.  But at that point, it had taken me most of the day to add and verify the
tests, along with all the things that life threw at me that Saturday.  A bit
reluctantly, I committed those tests as-is, after adding 11 new items to the issue list
to track those tests I needed to finish.  Then I went to sleep.&lt;/p&gt;
&lt;h2 id="finishing-up-the-series-k-tests"&gt;Finishing Up the Series K Tests&lt;a class="headerlink" href="#finishing-up-the-series-k-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a good night’s sleep, I took a look at that week’s article notes.  I figured
that the article notes were in a good enough state for me to look at those 11 new items
I added
the night before.  Planning out my work to address those issues, a couple of things
leapt out at me.&lt;/p&gt;
&lt;p&gt;The first thing that I noticed was that while I had added some good tests for the link
types, I had
not varied the type of character entity or numeric entity that I used in place of
the newline character.  While I was confident it had been covered in the base GFM
Specification, I believed that for completeness it would be good if I also added it
in this group of tests.  When I was done fixing that, there were 14 new tests in
the table, 7 new tests for Link elements and 7 new tests for Image elements.  In
addition, there was 3 extra scenario tests that I added to complete the coverage
for the other inline elements.  When that work was done, the Series K group contained
42 tests.&lt;/p&gt;
&lt;p&gt;The other thing that I did not realize the day before was that the failures were nicely
bucketed into three groups: one that failed in the &lt;code&gt;InlineProcessor&lt;/code&gt; class, ones that
failed in the &lt;code&gt;__verify_next_inline_handle_previous_end&lt;/code&gt; function, and ones that failed
in the &lt;code&gt;__verify_next_inline_text&lt;/code&gt; function.  While it would have been nice if they
all had the same root cause, three different causes to examine was still better than
eleven!&lt;/p&gt;
&lt;h3 id="attacking-the-parse-failure-cases"&gt;Attacking the Parse Failure Cases&lt;a class="headerlink" href="#attacking-the-parse-failure-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As luck would have it, this was the easiest problem to fix.  In the code for the
&lt;code&gt;__calculate_inline_deltas&lt;/code&gt; function, there was an assert statement as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;link_part_index&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Newline in link token not accounted for."&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When I originally added this code, I was being defensive, thinking that I had not
properly
handled a newline character occurring in the link label part of the Link element and
the Image element.  It took me a bit of time and some extra debug scenarios, but
I was able to conclusively prove that newline character in link labels were already
been handled by another part of the code.  As such, I was able to comment out that
assert and resolve two out of the eleven failures.  On the the next one!&lt;/p&gt;
&lt;h3 id="properly-handling-split-lines"&gt;Properly Handling Split Lines&lt;a class="headerlink" href="#properly-handling-split-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After a bit of looking at the remaining tests, one pattern leapt out at me.
Immediately, it looked like the line/column numbers being calculated by the parser were
correct, but the same calculation for the consistency checks was off.  With only
a small amount of looking at the problem, the cause for that result became obvious
to me almost immediately.&lt;/p&gt;
&lt;p&gt;When any of the character entities or numeric entities are used in a normally
processed part of the document, a replacement sequence is placed within the token
to represent that sequence.  For the Markdown generator, the original entity is
persisted, and for the HTML generator, the replacement text is persisted.  This
is performed by using a replacement sequence such as &lt;code&gt;\a&amp;amp;#xa;\a\n\a&lt;/code&gt;, making it
clear which part is “what is replaced” and which part is “what it is replaced with”.&lt;/p&gt;
&lt;p&gt;And therein lied the problem.  In the &lt;code&gt;__verify_next_inline_text&lt;/code&gt; function, the
&lt;code&gt;current_line&lt;/code&gt; variable is split as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;split_current_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there, each part of that split line is processed.  But due to the above
replacement sequence,
each entity sequence like &lt;code&gt;&amp;amp;#xa;&lt;/code&gt; generates another entry in that list.  Now, if the
HTML output were being verified, that would work well.  But as the consistency checks
are used to verify the line/column numbers in the Markdown document, those newline
characters confuse the issue.&lt;/p&gt;
&lt;p&gt;I realize that this may seem confusing, so consider a small Markdown document like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;#&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When this document is parsed, the above Python code will generate an array with two
values in it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"a&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;&amp;amp;#xa;&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;b"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If that does look right, it is because it is not right.  It is a faithful interpretation
of the request made to split the string &lt;code&gt;a\a&amp;amp;#xa;\a\n\ab&lt;/code&gt; at its newlines, but it
does not understand that it should only consider the first part of the replacement
sequence, not both the first and the second parts.&lt;/p&gt;
&lt;p&gt;I needed to come up with a way to deal with this issue.&lt;/p&gt;
&lt;h3 id="fixing-the-issue-with-split-lines"&gt;Fixing the Issue With Split Lines&lt;a class="headerlink" href="#fixing-the-issue-with-split-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;That is when I started putting together the &lt;code&gt;__handle_newline_character_entity_split&lt;/code&gt;
function.  Given that array of split lines, this function specifically looks for
any entries that start with the replacement character (&lt;code&gt;\a&lt;/code&gt;), and the previous entry
ends with the first part of the replacement sequence.  Basically, as the data is split
on the newline character (&lt;code&gt;\n&lt;/code&gt;), we want to look for cases where one entry ends with
the &lt;code&gt;\a&amp;amp;#xa;\a&lt;/code&gt; part of the sequence and the following entry starts with the &lt;code&gt;\a&lt;/code&gt; at
the end of that sequence.&lt;/p&gt;
&lt;p&gt;When it was all said and done, the function looked like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__handle_newline_character_entity_split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;try_again&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;try_again&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;try_again&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
                &lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__create_newline_tuple&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
                &lt;span class="n"&gt;combined_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;combined_line&lt;/span&gt;
                &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="n"&gt;try_again&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After testing this new function with a single scenario test, I execute all the failed
tests again, and was rewarded with only four failing tests.  Time to buckle down
and get the last ones taken care of.&lt;/p&gt;
&lt;h3 id="cleaning-up"&gt;Cleaning Up&lt;a class="headerlink" href="#cleaning-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With four tests remaining, I was ready to put in a lot of work to figure out what
the problem was.  I made sure I had a good snack and a big glass of water, turned
on the debug logging output for some of the tests, and
proceeded to look at the failed scenario tests and the scenario tests that were
around them and were passing. &lt;/p&gt;
&lt;p&gt;The first issues I noticed in the failed tests were in the
&lt;code&gt;__verify_next_inline_handle_current_end&lt;/code&gt; function, where the number of newlines
characters are counted.  Looking at the difference between the reported line numbers
and the calculated line numbers, there was a direct correlation between the number
of entity sequences used and how much the reported difference in line numbers.  Having
seen this pattern many times before,
it was easy for me to see that instead of using fields in this manner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;newline_count4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I needed to change that to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;pre_link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;pre_link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;

        &lt;span class="o"&gt;...&lt;/span&gt;

        &lt;span class="n"&gt;newline_count4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After a quick check against the tests, it was obvious that there were also some
issues with the &lt;code&gt;__verify_next_inline_handle_previous_end&lt;/code&gt; function, of the same
type.  Looking at that function, I needed to do the same with the &lt;code&gt;link_uri&lt;/code&gt; field
and the &lt;code&gt;pre_link_uri&lt;/code&gt; field that I did in the above example with the &lt;code&gt;link_title&lt;/code&gt;
field and the &lt;code&gt;pre_link_title&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;While verifying those changes, I did notice that there was an omission that was not
tested.  In cases where an inline link contains an URI that is inside of “angle
brackets” (&lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;), I was not adjusting the counts to accommodate for that.
After adding an extra test or two, the solution to this was easy, adding
the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;did_use_angle_start&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;part_3&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the &lt;code&gt;__verify_next_inline_handle_previous_end&lt;/code&gt; function.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There were a couple of times during the creation and validation of the scenarios
table that I wanted to give up.  It was a large body of work with no immediate
validation of its correctness.  It was also a body of work that could easily fall
out of sync with the actual scenario tests themselves, so there was the future work
to maintain and revalidate the table to consider.&lt;/p&gt;
&lt;p&gt;But still, that table was, and still is worth it!  I emphatically believe this with
few reservations, if any.  I do agree that I need to be careful in concluding about
whether to add a scenario test or two versus adding a new scenario
test group.  That is a no-brainer.  But this is another tool that I have in my toolbelt
to help me make sure the quality of the PyMarkdown project is where I want it to be.&lt;/p&gt;
&lt;p&gt;Take the case with the group for the newline character entity sequence.  If I had added
only a couple of tests, I would have wondered if I had captured all the cases.  By
adding the tests as a group of cases, I carefully documented and tested the cases that
I could come up with, but left the door open for more cases to be added at a future
date.  For me, that is a winning proposition for the right kind of scenario tests.&lt;/p&gt;
&lt;p&gt;And as I mentioned above, the proof is in the pudding.  I have already cleaned
up an old assert statement in the Inline Processor, something I would have overlooked
without that group of tests.  In addition, it found at least three issues with the
consistency checks for the line/column numbers, making that watchdog code more complete.
That small step towards completeness of the consistency checks means that I have more
confidence that it will detect any issues that arise when something is changed.&lt;/p&gt;
&lt;p&gt;I know I am getting close to the end of the project, and my goal is to add both
single tests and groups of tests with no changes to either the parser itself or the
consistency checks.  And this work brought me one step closer to that goal!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that I had the master table of scenario tests and their groups together, it
was time to leverage that information and add to it.  That was the focus of
the next week’s work, work that was indeed satisfying.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 6</title><link href="https://jackdewinter.github.io/2020/11/02/markdown-linter-delving-into-the-issues-6/" rel="alternate"></link><published>2020-11-02T00:00:00-08:00</published><updated>2020-11-02T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-02:/2020/11/02/markdown-linter-delving-into-the-issues-6/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/26/markdown-linter-delving-into-the-issues-5/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After having a week where I felt like I barely made any progress, it was nice to …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/26/markdown-linter-delving-into-the-issues-5/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After having a week where I felt like I barely made any progress, it was nice to get
a week where I was able to get some work done while keeping balance with my personal
life.  For some reason, the stop-and-go nature of last week was not repeated this
week, and I was grateful for it.  But this week was not really about any one of
those issues, just getting some good, solid work in to reduce the size of the
issues list.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ea62ec32ce232668df57c232a94d5311cc6107f9"&gt;14 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7ac7e655e3aabe6b220e9ba179f59620284ac9e1"&gt;18 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="finishing-up-the-work"&gt;Finishing Up the Work&lt;a class="headerlink" href="#finishing-up-the-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a day’s rest from writing that week’s article, I looked at my notes and noticed
there was one little issue that was left over from the last weeks’ worth of work:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- test_paragraph_extra_b5 - adding extra newline somewhere, possibly not clearing after previous image?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, I was not able to get the &lt;code&gt;test_paragraph_extra_b5&lt;/code&gt; function to pass before
the end of the previous week, so I marked it with &lt;code&gt;@pytest.mark.skip&lt;/code&gt; to disable the
test until I could look at it.  Not wanting to leave things undone, this was the number
one thing on my list for this week.&lt;/p&gt;
&lt;p&gt;Looking at the Markdown document and the HTML output, everything looked fine.  It was
when I looked at the tokens and saw the issue that it came flooding back to me: there
was a problem with the newlines.  Specifically, there was a problem with the Text token
following the test document’s Image token:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="s2"&gt;"[text(3,19):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;def::&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s2"&gt;]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If things are working properly, the number of newline characters in the text field is
equal to the number of new characters in the extracted field.  In this case, the text
field contains one newline character, but the extracted whitespace contains two newline
characters.  And once I saw that pattern, I was able to see it in other similar tests.
In total, there were 16 Paragraph token tests and 12 SetExt Heading token tests that
exhibited this behavior.  The key was that in each case, the Text token followed an
Image token and preceded the end of block token.&lt;/p&gt;
&lt;h3 id="digging-in"&gt;Digging In&lt;a class="headerlink" href="#digging-in" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now I had a pattern, so it was time to fix it. I started by turning the debug log on and
working my way through the data for the test.  There was a substantial amount of data,
but using my experience on the project, I was able to quickly narrow the search to
something
in the inline processing section.  Taking a look at the tokens produced right before
the inline processing started, everything looked right.  I then decided to focus on the
inline processing based on that information.&lt;/p&gt;
&lt;p&gt;Digging into the Inline Processor, I followed the processing along token by token,
right up to and including the Image token and everything looked fine.  Even the
processing for the Text token itself looked fine if it was not for that extra newline
character in the extracted whitespace field.  To narrow down where that character was
being added,
I started with some debug to log the tokens at various stages of the processing,
and the data confirmed my previous statement.  From a token point of view, everything
looked perfect.&lt;/p&gt;
&lt;p&gt;To me, that just left the tidying up after the tokens.  Because of the way the parser
is designed, the inline text is accumulated until an inline token is required.  Once
that token is created, the parser then grabs all the characters up to the start of that
token, creates a Text token with that information, and adds it before adding the new
token.  I stared at the code that created the token, and wondered what the problem
could be.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;inline_blocks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;TextMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;current_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;starting_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;end_whitespace&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;end_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;last_line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;last_column_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was on a hunch more than anything else that I decided to look at the &lt;code&gt;end_string&lt;/code&gt;
variable. This variable is where the extra whitespace stripped from the end of the line
is stored. Looking at this variable’s impact on the logs, I noticed a couple of “holes”
that I filled with extra debug log statements.  It was with that information that I was
able to pinpoint that along the way to the creation of that Text token, the extra
newline character was appearing.  Tracking backwards, it soon became clear that the
issue was that the &lt;code&gt;end_string&lt;/code&gt; was being assigned that newline character, but it was
not been cleared properly.&lt;/p&gt;
&lt;h3 id="fixing-the-issue"&gt;Fixing the Issue&lt;a class="headerlink" href="#fixing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After about 45 minutes of additional debugging and fiddling, the answer final came to
me.  When the &lt;code&gt;inline_response.consume_rest_of_line&lt;/code&gt; field was set, four different
fields and variables were being reset.  The thinking here was that if the different
handlers indicated that they had consumed the rest of the data on the line, there
was not anything else to do.  But one thing was forgotten: the resetting of the
&lt;code&gt;end_string&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Sometimes a fix is rewriting some logic, and sometimes a fix is adding some new logic to
handle a missed case. This time, the fix was just about completing the reset action.
Adding a single line in the &lt;code&gt;if inline_response.consume_rest_of_line:&lt;/code&gt; block was
all that was needed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;end_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Anticlimactic that it was only resetting one variable on one line, but that is the way
it sometimes is.  Lots of looking only to find out something small was missed.  With
the research I completed, it did make sense though.  Without that variable being reset
to &lt;code&gt;None&lt;/code&gt;, the newline character from a previous line was being carried through to
the Text token after the Image token.&lt;/p&gt;
&lt;p&gt;Once I verified that the fix worked with that one test, I ran the entire suite of tests
with the new code in place.  Comparing the test failures to the set of 16 Paragraph
token tests and 12 SetExt Heading token tests, there was a 100% match!  After
approximately 3 hours of work, I had found that small but required change!&lt;/p&gt;
&lt;h2 id="being-more-precise"&gt;Being More Precise&lt;a class="headerlink" href="#being-more-precise" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first part of this task was to perform some catch-up work on code coverage.  Having
forgotten to check the coverage with recent changes, I was happy that there were only
two small areas that
I needed to improve on.  Even better, both were cases where I had added defensive
code that was not being utilized.  As such, removing that code from the
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function and the
&lt;code&gt;__complete_inline_block_processing&lt;/code&gt; function returned the code coverage numbers to
their normal levels.&lt;/p&gt;
&lt;p&gt;With that task under my belt, I decided to address an issue that has been bugging me
for a couple of weeks: the &lt;code&gt;rehydrate_index&lt;/code&gt; assert.  Located in the
&lt;code&gt;__handle_last_token_text&lt;/code&gt; function, I have improved this assert over the last few
weeks.  While it started off as a simple “less than” expression, it was now down
to a comparison between the count of newlines in the tokens and the &lt;code&gt;rehydrate_index&lt;/code&gt;
field.  My problem with it?  As improved as it was, it was still checking to see if
the &lt;code&gt;rehydrate_index&lt;/code&gt; field was either equal to &lt;code&gt;num_newlines&lt;/code&gt; or &lt;code&gt;num_newlines + 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As documented in past articles, I have incrementally improved this check to the
point where it was when I started this work.  But the real target was always to get
that assert statement down to a one-part expression.  Specifically, based on its usage,
the goal was to get the statement down to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="debugging"&gt;Debugging&lt;a class="headerlink" href="#debugging" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting the work on this task, the first thing I did was to figure out the amount of
work I needed to do.  In this case, the best way to do this was to make the change
detailed at the end of the last section and look for failures.  While it was not
research in the typical way that I do it, it was useful.  It pointed out that all the
scenario test expect for approximately 15 scenario tests were passing.  This was
useful for both marking a starting point and for my confidence.&lt;/p&gt;
&lt;p&gt;As I started digging into the failures, those tests started to separate themselves
into two distinct groups: those with code spans including newline characters and
Text tokens occurring at the end of Paragraph blocks.  While the work took a long
time, in both cases the process was the same.  I started by isolating one test in the
group I was looking at, then looked at the consistency check output to find a pattern
that made sense.  Then I just kept on drilling and adding debug where needed until
the pattern became visible to me.  Now, as I have been working on this project for
a while, the “until a pattern became visible” to me is guided by experience and
enhanced by luck, and both just take time.&lt;/p&gt;
&lt;p&gt;After a while, the pattern that leapt out at me for the code span tests was simple:
the line number was being updated properly, but the &lt;code&gt;rehydrate_index&lt;/code&gt; field was not
being updated.  Adding some extra debug, I was able to validate that quickly, then
adding the follow code to remedy that problem:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;link_stack&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;num_columns&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having found and fixed that issue, the second group was then easier to see.  Seeing
as a not updated &lt;code&gt;rehydrate_index&lt;/code&gt; field was the issue with the problem, I gave it
a short with this one, and it worked here as well!  Once again, a quick fix solved
the issue.  Executing the tests with the new changes in place, the consistency checks
were now testing against my intended target of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="paragraphs-ending-with-multiline-non-text-inlines"&gt;Paragraphs Ending with Multiline Non-text Inlines&lt;a class="headerlink" href="#paragraphs-ending-with-multiline-non-text-inlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;That title is a mouthful, but accurate.  The next issue that I tackled was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; - repeat __handle_last_token_text with paragraphs ending with other inlines
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I was not sure if this was going to be a problem, but I can see why I added this to
the issues list.  Most of the existing tests were focused on a specific Markdown
element and either ended with that element or text following that element.  Even
harder to find were tests where the element at the end of the block contained a
newline character in the middle of it.  So, while I found an isolated scenario test
here and there that tackled some of these combinations, there was not a good solid
“here it is” block of tests.&lt;/p&gt;
&lt;p&gt;Time to change that!  To address this, I added test functions &lt;code&gt;test_paragraph_extra_c7&lt;/code&gt;
to &lt;code&gt;test_paragraph_extra_d4&lt;/code&gt;.  Quite simply, I added 8 tests, 4 tests for links and
4 tests for images.  Within each group of 4 tests, I added a split Text element,
a split Code Span element, a split Raw Html element, and a split Emphasis element.
It was not rocket science, but it was good to have all those tests in one place,
ensuring that I was addressing that concern.  Even better?  They all worked on the
first try.&lt;/p&gt;
&lt;h2 id="expanding-paragraph-tests-to-setext-heading-tests"&gt;Expanding Paragraph Tests to SetExt Heading Tests&lt;a class="headerlink" href="#expanding-paragraph-tests-to-setext-heading-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a metaphorical bounce in my step after addressing the last issue,  I decided to
tackle the copying and transformation of Paragraph tests to SetExt Heading tests.
While not officially on the issues list, my goal was to keep the extra Paragraph tests
synced up with their cousins, the extra SetExt Heading tests.  I am not sure if the
right term is cousins, but that is how I thought of them, as the only difference between
the two groups of tests was their
parent blocks.  The contents of the tests remaining the same, except for the addition
of a SetExt Heading block terminator.&lt;/p&gt;
&lt;p&gt;As I knew that these tests were based off existing Paragraph tests, it was pretty
simple to go through the new tests and adjust them to use a SetExt Heading token instead
of a Paragraph heading token.  While simple, even the creation of copied test
functions &lt;code&gt;test_setext_headings_extra_a3&lt;/code&gt; to &lt;code&gt;test_setext_headings_extra_d4&lt;/code&gt; took some
time to get right.  But once again, I was rewarded for my hard work with tests that all
passed, with no failures.&lt;/p&gt;
&lt;h2 id="are-links-being-verified-properly"&gt;Are Links Being Verified Properly?&lt;a class="headerlink" href="#are-links-being-verified-properly" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This task was not to solve the following issue, but to research it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- are links getting verified properly in checks? images are, cannot find link code for same
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on previous tasks, I have done extensive work on making sure that any image
links were verified properly.  However, I have previously noticed that the same
rigor had not been applied to the Link token.  While I did not want to solve the
issue right away, I wanted to make sure I had the right information to resolve it
later.&lt;/p&gt;
&lt;p&gt;And it did not take me long to finally figure out why this issue that had been bothering
me for a while.  The big issue here was that I was missing validation in cases where
an end token was present.  Specifically, while the end Emphasis token has a line/column
number attached to it, the end Link token does not.  That meant that when the previous
token validation was occurring, the existing code was doing the equivalent of a digital
shrug and letting it go.  That was the real crux of the problem.&lt;/p&gt;
&lt;p&gt;Additionally, the Image token was of interest.  Doing a double check of my findings, it
became
immediately obvious why it escaped the same fate: it is a whole token.  Whereas the
Link token has a start token, the inner text, and then an end token, the Image token is
entirely self-contained.  As such, everything is processed at one time, and no end token
handling is required, thus the processing for an empty line/column number was avoided.&lt;/p&gt;
&lt;p&gt;It was clear to me that solving this would require some serious planning and thinking.&lt;/p&gt;
&lt;h2 id="adding-proper-link-verification"&gt;Adding Proper Link Verification&lt;a class="headerlink" href="#adding-proper-link-verification" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given the research from the last section, I decided to take the time needed to tackle
that issue properly.  Dedicating a minimum of 4 hours to this task, I sat down and
started to work the problem.&lt;/p&gt;
&lt;p&gt;To keep things simple, I am going to keep track of the pseudo-code for this solution
instead of the actual code.  While it is true that the code needs some major refactoring
to occur, the more important reason is that it is just very verbose.  The big reason
for me to relay this information is that I found this useful during my development
of the solution.  While the algorithm at its base components is simple, I just found
keeping it in my head in a clear and concise form was too much.&lt;/p&gt;
&lt;h3 id="step-1"&gt;Step 1&lt;a class="headerlink" href="#step-1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first issue was that I needed to have an anchor to base the consistency check’s
line/column numbers from.  As the end Link token does not have a line/column
number associated with it, I first needed to add some code to look backwards in the
token stream for the first valid line/column number.   While I was initially worried
about possible interactions between the end Emphasis token and the end Link token,
I eventually determined that exploring that path was a dead end.  Because the end
Emphasis token has a line/column number, it can serve as an anchor token just as
well as any other token.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;search&lt;/span&gt; &lt;span class="nv"&gt;backwards&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;have&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;valid&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="step-2"&gt;Step 2&lt;a class="headerlink" href="#step-2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that anchor in place, it was then possible to apply the translations to the
line/column number.  This was mostly due to how the link is constructed.  In the
case of a simple inline link such as &lt;code&gt;[link](/url)&lt;/code&gt;, the &lt;code&gt;[&lt;/code&gt; is processed,
then the link label text &lt;code&gt;link&lt;/code&gt;, and then the rest of the link text.  When the
end Link token is encountered, the remaining text &lt;code&gt;](/url)&lt;/code&gt; needs to be accounted
for.&lt;/p&gt;
&lt;p&gt;Starting with the code for the handling of the Image token, I was able to quickly
build up a similar block of code that provided the translations for the line/column
number.  As I had a pattern to work off of, this work went by fairly quickly.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;search&lt;/span&gt; &lt;span class="nv"&gt;backwards&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;have&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;valid&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;apply&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;translations&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;due&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;rest&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;Link&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="step-3"&gt;Step 3&lt;a class="headerlink" href="#step-3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that work in place, I then went to handle the previous token in the normal
case and hit an issue.  The anchor line/column number did not seem to be correctly
calculated. I double checked my code, and everything looked fine.  Doing some
deep digging, I started to understand why.  When I figured out which token to use as
the anchor, I did not take into account any changes introduced
to the line/column number by the anchor token itself.  Basically, if I was
using a Text token containing &lt;code&gt;text&lt;/code&gt; at &lt;code&gt;(2,7)&lt;/code&gt; as an anchor, I was using that
&lt;code&gt;(2,7)&lt;/code&gt; as the starting point, ignoring any changes introduced by its contents.
Instead, I needed to use &lt;code&gt;(2,11)&lt;/code&gt; as the starting point, taking the length of
the token’s original Markdown into account.&lt;/p&gt;
&lt;p&gt;The saving grace here was that immediate calculations were okay, so I just added the
code following the previously added code.  While it does not affect the results, in
hindsight I might want to move the translation code for the anchor token up to make sure
that the code logically flows better.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;search&lt;/span&gt; &lt;span class="nv"&gt;backwards&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;have&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;valid&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;anchor&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;apply&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;translations&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;due&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;rest&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;Link&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;apply&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;translations&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;due&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;anchor&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="testing-the-changes-and-further-adjustments"&gt;Testing the Changes and Further Adjustments&lt;a class="headerlink" href="#testing-the-changes-and-further-adjustments" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having executed an isolated scenario test or two during these changes, I then went to
execute those tests again, and the results were hopeful.  From what I could see, the
line/column number calculations
were working properly, but another assert was getting fired.  After a quick check,
I came to an interesting observation: while looking at the line/column numbers and
making sure they were being adjusted properly, I totally forgot about the
&lt;code&gt;rehydrate_index&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;Most of the adjusting went off without a hitch, but a couple of outlying tests
were still failing with the assert for the &lt;code&gt;rehydrate_index&lt;/code&gt; field.  It took me
a good couple of hours of adding debug statements and scanning the consistency
check output before I found the pattern.  While I had just added code to adjust
the &lt;code&gt;rehydrate_index&lt;/code&gt; field to account for the Link token, I had failed to adjust
the field to account for the anchor token.  As such, if the token before the end
Link token (the anchor token) contained one or more newline characters, those
newline characters were missed.&lt;/p&gt;
&lt;p&gt;Fixing that problem took a bit of creativity.  I already had the code to properly
calculate the proper values, but they were in the &lt;code&gt;__process_previous_token&lt;/code&gt; function.
The problem with reusing that function was that it modifies the &lt;code&gt;rehydrate_index&lt;/code&gt; field
as a side effect, something I was not sure that I wanted to happen.  In the end, I
worked around this problem by doing a sample call to the &lt;code&gt;__process_previous_token&lt;/code&gt;
function and getting the change in the line number, then invoking that function
again on the anchor token, applying the proper change and restoring the
&lt;code&gt;rehydrate_index&lt;/code&gt; field.  It took a while to figure that out and get it working, but
it was worth it.&lt;/p&gt;
&lt;p&gt;With that code in place, I ran those tests again, and the consistency checks for
the small sample of tests I was using passed.  Crossing my fingers, I ran it for
the entire set of scenario tests and was happy to see that they all had passed.
While it took quite the while to accomplish, it was good to finally put that issue
to rest.&lt;/p&gt;
&lt;h2 id="needing-some-extra-emphasis"&gt;Needing Some Extra Emphasis&lt;a class="headerlink" href="#needing-some-extra-emphasis" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the description for this issue was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- add verification for links with the endlink as the last element
- add verification for links+emphasis as the last 2 inline elements
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I felt that it really did not describe the problem properly.  Added when addressing
the previous issue, what I believe I was trying to note is that I wanted more
testing with the interaction with the end Link token and the end Emphasis token.  At
the time when I added that note, I remember thinking that there might be some weird
interaction between the two end tokens.  It was only later that I remembered that the
end Emphasis token was the rare end token that has a line/column number attached to it.&lt;/p&gt;
&lt;p&gt;Still, it made sense to add some extra tests for emphasis and interactions with the
link tokens, as I did not believe I had good coverage of that so far.  To remedy that,
I added test functions &lt;code&gt;test_paragraph_extra_d7&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_e0&lt;/code&gt;, with
emphasis around the the link and image elements followed by emphasis within the link
label of the link and image elements.  These tests were not at all complicated to add
and I am also not sure they are actually needed.  However, as I perceived testing in
that area to be a bit thin, adding those tests just seems to me to be a good idea.
And luckily, after running those new tests, everything passed without incident.&lt;/p&gt;
&lt;h2 id="just-before-the-end"&gt;Just Before the End&lt;a class="headerlink" href="#just-before-the-end" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I remember looking at the clock and noticing that I had around 20 minutes left before I
started writing that week’s article at noon.  While I used to start writing first thing
Sunday morning, as
of recently I have tried to keep my notes in a way that I could more easily mine them
for the articles.  Still in the proving stage, it has helped me out with the writing
process, allowing me to find my flow more easily on Sunday at noon when I now start
writing.&lt;/p&gt;
&lt;p&gt;Anyhow, with somewhere near 20 minutes left before noon on a Sunday and me wanting to
milk the clock for every minute that I could, I quickly looked at the issues list.
I was hopeful that I could find some
&lt;a href="https://www.merriam-webster.com/dictionary/low-hanging%20fruit"&gt;low-hanging-fruit&lt;/a&gt;
to work on in the time remaining, and quickly came across this little gem:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- code span
  - multiple lengths of ticks, whitespace
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I felt that this was a good candidate, but I still needed to investigate it.  At the
very least, I could get the research done and have it ready for next week.&lt;/p&gt;
&lt;h3 id="the-research"&gt;The Research&lt;a class="headerlink" href="#the-research" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After some quick research, I found out that while the scenario tests between (and
including) the &lt;code&gt;test_code_spans_338&lt;/code&gt; function and the &lt;code&gt;test_code_spans_359&lt;/code&gt;
function has some interesting variations, I felt that they were missing some basic
coverage.  Looking at those tests, it was pretty evident that tests with variations
on the number of backticks and the amount of whitespace were in the minority.  Doing
some quick scans for the number of backticks in the tests, my suspicions were confirmed
with only 4 tests dealing with double backticks and no tests dealing with more than two
backticks.  As for whitespace, the tally was similar: 5 tests with one whitespace
character and 1 test with 2 whitespace characters.&lt;/p&gt;
&lt;h3 id="fixing-the-issue_1"&gt;Fixing the Issue&lt;a class="headerlink" href="#fixing-the-issue_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that research in hand, I could either document the issue more thoroughly, or fix
the issue.  Looking back at the description of the issue, I inferred that what I was
really looking for was a centralized place where those tests kept, not having to look
for them all over the place.  If that were the case, I figured I could solve the issue
by adding 3 new tests, so I decided to fix the issue.&lt;/p&gt;
&lt;p&gt;The 3 new tests?  I started with the text &lt;code&gt;aa`aa`aa&lt;/code&gt;, adding one backtick and
one whitespace in critical areas to get &lt;code&gt;aa `` aa `` aa&lt;/code&gt; and then finally
&lt;code&gt;aa  ```  aa  ```  aa&lt;/code&gt;.  I just kept it simple and created 3 new tests, each
one clearly handling an increasing number of backticks and whitespace.   A quick
execution of the new scenario tests, and… no issues.  Assuming my inference was
correct, problem solved!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there were only a couple of issues that made me really think about how
to solve them, this was a good week for just getting some issues taken care of.
At this point in the project, I am confident that I have 95 percent of the
code working properly.  My hope is that by adding new tests and making sure
that existing tests are grouped properly, I can find those outlier scenarios
that I have not thought of.  Whether those scenarios end up working or failing
is something I cannot control.  But I can strive to find as many of those
scenarios as possible.&lt;/p&gt;
&lt;p&gt;And I have noticed that this hope is being largely reflected in the work I am
doing.  Less and less work is in the project’s parser itself, with more
changes being attributed to improving the verification of the parser.  From where
I sit, that is a good place to be in.  The other observation?  In times when I do
need to change the parser, those changes are usually small changes of five lines or
less.  That statistic alone fills me with confidence.&lt;/p&gt;
&lt;p&gt;Now, while I do want to find as many scenarios as possible, I need to balance that
with trying to wrap up the initial phase of this project so I can use it and get the
project out there.  For me, that means I need to start buckling down and shifting
my focus away from issues in the “Nice to Have” category and work on the other
issues.  Here’s hoping I can action on that!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From my viewpoint, next week’s article will be interesting as I talk about my
efforts to group the tests together more concisely, with documentation to back
up the reasons for those tests.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 5</title><link href="https://jackdewinter.github.io/2020/10/26/markdown-linter-delving-into-the-issues-5/" rel="alternate"></link><published>2020-10-26T00:00:00-07:00</published><updated>2020-10-26T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-26:/2020/10/26/markdown-linter-delving-into-the-issues-5/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/19/markdown-linter-delving-into-the-issues-4/"&gt;last article&lt;/a&gt;,
I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To be totally honest with any readers, the work …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/19/markdown-linter-delving-into-the-issues-4/"&gt;last article&lt;/a&gt;,
I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To be totally honest with any readers, the work that I did for this article was just
more of the same stuff.  Basically, look at the
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/main/readme.md"&gt;issues list&lt;/a&gt;,
find something to work on, and work on it.  However, as of late, I have been trying to
find groups of issues to work on, instead of one-off items.  As such, I was looking
for issues that could help me resolve questions about a group of behavior for the
project, not just a very specific behavior.&lt;/p&gt;
&lt;p&gt;And to continue to be honest, this work was done during a difficult week for me.
With things to do around the house, I did not seem to get any really good stretches
of time to work on the project until later at night when I was tired.  It was just
one of those weeks.&lt;/p&gt;
&lt;p&gt;But even though I was tired, I wanted to continue.  While I would have been ecstatic
to continue working with great velocity, what I needed to do was to maintain forward
momentum.  That meant picking items from the issues list that I could work on in
phases, keeping that momentum up from phase to phase.  That is why I wanted to focus
on items I could deal with as a group.  It was a good way to keep working, while not
feeling I was forever stopping.  For me, it was not about doing the work as much as
maintaining the feeling that the work was progressing.  That is what was important to
me.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/98e691cc253e03769acecf087e546f0b90507e23"&gt;07 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/59c624c08a7fe6f9f3072123c5ec9beac8e5c6ad"&gt;11 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-with-some-cleanup"&gt;Starting With Some Cleanup&lt;a class="headerlink" href="#starting-with-some-cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As usual, there were some issues left over from the previous week that I needed to
take care of.  While not pivotal to my efforts going forward, I spent a brief amount of
time going through the &lt;code&gt;Bugs - General - Uncategorized&lt;/code&gt; section of the issues list,
making sure to remove anything that had already been done. This effort was mostly
done for reasons of cleanliness and accuracy, though I will admit that getting rid of
a handful of items that had been completed was good for my confidence.&lt;/p&gt;
&lt;p&gt;In addition, during the prior week’s testing, I had added functions
&lt;code&gt;test_fenced_code_blocks_099k&lt;/code&gt; and &lt;code&gt;`test_fenced_code_blocks_099l&lt;/code&gt; to test out
different counts of multiple blank lines within a fenced code block.  As those tests
passed and seemed useful, I decided to keep them in the test suite, but did not have an
issue to tag them with.  It just made sense to add them at this point, before taking
them any further.&lt;/p&gt;
&lt;h2 id="ensuring-consistent-paragraphs"&gt;Ensuring Consistent Paragraphs&lt;a class="headerlink" href="#ensuring-consistent-paragraphs" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The work in this section all came from one line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- make sure line/column is tracking text indenting on each line
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not a fantastically descriptive line, but it was there.  And it was enough for me to
understand what it is that I wanted to look at.&lt;/p&gt;
&lt;p&gt;In previous articles, I have talked about how paragraphs are the base building block of
any Markdown document.  Being the default block container for the default inline
element, I would guess that an average of 75% of existing Markdown document blocks are
Paragraph elements.  I have no hard facts to back it up, but as I look at a
representative sample of the articles I have worked on, a
&lt;a href="https://en.wikipedia.org/wiki/Scientific_Wild-Ass_Guess"&gt;SWAG&lt;/a&gt; leads me to think that
75% is a fairly good estimate.&lt;/p&gt;
&lt;p&gt;This perceived predominance of Paragraph elements in Markdown documents influenced
my perception when I was designing the token system used by the PyMarkdown project.
To accommodate this perception, I decided to place any
newline handling elements in the Paragraph token instead of the encapsulated inline
tokens.  At the time, my thoughts were that the Paragraph element
had rules that were different enough from the 2 header elements, the 2 container
elements, and the 2 code block elements, that I needed to capture the element’s
information differently.  As Paragraph elements largely ignore leading space on a given
line, the Paragraph token seemed to be the right place to store that information.  While
it has caused a couple of issues in the past, I still believe that it is still the right
decision.&lt;/p&gt;
&lt;h3 id="the-issue"&gt;The Issue&lt;a class="headerlink" href="#the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I do believe it was the right decision to make, that decision has added extra
headaches to the project.  The big headache is confirming that the newlines in the
inline token correspond to newlines in the whitespace that is extracted and stored
in the Paragraph token.  That is where the &lt;code&gt;rehydrate_index&lt;/code&gt; field comes in.&lt;/p&gt;
&lt;p&gt;I have talked about it in passing, especially in a previous post in the section
titled
&lt;a href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/#verifying-the-rehydration-index"&gt;Verifying the Rehydration Index&lt;/a&gt;.
In that article, I talk about how I was not sure if there were any errors because
I was not sure that the field was named correctly.  While I concluded that
the field was named correctly, that name can still be confusing at times.  The
&lt;code&gt;rehydrate_index&lt;/code&gt; field
indicates the index of the next newline that will need processing.  As such, once the
processing of any text at the start of a line is done within the bound of a Paragraph
token, that field is updated to &lt;code&gt;1&lt;/code&gt;.  This offset also means that when all processing
for the text within the Paragraph token has been completed, the index should be set to
the number of newline characters plus &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To move towards consistency of this field’s value, I added the following code to the
end of the processing of the end of a Paragraph block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;num_newlines&lt;/span&gt;
            &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"rehydrate_index ("&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;") != num_newlines("&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;")"&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, if the algorithm is at the end of a Paragraph block, any inline elements
contained within the paragraph should have moved the &lt;code&gt;rehydrate_index&lt;/code&gt; field to its
proper value.
However, I needed to add an alternate conditional to handle the case where it was
1 count short.  While that was concerning, it was more concerning that there were some
cases where the &lt;code&gt;rehydrate_index&lt;/code&gt; field even fell short of that adjusted mark.  I felt
it was imperative to get those outliers addressed first.&lt;/p&gt;
&lt;h3 id="addressing-the-failures"&gt;Addressing the Failures&lt;a class="headerlink" href="#addressing-the-failures" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In debugging, it is not often that an answer almost literally jumps out and screams
“Here I am, please fix me!”  In this case, when I executed the failing scenario tests
and looked at their failures, it was an easy observation to make.  For some
reason, the Text token after a Hard-Line Break token included a newline character in
its text section, but did not include a newline character in its whitespace section.
As a result of that mismatch, the tests failed as the Paragraph token’s
&lt;code&gt;rehydrate_index&lt;/code&gt; field was not set to the correct value when verifying the tokens.&lt;/p&gt;
&lt;p&gt;It took me a while of careful tracing through the logs, but I finally found that in
the handling of the end of the line for a Hard-Line Break token, it was not clearing
the &lt;code&gt;whitespace_to_add&lt;/code&gt; variable in both case.  This code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;whitespace_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was being executed if the Hard-Line Break token was created by multiple space characters
in the Markdown document.  However, if the token was created by the backslash character
at the end of the line, it was not.  Making sure that code was in both branches solved
some of those issues, but every test.  There were still a handful of tests that failed.&lt;/p&gt;
&lt;h3 id="covering-my-bases"&gt;Covering My Bases&lt;a class="headerlink" href="#covering-my-bases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While the tests for the SetExt Headings tokens were all passing, the discovery of
the previous failures inspired me to add some similar tests for the SetExt Heading
tokens.  To do this, I started with the original scenario test,
&lt;code&gt;test_setext_headings_extra_22&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="err"&gt;\\&lt;/span&gt;
&lt;span class="c1"&gt;---&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there,
I added functions &lt;code&gt;test_setext_headings_extra_22a&lt;/code&gt; to &lt;code&gt;test_setext_headings_extra_22d&lt;/code&gt;
to test the creation of a Hard-Line Break token followed with a Text token.  To start,
I added the first two functions that simply had both forms of creating a Hard-Line
Break token with some simple text following it.  In addition, to make sure that I was
handling the next line’s leading whitespace properly, I added two more variations that
included a single space character at the start of the following line.&lt;/p&gt;
&lt;p&gt;While I am not sure how useful these four tests will be in the future, at the time they
were important.  As I had just fixed some issues with Paragraph tokens and extracted
whitespace, I wanted to make sure that a similar format with SetExt Heading embedded
text did not suffer from a similar problem.&lt;/p&gt;
&lt;h3 id="continuing-forward"&gt;Continuing Forward&lt;a class="headerlink" href="#continuing-forward" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the experience from the last section in hand, I continued to look for the root
cause of the remaining failed tests.  As in the previous section, the tests were
failing with a common theme: newlines that occurred within a Link token.  &lt;/p&gt;
&lt;p&gt;While the solution to this issue was not as easy to arrive at as the solution for
the last section, it was fairly simple to see that the problem had two parts:
the tokens derived from the link’s label, and the main body of the link itself.
Almost as soon as I started looking at the logs, I noticed that the numbers were
off, and I had to dig in a bit deeper.&lt;/p&gt;
&lt;h3 id="digging-deeper"&gt;Digging Deeper&lt;a class="headerlink" href="#digging-deeper" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The way inline links are constructed is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, the token generation algorithms follow the way that the tokens are used to
generate the HTML output, which for that Markdown is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the link label (the text &lt;code&gt;link&lt;/code&gt; in the above sample) may contain any form of inline
text except for another link, that information cannot be contained in its processed
form within the Link token.  Instead, there is a start Link token, followed by the
processed version of the link label, followed up by the end Link token.  From
PyMarkdown’s point of view, the token stream for the above Markdown document is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "[para(1,1):]",
        '[link(1,1):inline:/uri:title::::link:False:":: :]',
        "[text(1,2):link:]",
        "[end-link:::False]",
        "[end-para:::True]",
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unless the Link token contained a newline character somewhere within its bounds,
everything was working properly, and the consistency checks were properly verifying the
tokens.  But when the Link tokens contained a newline character, those properly working
algorithms were not working so well.&lt;/p&gt;
&lt;h3 id="finding-a-solution"&gt;Finding A Solution&lt;a class="headerlink" href="#finding-a-solution" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I knew that this problem had two parts, I figured that the solution needed to have
two parts are well.  I believe that my realization of that conclusion is what enabled
me to shortcut other solutions that did not work in favor of a split
solution that did work.&lt;/p&gt;
&lt;p&gt;The first half of the solution needed to deal with the text contained within the link
label.  While this text is handled in the tokens between the start end end Link tokens,
from a Markdown point of view, it occurs right after the opening &lt;code&gt;[&lt;/code&gt; character of the
link.  The good news here is that adjusting the &lt;code&gt;rehydrate_index&lt;/code&gt; field for each
enclosed token was easily done by adding some simple code at the end of the processing
loop in the &lt;code&gt;__verify_inline&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;The second half of the solution was in the handling the Link token itself.  As the
inside inline tokens come first in the Markdown document, it made sense to handle
the Link part of the solution when the end Link token is processed.  This meant
adding some extra code to the &lt;code&gt;__verify_next_inline&lt;/code&gt; function, processing the
end Link token at the top of the function if the &lt;code&gt;current_line_token&lt;/code&gt; line/column
numbers are both &lt;code&gt;0&lt;/code&gt;.  If the &lt;code&gt;current_line_token&lt;/code&gt; variable is a end Link token
and the code is processing within a Paragraph token, I added new functionality
to calculate the number of newline characters encountered within the Link token
itself.&lt;/p&gt;
&lt;p&gt;Running through this code in my head, and solving some simple issues, I executed
the failing tests again, and was pleased to find that they were all passing.  In
that version of the code, I had four different sections, one for each type of
link.  However, after a quick examination of the code, I believed that the code could
easily be parsed down to one block of code that just gathered the newline counts
from each part.  Eliminating all the other blocks except for the inline block,
I was happy to find out that my guess was correct.  The way I had set up the values
for the other types of links allowed for a more simplified version of the code.&lt;/p&gt;
&lt;p&gt;After a quick check of that guess locally, a full scenario test run confirmed that
there were no ill effects of these changes, I cleaned the code up and checked in
that work for the first part of the week.&lt;/p&gt;
&lt;h2 id="interlude"&gt;Interlude&lt;a class="headerlink" href="#interlude" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It was after this point in the week where it became more difficult to find numerous
good blocks of time to work on the project.  The first day it happened it was not so
bad, but the struggle to find good time to work on the project was draining.  I
knew I had to keep my priorities focused on the other tasks in my life, as they
had priority.  But even so, it was just hard not to get a good block of work done
on the project.&lt;/p&gt;
&lt;p&gt;But I persevered.&lt;/p&gt;
&lt;h2 id="inlines-and-new-lines"&gt;Inlines and New Lines&lt;a class="headerlink" href="#inlines-and-new-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The second half of the week was spent working on clearing up a related item from
the issues list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- need other multiline elements in label and verify
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Piggybacking off the previous item, this seemed like a really good choice to pick off
the issues list.  While the previous work dealt with plain text inside of the link
label, this issue took that work and improved on it.  Instead of just simple text
elements, this work adds testing support for Raw Html tokens and Code Span tokens that
span multiple lines.&lt;/p&gt;
&lt;h3 id="starting-with-tests"&gt;Starting with Tests&lt;a class="headerlink" href="#starting-with-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The start of this work was easy.  I added scenario
test functions &lt;code&gt;test_paragraph_extra_a3&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_c6&lt;/code&gt; to cover all
the new scenarios.  Starting with simple tests, the first three tests that I specified
were a normal link label &lt;code&gt;[li\nnk]&lt;/code&gt;, a code span &lt;code&gt;[li`de\nfg`nk]&lt;/code&gt;, and a raw
html &lt;code&gt;[li&amp;lt;de\nfg&amp;gt;nk]&lt;/code&gt;.  Moving on to variations of those tests, having completed
those tests for the inline link type, I transitioning to examples for the full link
type, the collapsed link type, and the shortcut link type.  Once those variations were
done, I copied each of those tests, replacing the start Link element character &lt;code&gt;[&lt;/code&gt; with
the Image element character &lt;code&gt;![&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Work to setup the tests was also easy, but pedantic.  After a quick survey of the
inline element types, I was shocked to find out that only the three inline tokens
named above allow for newlines with their elements.  It did make the creation of
the tests easier though, so I was happy to find that out.&lt;/p&gt;
&lt;p&gt;And maybe it was just my experience on the project, but the test setup went
smoothly.  I did the research, I figured out what I needed to test, and then cycled
through the variations with speed and accuracy.  Just felt good to have a solid grasp
on the problems.&lt;/p&gt;
&lt;h3 id="starting-with-the-inline-processor"&gt;Starting with the Inline Processor&lt;a class="headerlink" href="#starting-with-the-inline-processor" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From a link point of view, the tests were generating their tokens
successfully.  The Text tokens and Code Span tokens were being handled properly,
passing all their tests.  However,
when the Raw Html token tests were executed, the text &lt;code&gt;text&lt;/code&gt; was being added
to the token stream instead of the Raw Html token.  Having fixed an issue in this area
before, I had a feeling
it was in the &lt;code&gt;__collect_text_from_blocks&lt;/code&gt; function, where link tokens are
translated back into their source text.  After taking a quick look there, it
was somewhat funny to see that I had handled the Code Span token case, but not
the Raw Html token case.  A quick fix, followed by another run over those tests,
and the Link token tests that were failing started working again.&lt;/p&gt;
&lt;p&gt;That left the failing tests that dealt with Image tokens.  While this took a bit
more work, it was roughly the same process as with the Link token.  In this case,
the text for the &lt;code&gt;alt&lt;/code&gt; parameter of the &lt;code&gt;image&lt;/code&gt; tag is created by consuming
the elements generated from the Image token’s label field.  This work is done
by the &lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function, consuming the tokens as the
processing is done.&lt;/p&gt;
&lt;p&gt;The main difference with this process from the link process is that, according to
the GFM specification, this text is preserved largely without any of the special
characters.  As such, I had to check the proper translation of each of the
inline tokens against BabelMark to make sure that I had the right translation.
But other than that extra bump in the process, it went smoothly.  The
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function filled out quickly with each
coded translation.&lt;/p&gt;
&lt;p&gt;With that task completed, the scenario tests were generating the HTML output
that I expected.  Onwards!&lt;/p&gt;
&lt;h3 id="rehydrating-the-markdown-text"&gt;Rehydrating the Markdown Text&lt;a class="headerlink" href="#rehydrating-the-markdown-text" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After I was sure that the tokens being generated correctly, I quickly ran each of the
Markdown documents from the new tests through
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;Babel Mark&lt;/a&gt;,
verifying that the output
HTML was correct.  Encountering no problems, I moved on to the rehydration of those
tokens into Markdown and was happy with the results.  With only a couple of tests
failing, I took a quick look at the failures and noticed the problem right away:
rehydrating Link tokens and Image tokens that contained newlines was not working.&lt;/p&gt;
&lt;p&gt;Following the log files, I was able to quickly figure out that the problem was
that the backslash escape sequences and replacement markers were not being resolved
from the text before doing the final rehydration of the elements.  In the end,
the following lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;text_to_modify&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove_backspaces_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_modify&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;text_to_modify&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resolve_replacement_markers_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;text_to_modify&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;were added to the &lt;code&gt;__insert_leading_whitespace_at_newlines&lt;/code&gt; function to resolve
those elements.&lt;/p&gt;
&lt;p&gt;With that code added, every scenario test was passing to the point of being able
to regenerate its original Markdown.  On to the consistency checks!&lt;/p&gt;
&lt;h3 id="cleaning-up-the-consistency-checks"&gt;Cleaning Up the Consistency Checks&lt;a class="headerlink" href="#cleaning-up-the-consistency-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It was in this area that I spent a lot of time making sure things were correct.
Due to the shortened time blocks in which I could work on the project, the solutions
that I initially came up with were just not solid enough solutions to use.  These
solutions were either too complicated or failed to meet the criteria, leading me to
throw each approach out.  In the end, I just reset to use a simple approach, after
which things started to work out fine.&lt;/p&gt;
&lt;p&gt;Learning from my previous work, I was pretty sure these changes were going to involve
handling replacement markers and backslash escapes better.  Specifically focusing
on the link label and image label, I was able to quickly determine that the link
labels and link text from the different link types in the
&lt;code&gt;__verify_next_inline_inline_image&lt;/code&gt; function needed to call the
&lt;code&gt;resolve_replacement_markers_from_text&lt;/code&gt; function to remove the replacement markers.&lt;/p&gt;
&lt;p&gt;After making that change, I followed a hunch to see if the other changes I made needed
to be copied in some form to the consistency checks.  I was rewarded to find positive
benefit to extending the code under the &lt;code&gt;if "\n" in str(current_inline_token):&lt;/code&gt;
condition of the &lt;code&gt;__verify_inline&lt;/code&gt; function in a manner similar to the changes made to
the &lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function.  It just made sense.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This was just a brutal week project-wise.  The stop-and-go (but mostly stop) nature
of this week reminded me of a time home when I worked in a cubicle farm for a year.
Instead of people just looking over at you or emailing you, they would have to walk
over to your cubicle and stand by your “door” to have a conversation with you.  At
least for me, it often seemed like I was just getting into a good work flow when
someone else showed up to talk, causing another interruption.&lt;/p&gt;
&lt;p&gt;While I definitely had my priorities straight in dealing with the issues around my
house, the stop-and-go nature of this week made it hard to get into a good flow.
Even thinking about how I felt that week made the task of writing this article more
difficult.  It was just that jarring at times.&lt;/p&gt;
&lt;p&gt;That also made my current predicament that much more painful.  I can see the issues
list getting smaller and smaller, closer to a point where I know I will feel comfortable
in releasing the project.  And I want to get there, but I want to get there with what
I consider to be solid quality.  But I also want to get there soon.  And I know that
if I had more quality time during the week, I would have been able to resolve at least
a couple more issues.&lt;/p&gt;
&lt;p&gt;But I am still happy with the momentum on the project, and where I am with it.  And
one of the promises that I made to myself at the start of the project is that I must
have balance between this project and other priorities in my life.  And this was
just a week where I had to put my money where my mouth was.&lt;/p&gt;
&lt;p&gt;Hopefully next week will be better.&lt;sup id="fnref:ofCourse"&gt;&lt;a class="footnote-ref" href="#fn:ofCourse"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next week’s article will be more interesting, as I was able to address my time
allotments on the project, submitting 9 commits during that week.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:ofCourse"&gt;
&lt;p&gt;It was better.  These articles track roughly 2-3 weeks behind the actual work, I know for a fact it got better. &lt;a class="footnote-backref" href="#fnref:ofCourse" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 4</title><link href="https://jackdewinter.github.io/2020/10/19/markdown-linter-delving-into-the-issues-4/" rel="alternate"></link><published>2020-10-19T00:00:00-07:00</published><updated>2020-10-19T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-19:/2020/10/19/markdown-linter-delving-into-the-issues-4/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/12/markdown-linter-delving-into-the-issues-3/"&gt;last article&lt;/a&gt;, I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are times during the development of a project …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/12/markdown-linter-delving-into-the-issues-3/"&gt;last article&lt;/a&gt;, I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are times during the development of a project where the tasks are all feature
related, and then there are times where the tasks are all issue related.  Instead of
waiting for that second era to arrive, I instead elected to proactively invest extra
time in trying to improve the scenario tests.  While I know I will not find every
issue, I want to make sure I do my best to throw as many combinations of elements
against the wall, hoping none of those combinations will stick.&lt;sup id="fnref:spaghetti"&gt;&lt;a class="footnote-ref" href="#fn:spaghetti"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;From my viewpoint, I am aware that this focus on quality is taking time and effort
away from adding new rules to PyMarkdown.  However, in my eyes, every minute spent on
making sure the project is stable is worth it.  Even with the knowledge that I will
not catch every issue before it happens, I am confident that by being proactive and
adding groups of tests, I will put the project in a great position to be a stable
platform for linting Markdown documents.  Even better, by focusing on groups of
combinations instead of individual tests, I believe I can discover a large group
of issues at the current stage, instead of in a bug report later.  At the very least,
that is my hope, and my confidence is increasing with each group I add.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/a506ddd3bda08a8ca1d97a7b0d68c114325b545e"&gt;02 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/953ed1b4afdc40353995dd7b1dcd41e7a306effc"&gt;04 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="cleaning-up-after-last-week"&gt;Cleaning Up After Last Week&lt;a class="headerlink" href="#cleaning-up-after-last-week" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As the work I documented last week ran into the overtime territory, I decided at that
time to disable those tests, with promises to work on them next week.  As this is the
next article, this is the next week.  Time to get to work!&lt;/p&gt;
&lt;p&gt;With very few exceptions, the results of each scenario test have been checked at
least three times.  As such, I was very confident that I needed to update the
consistency checks to deal with these changes, and not the results. As an ancillary
task, since the code to calculate the line/column number was just introduced, I knew
that there was a decent chance that I might find an issue or two that would need to be
fixed.  As the consistency checks were not passing, I was hoping that it was the
checks that needed updating but prepared for changes in the parser itself.  Only
research would tell, so it was on to more research!&lt;/p&gt;
&lt;h3 id="doing-the-research"&gt;Doing the Research&lt;a class="headerlink" href="#doing-the-research" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Digging into the code for links, it seemed obvious that the issue was with the links
and their column numbers was something simple.  As I scanned more code, my confidence
that it was something simple just increased.  All the big pieces of code looked
fine, but one thing was sticking out: replacements.  Back when I was adding the
Markdown transformer, I made sure that both the HTML-friendly and Markdown-friendly
versions of the token’s text were included in the Link Token.  However, when I added
the code to handle this into the consistency checks, I got confused.&lt;/p&gt;
&lt;p&gt;Part of this is my own fault, but the reason I was confused was due to the duality
that exists in the tokens and the project.  In inline text situations, replacement
sequences are used to show both the &lt;em&gt;before&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; parts of the replacement.
In link situations, a similar pattern is used, including both parts of the replacement
in the token.  However, in the link case, there are a couple of added wrinkles.&lt;/p&gt;
&lt;p&gt;The first wrinkle is that there are usually 2 different fields of the Link token
that contain this information. Using the &lt;code&gt;link_title&lt;/code&gt; field as an example, the processed
version is stored in that field, while the raw text used to generate that field is
kept in the &lt;code&gt;pre_link_title&lt;/code&gt; field.  To avoid useless duplication of fields, the
&lt;code&gt;pre_&lt;/code&gt; version of the field is only used if they have a different value that their
processed field.  That is the second wrinkle.  In processing that Link token
information, it is common to see code likeL&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, set the &lt;code&gt;link_title&lt;/code&gt; variable to the token’s &lt;code&gt;link_title&lt;/code&gt; field by default.
But if the &lt;code&gt;pre_link_title&lt;/code&gt; field is set, use that instead.&lt;/p&gt;
&lt;p&gt;Given that there are two different access patterns, sometimes I can get confused and
use a process for dealing with the other access pattern.  And that is where the third
wrinkle shows up: dealing with link labels.  In the case of link labels, the processed
version of the text exists between the start Link token and the end Link token, with
the raw version being kept in the start Link token’s &lt;code&gt;text_from_blocks&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;And to be honest, while it does make sense in how each of the 3 use cases are used in
practice, remembering which one is in play when I am writing code on a given field
can be difficult.&lt;/p&gt;
&lt;h3 id="fixing-the-issues"&gt;Fixing the Issues&lt;a class="headerlink" href="#fixing-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Hopefully there is enough information in the previous section to allow for this
revelation
to be easy to see in advance: I used the wrong pattern in one place and the wrong
field in another place.  While the fix was just a couple of lines of code in the
newly refactored &lt;code&gt;__verify_next_inline_inline_image_inline&lt;/code&gt; function, it took some
debugging to properly address the issue by using the correct patterns.  With both
patterns adjusted, most of the tests were passing.&lt;/p&gt;
&lt;p&gt;It was in those remaining failures that I noticed that another problem that was hiding
behind that problem:
character references were not updating the column number.  With all the confusion
of the other problem out of the way, there were a couple of outlier tests dealing
with character entities that were not adding any space for the Code Span tokens.
That was fixed by adding the following code to the end of the
&lt;code&gt;handle_character_reference&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_index&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, it was obvious that something needed to be done once I started looking
at the function itself, but without something causing me to look there, it was
overlooked.  I was just grateful that the extra scenario tests pointed this out!&lt;/p&gt;
&lt;h2 id="rounding-out-image-support"&gt;Rounding Out Image Support&lt;a class="headerlink" href="#rounding-out-image-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the support for images and their line/column numbers was added a long time ago,
the proper validation support in the consistency checks was only recently added.  In
addition, while previous work tested the inline image support, there was very little
testing of the shortcut and compressed image types, and no testing of the full image
type.&lt;/p&gt;
&lt;h3 id="adding-the-tests"&gt;Adding The Tests&lt;a class="headerlink" href="#adding-the-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The testing part of this support was easy to address.  As part of finishing the work
from the previous
week, I copied over tests &lt;code&gt;test_paragraph_extra_78&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_89&lt;/code&gt;, renaming them &lt;code&gt;test_paragraph_extra_90&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_a2&lt;/code&gt;.  Once that was
done, I changed the example text from the link start sequence &lt;code&gt;[&lt;/code&gt; to the image start
sequence &lt;code&gt;![&lt;/code&gt;.  Temporarily disabling the consistency checks, I then ran through
each of the scenario tests, adjusting the token output and the HTML output for the
change from a Link token to an Image token.  From the token point of view, I was
primarily looking for the Image token to take the place of the start Link token.  In
addition, I was checking to ensure that any tokens after the start Link token but before
(and including) the end Link token were removed.  Finally, I adjusted the HTML for the
scenario from an HTML anchor tag to an HTML image tag, along with any tag attribute
changes that were required.&lt;/p&gt;
&lt;p&gt;At this point, it should go without saying that as I was making those changes, I ran
through the token output and the HTML output multiple times.  I did these checks both
mentally and my tried and true method of “counting out loud”, verifying that both values
were the same. As I knew the next task was to properly implement the consistency checks
for the other image types, I also knew that an extra count or two would take less time
than trying to debug any off-by-one issues with any of the line/column numbers.  It just
made sense to take an extra minute per test and do that extra level of verification.&lt;/p&gt;
&lt;h3 id="reviewing-collapsed-and-shortcut-images"&gt;Reviewing Collapsed and Shortcut Images&lt;a class="headerlink" href="#reviewing-collapsed-and-shortcut-images" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Containing only a link label, the shortcut and collapsed image types had already been
coded into the consistency check.  From a quick visual inspection, they both made
sense and looked great:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"collapsed"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;image_alt_text&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_from_blocks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_from_blocks&lt;/span&gt;

        &lt;span class="n"&gt;token_prefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;newline_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image_alt_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;
            &lt;span class="n"&gt;para_owner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;
            &lt;span class="n"&gt;estimated_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

            &lt;span class="n"&gt;split_label_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_alt_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_label_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;token_prefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="n"&gt;estimated_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="n"&gt;estimated_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;token_prefix&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image_alt_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the collapsed link type as an example, the algorithm was really easy to code up.
A Markdown collapsed link type looks like this: &lt;code&gt;[reference][]&lt;/code&gt;.  To start with, the
code to determine the content of the link label is used, as was mentioned in the
previous sections.  With that information in hand, the &lt;code&gt;token_prefix&lt;/code&gt; was set to &lt;code&gt;1&lt;/code&gt; to
account for the opening &lt;code&gt;[&lt;/code&gt;, before proceeding to deal with any newlines.  Dealing
with the newlines used the same pattern that I used for each part of the inline image
type.  However, the big change here is that the &lt;code&gt;token_prefix&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; if a
newline character is found.  The rationale behind this is that if there any newlines
in the link label, the length of the opening &lt;code&gt;[&lt;/code&gt; is no longer useful in determining
the column number, as it comes before the part that has a newline character in it.&lt;/p&gt;
&lt;p&gt;With all that preparation in place, it is then time to compute the change in the
column number.  The initial &lt;code&gt;estimated_column_number += 2&lt;/code&gt; takes care of the
&lt;code&gt;[]&lt;/code&gt; characters at the end of the image text.  The &lt;code&gt;2&lt;/code&gt; from the first part of the
following statement combines a &lt;code&gt;+1&lt;/code&gt; for the translation from an index into a position
and a &lt;code&gt;+1&lt;/code&gt; for the &lt;code&gt;]&lt;/code&gt; character after the link label.  The &lt;code&gt;token_prefix&lt;/code&gt; variable
is then added to account for the length of the opening &lt;code&gt;[&lt;/code&gt; label, as described above,
followed by adding the length of the raw version of the link label text.&lt;/p&gt;
&lt;h3 id="why-review-this"&gt;Why Review This?&lt;a class="headerlink" href="#why-review-this" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It may seem weird that I reviewed this before going forward but let me explain.
I reviewed both because I knew that I had plans to use either the shortcut
code or the collapsed code as a template for the full image type.  I knew that the
only difference in the code between those two types was the addition of a link
reference.  To me, it just made sense to start with the code for either of those image
types and just add the extra code to handle the link reference.&lt;/p&gt;
&lt;p&gt;Following that plan to reuse that code, the support for the full image types was
added within a couple of hours.  After making sure the consistency checks were enabled,
I started running the newly added scenario tests against the newly added consistency
check code.  It was then that I started noticing some weird failures.&lt;/p&gt;
&lt;h2 id="debugging-the-alt-attribute"&gt;Debugging The Alt Attribute&lt;a class="headerlink" href="#debugging-the-alt-attribute" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Digging into those failures, it was initially hard for me to figure out what the issue
was.  Everything looked fine until I started doing a character by character mental
reconstruction of the tokens from the Markdown.  It was then that I saw it:  the &lt;code&gt;alt&lt;/code&gt;
attributes on a handful of the image tags were wrong.&lt;/p&gt;
&lt;p&gt;The scenario test function &lt;code&gt;test_paragraph_extra_73&lt;/code&gt; is a great example of that.  With
the Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Fo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;beta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="ss"&gt;"testing"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and a simple knowledge of Markdown, the text assigned to the &lt;code&gt;alt&lt;/code&gt; attribute of the
HTML image tag was obvious to me.  It should be &lt;code&gt;Foβo&lt;/code&gt;.  But when I looked at the
token itself, that token was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[image(1,2):inline:/uri:testing:Foo::::Foo:False:":: :]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That was close, but I was expecting a token that was more like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[image(1,2):inline:/uri:testing:Foβo::::Fo&amp;amp;beta;o:False:":: :]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which contained both the processed version of the text &lt;code&gt;Foβo&lt;/code&gt; and the unprocessed
version of the text &lt;code&gt;Fo&amp;amp;beta;o&lt;/code&gt;.  This was not like some previous issues that I had
already resolved where one of the other inline tokens was not being represented
properly.  This was a case of some very simple replacements needing to take place
but being missed.&lt;/p&gt;
&lt;p&gt;In addition, after looking at some other cases, backslash escape sequences
were also causing issues, though usually hidden.  Function &lt;code&gt;test_paragraph_extra_74&lt;/code&gt;
is a good example where the output HTML was correct, but the tokenization contained an
&lt;code&gt;o&lt;/code&gt; for the processed text instead of &lt;code&gt;Fo]o&lt;/code&gt;.  &lt;/p&gt;
&lt;h3 id="fixing-the-issue"&gt;Fixing The Issue&lt;a class="headerlink" href="#fixing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To get around this issue, I was faced with three different choices.  The first choice
was to code something up specific to this issue.  I immediately rejected that approach
as I felt that one of the extensions that I will need to support in the future may have
to introduce some base level of character manipulation like the character entities.  As
such, I wanted to leave my options open.&lt;/p&gt;
&lt;p&gt;That left the other two options, or rather one option with two variations.  In
either case, I already had a mechanism for registering inline handling and using those
handlers.  As such, my second choice was to use the existing inline processor code for
text blocks.  The issue that I had with that approach was that I would need to pass an
additional flag into that function that would limit its use to only the backslash
escapes and the character entities.  While that may have been possible with a smaller
function, the size and complexity of the &lt;code&gt;__process_inline_text_block&lt;/code&gt; function gave me
have concerns about possible side effects.&lt;/p&gt;
&lt;p&gt;From three choices down to one, I went with a simplified processor approach to the
&lt;code&gt;__process_inline_text_block&lt;/code&gt; function.  When
the handlers register themselves, I added a new flag to denote whether the
handler was for
one of the two simple inline sequences.  If it was, I added the text sequence to
the &lt;code&gt;__valid_inline_simple_text_block_sequence_starts&lt;/code&gt;.  Then, in the imaginatively
named &lt;code&gt;process_simple_inline&lt;/code&gt; function, I added the code for a very pared down
version of the &lt;code&gt;__process_inline_text_block&lt;/code&gt; function.  This function was purposefully
crafted to
only handle those simple inline sequences and the newline character, nothing else.&lt;/p&gt;
&lt;p&gt;It was when I went to wire the function up that I found another interesting surprise
waiting for me.&lt;/p&gt;
&lt;h3 id="circular-references-suck"&gt;Circular References Suck!&lt;a class="headerlink" href="#circular-references-suck" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With a decent first attempt at a simplified inline processor in place, I did as I
normally do and went to the place where I needed the function, the
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function in the &lt;code&gt;LinkHelper&lt;/code&gt; module, and added
the reference and the import to go along with it.  After starting the test executing,
there was a long pause, and I was then greeted with a simple error telling me:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E   ImportError: cannot import name 'LinkHelper' from 'pymarkdown.link_helper'
    (C:\old\enlistments\pymarkdown\pymarkdown\link_helper.py)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having hit these a number of times, I was sure it was a circular import reference,
but where was it?  It was then that I thought about it.  The &lt;code&gt;LinkHelper&lt;/code&gt; module
was already imported from the &lt;code&gt;InlineProcessor&lt;/code&gt; module, as I used it to handle
all the heavy lifting with the links.  As Python does not have any concept of
forward references, all referenced classes or functions must be loaded before
a reference is made to that item.  In this case, with the relationship already
established, I could not add the reference in the other direction.  I needed to find
another solution.&lt;/p&gt;
&lt;p&gt;I was sure that I would be able to come up with a more elegant solution at a later
time, but I wanted to finish this task up, so I took the &lt;em&gt;lazy&lt;/em&gt; approach of passing
the function as an object.  As it was passed as an argument to each function, there
was no restriction imposed and I was able to use that method at the target
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function.  I may want to look at a better way
to do that in the future, but at the time, it worked.&lt;/p&gt;
&lt;h3 id="rounding-the-corner"&gt;Rounding The Corner&lt;a class="headerlink" href="#rounding-the-corner" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At that point, all the scenario tests were passing.  I was sure that there were
other scenarios that I could find and test, but I was confident that I had a good
collection of paragraph tests added to the project.  I knew in future weeks I would
need to expand that collection in size and cover the SetExt Headings, but that could
come later.&lt;/p&gt;
&lt;h2 id="duplicating-tests-without-duplicating-effort"&gt;Duplicating Tests Without Duplicating Effort&lt;a class="headerlink" href="#duplicating-tests-without-duplicating-effort" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With those scenario tests completed for links and images contained within paragraphs,
it was time to extend those tests to including inline processing within SetExt Heading
tokens.  To that extent, I copied over &lt;code&gt;test_paragraph_extra_43&lt;/code&gt; to
&lt;code&gt;test_paragraph_extra_a2&lt;/code&gt;, creating tests &lt;code&gt;test_setext_headings_extra_43&lt;/code&gt; to
&lt;code&gt;test_setext_headings_extra_a2&lt;/code&gt;.  In terms of the Markdown documents for each test,
the only change I made was to add &lt;code&gt;---&lt;/code&gt; after the Markdown being tested, transforming
it from a Paragraph token test to a SetExt Heading token test.&lt;/p&gt;
&lt;p&gt;As I expected, there were some issues that I needed to resolve to get those tests
working.  As the original versions of the tests used Paragraph Tokens, and the handling
of those Paragraph tokens relied on the &lt;code&gt;rehydrate_index&lt;/code&gt; field of the Paragraph
token, that was an obvious change that needed to be made.  To be specific, I needed
to add code to each reference of the &lt;code&gt;rehydrate_index&lt;/code&gt; field to only reference that
field if the Paragraph token was the container for the inline text.  For the consistency
check and the Inline Processor, this meant protecting any use of the &lt;code&gt;para_owner&lt;/code&gt;
variable, and the &lt;code&gt;owning_paragraph_token&lt;/code&gt; variable for the Markdown transformer.&lt;/p&gt;
&lt;p&gt;With that change made, the only other thing that needed to be dealt with is the change
in how the leading whitespaces are handled within a Paragraph token and within a
SetExt Heading token.  To allow better processing of paragraphs, the Paragraph token
collects any leading whitespace in the Paragraph token, whereas the processing of
inline tokens within the SetExt Heading token stores that information with the inline
tokens themselves.  That handling was changed to ensure the information was properly
being mined from each inline token.&lt;/p&gt;
&lt;p&gt;And while it probably took a couple of hours to resolve, it felt like these changes
only took a couple of minutes.  Compared to some of the other changes I have done
in the last couple of weeks, these changes were completed quickly.  I am sure that
there were a couple of issues in the code that I needed to fix, but as I said, the
time just flew by.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the introduction, I mentioned my increase in confidence for the project, mostly due
to my switch from individual scenario tests to scenario test groups.  From a work
point of view, instead of many small issues, I am lucky if I can get 2 to 3 medium
or large sized issues done in a week.  But as I am covering many combinations in one
task, I feel that the benefit easily outweighs the cost.  And
that benefit is what helps me drive forward.&lt;/p&gt;
&lt;p&gt;And especially with today’s climate, I find that I sometimes need some help in
maintaining focus on this project and driving it forward.  At times like that, when
I need some extra focus, I find it is good to think about the positive parts of the
project.  Instead of focusing on what is left to do, I focus on the progress I have
made in getting to this point.  Instead of focusing on the quantity of tasks I can
get done in a week, I focus on the quality that those tasks being to the project.
And most importantly, instead of focusing on what I cannot change around me, I choose
to focus on this PyMarkdown project, and the benefits I can provide to Markdown
authors with this project.&lt;/p&gt;
&lt;p&gt;So, as I move forward with the project, focusing on quality, I choose these areas
to focus on.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Staying with the theme of testing blocks, I tackle another couple of testing blocks
in the next article.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:spaghetti"&gt;
&lt;p&gt;&lt;a href="http://www.english-for-students.com/Spaghetti.html#:~:text=Alternative%3A%20Throwing%20spaghetti%20on%20the%20wall%20is%20how,to%20the%20walls%20too%21%20Thanks%20to%20Tarean%20West"&gt;Throwing Spaghetti&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:spaghetti" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 3</title><link href="https://jackdewinter.github.io/2020/10/12/markdown-linter-delving-into-the-issues-3/" rel="alternate"></link><published>2020-10-12T00:00:00-07:00</published><updated>2020-10-12T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-12:/2020/10/12/markdown-linter-delving-into-the-issues-3/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/"&gt;last article&lt;/a&gt;,
I continued the long journey to remove items from the project’s issues list.  Still
without a better title than the equivalent of “chapter 3”, this article details more
pruning of that list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this process feels like just one of many stops on …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/"&gt;last article&lt;/a&gt;,
I continued the long journey to remove items from the project’s issues list.  Still
without a better title than the equivalent of “chapter 3”, this article details more
pruning of that list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this process feels like just one of many stops on a long journey, I do find
that I am finding this part of the project particularly satisfying.  Sure, I am fixing
issues that I have found along the
way, but that is a good thing.  I am not finding a lot of “I need to redesign this from
scratch” issues, just a lot of “wow, did I forget to…” or “wow, I didn’t think to
test the combination where…” issues.  And I find that observation both calming and a
boost to my confidence.&lt;/p&gt;
&lt;p&gt;Is it taking up time? Sure.  Would I like to get back to implementing and adding rules?
Yup.  But, with each
issue that I resolve, my confidence that this is the right course of action increases.
The project’s collection of different Markdown documents and test data just keeps on
growing.  As I manually check each scenario test out against what is expected,
verify the output HTML against the reference implementation, and have consistency checks
in place, any new issues just give me that much more information that the project is
working properly.&lt;/p&gt;
&lt;p&gt;Mind you, properly does not mean it is perfect, just that it is headed in the right
direction.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/d3780447b4b71153a6a2a259f2512483d8c153a0"&gt;21 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f3cc298745e56b435f4962965502a00d281eb2dc"&gt;27 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="small-cleanups-and-large-aspirations"&gt;Small Cleanups and Large Aspirations&lt;a class="headerlink" href="#small-cleanups-and-large-aspirations" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first commit in this week’s work was an easy one.  During the writing of the
article on that week’s
work, I realized two things: I wasn’t taking &lt;code&gt;show_debug&lt;/code&gt; arguments out of tests
after debugging,
and test &lt;code&gt;test_raw_html_632&lt;/code&gt; needed a child test with a bit of change, creating
&lt;code&gt;test_raw_html_632a&lt;/code&gt;.  Both changes were accomplished within 15 minutes, so
they were good cleanup issues. But after that, I was left with an interesting problem
to deal with:  Newlines and various inline elements.&lt;/p&gt;
&lt;p&gt;There were a couple of issues that I wanted to deal with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- HTML and Fenced Blocks and better handling of capturing newlines to avoid counting token height
- verify which inlines cannot contain newlines and verify with line/col
  - autolinks
  - raw_html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To break these issues out a bit more, I want to make sure I convey the difference
between the PyMarkdown project and a normal Markdown parser.  As the project’s
focus is to be a Markdown linter, there are additional requirements imposed that are tested with every commit.  Those requirements are that
any element of interest, once translated into a token to represent it, must include the
line number and column number of the original Markdown.  While the examples provided
by the GFM specification are great for testing a parser, they fall a bit short for
testing a linter.&lt;/p&gt;
&lt;p&gt;To be clear, that is not a problem with the GFM specification.  The section called
&lt;a href="https://github.github.com/gfm/#about-this-document"&gt;About this document&lt;/a&gt;
specifically starts with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This document attempts to specify Markdown syntax unambiguously. It contains many examples with side-by-side Markdown and HTML.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The specification specifically deals with syntax and how a given Markdown document
should be represented by HTML.  Full stop.  It is this project’s additional requirement
of being able to examine the tokens that are then translated to HTML that add that
extra level of complexity.  And that extra complexity comes with a cost.&lt;/p&gt;
&lt;h2 id="changing-that-cost-benefit-ratio"&gt;Changing That Cost-Benefit Ratio&lt;a class="headerlink" href="#changing-that-cost-benefit-ratio" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The cost of this complexity has not been large until this point.  Hitting an issue
where I thought needed
some extra testing, I created a child test by adding a letter to the end of the parent
scenario test and made the required variations to the child test for that situation.
In cases where there were more variations, I introduced multiple child scenarios,
each one testing something specific.  This approach did not significantly increase
the complexity of the tests, due to its focused nature.&lt;/p&gt;
&lt;p&gt;But with this week’s work, it was different.  Instead of having one test here to verify
and one test there to verify, I wanted to make sure that all inline tokens that
followed a given pattern were being handled properly.  I wanted to have one central
location where I could look to make sure inline tokens and newline characters were
being handled properly.  This was different in that its scope was going to make it
complex.&lt;/p&gt;
&lt;h2 id="new-tests-first-batch"&gt;New Tests - First Batch&lt;a class="headerlink" href="#new-tests-first-batch" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first batch of these new scenario tests were the group from
&lt;code&gt;test_paragraph_extra_43&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_46&lt;/code&gt;.
To reiterate the message from the previous section, the purpose of these tests was not
to provide one off tests for each type of inline element, but to provide a group of
tests along a given theme.  In this case, that theme was an inline element
surrounded by simple text on either side, with a newline in the middle of the element.&lt;/p&gt;
&lt;p&gt;Far from being tricky, adding these tests was simple.  I started with test
&lt;code&gt;test_paragraph_extra_43&lt;/code&gt; and support for the Code Span token, adding support for the
Raw Html token,
the URI Autolink token, and the email Autolink token, ending at
&lt;code&gt;test_paragraph_extra_46&lt;/code&gt;  Those were easy
tests to add.  In each case, it was just a simple Markdown document like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;
&lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was when I started looking at the links and images that I realized that I was in
for a world of hurt.  Well, maybe not hurt, but it was going to be a lot of work.&lt;/p&gt;
&lt;h3 id="new-tests-links-and-newlines"&gt;New Tests - Links and Newlines&lt;a class="headerlink" href="#new-tests-links-and-newlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting off with the links, I began with inline links, as they are what I mostly
use in my documents.  In terms of changeable parts, the inline
links have 6 elements: the link label, the whitespace before the URI, the URI,
the whitespace before the title, the title, and the whitespace after the title.
To test these parts, I added tests &lt;code&gt;test_paragraph_extra_47&lt;/code&gt; to
&lt;code&gt;test_paragraph_extra_52&lt;/code&gt;, one for each of the parts.  In addition,
for each whitespace test, I added variations on the tests that included whitespace
before the newline, whitespace after the newline, and whitespace before and after
the newline.  &lt;/p&gt;
&lt;p&gt;Once those tests were added, it was time to focus on the other 3 link types.  The
full link type was tested by adding a test for newlines in the label
(&lt;code&gt;test_paragraph_extra_53&lt;/code&gt;) and
newlines in the link reference (&lt;code&gt;test_paragraph_extra_54&lt;/code&gt;).  A new test was added
for a shortcut
link with a newline in the link reference (&lt;code&gt;test_paragraph_extra_55&lt;/code&gt;) and a
collapsed link with a newline
in the link reference (&lt;code&gt;test_paragraph_extra_56&lt;/code&gt;).  Finally, to address some
concerns I had about a newline
at the start of those elements, I added test &lt;code&gt;test_paragraph_extra_57&lt;/code&gt; that includes
a collapsed link with
a newline at the start of the link label, and test &lt;code&gt;test_paragraph_extra_58&lt;/code&gt;
that includes a full link with
a newline at the start of the link reference.&lt;/p&gt;
&lt;p&gt;With that group of tests added, it was time to shift to the next group of tests: images.
After adding test &lt;code&gt;test_paragraph_extra_59&lt;/code&gt; to place a newline between the &lt;code&gt;!&lt;/code&gt;
character and the &lt;code&gt;[&lt;/code&gt; character of the image link, tests &lt;code&gt;test_paragraph_extra_60&lt;/code&gt; to
&lt;code&gt;test_paragraph_extra_67&lt;/code&gt; were added as versions of tests
&lt;code&gt;test_paragraph_extra_47&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_52&lt;/code&gt;, modified for an image instead
of a normal link.  In addition, tests &lt;code&gt;test_paragraph_extra_60&lt;/code&gt; and
&lt;code&gt;test_paragraph_extra_65&lt;/code&gt; were added to test an image link without any link title
being provided.&lt;/p&gt;
&lt;p&gt;To me, this was a good start to some solid tests.  I was focusing on a particular
group of tests, and make sure that pattern was cleanly covered.&lt;/p&gt;
&lt;h3 id="adding-in-replacements-and-backslashes"&gt;Adding in Replacements and Backslashes&lt;a class="headerlink" href="#adding-in-replacements-and-backslashes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finding that the pattern of adding new tests in the previous section was working well
as a template,
the next group of tests followed a similar pattern.  In this group of tests, I wanted
to focus on newlines as part of replacement sequences and backslash sequences within
different parts of the inline links.  My concern was that the special character
handling would play havoc with the determination of the column number for the token
following the token with the special character.  It just seemed to be a good idea to
test these thoroughly.&lt;/p&gt;
&lt;p&gt;Tests &lt;code&gt;test_paragraph_extra_68&lt;/code&gt; and &lt;code&gt;test_paragraph_extra_69&lt;/code&gt; provide for testing in
the inline link label, with a newline around
a replacement sequence and a newline near a backslash sequence.  Then test
&lt;code&gt;test_paragraph_extra_70&lt;/code&gt;
tests a inline URI containing a space, followed by tests &lt;code&gt;test_paragraph_extra_71&lt;/code&gt;
and &lt;code&gt;test_paragraph_extra_72&lt;/code&gt; testing for
newlines within a replacement sequence and a backslash sequence.  Then tests
&lt;code&gt;test_paragraph_extra_73&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_77&lt;/code&gt; repeat those tests, but with
image links instead of normal links.  To round out
this testing tests &lt;code&gt;test_paragraph_extra_78&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_89&lt;/code&gt; repeat
the link testing with the variations
based on the other 3 link types.&lt;/p&gt;
&lt;p&gt;As I was compiling the list of tests for this article, I did notice that it appears
that I have some tests that are done more than once.  To combat this, I added
a new item to the issues list to create a table or spreadsheet to more
accurately track these variations.&lt;/p&gt;
&lt;h2 id="addressing-the-issues"&gt;Addressing the Issues&lt;a class="headerlink" href="#addressing-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;All in all, things went well with adding the new tests.  For the initial group
of 4 tests, the only thing that the tests uncovered was that the Code Span token was
not handling the newline properly.
That was quickly resolved with a couple of small changes in the &lt;code&gt;handle_inline_backtick&lt;/code&gt;
function.  The bigger issues arose in the handling of the links.&lt;/p&gt;
&lt;p&gt;While not a design change, most of that section either needed to be added or enhanced
to properly handle links with newlines.
The way the code was implemented before that week’s work, if there was a newline
character in the current token, the logic was invoked to properly determine what the
line/column number should be.  There were two problems with that code.  The first is
that it was only setup to handle newline characters in an inline link.  This meant that
the code to handle full links, collapsed links, and shortcut links needed to be added.&lt;/p&gt;
&lt;p&gt;The second issue was that the initial code added to handle the inline links was only
partially complete.  In trying to figure out why that was for this article, my notes
refer to an extreme lack of examples in the GFM specification that have newline
characters in any parts of the Link elements themselves.  Part of the push to add this
current series of tests was to try and shore up that deficiency, adding those tests
myself.&lt;/p&gt;
&lt;h3 id="breaking-things-down"&gt;Breaking Things Down&lt;a class="headerlink" href="#breaking-things-down" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As it is the link type that I use most often, I started
with the inline links and their component length arrays.  This array, in a variable
named &lt;code&gt;link_part_lengths&lt;/code&gt;, contained all 5 lengths of the variable parts of the
inline links: pre-URI whitespace, URI, pre-title whitespace, title, and post-title
whitespace.  The link labels were already handled before reaching that point in the
code, so there were no issues there.&lt;/p&gt;
&lt;p&gt;That code started off with some initialization of the array and its values:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;link_part_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;active_link_uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;before_title_whitespace&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inline_title_bounding_character&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;active_link_title&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;after_title_whitespace&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These values were not always going to be the right values, but they proved to be
a good place to start for each link part.  Basically, I started with an array of 5
integer values, each set to reflect a certain section of the inline link.  While those
values are not a direct 1-to-1 mapping of inline link part to length of that part,
they are keyed to handle a newline character showing up in any of those inline link
parts.&lt;/p&gt;
&lt;p&gt;A good example for this is handling a newline character in the inline link title part.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;newline_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;active_link_title&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;delta_line&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;
    &lt;span class="n"&gt;para_owner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;

    &lt;span class="n"&gt;split_active_link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;active_link_title&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_active_link_title&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;link_part_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the title part, if there are any newlines discovered, the count of newlines found
is added to the relevant variables.  Once that is done, the title is split on newline
characters, and the length of the entire part is set to the length of the last part of
that split.  Finally, the &lt;code&gt;link_part_index&lt;/code&gt; variable is set to the part itself.&lt;/p&gt;
&lt;p&gt;Finally, once all the parts are examined in this manner, the following code is
executed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;link_part_index&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;split_paragraph_lines&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;para_owner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;link_part_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;link_part_index&lt;/span&gt;
    &lt;span class="n"&gt;repeat_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Essentially, this is the magic part of the algorithm that pulls everything together.
At the start of the final processing, the last element in the array is set to include
any whitespace prefix from the last line that was added.  Once that is done, the
elements before the last element containing a newline are set to 0.  Basically, if we
have a title part that has a newline, anything before that title is not useful in
determining the column number.  Finally, the algorithm then calculates the column
number (in the &lt;code&gt;repeat_count&lt;/code&gt; variable) by summing up each of the values in the
&lt;code&gt;link_part_lengths&lt;/code&gt; array.&lt;/p&gt;
&lt;h3 id="show-me-this-in-practice"&gt;Show Me This in Practice&lt;a class="headerlink" href="#show-me-this-in-practice" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Applying that algorithm to the following Markdown&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"test&lt;/span&gt;
&lt;span class="ss"&gt;ing"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given this information, the array was initialized as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;link_part_lengths[0] = 4 + 1
link_part_lengths[1] = 1
link_part_lengths[2] = 8 + 1
link_part_lengths[3] = 0
link_part_lengths[4] = 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the newline in the title is detected, the &lt;code&gt;link_part_index&lt;/code&gt; variable is set to
&lt;code&gt;2&lt;/code&gt; and the 2nd element is reset to &lt;code&gt;4&lt;/code&gt;: &lt;code&gt;3&lt;/code&gt; for the length of &lt;code&gt;ing&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as per
the rest of the adjustment equation.&lt;/p&gt;
&lt;p&gt;Without any more newlines, when the final part of the algorithm is executed, no
adjustments are made to the 4th element, any element before the 2nd element is
zeroed out, and the sum of the remaining elements is then &lt;code&gt;4&lt;/code&gt;.  Following the
final part of the algorithm, &lt;code&gt;2&lt;/code&gt; is added to that value, ending with a value of
&lt;code&gt;6&lt;/code&gt;.  In double checking the above text, the letter &lt;code&gt;a&lt;/code&gt; on the second line does indeed
start at column 6.&lt;/p&gt;
&lt;h3 id="summary_1"&gt;Summary&lt;a class="headerlink" href="#summary_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For me, this algorithm is very effective. It starts with good defaults, updating
those values as each part is evaluated.  As the column number cannot be determined
until after the last part is evaluated, that evaluation is only done at the very
end.  And by using an array, the algorithm can use the &lt;code&gt;sum&lt;/code&gt; function to add those
elements up, instead of manual summation.&lt;/p&gt;
&lt;p&gt;It took me a while to get to it, but it is and accurate algorithm and an efficient
one.&lt;/p&gt;
&lt;h3 id="adjusting-the-consistency-checks"&gt;Adjusting the Consistency Checks&lt;a class="headerlink" href="#adjusting-the-consistency-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like the changes that needed to be made to the Markdown parser, its consistency checks
needed to change to test the new criteria.  I initially wanted to just copy over the
work I had done in setting the new line/column numbers with newlines, but after 15
milliseconds, I realized the fallacy of that approach.  The problem was that because
I knew of the approach I already used; it was hard to come up with another way to do
it.&lt;/p&gt;
&lt;p&gt;In the end, I just started the code with a less optimal starting point for the inline
links, growing it from
there.  Instead of a nice array that I could easily sum, I used a series of 5 boolean
variables and 5 string variables that contained the content of each part of the link.
While I knew this was almost the same approach, I had confidence that I was picking a
path that was enough different that I wouldn’t be tempted to look at the previous
code base to figure things out.  The approach did not have to be optimal, it just had
to be independent from the original algorithm, at least for this phase of the project.&lt;/p&gt;
&lt;p&gt;After all that work, adding the shortcut links and collapsed links were simple,
being simple sums of the component parts, both constant and variable.  But that brought
up things that I knew I was going to have to work on soon.&lt;/p&gt;
&lt;p&gt;First off, all this verification was happening in the
&lt;code&gt;__verify_next_inline_inline_image&lt;/code&gt; function.  I made a note in the issues list to
check out why, but there was not any verification present for the link tokens.
Secondly, any support for validating the full link type was missing.  After checking
the entire list of tests, there were no image tests that were specified using a full
link format.  Noted, and continued.  Finally, there were the existing calculations for
the collapsed and shortcut tests.  While there was something there, I was sure
that those checks wouldn’t handle any newline characters in any of their components.
Once again, I noted an item in the issues list, and moved forward.&lt;/p&gt;
&lt;p&gt;Besides those missing test areas that I discovered, there were a handful of tests
that I could not get working by the end of the week.  While it may seem like the tests
were only small variations on each other, it did take quite a bit of work to get them
working to the extent I did.  Not include child tests, there were 47 scenario tests that
I added.  While some of them worked right away, most of them required research and small
changes to get them working.  Any even with a good push to get all the work done,
I needed to leave some of the tests unfinished.&lt;/p&gt;
&lt;h3 id="leaving-something-undone"&gt;Leaving Something Undone&lt;a class="headerlink" href="#leaving-something-undone" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It was a hard decision to document the cases that I had missed and leave them for
later, but I thought it was an important thing to do.  As it was, the commit was done
on Sunday morning, already digging into my article writing time for that week.  I had
no clue if the remaining tests were going to take 5 minutes to resolve or 5 days.  I
needed to draw a line somewhere and put those tests into the bank for the following
week.&lt;/p&gt;
&lt;p&gt;While I was not 100% sure about the groupings, I had a bit of information that I used
to group them together into 4 groups.  The first group was a set of 7 tests that
contained a character entity and seemed to have their column number off by 6.  The
second group was a set of 2 tests that contained a backslash and seemed to have their
column number off by 2.  I was not sure about the 3 tests in the third group, but they
seemed to fit together.  Finally, I recognized that I had started work on image versions
of some of the links, but I needed to make sure that each of the tests at &lt;code&gt;78&lt;/code&gt; and over
needed image versions.&lt;/p&gt;
&lt;p&gt;With that information added to the issues list for the following weeks’ work, I ended
the week with a good amount of work done.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One thing that I am learning about in this phase of the project is that I have wells
of patience that I can tap into if need be.  To be honest, it is surprising me that
I have this ability.  I usually want to forge ahead with things and make sure they
get done to the 90 percent mark, and struggle with that last 10 percent.  But this
project is different.&lt;/p&gt;
&lt;p&gt;I am not sure if it is my self-imposed strictness on the project requirements or my
personal investment into this project, but I just find I am a lot more focused on
making this project a solid, well-tested application.  I know I am not going to be
able to catch every issue at the beginning, but I also know the cost of catching those
issues once I release the application to the community.  For that, I am prepared to
make a good-faith effort to do a thorough job in testing, even if it delays the
release of the project by a couple of months.&lt;/p&gt;
&lt;p&gt;In writing this article though, I am realizing how boring it may appear to others.
That possible appearance was made clear to me as I worked on parts of this article.
Yes, I added over 40 new scenario tests, debugged them, and got most of them working.
And because they are in themes, it was harder to write something interesting about
them.  No more “hey I caught this, and here is the interesting part”.  It was just
one or two themes, and then numerous variations on that theme.&lt;/p&gt;
&lt;p&gt;But boring as it may be, I believe it is important.  Going forward, I want to have
a cohesive collection of tests that I can use as a foundation to improve on.  I
firmly believe that this work, and the work that follows in the next couple of weeks,
builds that testing foundation.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;No surprise here, more issues to address, and still focusing on newline and links.
Stay tuned!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 2</title><link href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/" rel="alternate"></link><published>2020-10-05T00:00:00-07:00</published><updated>2020-10-05T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-05:/2020/10/05/markdown-linter-delving-into-the-issues-2/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/28/markdown-linter-delving-into-the-issues-1/"&gt;last article&lt;/a&gt;,
I started to tackle a few of the items on the project’s issues list.  As the imaginative
title for this article suggests, this article details more of the effort to reduce the
items on the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/28/markdown-linter-delving-into-the-issues-1/"&gt;last article&lt;/a&gt;,
I started to tackle a few of the items on the project’s issues list.  As the imaginative
title for this article suggests, this article details more of the effort to reduce the
items on the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last article, this part of the project is not about anything
stellar, just going through the issues list and removing one item at a time.  Far from
moving a mountain by itself, it is all about moving that mountain one pebble at a time.
The work for this week was no different.  It was just about dealing with 6 items from
the issues list and either proving they are not an issue or fixing the item if it
really is an issue.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/57d7add2a3b51b0cfb9df9446f9c13b61f100ea4"&gt;15 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/663191ae12e13fe058507b8c0f85dfc69ae38af5"&gt;20 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="rounding-out-coverage"&gt;Rounding Out Coverage&lt;a class="headerlink" href="#rounding-out-coverage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the entry for this issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;each&lt;/span&gt; &lt;span class="n"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="n"&gt;surrounded&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was short, I knew that this issue was all about completing the code coverage on
recently changed code.  I was already aware that more than half of the cases in the
consistency check
&lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function had the default &lt;code&gt;assert False&lt;/code&gt; code put there as
a placeholder.  In addition, as soon as I looked the rest of the code, it was obvious
that I had not tested a lot of the inline sequences within an Atx Heading element or a
SetExt Heading element.  That entry was a reminder for me to circle back around 
and fix it!&lt;/p&gt;
&lt;p&gt;To accomplish that, I started by working with each inline element and its relevant
position in a line of the Markdown document.  Tests 1 to 11 dealt with each inline
element at the
start of the line with text after it, tests 12 to 20 dealt with each element with text
on either side of it, and tests 21 to 31 dealt with each element at the end of the line
with text before it.  For good measure, I added tests 32 to 42 which were each inline
element by itself on a line.  Once that was accomplished for the simple case, the
Paragraph element, I cloned those tests into 2 other sets of tests, one for Atx Heading
elements and one for SetExt Heading elements. Once cloned, I introduce a small change
for both elements, the Atx Heading tests starting
with the sequence &lt;code&gt;#{space}&lt;/code&gt; at the start of each line and the SetExt Heading tests
having the sequence &lt;code&gt;---&lt;/code&gt; follow the test text on the next line.&lt;/p&gt;
&lt;h3 id="what-did-i-find"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Running the tests after completing those changes, I found two expected results and one
unexpected result.  The first expected result was that the new tests rounded out
the &lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function by providing good examples for each of
the inline elements, except for the Hard Line Break element.  The Hard Line Break element
has some special rules, so in most cases the setup caused the text to not be interpreted
into a Hard Line Break token, and just placed in a normal Text token.&lt;/p&gt;
&lt;p&gt;The second expected result was that several of the &lt;code&gt;__handle_last_token_&lt;/code&gt; functions
needed adjustment when evaluated within the bounds of a SetExt Heading element. During
the creation of those functions, as evidenced by the work required in the
&lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function, testing within a SetExt Heading element was
almost entirely missed.  While it was not difficult to address, the testing clearly
showed that I needed to add the following code to each &lt;code&gt;__handle_last_token_&lt;/code&gt; function
to compensate:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_setext_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;inline_height&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, the unexpected result was that the normal Paragraph processing and the Atx
Heading processing were fine, requiring no fine tuning.  While I had hoped for that
outcome, it was nice for it to happen.  I had expected at least one or two small issues
to show up, but none appeared.&lt;/p&gt;
&lt;h2 id="fixing-a-simple-yet-wincing-issue"&gt;Fixing A Simple, Yet Wincing Issue&lt;a class="headerlink" href="#fixing-a-simple-yet-wincing-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Yes, I said a “wincing” issue.  While there are more colorful names for these issues,
I prefer the name “wincing” as I believe it is clear, descriptive, and obvious.  Quite
simply, these are a class of issues that are so simple that when I see them, I cannot
help but wince that the error made it through any of my commit processes without being
detected.  In this case, it was a typo where I typed &lt;code&gt;estiated_column_number&lt;/code&gt; instead of
&lt;code&gt;estimated_column_number&lt;/code&gt;, before I copied it into many places.  Yeah, I winced.&lt;/p&gt;
&lt;p&gt;While I was at it, I also decided to also tackle the issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;make&lt;/span&gt; &lt;span class="nv"&gt;new&lt;/span&gt; &lt;span class="nv"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;different&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="nv"&gt;levels&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;each&lt;/span&gt;`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like my reasons for doing the work in the previous section on
&lt;code&gt;Rounding Out Coverage&lt;/code&gt;, I just had doubts about whether I had missed anything
with the scenario test 52e.  With previous issues, I had seen a handful of false
positives occur from a test having a constant number of indent spaces. I believe my
feeling was that to truly test this scenario, I needed to add a test where the number of
ident spaces varied from line to line.  As such, I cloned scenario test 52e into 52f,
altering the indents on the second and third line to 3 spaces and 1 space, respectively.&lt;/p&gt;
&lt;h3 id="what-did-i-find_1"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One of the amusing things that I found out is that I get really embarrassed by simple
typos. Other than that, while I was right to question the indents from scenario test 52e,
the newly added scenario test 52f confirmed that the code was handling the indents
properly.&lt;/p&gt;
&lt;h2 id="verifying-the-rehydration-index"&gt;Verifying the Rehydration Index&lt;a class="headerlink" href="#verifying-the-rehydration-index" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In looking at this issue, I could easily tell beforehand that it was going to be
a research issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;why&lt;/span&gt;?  &lt;span class="nv"&gt;shouldn&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;t each one be of the proper length?&lt;/span&gt;
```
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;split_extracted_whitespace&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;last_token&lt;/span&gt;.&lt;span class="nv"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;len&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;
            &lt;span class="nv"&gt;split_extracted_whitespace&lt;/span&gt;
        &lt;span class="ss"&gt;)&lt;/span&gt;:
```
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Introduced when I was working on the Markdown transformer, the &lt;code&gt;rehydrate_index&lt;/code&gt; field
of the Paragraph token is not serialized with the other fields in the token.  It is used
exclusively for tracking the index into the Paragraph token’s &lt;code&gt;extracted_whitespace&lt;/code&gt;
field.  When I reviewed this code for another issue, I believe that I saw something
about this statement that made me question why it was needed or what it was used for.&lt;/p&gt;
&lt;h3 id="what-did-i-find_2"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After adding extra debug statements and running through the tests, I started
to understand why I might have had issues with this code.  Normally, when software
developers talk about an index, they are referring to a number that is 0 based instead
of a position which is 1 based.  Basically, the difference is whether the counting
starts with 0, as with an index, or the counting starts with 1, as with a position.
From a purist point of view, this field
is named properly: if the field has a value of 0, it is referring to the set of
characters before the first newline character in the &lt;code&gt;extracted_whitespace&lt;/code&gt; field.
Another way to look at this is that when the line is split on the newline character into
an array, as I often do for processing, the 0th element is the first element.&lt;/p&gt;
&lt;p&gt;However, when this field is used, it has the appearance of being a position.  The
&lt;code&gt;extracted_whitespace&lt;/code&gt; field holds any leading whitespace for a Paragraph token.
Accordingly, any whitespace
before the first newline in that field is applied as leading whitespace to that text
string as soon as that string’s processing starts.  As such, if there are multiple lines
in the paragraph, the &lt;code&gt;rehydrate_index&lt;/code&gt; field is set to 1 almost from the very
beginning of processing.  So, while
it is properly called an index, it can appear to look like a position based on its usage.&lt;/p&gt;
&lt;p&gt;Following that information back to the code sample above, my question now made sense.
However, while the naming could perhaps be better, it is indeed an index that somewhat
behaves like a position, with that duality causing the confusion.  In the end, after a
decent amount of review, I resolved this issue without any changes except for an extra
assert statement and some debug.  I felt that the name of the variable and the
variable’s use were both exactly what they should be.&lt;/p&gt;
&lt;h2 id="fenced-code-blocks-and-blank-lines"&gt;Fenced Code Blocks and Blank Lines&lt;a class="headerlink" href="#fenced-code-blocks-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This issue was an interesting one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;verify&lt;/span&gt; &lt;span class="nv"&gt;that&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;blank&lt;/span&gt; &lt;span class="nv"&gt;lines&lt;/span&gt; &lt;span class="nv"&gt;solution&lt;/span&gt;
`&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;previous_inline_token&lt;/span&gt;.&lt;span class="nv"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nv"&gt;MarkdownToken&lt;/span&gt;.&lt;span class="nv"&gt;token_blank_line&lt;/span&gt;`
&lt;span class="nv"&gt;does&lt;/span&gt; &lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;affect&lt;/span&gt; &lt;span class="nv"&gt;single&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;solutions&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;why&lt;/span&gt; &lt;span class="nv"&gt;needed&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From the start of the work on this issue, I knew it was going to either be
very simple or very complex.  The easy part of working on this issue was adding 4 new
scenario tests, 99f to 99i, to check for any abnormalities.  Based on the information
contained in the issue’s text, those new tests included multiple blank lines as well as
mixing blank lines and text lines within the Fenced Code Block element.&lt;/p&gt;
&lt;h3 id="what-did-i-find_3"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first thing I did after running the tests was to adjust the produced tokens to the
new values, after manually verifying each one individually.  Considering how the
coalescing processor merged the Text tokens together, the text and the line/column
numbers for each token seemed fine.  What
was immediately different was the HTML that was produced.  Instead of being a direct
interpretation of the Markdown, the resultant HTML had a few newlines missing.&lt;/p&gt;
&lt;p&gt;Far from being easy to find, this issue took me 2 days of research to find and diagnose,
revealing problems with both the HTML transformer and the Markdown transformer. This
issue just proved to be very difficult to isolate and identify.&lt;/p&gt;
&lt;h3 id="addressing-the-issue"&gt;Addressing the Issue&lt;a class="headerlink" href="#addressing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For
the HTML transformer, additional logic needed to be added to track past characters.
For whatever reason, when there are 2 blank lines in a Fenced Code Block element,
one of the newline characters is not emitted.  &lt;/p&gt;
&lt;p&gt;To properly address this issue, newlines needed to be added in 3 areas.  The first
area was in the handling of the text token, where a Text token preceded by 2 Blank
Line tokens, requiring a newline to be added.  The second area was in the handling
of a Blank Line token to make sure that the newline was only added in the right cases.
Finally, at the end of a Fenced Code Block element, another check needed to be added
for the multiple Blank Line tokens, adding a newline if they were found.&lt;/p&gt;
&lt;p&gt;After completing that grueling episode of debugging, my focus turned to the Markdown
transformer and consistency checks.  While I was dreading another 2 days of research
into the issue and how it affected the Markdown transformer, the results there was
very easy to see and diagnose.  When a switch is made from rehydrating a Text token
to rehydrating a Blank Line token, a newline is omitted in the process.  As such, it
was easy to identify this case and add an extra newline before focusing on the
rehydration of the Blank Line token.&lt;/p&gt;
&lt;p&gt;Having fixed that issue, I reran the scenario tests and got a series of weird
errors complaining about &lt;code&gt;current_token&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt;.  That was quickly tracked down
to working code for handling the last token in a consistency check, and checking
to see if the &lt;code&gt;inline_height&lt;/code&gt; variable needed to be increased by 1 to take care of
the end Fenced Code Block token.  After adding a quick check to make sure that it was
not &lt;code&gt;None&lt;/code&gt;, all the tests ran without issue.&lt;/p&gt;
&lt;p&gt;I had mixed emotions about this issue as I worked through it.  On one hand, it was
not
a simple issue, so it was good to get it out of the way.  Whether it was pride or
confidence, I was pretty sure that most of the simple issues had been cleaned
up, and this easily was not a simple issue.  On the other hand, to find an issue
like this near the end of the first phase of the project was a bit disheartening.&lt;/p&gt;
&lt;p&gt;In the end, I felt that the positives of finding and fixing this issue outweighed
the negatives.  It took a while to clean up, but that scenario was now running
properly.&lt;/p&gt;
&lt;h2 id="testing-backslashes"&gt;Testing Backslashes&lt;a class="headerlink" href="#testing-backslashes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The item for this one was simple, yet descriptive:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;backslashes&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;600&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;verify&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="k"&gt;before&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;after&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="k"&gt;all&lt;/span&gt; &lt;span class="k"&gt;valid&lt;/span&gt; &lt;span class="n"&gt;inline&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;During the various passes I have made through the code, one thing that I worried about
was whether each of the inline sequences properly handled the backslash character.
While I was confident that the start sequences of inline elements were decently
tested, I still retained a shred of doubt that I had missed something.  As for the
end of the inline elements, the confidence level was somewhere between a shred of doubt
and a hunch that I missed something.  Regardless, it was a good thing to check out
and then check off the list.&lt;/p&gt;
&lt;p&gt;To complete this task, the first part was simple:  I needed to come up with a series
of scenario tests to cover all the cases for backslashes and inline character
sequences.  So, starting with the Code Span element, I started working my way through
the inline elements.  In each case, the main test was to make sure that a backslash
character before the start inline sequence prevented the inline element from starting.
Then, if there was an end inline sequence, I added an additional test to make sure that
a backslash used right before the end of the sequence had the intended result.&lt;/p&gt;
&lt;p&gt;Finally, to make sure all inline sequences were covered properly, I replicated each of
the tests for all three inline blocks: Paragraph elements, Atx Heading elements, and
SetExt Heading elements.  Tests 1 to 13 were for Paragraph elements, tests 14 to 26 were
for SetExtHeading elements, and tests 27 to 39 were for the Atx Heading elements.&lt;/p&gt;
&lt;h3 id="what-did-i-find_4"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For this issue, I lucked out.  Each of the tests passed, without any issues.  But
far from being a disappointment, researching this issue and adding the additional
tests helped me put to rest any doubts that I had about backslash handling.&lt;/p&gt;
&lt;h2 id="properly-escaping-special-characters"&gt;Properly Escaping Special Characters&lt;a class="headerlink" href="#properly-escaping-special-characters" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unlike a lot of the other issues in this block of work, this item was clearly a task:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;verify that any special characters used can be recognized and specially escaped&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To get to this point in the development of the project, I had to &lt;em&gt;enable&lt;/em&gt; certain
characters to have additional meanings.  From the backspace character (\b) meaning
“do not consider the previous character” to the replacement character (\a) allowing
for a substitution to be documented, there were in all 5 characters that fit into
this group.&lt;/p&gt;
&lt;p&gt;According to the Github Flavored Markdown (GFM) specification,
&lt;a href="https://github.github.com/gfm/#character"&gt;a character is&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a Unicode code point. Although some code points (for example, combining accents) do not correspond to characters in an intuitive sense, all code points count as characters for purposes of this spec.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Following this logically, any character that is a classic ASCII control character, that
is a character between 0 and 31, is considered part of the Unicode control characters
group.  As all the special characters are classic control characters, they also exist
as valid Unicode code points.  Therefore, if I wanted to use them as special characters,
I had to make sure to escape them if they appeared in input.&lt;/p&gt;
&lt;p&gt;So now, to complete this task, I just needed to figure out how to do that.&lt;/p&gt;
&lt;h3 id="walking-on-the-shoulders-of-giants"&gt;Walking on The Shoulders of Giants&lt;a class="headerlink" href="#walking-on-the-shoulders-of-giants" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Many languages face the same problem that I was then facing: how do we represent a
control character in various formats while keeping the string readable?  In
the case of strings in languages such as Python, the backslash character is the go-to
choice.&lt;/p&gt;
&lt;p&gt;A good example of this is the definition of the various special characters themselves.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;__backspace_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\b&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;__alert_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;whitespace_split_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x02&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;replace_noop_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x03&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;blech_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x04&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the first two cases, the backslash precedes a character which is a stand-in for the
control character.  In the two first cases, the &lt;code&gt;\b&lt;/code&gt; character is standing in for the
backspace character (ASCII 08) and the &lt;code&gt;\a&lt;/code&gt; character is standing in for the bell or
alert character (ASCII 07).  In the remaining cases, the &lt;code&gt;\x&lt;/code&gt; informs the Python
interpreter that a 2-digit hexadecimal number will follow that is the actual character to
insert into the string.  In all cases, there is a clear understanding of what the
character is, due to the backslash character escaping the readable form of the character
to insert.&lt;/p&gt;
&lt;p&gt;For the processing of Markdown documents, the backslash was not a good character to use.
The biggest advocate against its use was that it was already being used as an escape
character
for Markdown’s special characters.  To efficiently escape the desired character
sequences, the
chosen sequence would have to be one that rarely showed up in the normal Markdown
document.  Unimaginatively, I ended up choosing the character &lt;code&gt;\x05&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I could try and explain why it was the best choice, giving lots of made up reasons, but
in this case, the reason was simple: 5 follows after 4.  It made a lot of sense to
pick another control character for the escaping character, as the other characters were
all in that group.  At that point, after eliminating any control characters that were
commonly used, there were roughly 25 characters left.  Any character would have been
just as good as the others, so I just picked the next one in the sequence.  Sometimes
you need to solidly think something through, and sometimes you just need to pick
something that just works.  This was definitely a “just works” moment.&lt;/p&gt;
&lt;h3 id="making-the-change"&gt;Making The Change&lt;a class="headerlink" href="#making-the-change" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From the outset, I knew that if I did this change properly, the bulk of the work would
be contained within the &lt;code&gt;ParserHelper&lt;/code&gt; class and the &lt;code&gt;InlineProcessor&lt;/code&gt; class.  The
changes to the &lt;code&gt;InlineProcessor&lt;/code&gt; class were easy to define. When parsing inline blocks
of text, I would need to specifically look for any of the special characters, escaping
them before moving forward with the rest of the string.  For any processing after that
change had been made, I knew that is where the &lt;code&gt;ParserHelper&lt;/code&gt; class came in.&lt;/p&gt;
&lt;p&gt;Adding the following declaration to the top of the class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;escape_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x05&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the next function was easy.  To avoid a cycle in the module dependencies,
the &lt;code&gt;valid_characters_to_escape&lt;/code&gt; function was added to allow the &lt;code&gt;InlineProcessor&lt;/code&gt; class
query the &lt;code&gt;ParserHelper&lt;/code&gt; class for the characters to escape.  After that, to make sure
that I had coded things properly, I added a series of 24 scenario tests prefixed with
&lt;code&gt;test_textual_content_extra_&lt;/code&gt; to perform special character tests.  Starting with a
simple test with an example that contained each special character, those tests quickly
moved to testing various combinations of each character and normal text.  Each section
picked a specific type of escaped character, including it in a simple string and
interspersed with examples that produced the unescaped versions of those same characters.&lt;/p&gt;
&lt;p&gt;A good example of this is the function &lt;code&gt;test_textual_content_extra_4&lt;/code&gt;.  Used to test
the replacement character &lt;code&gt;\a&lt;/code&gt;, the Markdown document is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To prove that the code is working properly, an escaped replacement character must appear
on either side of an actual replacement sequence, also using the &lt;code&gt;\a&lt;/code&gt; character.  This
results in a Text token containing the text &lt;code&gt;\x05\a\a&amp;amp;\a&amp;amp;amp;\a\x05\a\a&amp;amp;\a&amp;amp;amp;\a\x05\a&lt;/code&gt;,
as predicted.  It starts with the sequence &lt;code&gt;\x05\a&lt;/code&gt; to provide for an actual &lt;code&gt;\a&lt;/code&gt;
character to be output.  The following sequence, &lt;code&gt;\a&amp;amp;\a&amp;amp;amp;\a&lt;/code&gt; then documents that the
&lt;code&gt;&amp;amp;&lt;/code&gt; character was replaced with the text &lt;code&gt;&amp;amp;amp;&lt;/code&gt;.  From there, it just repeats enough
times to make sure it works well.&lt;/p&gt;
&lt;p&gt;Once that simple sequence and others like it with the &lt;code&gt;\a&lt;/code&gt; character were verified,
this pattern was then repeated with the other inline containers: Atx Heading elements
and SetExt Heading elements.&lt;/p&gt;
&lt;h3 id="cleaning-up"&gt;Cleaning Up&lt;a class="headerlink" href="#cleaning-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While these changes sound good in theory, in practice there were some issues that needed
to be addressed.  The major change was the inclusion of the function
&lt;code&gt;remove_escapes_from_text&lt;/code&gt;.  To ensure that those character were properly represented,
I needed to be able to present a text string and have any instances of the escape
character removed from them.  Basically, if I supplied a Markdown document of &lt;code&gt;\aa&lt;/code&gt;,
that &lt;code&gt;\a&lt;/code&gt; character is then escaped, producing a token with the text &lt;code&gt;\x05\aa&lt;/code&gt;  When
I go to use that text, I need to remove the “protection” of the escape character before
rendering that text.&lt;/p&gt;
&lt;p&gt;That was easy to do, and as I started adding calls to the &lt;code&gt;remove_escapes_from_text&lt;/code&gt;
function, there were some previously working tests that started failing.  After doing a
bit of research, the cases that were failing were a portion of the tests that relied
on the &lt;code&gt;remove_x_from_text&lt;/code&gt; and &lt;code&gt;resolve_x_from_text&lt;/code&gt; functions.  In each of those
functions, something like the following was being done:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove_backspaces_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__backspace_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While that was acceptable before this change, there was one glaring error with it after
this change: it was removing all backspace characters, including escaped ones.  Thought
it took a bit more code, that one function was transformed into the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove_backspaces_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
        &lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__find_with_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__backspace_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;next_backspace_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;:]&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_backspace_index&lt;/span&gt;
            &lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__find_with_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__backspace_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it was not as simple, it was correct.  Create a copy of the string, and then look
for the first occurrence of the backspace character that is not escaped.  When that
is done, adjust that copy to remove that backspace, and then continue searching from
there until there are no more backspaces to remove.&lt;/p&gt;
&lt;p&gt;Finally, after all that work, there was only one set of cases left, special characters
within a code span.  This was a special case because the characters needed to be
preserved exactly, with no substitutions.  In the case of the code span, once the code
span start character sequence is found, a scan is made to locate a matching end character
sequence.  If it is found, the handler simply grabs and characters between the end of
the start sequence and the start of the end sequence.  To properly escape these
characters, the &lt;code&gt;escape_special_characters&lt;/code&gt; function was added.&lt;/p&gt;
&lt;p&gt;After a lot of work, and a fair number of changes, the parser was cleanly handling the
escaped characters.  From my point of view, that was a good, solid issue to end the work
for the week on!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there were many little things to learn, the big thing that I am learning with
this phase of the project is that the bulk of this work is in the research.  If I
am having a good day, the research will take anywhere from 5 minutes to an hour,
followed by at least an hour of retesting, or adding a slew of new tests and then
retesting.  When that happens, I am grateful that it goes by so quickly.&lt;/p&gt;
&lt;p&gt;And those positive experiences prepared me for experiences like the one that I had with
Fenced Code Blocks this week.  They are frustrating and can make me want to pull my
hair out.  I actually prefer the complex issues over these types of issues.  With those
issues, I can more clearly see the issue by breaking down that complex systems into
simpler systems that can then be analyzed individually.  For the Fenced Code Block
issue, it was just a small nitpicky issue that I had to calmly analyze, looking within a
small and complex set of variables to figure out.&lt;/p&gt;
&lt;p&gt;It is at moments like that, when I am faced with tough issues, that I take the time
to step back and try and get a better perspective.  While there are some issues that
are more difficult like the Fenced Code Block issue, the bulk of the issues are
relatively easy to diagnose given the right debug statements.  And fortunately, the
bulk of the project’s design has held up nicely, so only a couple of small redesigns
needed to be done.  All in all, it is not a bad place to be in.  Stepping back and
really appreciating those parts of the project is what I believe keeps me sane.
In the end, the severity of the issues and features evens out, even reducing in scope
the further I get to the end of the project’s first phase.&lt;/p&gt;
&lt;p&gt;Looking ahead, I know that I have a good handful of tough issues to deal with.
Knowing that I was still able to keep a good perspective and keep my wits around me,
I have confidence that I will be able to solve those issues.  Some of them may take
an hour to solve, some may take a couple of days to solve, but I will solve them!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not to sound like I am repeating myself, but this part of the project is all about
keeping the momentum going and solving another handful of issues.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 1</title><link href="https://jackdewinter.github.io/2020/09/28/markdown-linter-delving-into-the-issues-1/" rel="alternate"></link><published>2020-09-28T00:00:00-07:00</published><updated>2020-09-28T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-28:/2020/09/28/markdown-linter-delving-into-the-issues-1/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/21/markdown-linter-adding-remaining-inline-tokens/"&gt;last article&lt;/a&gt;,
I completed the last bit of work needed to complete the consistency checks.  However,
as I accumulated some items in my issues list, I decided to take some time and make a
sizable dent in that list.  This article details those issues that I investigated …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/21/markdown-linter-adding-remaining-inline-tokens/"&gt;last article&lt;/a&gt;,
I completed the last bit of work needed to complete the consistency checks.  However,
as I accumulated some items in my issues list, I decided to take some time and make a
sizable dent in that list.  This article details those issues that I investigated and
their results.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I am teaching archery at the camps in my local area, I must
constantly keep a level head and strive to find ways keep the kids motivated.  Faced
with children possessing various levels of archery skill, not only do I have to tailor
any assistance to each individual child, but I also try to figure out how to get that
child to retain some part of that assistance. Luckily, I have a couple of tricks up my
sleeve that helps me in this area.&lt;/p&gt;
&lt;p&gt;The most useful trick involves the difference between moving a mountain and moving
a mountain’s worth of pebbles.  When I ask the camper how easy it is to move a mountain,
they usually look at me like I am the most stupid parent on the planet and then proceed
to express how impossible it is in various colorful forms.   As a follow up, when I then
ask them if they can move that mountain one pebble as a time, they state that it would
take a long time, but eventually they would be able
to move that mountain.  Granted, the description of how long that effort would take
differs from camper to camper, some more colorful than others, but they all convey that
it is ultimately doable.&lt;/p&gt;
&lt;p&gt;At that point, I calmly talk to the camper and explain that we are going to start working
on each pebble of their archery skills, one pebble at a time.  At open range events, I
let each group of kids know that me and the other coaches will be there
all day, and will be as helpful at the end of the day as we are at the beginning.
Admittedly, a bit crazier near the end, but we try our best to remain helpful in
the middle of that craziness.&lt;/p&gt;
&lt;p&gt;The reason I mention this story is that when it comes to the items on the project’s
issues list, the list definitely
looks more like a mountain than a pebble to me.  But by taking the same approach with
the items that I do when teaching archery, I can approach that list calmly and not be hit
with a large wall of anxiety.  Instead of seeing the list as a large mountain, I can
choose to see it as a large group of pebbles, moving them one at a time.  My goal at
this point is not to get rid of all those items at once, but to make steady progress
in reducing the size of the issues list, once pebble at a time.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/d56857b8839b2651724935d7b2145b62fb0d20cf"&gt;09 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/573cdf32570611cbc61273cef9c6808fe44137ba"&gt;12 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-with-an-easy-one"&gt;Starting with An Easy One&lt;a class="headerlink" href="#starting-with-an-easy-one" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that I have the consistency checks in place, when I am faced with a problem with a
line number being off or a column number being off, it is a question of whether the
parser’s calculation is wrong or the check’s calculation is wrong.  While I hope that it
is not an error with the consistency checks, I feel that it is a valid question to ask
myself with each issue.&lt;/p&gt;
&lt;p&gt;That is the mindset that I had when I started looking at this issue.  Leftover from my
previous work on
consistency checks, this was an issue where 15-20 minutes of digging into it with
little success caused me to sideline it for later.  The Markdown sample in question was
a modified
&lt;a href="https://github.github.com/gfm/#example-143"&gt;example 143&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;

&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At issue was the tokenization of the Blank Line element at the end of the Block Quote
element.  According to the parser, that Blank Line element was tokenized to
&lt;code&gt;[BLANK(4,1):]&lt;/code&gt;.  However, the consistency checks were stating that the proper
tokenization should be &lt;code&gt;[BLANK(4,3):]&lt;/code&gt;.  Which one was correct?  What was the
miscalculation that was causing one of the two to be off?&lt;/p&gt;
&lt;h3 id="digging-in"&gt;Digging In&lt;a class="headerlink" href="#digging-in" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Performing a quick visual check of the tokenization, things seemed to be valid on
the parser side. The Blank Line element was enough to terminate the HTML element,
but not to also terminate the Block Quote element before the Blank Line element itself.
That part of the test looked good. In addition, the Markdown text does not contain any
other text on that Blank Line, so the position of &lt;code&gt;(4,1)&lt;/code&gt; looked to be an accurate
position for the token.  This meant shifting my focus to the consistency checks.&lt;/p&gt;
&lt;p&gt;Looking at the debug information for the consistency checks, something immediately leapt
out at me.  The debug output read:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;blank_line&amp;gt;&amp;gt;split&amp;gt;['&amp;gt; ', '&amp;gt; ', '&amp;gt; ', '', '']
&amp;gt;&amp;gt;blank_line&amp;gt;&amp;gt;index&amp;gt;1
&amp;gt;&amp;gt;current_position.index_number&amp;gt;&amp;gt;1
&amp;gt;&amp;gt;current_position.index_indent&amp;gt;&amp;gt;0
&amp;gt;&amp;gt;1 + init_ws(2)&amp;gt;&amp;gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Matching that up against the code that produced the debug, it stated that the
&lt;code&gt;index_number&lt;/code&gt; variable was set to &lt;code&gt;1&lt;/code&gt; while the consistency check calculated the number
&lt;code&gt;3&lt;/code&gt; for that same value.  That matched up with the previous information, so looking at
that last line, I saw that the calculation was determining that there was an initial
whitespace of 2 applied to get to the value of &lt;code&gt;3&lt;/code&gt;.  That did not seem right.&lt;/p&gt;
&lt;p&gt;Adding some temporary debug statements, I was able to quickly determine that the reason
that the
check was adding that indent of 2 characters was due to a bad index on the Block Quote
token.  With every newline that occurs within a given Block Quote, the
&lt;code&gt;leading_text_index&lt;/code&gt; field must be updated to point to the current line.  In this case,
the HTML Block had a number of newline characters within its data but had not updated
the index.  As a result, instead of the index being set to 3, it was set to 0.  This
meant that it was picking up the 0th element of the array&lt;sup id="fnref:zeroBased"&gt;&lt;a class="footnote-ref" href="#fn:zeroBased"&gt;1&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;&amp;gt;{space}&lt;/code&gt;,
with its length of 2 instead of the 3rd element in the array, an empty string with its
length of 0.&lt;/p&gt;
&lt;h3 id="fixing-the-problem"&gt;Fixing the Problem&lt;a class="headerlink" href="#fixing-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having learned a decent amount of information from my research, fixing the issue was
relatively
simple.  To increase the index by the right amount, I had to count the number of
newlines in the text and apply that number to the &lt;code&gt;leading_text_index&lt;/code&gt; field.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;newlines_in_text_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;gt;&amp;gt;newlines_in_text_token&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newlines_in_text_token&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leading_text_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newlines_in_text_token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To err on the side of caution, I also decided to add a couple of extra scenario tests
with further variations on the example.  Just to make sure that the right thing would
happen with an extra line of text, I added an extra line of text and created test
&lt;code&gt;test_html_blocks_143b&lt;/code&gt;.  This addressed my concern that there may be something special
with 2 lines of text, and a third line of text would either highlight or eliminate that
concern.  Then, to make sure that Block Quote lines and their indents were working
properly, I added test &lt;code&gt;test_html_blocks_143c&lt;/code&gt;.  This test alternated the indents for the
Block Quote element between 0 spaces and 1 space, stressing that part of the fix.&lt;/p&gt;
&lt;h2 id="the-start-of-a-series"&gt;The Start of A Series&lt;a class="headerlink" href="#the-start-of-a-series" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This next issue was the start of what I would later refer to as the 518 series of tests.
The process started when I looked at
&lt;a href="https://github.github.com/gfm/#example-518"&gt;example 518&lt;/a&gt;
and I wrote down a note check if all the combinations were covered.  To give more
context, I scribbled down “518, are we sure?” which I interpreted as “Am I sure that I
have all the combinations covered?”.  While it may sound like a weird logically jump
to make from a couple of scribbles, in my own way, I wrote down what was needed to make
sure that I followed it up.&lt;/p&gt;
&lt;p&gt;My thinking was simple.  A standard link, such as the following Markdown from example
518:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;has 6 parts: the link label, the whitespace before the URI, the URI, the whitespace
before the title, the title, and the whitespace after the title.  All other parts of
that link are single characters in nature and required elements.  So, what I did with
this series of tests
is to start changing where the newline(s) were, seeing if I could break anything.  To
add some extra flavor to the tests, I also added a couple of tests that included
backslash characters.&lt;/p&gt;
&lt;h3 id="what-did-i-find-out"&gt;What Did I Find Out?&lt;a class="headerlink" href="#what-did-i-find-out" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The primary thing that I found out was that the parser itself was not handling the
newline characters within links properly.  Specifically, the line numbers and column
numbers were not reflective of the Markdown document that was parsed.  To address
this, the &lt;code&gt;__handle_inline_special&lt;/code&gt; function was modified to handle an alternate
calculation of the line/column number if a Link end token was found.  While the
initial calculation of &lt;code&gt;new_index - next_index&lt;/code&gt; works for any Link tokens that do not
contain a newline character, the calculation for those that included a newline
character was going to be a bit more complicated.&lt;/p&gt;
&lt;p&gt;After trying out a couple of solutions in my head, the only one that gained the
most traction with me
was a staggered approach.  In this approach, I preset an array with the lengths of
various parts of the link, as outlined above.  The function then goes through each of
the parts of the link in their order, checking for newlines for each part as it goes.
If at least one newline character is found, the line variables are updated and the
&lt;code&gt;link_part_index&lt;/code&gt; is set to that part’s index number.  At the end, all values before
that index are reset to 0 and the column number is adjusted by the sum of each value
in the array.&lt;/p&gt;
&lt;p&gt;While there are small fixes along the way to make the algorithm work properly, this
algorithm works well as it keeps things simple.  As each part is checked in turn for
newline characters, the change to the line number variable is accurate.  By setting
and resetting the &lt;code&gt;link_part_index&lt;/code&gt; variable to the last element that had a newline,
only the elements after that index get added to the total, accurately reflecting
the number of characters after the last newline character.&lt;/p&gt;
&lt;p&gt;After that was done, the only extra adjustment that needed to be added was accounting
for whitespace at the start of lines within Paragraph elements, making sure that it
gets applied properly.  That entailed tracking whether or not the parser was currently
processing a paragraph token and using the &lt;code&gt;rehydrate_index&lt;/code&gt; field of the Paragraph
token.  With that in place, manual verification of the newly added case confirmed
that the algorithm was calculating things properly.&lt;/p&gt;
&lt;h3 id="but-what-about"&gt;But What About…?&lt;a class="headerlink" href="#but-what-about" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finishing up the work, there were two things that I knew I needed to work on:
consistency checks and other types of links.  Strangely, the only changes I needed to
the checks were to change Link Reference Definition checks to ensure that it accounted
for the newlines in various components.  Other than that, the everything seemed to
line up.&lt;/p&gt;
&lt;p&gt;As for other types of links, that answer was clear.  Based on the parser code
and the consistency check code, the only type of link that was being tested for newlines
inside of the link were plain inline links.  To combat this, I added extra items to the
issues list, as well as made a mental note to revisit this later.&lt;/p&gt;
&lt;h2 id="fenced-code-blocks-and-blank-lines"&gt;Fenced Code Blocks and Blank Lines&lt;a class="headerlink" href="#fenced-code-blocks-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this did not take a long time to solve, it was a good issue to get out of the
way.  At issue was the Markdown for
&lt;a href="https://github.github.com/gfm/#example-99"&gt;example 99&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;

&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;{space}&lt;/code&gt; stands for an actual space character.  While the actual item reads
&lt;code&gt;fenced, 99 with more blanks&lt;/code&gt;, I knew that I was concerned about not having more
examples with different types of blanks inside of the fenced code block.  To fully
test this, I created many variations on this one test, differing the
number of blank lines and the amount of whitespace on each blank line.&lt;/p&gt;
&lt;p&gt;I was happy to find out that the work on the parser stood up to this extended testing,
and the consistency checks only required a small change.  To be precise, the only
change that it needed was to reset the column number to &lt;code&gt;0&lt;/code&gt; if the
first inline token inside of a Fenced Code block was a Blank Line token.&lt;/p&gt;
&lt;p&gt;I did discover something somewhat puzzling though.  In a Fenced Code block, if the
first token is a Text token, the rest of the body of the block is coalesced. If the
first token is a Blank Line token, then the tokens are not coalesced at all.  Rather
than focus on that at the time, I just noted it down in the issues list, and hoped
to find time soon to figure out if that is the correct solution.&lt;/p&gt;
&lt;h2 id="the-first-inline-token-after-an-atx-heading-token"&gt;The First Inline Token After an Atx Heading Token&lt;a class="headerlink" href="#the-first-inline-token-after-an-atx-heading-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having noticed this one a while ago, it was always something that I wondered about:
why does the parser sometimes insert a whitespace character right after an Atx Heading
token?  I knew I must have a good reason for it, but I could not recall why.  I did find
a couple of scribbles in old notes about Atx Headings, but that was it.  I needed
something more to go on for me to understand this and wrap it up.&lt;/p&gt;
&lt;h3 id="doing-the-research"&gt;Doing the Research&lt;a class="headerlink" href="#doing-the-research" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Going way back in the project’s commit log, I noticed two things:  The first thing was
that this project has been going on for a long while, and the second was that in that
long while, very few of the commits refer to Atx Headings in their commit messages.  To
me, this means that Atx Headings are very stable, something that I felt proud of.
That stability helps me to understand why I did not make any notes around what I was
doing: quite probably they just were not needed.&lt;/p&gt;
&lt;p&gt;There are only 4 times where Atx Headings have
been mentioned in the commit logs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f66221957d761c930728bb8c462576ac951e3552#diff-99f7c38bdec0a4060beb648f08162098"&gt;Adding atx and setext headings.&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;initial addition for Atx Heading support&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fa7ff7223fd614758b95bf8cde76052671680c7d#diff-99f7c38bdec0a4060beb648f08162098"&gt;Fixing Atx headers to allow better inline processing.&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;moved most text out of the token to allow normal inline processing to take place&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/0565ed9db906873b88d224c829c2acbf9bdb6370#diff-99f7c38bdec0a4060beb648f08162098"&gt;Adding line/column support for tax headings.&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;adding line numbers and column numbers to the tokens&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/573cdf32570611cbc61273cef9c6808fe44137ba#diff-99f7c38bdec0a4060beb648f08162098"&gt;Added testing of every inline at the start of a Atx heading…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;this issue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This summary made it really easy for me to come to the observation that when the change
was made to
allow better inline parsing, the initial whitespace between the Atx Heading and its
enclosed text was placed in the whitespace section of the text token.
By looking at the consistency checks, I also observed that there are zero instances
where an Atx Heading is not immediately followed by a Text token.  After looking at
those two observations and commit history, I do not feel it is a leap to say that
this was a design decision that I made but never recorded.  Further, I feel that the
worst case is that it is a pattern that has a lot going for it and could easily be
adopted as a new design decision.  Either way, it seems to be a winning design.&lt;/p&gt;
&lt;h3 id="backing-up-the-design-decision"&gt;Backing Up the Design Decision&lt;a class="headerlink" href="#backing-up-the-design-decision" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Another thing that I learned from my research was that there was only one case of a
non-Text element following the Atx Heading characters in any of the Markdown examples.
The Markdown for
&lt;a href="https://github.github.com/gfm/#example-183"&gt;example 183&lt;/a&gt; is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;""&lt;/span&gt;&lt;span class="err"&gt;"#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which produces an Atx Heading element with a Link element right after it.  Based on
the previous research, I expected the tokenization to include that whitespace character,
and it did not disappoint:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;"[atx(1,1):1:0:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,3)::&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="se"&gt;\a\x03\a&lt;/span&gt;&lt;span class="s2"&gt;]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[link(1,3):shortcut:/url:::::Foo:::::]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,4):Foo:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-link:::False]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-atx:::False]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For readers that have not been following along, the &lt;code&gt;\a&lt;/code&gt; character in an inline text
string represents a replacement of one character for another character.  In this case,
the &lt;code&gt;{space}&lt;/code&gt; character between the first two &lt;code&gt;\a&lt;/code&gt; characters is being replaced by
the character &lt;code&gt;\x03&lt;/code&gt; used as a NOOP character.  To me, this means that when the parser
tokenized that part of the line, it purposefully replaced a space character with an empty
string.  Based on the research, this was the right thing to do.&lt;/p&gt;
&lt;p&gt;The rest of addressing this issue was just replicating various forms of this example for
each inline sequence.  Starting with function &lt;code&gt;test_atx_headings_extra_2&lt;/code&gt; and ending with
function &lt;code&gt;test_atx_headings_extra_12&lt;/code&gt;, I just cycled through each of the newline
sequences, include Hard Line breaks.  And with two exceptions, each of the new test
functions passed.&lt;/p&gt;
&lt;p&gt;The first case where I needed to fix something came even before I added the extra
functions: example 183.  To make sure this was working properly, I needed to add an extra
line to the &lt;code&gt;__process_inline_text_block&lt;/code&gt; function of the &lt;code&gt;InlineProcessor&lt;/code&gt; class.  In
the specific case where I was adding that special replacement, I determined that I was
not clearing the &lt;code&gt;starting_whitespace&lt;/code&gt; variable, and that caused the extra text to occur
within the link instead of before the link.  That caused the rehydration to fail as the
space character was in the wrong position.&lt;/p&gt;
&lt;p&gt;The second case was in the &lt;code&gt;__verify_first_inline_atx&lt;/code&gt; function of the consistency
checks.  The function was first cleaned up removing all the extra &lt;code&gt;assert False&lt;/code&gt;
statements and replacing them with an assert that the first token processed within
the Atx Heading was a Text token.  Once that was done, I just reordered the remaining
lines in the function to keep functionality together, and it was done.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I went into this work knowing that at best, I would be able to knock a handful of issues
of the list in one week.  Meeting that goal, it also started to sink in
that the research for each issue was going to take the lion’s share of resolving
each issue.&lt;/p&gt;
&lt;p&gt;If I was lucky, I figured I would stumble upon what I needed to do early in the
research.  But I prepared myself for the probability that, most often, I would need to
add debug statement, add some extra scenario tests, execute all relevant scenario tests,
examine the results of those tests, and iterate.  Sometimes it would only take 1 or 2
iterations, but I figured that most often it would take upwards of 5 to 10 iterations.
Based on my experience with this week’s work, that set of expectations was a healthy
set to start with.&lt;/p&gt;
&lt;p&gt;At this point, I was feeling decently okay.  Not to sound too vague, but what I went
through was right down the middle of what I expected to happen.  As such, I was not
feeling over positive or overly negative, just… well… okay.  If anything, I was
hoping that this “down the middle” result would apply most of the time.  Having too
many quick issues would get my hopes up for the remaining issues and having too many
long running issues would stop any momentum I was gaining.&lt;/p&gt;
&lt;p&gt;But more importantly, I just wanted to keep on working through the issues list.  I was
okay with moving issues to the “nice to have” section that I had created.  But I was
only okay with that if I honestly though it was not required.  If I kept myself
honest, it was a good way to move forward without jeopardizing the project.&lt;/p&gt;
&lt;p&gt;And with that, I ended the work for the week, on a mostly positive note.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed resolving a small number of issues, I was hoping to keep up some
momentum by continuing to solve more issues in the next week.  Simple as that!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:zeroBased"&gt;
&lt;p&gt;A simple reminder that when most people talk about arrays, they refer to an index into that array.  As such, the first element of the array in the zeroth (0th) element of the array. &lt;a class="footnote-backref" href="#fnref:zeroBased" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Remaining Inline Tokens</title><link href="https://jackdewinter.github.io/2020/09/21/markdown-linter-adding-remaining-inline-tokens/" rel="alternate"></link><published>2020-09-21T00:00:00-07:00</published><updated>2020-09-21T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-21:/2020/09/21/markdown-linter-adding-remaining-inline-tokens/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/"&gt;last article&lt;/a&gt;,
I completed the addition of proper support for line and column numbers for the
text token and emphasis tokens by finishing the consistency checks.  In this article,
I talk about the efforts and issues required to finish implementing the line and
column numbers for the …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/"&gt;last article&lt;/a&gt;,
I completed the addition of proper support for line and column numbers for the
text token and emphasis tokens by finishing the consistency checks.  In this article,
I talk about the efforts and issues required to finish implementing the line and
column numbers for the remaining inline tokens, including their consistency checks.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From a wholistic point of view, I felt that the accuracy and consistency of the tokens
were getting more solid with each change.  While I expected a fair number of tests to fail
when I started to add the consistency checks, I was now at a point where a failing test
would be a novel thing. And that was good!  But even with that positive outlook on the
project and the consistency checks, I knew I still had a way to go to finish
things up properly with respect to the tokens.&lt;/p&gt;
&lt;p&gt;After having finished adding the line/column numbers for the Emphasis tokens and the
Text token, the remaining inline tokens were the only things left in the way of
finishing that work.  After the work
I had done on that group of tokens, I was hoping that this would be an easy batch of
work to complete.  But only time would tell.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f518085e03979439ea20f48a787213f1f145eb3a"&gt;04 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/0d7be8514f459102853974a88810ce6842618e58"&gt;09 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="remaining-inline-tokens"&gt;Remaining Inline Tokens&lt;a class="headerlink" href="#remaining-inline-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having taken care of the Emphasis tokens and the Text token, all the other inline tokens
remained: Raw-HTML, Links, Images, Autolinks, Code Spans and Hard Line Breaks.
Before starting work on each of these tokens, I was not sure if the effort required
to implement each one would be more like the Emphasis tokens or more like the Text
token.  I hoped it would be a simple case and easy to work on, but there were no
guarantees.&lt;/p&gt;
&lt;p&gt;With some optimism in mind, and my fingers crossed, I started my work.&lt;/p&gt;
&lt;h3 id="raw-html-and-links"&gt;Raw HTML and Links&lt;a class="headerlink" href="#raw-html-and-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I write this article and look back at my notes, I fully admit that I am a bit
stumped.  Picking one of these two inline tokens to work on makes sense to me.  I have
no notes to myself saying, “two for the price of one” or “these will be simple”.&lt;br/&gt;
I am left scratching my head as to why I decided to work on both at the same time.
Regardless of why I decided to do both, they were both completed.&lt;/p&gt;
&lt;p&gt;I believed that working on both items at the same time would just be asking for
something to go wrong, so I chose to focus first on the Raw HTML token.  The initial
change was easy, changing the creation of the token from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;RawHtmlMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_raw_html&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;RawHtmlMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_raw_html&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;thereby passing the line number and the column number to the constructor for the
&lt;code&gt;RawHtmlMarkdownToken&lt;/code&gt; class.  Once that was done, another simple change was made
to the &lt;code&gt;handle_angle_brackets&lt;/code&gt; function to pass the current line number and column
number as arguments, as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;after_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HtmlHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_raw_html&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;between_brackets&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;remaining_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="testing-and-iterating"&gt;Testing and Iterating&lt;a class="headerlink" href="#testing-and-iterating" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Running the tests for the Raw HTML token, it was immediately obvious to me that in
certain cases, the column number was off by a bit.  After a bit of research, I noticed
that in cases where there was a Text token before the Raw HTML token, the new Raw HTML
token had the same line/column number as the Text token.  Digging a bit deeper, it
appeared that in those cases, the &lt;code&gt;remaining_line&lt;/code&gt; field of the &lt;code&gt;inline_request&lt;/code&gt; object
had the correct number of characters to make up the difference, but they were not being
applied.&lt;/p&gt;
&lt;p&gt;To address that inadequacy, I made a small change to the above example.  Following the
logic of the inline algorithm, once a new token is created to be inserted, the text
leading up to that token is determined, largely based off the &lt;code&gt;remaining_line&lt;/code&gt;
variable.  While this seems slightly out of order, it ensures that the proper Text token
with the proper line/column number is inserted in the correct order.  However, because
the new token is created before that Text token is inserted, it does not have the
right column number.  By simply adding the length of the &lt;code&gt;remaining_line&lt;/code&gt; variable to
the column number, the difference is accounted for.  This was accomplished by first
calculating that new column number:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;new_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
            &lt;span class="n"&gt;new_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remaining_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and then passing that new &lt;code&gt;new_column_number&lt;/code&gt; value into the call to the
&lt;code&gt;HtmlHelper.parse_raw_html&lt;/code&gt; function in the previous example instead of the
&lt;code&gt;inline_request.column_number&lt;/code&gt; argument.&lt;/p&gt;
&lt;h4 id="new-lines-inside-of-the-token"&gt;New Lines Inside of the Token&lt;a class="headerlink" href="#new-lines-inside-of-the-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;After running through the tests again, almost all the tests were passing, except for
the test for
&lt;a href="https://github.github.com/gfm/#example-500"&gt;example 500&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This case may look weird, but everything is computed properly as a series of Text
tokens and a Raw HTML token.  Because of
the newline in the URI, the text is not eligible to be a link, but since the URI part
is enclosed in “angle brackets”, it is eligible to be a Raw HTML token.  But even with
the Raw HTML token being parsed, the Text token containing the trailing &lt;code&gt;)&lt;/code&gt; character was
off.  Instead of being reported as &lt;code&gt;(2,5)&lt;/code&gt;, it was being reported as &lt;code&gt;(1,17)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To investigate this further, I created the new scenario test &lt;code&gt;test_raw_html_634a&lt;/code&gt;.  This
new test was a more isolated
case of example 500, a copy of the test function &lt;code&gt;test_raw_html_634&lt;/code&gt; with a newline
character inserted inside of the &lt;code&gt;b2&lt;/code&gt; HTML tag, as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;  &lt;span class="o"&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;b2&lt;/span&gt;
&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="ss"&gt;"foo"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I started to look at this issue and
it turned out to be an easy issue to overcome.&lt;/p&gt;
&lt;h4 id="fixing-newlines"&gt;Fixing Newlines&lt;a class="headerlink" href="#fixing-newlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;With this isolated scenario test, it was very easy to see that the issue was with the
&lt;code&gt;raw_tag&lt;/code&gt;
field of the Raw HTML token.  When the token contained a newline character, that newline
was treated as a normal character and added to the character count.  What I needed to
do was to make sure that the algorithm understood that the newline character was special
and to handle it differently.  So, to address that
behavior, I introduced some extra code to the &lt;code&gt;handle_angle_brackets&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;new_token&lt;/span&gt;
    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_raw_html&lt;/span&gt;
    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_tag&lt;/span&gt;
&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;split_raw_tag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_tag&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_line_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_raw_tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;length_of_last_elements&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_raw_tag&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length_of_last_elements&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_index&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inline_response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, since the existing code already handled the case with zero newlines perfectly,
I did not need to change that aspect of the function.  However, in the case of a Raw HTML
token that contained a newline in its &lt;code&gt;raw_tag&lt;/code&gt; field, I needed special processing to
kick in.  The first thing I
needed was a clear picture of the &lt;code&gt;raw_tag&lt;/code&gt; field and its newline characters, so I
split the string on newline characters into the &lt;code&gt;split_raw_tag&lt;/code&gt; variable.  Then I
addressed the line number calculation first, correcting the line number calculation by
adding the number of newline characters found to the &lt;code&gt;inline_response.delta_line_number&lt;/code&gt;
variable.&lt;sup id="fnref:splitLine"&gt;&lt;a class="footnote-ref" href="#fn:splitLine"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;After I was sure that the line number was being correctly calculated, it was time for me
to focus on the column number.  While each of the lines in the &lt;code&gt;raw_tag&lt;/code&gt; field were
important, their content was already mostly covered by the calculation for the change to
the line number.  Each line except the last line that is.  That last line was the new
information that would lead the text after the Raw HTML token.  As such, the column
number was at least as many characters along as the length of any text past that last
newline character, as calculated for the &lt;code&gt;length_of_last_elements&lt;/code&gt; variable.  With
that calculation completed, all that was required was to add 2 to that value for
constant element overhead: 1 for
the length of the closing angle brackets (&lt;code&gt;&amp;gt;&lt;/code&gt;) and 1 to translate the value from an
index to a position.&lt;sup id="fnref:indexPosition"&gt;&lt;a class="footnote-ref" href="#fn:indexPosition"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h4 id="conveying-that-information-back-to-the-caller"&gt;Conveying That Information Back to The Caller&lt;a class="headerlink" href="#conveying-that-information-back-to-the-caller" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;With everything else completed, I then had to decide how I was going to get the newly
calculated column number back to the calling function.  According to the debug
statements that I had added, the value was being calculated properly.  While there were
a couple of options on the table, I decided to go for a simple approach: a negative
number.&lt;/p&gt;
&lt;p&gt;I am not sure if this choice is
&lt;a href="https://blog.startifact.com/posts/older/what-is-pythonic.html"&gt;pythonic&lt;/a&gt;
or not, I believe that it conveys the right information in an efficient manner.
If the column number is zero or positive, it represents a simple change or delta to the
column
number, a simple value to be added to the current column number to arrive at the new
column number.  However, if the column number is negative, it represents an absolute
number that should be used for the column number.  For example, if the token contains
a newline character, it makes sense that the returned value would indicate a value
from the start of the new line, not from the last know position.&lt;/p&gt;
&lt;p&gt;Why a negative number?  While I could have returned an extra value that determined
whether the number was referential or absolute, that seemed too bulky.  For me, this
was keeping it lean within its limited scope.&lt;/p&gt;
&lt;h4 id="adding-validation"&gt;Adding Validation&lt;a class="headerlink" href="#adding-validation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;After all that work, the validation was very anti-climactic.  It may appear that I
cheated and copied the calculation from above as-is into the new
&lt;code&gt;__verify_next_inline_raw_html&lt;/code&gt; function.  Rather than being a cheat, I worked
through the calculations again on paper, making sure that I did not miss any weird
boundary conditions.  After generating the algorithm in the
&lt;code&gt;__verify_next_inline_raw_html&lt;/code&gt; function from scratch, I compared the two algorithms
together and the algorithms themselves were the same.  Rather than cheating,
I considered it a validation that I had derived the right algorithm twice.&lt;/p&gt;
&lt;h4 id="what-about-the-links"&gt;What About the Links?&lt;a class="headerlink" href="#what-about-the-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;As I mentioned at the start of this section, I am not sure why I decided to work on
these two tokens together.  I can only guess that perhaps
I thought that adding line/column numbers to the Link tokens would uncover something
important that adding line/column numbers to the Raw HTML tokens would not.
The reality was that after completing the Raw HTML token work, the changes needed
to implement the line/column numbers for Link tokens was trivially easy.&lt;/p&gt;
&lt;p&gt;Unexpectantly, this would foreshadow the following work on the other inline tokens.&lt;/p&gt;
&lt;h2 id="autolinks-code-spans-images-and-hard-line-breaks"&gt;Autolinks, Code Spans, Images and Hard Line Breaks&lt;a class="headerlink" href="#autolinks-code-spans-images-and-hard-line-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I expected some manner of difficulty in implementing the line/column numbers
for these tokens, however the previous work made the implementation of the new code easy.
There were issues that needed to be properly addressed for each specific type of
token, but the hard work had already been done.  As such, the work was more akin
to copy-and-paste-and-adjust than anything else.&lt;/p&gt;
&lt;p&gt;In the implementation of each of the tokens, the initial calculation for each of the
tokens included values for the length of the constant part of the element and the
variable part of
the element.  Once that was complete and the easy tests were passing, any multiline
parts were addressed, with progress being made to get closer to having the remaining
scenario tests passing.  To finish that work, consistency checks were added that were
simply verifying the algorithms used previous and verifying the work.&lt;/p&gt;
&lt;p&gt;This process was a simple rehash of the work that I did for the Raw HTML token, and
then again for the Link token.  But it was working and working well.  While a part
of me was saying “this is too easy, what’s wrong?”, I double checked all my work
to quiet that voice and assure myself that I had not missed anything.&lt;/p&gt;
&lt;p&gt;While it was simple work, it did take a couple of days to complete.  But at the end
of that work, each relevant token had a line number and a column number, and they
had been verified.  Even more interesting, while some extra scenarios were added to
deal with missing cases (mostly to deal with multiline element parts), no new issues
had been found.  Things were looking good.  Almost.&lt;/p&gt;
&lt;h2 id="last-inline-vs-next-block"&gt;Last Inline vs Next Block&lt;a class="headerlink" href="#last-inline-vs-next-block" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With all the inline tokens supporting line/column numbers, I felt as if a bit of
a load was taken off of my shoulders.  I was not really worried that there was something
wrong, but as I mentioned
&lt;a href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/#introduction"&gt;in the last article&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I know that I am fallible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There was no proof that I could see that I had missed something, but I just had a
nagging feeling that I had left something out.  Trying to get rid of that feeling, I went
through the work that I had just completed and checked it again, finding nothing out
of the ordinary.  On top of that, I had automation in place to catch any miscalculations
that I made, something that was welcome.&lt;/p&gt;
&lt;p&gt;After that extra checking was completed, I could not find anything wrong and I was ready
to move on.  But as I was getting ready to start working on some of the items
in the issue list, I noticed something.  Reading my previous article to gain some
extra perspective on where I was in the project, I noticed the part where I stated:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So, whether I liked the idea or not, validation of the first element in the list was mandatory.  The last element is a different story.  While it would be nice to tie the last inline token to the following block token, I felt that it was not as important as the verification of the first element.  However, I added in a placeholder to the code to make sure that I would follow up on it later.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I remembered!&lt;/p&gt;
&lt;h3 id="the-other-anchor-for-the-inline-tokens"&gt;The Other Anchor for the Inline Tokens&lt;a class="headerlink" href="#the-other-anchor-for-the-inline-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I mentioned before, I started with the outer token and the first token because
I wanted to ensure that was able to anchor the list, and the anchoring the first token
was the easiest solution at the time.  Having finished that task off and
also having finished validation of the inline tokens within the list, it was now time to
work on anchoring the other side of the list: the last inline token and the following
block token.  That is what the nagging feeling was! That is what I was trying to
remember.&lt;/p&gt;
&lt;p&gt;Starting to research what I needed to do to resolve this anchor issue, I came to an
interesting
observation.  While all groups of inline tokens start after a block token, not all
groups of inline tokens end with a block token.  Because of the way tokenization is
performed, I decided not to expose line/column numbers for any of the end tokens that
did not add something to the data stream.  This means that except for the
Emphasis end token, none of the other end tokens have a line/column associated with
them.&lt;/p&gt;
&lt;p&gt;Why is that observation on tokenization important?  A good example is the Markdown
document for
&lt;a href="https://github.github.com/gfm/#example-364"&gt;example 364&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From that Markdown,
I can surmise that the tokens for that document will start with a Paragraph
start token and end with a Paragraph end token.  Inside of the paragraph, there will be
a Text token containing &lt;code&gt;foo&lt;/code&gt;, an Emphasis start token, a Text token containing &lt;code&gt;bar&lt;/code&gt;,
and an Emphasis end token.  This is backed up by the realized tokens for the example,
which are:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;"[para(1,1):]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,1):foo:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[emphasis(1,4):1:*]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,5):bar:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-emphasis(1,8)::1:*:False]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para:::True]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From looking at this tokenization, the last token with a line/column number attached
to it is the Emphasis end token, an inline token.  Getting an actual block token to
appear after those tokens is as simple as changing the Markdown to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This adds a new Blank Line token to the end of the array, adding the tokenization
&lt;code&gt;'[BLANK(2,1):]'&lt;/code&gt;.  However, I knew the real trick would be to determine that value
without having to add that extra token.&lt;/p&gt;
&lt;h3 id="focusing-on-that-line-number"&gt;Focusing on That Line Number&lt;a class="headerlink" href="#focusing-on-that-line-number" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Working through the issue from the previous section helped me understand something
else about the relationship with the last inline token and the possible following
block token: only the line number was important.  Because the inline tokens
are always contained within a container block element or a leaf block element, the
last token in an inline token group is guaranteed to be either an end token for a
previously started block element or a start token for a new block element.&lt;/p&gt;
&lt;p&gt;If the next block token after the inline tokens is a block start token, because of
the work up to this point, a line/column number is guaranteed.  If the next block
token is a block end token, one of two things happens.  Either a block start token
follows with the start of a new block element, or the end of the document is reached.
If a block start token follows, the line/column number is guaranteed as above.
In the case of the end of the document, as no token with a valid line/column number
follows, some other calculation is needed to determine the line number to compare
to.&lt;/p&gt;
&lt;p&gt;The good news is that only the line number is important.  Because only the line number
is important, there is another available number that we can use: the number of lines
in the Markdown document.  As such, if there is a block start token after the inline
block, I used the line number from that token as the line number to compare against.
If no such token existed, I used the number of lines in the document.&lt;/p&gt;
&lt;p&gt;I tested this approach with a handful of scenarios, some with eligible following block
tokens and some with an absence of eligible following block tokens.  On paper it seemed
to work without fail.  The only thing that was left was to test that approach with
actual code.&lt;/p&gt;
&lt;h3 id="completing-the-checks"&gt;Completing the Checks&lt;a class="headerlink" href="#completing-the-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To calculate the line number to compare to, I added the &lt;code&gt;__verify_last_inline&lt;/code&gt;
function with my usual development pattern.  Following that pattern, I started
adding handlers for each of the inline tokens it encountered, just trying to
get to a steady state where all the handlers were present.  Once that was achieved,
I started adding the content to each handler to calculate the height of the inline
token.&lt;/p&gt;
&lt;p&gt;Now I wish I could say it was good planning, but it was just serendipity that I
did this work right after the work on adding the line/column number support to most
of the inline tokens.  Based on that recent work, adding the calculations for the
heights of each of the tokens was exceedingly easy.  While it was easy, it took
a couple of days for me to work through each case and verify each twist and turn
of the token.  But in the end, with only one planned failure&lt;sup id="fnref:IKnew"&gt;&lt;a class="footnote-ref" href="#fn:IKnew"&gt;3&lt;/a&gt;&lt;/sup&gt; to address and
one or two items to look at later, the token validation was complete!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Getting to this point in the PyMarkdown project was a momentous achievement for
me, measured in months rather than days.  Along the way, I had developed a
Markdown parser, ensured that it emitted tokens that include line numbers and
column numbers, verified its output against both expected HTML output and the original
Markdown input, and had a good array of consistency checks on the line numbers and
column numbers.  Phew.  It was a long list, but the project has come a long way.&lt;/p&gt;
&lt;p&gt;I was relieved that I got to this point with my original design mostly intact.  I
was aware that I was going to have to do some refactoring in the future to make the
code more modifiable, but I believe it is in a decent position to make that happen.
Besides, when I start doing that, I have almost 1400 scenario tests that will make
sure any changes are not negatively impacting the code.&lt;/p&gt;
&lt;p&gt;With all that good stuff in mind, I started to look at the issues list, and paged
through it.  At just over 200 lines of text, it was a bit daunting to look at initially.
But as I progressed with the project, any idea or question I had was put into that
list.  There were ideas for better tests, questions on whether something was done right,
and notes on things I wanted to check because they looked weird in some way.  And during
the project’s development to date, I had taken proactive efforts to get any
serious issues out of the way.  Being the optimistic, I hoped that I was left with a
solid set of enhancements.  Regardless
of what remained in the list, I was sure that I could tackle it.  And sure, there
might be some rewrites that I would need to do, but they would make the project stronger,
leaner, faster, and more maintainable.&lt;/p&gt;
&lt;p&gt;So how was I feeling?  Very optimistic.  There were quite the number of items in the
issues list, but if I tackled them one at I time, I could get through them.  And going
through them would either fix an issue or confirm that the project did not have that
particular issue.  And to me, both outcomes were positive.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed all the consistency checks, I now had operating scenario tests with
values and line/column numbers that I was very confident about.  But along the way,
I had accumulated a decent number of items in the issues list.  Before getting back
to filling out the set of rules, it was time to address those items.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:splitLine"&gt;
&lt;p&gt;Python’s &lt;code&gt;split&lt;/code&gt; function works as expected.  If you have a string that does not contain the sequence to split on, it returns an array with one element.  If you have a string that has one or more instances of the sequence to split on, it returns an array with each element being any text between those instances.  As such, if a string has one newline character and is split, it will result in an array with a length of 2.  Therefore, I used &lt;code&gt;len(split_raw_tag) - 1&lt;/code&gt; to figure out the number of newline characters found in the &lt;code&gt;raw_tag&lt;/code&gt; field. &lt;a class="footnote-backref" href="#fnref:splitLine" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:indexPosition"&gt;
&lt;p&gt;By their nature, an index starts at 0 and a position starts at 1.  As a column number is a position on a line but was being computed as an index, I needed to add 1 to the value to transition it into being a position. &lt;a class="footnote-backref" href="#fnref:indexPosition" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:IKnew"&gt;
&lt;p&gt;Ahead of time, I had already determined that the scenario test &lt;code&gt;test_inline_links_518b&lt;/code&gt; was split over multiple lines and would be addressed by this validation. &lt;a class="footnote-backref" href="#fnref:IKnew" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Consistency Checks for Emphasis and Text Tokens</title><link href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/" rel="alternate"></link><published>2020-09-14T00:00:00-07:00</published><updated>2020-09-14T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-14:/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/"&gt;last article&lt;/a&gt;,
I started to add the proper support for line and column numbers for both the text
tokens and the emphasis tokens.  In this article, I increase my confidence in the
line and column numbers for those two inline tokens by adding the consistency checks
for …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/"&gt;last article&lt;/a&gt;,
I started to add the proper support for line and column numbers for both the text
tokens and the emphasis tokens.  In this article, I increase my confidence in the
line and column numbers for those two inline tokens by adding the consistency checks
for those tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I know that I am fallible.  It therefore stands to
reason that any code that I write will have some issues with it.  Those issues may be
obvious issues, or they may be issues that only occur under a bizarre set of
circumstances, but they are there.   Rather than fight against them, I embrace
the attitude that good test automation will help me to identify those types of issues
as early as possible.&lt;/p&gt;
&lt;p&gt;For the PyMarkdown project, this test automation takes the form of scenario tests
containing consistency checks.  These consistency checks validate that the Markdown
documents in the scenario tests are properly interpreted by the PyMarkdown project.
But while these consistency checks are beneficial, the consistency checks have
taken a long while to complete.  After 3 calendar months have passed, it can easily be
said that my decision
to add consistency checks to the project removed 3 months of project development time
and replaced it with 3 months of project test time.  Plain and simple, those statements
are facts.&lt;/p&gt;
&lt;p&gt;My confidence about the project and its ability to work correctly is an emotional and
abstract statement.  However, with effort, I have been able to move it in the direction
of being more of a fact than a feeling.  The consistency checks are a form
of test automation that apply a generalized set of rules over a group of tokens,
looking for each group to behave in a predictable manner.  Before this work,
my confidence was expressed as a feeling: “I believe the project is stable”.  With
this work nearing its completion, I can now point to the scenario tests and consistency
checks that run within those scenario tests.  I can state that each of the scenario
tests is passing a rigorous set of criteria before it is marked as passing.  That
confidence can now be expressed as: “Here are the tests that are passing and the
checks that are being performed on each test.”&lt;/p&gt;
&lt;p&gt;From that point of view, it made sense that before I start working on setting the
line/column numbers for the remaining inline tokens that I would implement the
consistency checks for the Text token and the Emphasis tokens.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c6cc992fa4c5c7c25f2a93038010dfab84a22da8"&gt;02 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="getting-started-with-inline-token-validation"&gt;Getting Started With Inline Token Validation&lt;a class="headerlink" href="#getting-started-with-inline-token-validation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the start of the week, the code used to verify the consistency of inline tokens was
extremely simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;gt;&amp;gt;last_token:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_value_visible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;next_token_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;last_token_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;next_token_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"-token:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_value_visible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;next_token_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;next_token_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Added in as a placeholder to allow me to see what was going on with the inline tokens,
it served its purpose well.  But as I started to work on the inline tokens
and their line/column numbers, I needed to facilitate better consistency checking of
those inline tokens.&lt;/p&gt;
&lt;p&gt;To start the work off, I removed that placeholder code from two places in the code
and replaced both with a call to a new function &lt;code&gt;verify_inline&lt;/code&gt;.  The only
difference between the two
invocations of the function were the fourth argument, &lt;code&gt;current_token&lt;/code&gt;.  Called for
the first time from the_&lt;code&gt;__verify_token_height&lt;/code&gt; function, the &lt;code&gt;current_token&lt;/code&gt; variable
is set to the block token after a series of inline tokens.  The second time it is
called, it is called at the end of processing to capture any inline tokens that are
within one of the valid text elements, but at the very end of the document.  When it
is invoked from that location, that same argument is set to &lt;code&gt;None&lt;/code&gt;.  In both cases,
the inline tokens to be validated were clearly outlined for the &lt;code&gt;verify_inline&lt;/code&gt;
function.&lt;/p&gt;
&lt;h3 id="clearly-defining-the-problem"&gt;Clearly Defining the Problem&lt;a class="headerlink" href="#clearly-defining-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Before doing any real processing with the inline tokens, I needed to create a simple
list containing the actual inline tokens that I wanted to check.  I could have done that
with the main list of tokens and the previously document outlining.  However, I thought
about it and decided that it was clearer to have a separate list that just
contained the tokens that I was concerned about.  Once I had all the inline tokens
between the two block tokens in that new list, there was a small amount of work to do
before the list was usable.  While it was not difficult, the new list had some extra
end tokens at the end of the list that needed to be removed.  Working around
those extra end tokens would have been okay, but I just felt that it was simpler to
remove them from the list before I did any further processing.&lt;/p&gt;
&lt;p&gt;Having a simple list of the inline tokens to work with, the first iteration of the
checking algorithm started with an easy outline to follow:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;token_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;token_index&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;__verify_first_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;__verify_next_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;token_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                    &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# verify_last_inline(inline_tokens[-1], current_inline_token)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From my viewpoint, the processing of the inline tokens had 3 distinct phases: the first
element in that list, each element after it, and the last element in that list.  Based
on their locations, the first and last elements are special in that they anchor the
other inline tokens to the block tokens on either side of the middle elements.  Without
those anchors, the middle elements lack a foundation with which they can based their
positions on.&lt;/p&gt;
&lt;p&gt;Based on those observations, I chose to implement the check for the first inline token
against the previous block token, and not the check for the last inline token against
the following block token.  Without validating the first element, validating any of the
elements on the inside of the list would be useless.  So, whether I liked the idea or
not, validation of the first element in the list was mandatory.  The last element
is a different story.  While it would be nice to tie the last inline token to the
following block token, I felt that it was not as important as the verification of the
first element.  However, I added in a placeholder to the code to make sure that I
would follow up on it later.&lt;/p&gt;
&lt;h3 id="validating-the-first-element"&gt;Validating the First Element&lt;a class="headerlink" href="#validating-the-first-element" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Following the pattern that I have used for validation in the past, I created the
&lt;code&gt;__verify_first_inline&lt;/code&gt; function with my standard starting template:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_first_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As this function is comparing the starting position of the first inline token to the
last valid block token, the &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; in the above code sample was quickly replaced
with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_atx_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_setext_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_fenced_code_block&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_indented_code_block&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_html_block&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and one by one I added the validation functions to replace the &lt;code&gt;assert False&lt;/code&gt;
statements.  Following that same pattern for
resolving these as I have before, I ran the scenario tests over the entire project
using the command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -m gfm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each time, I just picked one of the failing tests, and worked on that tests in that
group until they were all passing.  For each validation function, I repeated the same
pattern with the first inline
token that was observed.  For example, the &lt;code&gt;__verify_first_inline_atx&lt;/code&gt; function quickly
evolved to look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_first_inline_atx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Handle the case where the last non-inline token is an Atx Heading token.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="n"&gt;col_pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hash_count&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;replaced_extracted_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resolve_replacement_markers_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;col_pos&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;replaced_extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;col_pos&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_hard_break&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_link&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
            &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_link&lt;/span&gt;
        &lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="what-did-i-discover"&gt;What Did I Discover?&lt;a class="headerlink" href="#what-did-i-discover" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Predictably, I discovered that there are 2 groups of text within block tokens: ones
that support
inline tokens other than the Text token, and ones that do not.  The ones that do not
support inline tokens are
mostly easy: assert that the inline token is a Text token, and then assert on a simple
calculation of the first line/column number.  The validation of the HTML Block token and
the Indented Code Block token both followed this pattern, with very simple validation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_first_inline_html_block&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;
    &lt;span class="n"&gt;leading_whitespace_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;leading_whitespace_count&lt;/span&gt;
        &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Fenced Code Block tokens required a bit more effort, but not much. As the Fenced
Code Blocks can start with 0-3 space characters that then need to be managed on any
subsequent line in the code block, the owning block token’s &lt;code&gt;leading_spaces&lt;/code&gt; variable
holds the information on what leading spaces were already removed.  As such, when
calculating the proper position of the first Text token inside of a Fenced Code Block,
that removed space needs to be accounted for.  To properly facilitate that, the
&lt;code&gt;last_token_stack&lt;/code&gt; argument needed to be plumbed through so the verification function
could calculate the proper owning blocking token.&lt;/p&gt;
&lt;p&gt;The second group of block tokens were the more interesting group of tokens to deal with.
This group of tokens includes the Atx Heading tokens (as shown in the above example),
SetExt Heading tokens, and Paragraph tokens.  The &lt;code&gt;__verify_first_inline_atx&lt;/code&gt; function
and the &lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function ended up looking similar: the Text
inline token case was populated, but all the other types of inline tokens were handled
with &lt;code&gt;assert False&lt;/code&gt; statements.  The &lt;code&gt;__verify_first_inline_paragraph&lt;/code&gt; function was
similar, but also slightly different.  The same template was used to generate the
function, but each of the conditions in the &lt;code&gt;if-elif-else&lt;/code&gt; block were met at least once.
However, since only the Text token and the Emphasis token have line/column numbers,
allowing this comparison to be performed for them:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the other inline tokens, the ones that did not currently have a line/column assigned
to them (yet), used the following comparison:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was not much, but it gave me two important bits of information.  The first was that
there was at least one case where each available inline token was the first inline
token inside of a Paragraph token.  The second was that both heading tokens, the Atx
Heading token and the SetExt Heading token, only contained scenario tests that started
with Text tokens.  I made a note of that observation in the issue’s list and moved on.&lt;/p&gt;
&lt;h2 id="verifying-the-middle-tokens"&gt;Verifying the Middle Tokens&lt;a class="headerlink" href="#verifying-the-middle-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the validation of the first element out of the way, it was time to start working
on the &lt;code&gt;__verify_next_inline&lt;/code&gt; function.  Now that the middle tokens were anchored at
the beginning, each of the middle inline tokens could be validated against the inline
token that preceded it.  Since I knew that most of the inline tokens had not
been handled yet, I started out that function with a slight change to the template:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_next_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pre_previous_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;
&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;

    &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
    &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;

    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s2"&gt;"&amp;gt;&amp;gt;est&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;estimated_line_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&amp;gt;act&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s2"&gt;"&amp;gt;&amp;gt;est&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;estiated_column_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&amp;gt;act&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first set of &lt;code&gt;if&lt;/code&gt; statements made sure that if either the previous inline token or
the current inline token
was one that I had not worked on yet, it would return right away.  While this assumed
that the line/column numbers were correct to a certain extent, I was okay with that
assumption in the short term.  The second part computed a starting point for the new
line/column numbers, and then went into the usual pattern of dealing with
each of the eligible tokens by name.  Finally, the third part compared the modified
line/column numbers against the actual line/column numbers of the current token,
asserting with meaningful information if there were any issues.&lt;/p&gt;
&lt;h3 id="emphasis-tokens"&gt;Emphasis Tokens&lt;a class="headerlink" href="#emphasis-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I thought it would be quick to get emphasis out of the way, and it was!  As both the
start and end Emphasis tokens contain the &lt;code&gt;emphasis_length&lt;/code&gt;, it was a quick matter of
adjusting the column number by that amount.  As both tokens are confined to
a single line, there was no adjusting of the line number to worry about.&lt;/p&gt;
&lt;h3 id="text-tokens"&gt;Text Tokens&lt;a class="headerlink" href="#text-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As mentioned in a previous section, there are two major groups of block tokens
that contain Text tokens: ones that allow all inline tokens and ones that do not allow
inline tokens except for the Text token.  The ones that do not allow inline tokens are
simple, as all the
information about the Text token is contained within the token itself.  It is the
other group that are interesting to deal with.&lt;/p&gt;
&lt;p&gt;The easy part of dealing with the Text token is determining the new line number.
With the exception of a Text token that occurs right after a Hard Line Break token,
the calculation is simple:  split the text by the newline character, subtract 1,
and that is the number of newlines in the Text token.  If the token before the Text
token was a Hard Line Break token, it already increased the line number, but the
Text token that followed also started with a newline character.  To remedy this,
that pattern is looked for, and the &lt;code&gt;current_line&lt;/code&gt; variable adjusted to remove the
newline character at the start of the line.&lt;sup id="fnref:noted"&gt;&lt;a class="footnote-ref" href="#fn:noted"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Determining the column number is a more interesting task to undertake.  For any
Text tokens occurring within a block that does not allow for extra inline tokens,
the column number information is already in the token itself, and the calculation
is as simple.  The column delta is equal to the number of text characters stored
within the token&lt;sup id="fnref:processing"&gt;&lt;a class="footnote-ref" href="#fn:processing"&gt;2&lt;/a&gt;&lt;/sup&gt;.  If there was a newline in the token’s text, this
count is started after the last newline character.&lt;/p&gt;
&lt;p&gt;The second group of block tokens that can contain text are the Atx Heading token, the
SetExt Heading token, and the Paragraph token.  Since the Atx Heading token can only
contain a single line’s worth of data, no extra calculations are required to handle
multiple line scenarios.  In the case of the other Heading token, the SetExt Heading
token, the starting whitespace is stored in the Text token’s &lt;code&gt;end_whitespace&lt;/code&gt; field.
The processing of this information is a bit tricky in that the starting and ending
whitespace for the Text tokens within the SetExt Heading token is stored in that
field using the &lt;code&gt;\x02&lt;/code&gt; character as a separator.  Still, determining the proper
indent and applying it to the column number is relatively simple.&lt;/p&gt;
&lt;p&gt;Dealing with a Text token within a Paragraph token is a lot more work.  Due to other
design reasons, the whitespace indent for these Text tokens is stored within the
owning Paragraph token.  While that is not difficult by itself, keeping track of which
indent goes with which line is a bit of a chore.  Luckily, when I was working on the
Markdown transformer, I introduced a variable &lt;code&gt;rehydrate_index&lt;/code&gt; to the Text token.
When rehydrating the Text token, I used this variable to keep track of which stripped
indent needed to be added back to which line of any subsequent Text tokens. Given
the prefix whitespace for any line within the Paragraph block, calculating the
column number delta was easy.&lt;/p&gt;
&lt;h3 id="blank-line-tokens"&gt;Blank Line Tokens&lt;a class="headerlink" href="#blank-line-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;That left the Blank Line tokens to deal with, and I hoped that the effort needed to
complete them was more in line with the Emphasis tokens than the Text tokens.  I was
lucky, and the Blank Line tokens were easy, but with a couple of small twists.
Intrinsically, a blank line
increases the line number and resets the column number to 1.  That was the easy part.
The first twist is that if the current token is a Text token, that text token can
provide leading whitespace that needs to be considered.  That was easily dealt
with by adding the following lines to the handler:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The more difficult problem occurred when 2 blank line tokens appear one after the
other within a Fenced Code Block token.  Because of how the numbers added up, I needed
to adjust the &lt;code&gt;estimated_line_number&lt;/code&gt; variable by one.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_blank_line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_blank_line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that tweak being done, all the tests were then passing, and it was time to
wrap it up.&lt;/p&gt;
&lt;h2 id="was-it-worth-it"&gt;Was It Worth It?&lt;a class="headerlink" href="#was-it-worth-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The interesting part about defensive code is that sometimes you are not aware of how
good that defense is.  Using the analogy of a castle, is a castle better defensible if
it can withstand attack or if it deters others from attacking the castle?  While I
did not have any information about potential attacks that were stopped ahead of time,
there were 2 actual issues that the current round of consistency checks did find.&lt;/p&gt;
&lt;h3 id="issue-1-image-link"&gt;Issue #1: Image Link&lt;a class="headerlink" href="#issue-1-image-link" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first of those issues was an issue with the column number for
&lt;a href="https://github.github.com/gfm/#example-600"&gt;example 600&lt;/a&gt;
as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!\&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Before these inline consistency checks were added, the text for the &lt;code&gt;]&lt;/code&gt;
character was reported as &lt;code&gt;(1,6)&lt;/code&gt;.  By simply counting the characters, the &lt;code&gt;!&lt;/code&gt;
character starts at position 1 and the second &lt;code&gt;o&lt;/code&gt; character is at position 6.  As
such, the &lt;code&gt;]&lt;/code&gt; character should be reported as &lt;code&gt;(1,7)&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;Doing some research, I concluded that the handling of a properly initiated Image
token was being handled properly.  However, with a failed Image token sequence,
the &lt;code&gt;!&lt;/code&gt; character followed by any other character than the &lt;code&gt;[&lt;/code&gt; character, the
&lt;code&gt;!&lt;/code&gt; character was being emitted, but the column number’s delta wasn’t being set.
Adding the line&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;at the end of the &lt;code&gt;__handle_inline_image_link_start_character&lt;/code&gt; function solved that
issue.&lt;/p&gt;
&lt;h3 id="issue-2-a-simple-adjustment"&gt;Issue 2: A Simple Adjustment&lt;a class="headerlink" href="#issue-2-a-simple-adjustment" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The second of those issues was more of a nitpick that an actual issue.  In the
tokenization for
&lt;a href="https://github.github.com/gfm/#example-183"&gt;example 183&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the first line was tokenized as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "[atx(1,1):1:0:]",
        "[text(1,3):\a \a\x03\a:]",
        "[link:shortcut:/url:::::Foo:::::]",
        "[text(1,4):Foo: ]",
        "[end-link:::False]",
        "[end-atx:::False]",
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having a lot of experience sight reading serializations for all the tokens, the
information in the Text token leapt out at me right away.  In that token, the extra
data associated with the token is composed by adding the &lt;code&gt;self.token_text&lt;/code&gt; field,
the &lt;code&gt;:&lt;/code&gt; character, and the &lt;code&gt;self.extracted_whitespace&lt;/code&gt;.  Based on the above
tokenization, that meant that the text sequence &lt;code&gt;\a \a\x03\a&lt;/code&gt; was being considered
as text instead of whitespace.&lt;/p&gt;
&lt;p&gt;To understand why I thought this is wrong requires an understanding of the
existence of that character sequence.  The &lt;code&gt;\a&lt;/code&gt; sequence is used to denote that
a sequence of characters in the original Markdown document was interpreted and
replaced with another sequence of characters.  The &lt;code&gt;\x03&lt;/code&gt; character within the
second half of that sequence means that the &lt;code&gt;{space}&lt;/code&gt; character in the first part
of the sequence is being replaced with the empty string.  Basically, to properly
represent the space between the &lt;code&gt;#&lt;/code&gt; character denoting the Atx Heading element
and the &lt;code&gt;[&lt;/code&gt; that starts the Link element, I needed to add a space character that
would not appear in any HTML transformation.&lt;/p&gt;
&lt;p&gt;And here is where the nitpicking comes in.  When I originally added that sequence
when working on the Markdown transformer, it made sense to me to assign it to
the token’s &lt;code&gt;self.text_token&lt;/code&gt; field.  But since then, I have grown to think of
that sequence as being more extracted whitespace than token text.  To resolve
that, I decided to move the call to generate the replacement text from the
&lt;code&gt;self.token_text&lt;/code&gt; field to the &lt;code&gt;self.extracted_whitespace&lt;/code&gt; field.  It wasn’t
a big move, but it was something that I thought was the right thing to do.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this batch of work wasn’t as laborious as last week’s work, the effort required
to make sure it was correct was equal to or exceeding last week’s work.  I knew that
if I made any mistakes last week, they would be caught when I implemented the
consistency checks.  Well, these were the consistency checks that would capture
any such issues that slipped through.&lt;/p&gt;
&lt;p&gt;I am both happy and proud that I am coming to the end of implementing the consistency
checks.  It has been a long 3 month voyage since I decided that consistency checks
were the best way to ensure that the quality that I wanted in the PyMarkdown project
was maintained.  And while there were times that I questioned if I made the right
decision in dedicating this large block of time to this aspect of the project, I was
confident that I had made the right decision.&lt;/p&gt;
&lt;p&gt;But looking ahead to what I needed to do after the consistency checks, I saw a
fair number of items in the issues list that would need researching and possibly
fixing.  While I could start to release the project without them, I didn’t feel
comfortable doing that.  I wanted to give the project the best chance it could to
make a first impression, and then move from there.  And that would mean more work
up front.  So while I was happy that the consistency check work was coming to an
end, there seemed to be a deep pool of issues that would need to be research… and
I wasn’t sure how much I was looking forward to that.&lt;/p&gt;
&lt;p&gt;I still believe that adding the consistency checks was the right move.  Of that
I am still certain.  Instead of a feeling that I have the right code in place to
do the Markdown transformations, I have hard, solid checks that verify the results
of each and every scenario test.  It also gave me the interesting bit of information
that the scenario tests did not include any cases where the Atx Heading token and the
SetExt Heading token were followed by anything other than a Text token.  Something
interesting to follow up on later.&lt;/p&gt;
&lt;p&gt;To me, adding more of those checks for the inline
tokens was just another solid step forward in quality.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed the hardest inline token (Text token) and the easiest inline tokens
(Emphasis tokens), it was time to buckle down and get the remaining tokens done.  If
I was lucky, the foundational work that I had already completed would make completing
those tokens easy.  If I was unlucky, there would be a whole selection of edge cases
that I needed to account for.  Realistically, I was expecting something square in the
middle between those two scenarios.  The next batch worth of work would answer that
question!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:noted"&gt;
&lt;p&gt;This has been noted in the issue’s list, and I am hoping to look at it soon. &lt;a class="footnote-backref" href="#fnref:noted" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:processing"&gt;
&lt;p&gt;That is, after removing any special characters and leaving the original text used to create those special characters. &lt;a class="footnote-backref" href="#fnref:processing" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Starting to Add Line/Column Numbers For Inline Tokens</title><link href="https://jackdewinter.github.io/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/" rel="alternate"></link><published>2020-09-07T00:00:00-07:00</published><updated>2020-09-07T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-07:/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/31/markdown-linter-adding-consistency-to-token-heights/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying the height of all block
tokens.  In this article, with all the block tokens now properly covered, I
start to add proper support for line and column numbers for the text inline tokens
and the …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/31/markdown-linter-adding-consistency-to-token-heights/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying the height of all block
tokens.  In this article, with all the block tokens now properly covered, I
start to add proper support for line and column numbers for the text inline tokens
and the emphasis inline tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last article:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To properly verify any of the inline tokens, the tokens around it needed to be verified to give that token a solid foundation. Without those other tokens as a foundation, any attempt at verifying inline tokens would be shaky at best.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With that foundation now firmly in place, it was then time for me to start adding the
line/column numbers to the inline tokens.&lt;/p&gt;
&lt;p&gt;The scope of what I was about to start was not lost on me.  From the outset, I knew
that adding the line/column numbers to the Text tokens was going to be expensive.
Starting with the obvious, the Text tokens are the default “capture-all” for anything
Markdown that does not firmly fall under another token’s purview.  That alone meant
there were going to be a fair number of scenarios in which Text tokens were present.
Add to
that number the various forms of text that the token contains, and each form’s
way of dealing with the Text tokens within their bounds.  Also, as I wanted
to have a good gauge on how hard it was going to be to add the other inline tokens,
I added support for Emphasis tokens to the worklist.&lt;/p&gt;
&lt;p&gt;I was clear about the scope of this change with myself from the outset.  It was going to
be a long trek to complete all this work in one week.  I did contemplate updating the
consistency checks to accommodate the changes to the inline tokens, but discretion got
the better part of me.  This work was going to be tough enough on its own, no need to
add some extra tasks to the list.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7eb893cf1b7c815666946661b790b956fa87278d"&gt;29 Aug 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="framing-a-big-problem-in-a-better-light"&gt;Framing a Big Problem in a Better Light&lt;a class="headerlink" href="#framing-a-big-problem-in-a-better-light" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before starting with this monumental task, I wanted to take a step back and really
understand the task and its intricacies.  When I
started looking at the sheer depth of this task, I will admit I was a bit scared at
first.
The work this task requires is daunting.  Doing a simple search over the project’s
scenario tests, I found 1577 instances of a Text token in a scenario test and 161
instances of Emphasis Start tokens in a scenario test.  That meant between the Text
tokens and both Emphasis Start and Emphasis End tokens, I was looking at 1899 instances
that needed to be changed and manually verified.  That was indeed overwhelming.&lt;/p&gt;
&lt;p&gt;This is where my experience with test automation came in handy.  I took a breath and
started to look for
&lt;a href="https://en.wikipedia.org/wiki/Equivalence_partitioning"&gt;equivalence partitions&lt;/a&gt;
that I could use.  While the number of discrete instances of Text tokens and Emphasis
tokens were facts that
I could not change, I decided to apply equivalence partitioning and reduce the effective
number of instances down to a more manageable number.&lt;/p&gt;
&lt;h3 id="how-does-that-work"&gt;How Does That Work?&lt;a class="headerlink" href="#how-does-that-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let me take a small sample function that is in the &lt;code&gt;ParserHelper&lt;/code&gt; class,
the &lt;code&gt;is_character_at_index&lt;/code&gt; function.  This function is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_character_at_index&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;index_in_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_character&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;index_in_string&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;source_string&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_in_string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;valid_character&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function is simple in that given a large variation on the parameters, it will
simply return a &lt;code&gt;True&lt;/code&gt; response or a &lt;code&gt;False&lt;/code&gt; response.&lt;sup id="fnref:mostlyTrue"&gt;&lt;a class="footnote-ref" href="#fn:mostlyTrue"&gt;1&lt;/a&gt;&lt;/sup&gt;  While the number of
variations are largely finite&lt;sup id="fnref:largeFinite"&gt;&lt;a class="footnote-ref" href="#fn:largeFinite"&gt;2&lt;/a&gt;&lt;/sup&gt;, they do fall into a number of
categories.  Starting with
the &lt;code&gt;index_in_string&lt;/code&gt; argument, those groups are: less than 0, equal to 0,
greater than 0
and less then &lt;code&gt;len(source_string)&lt;/code&gt;, equal to &lt;code&gt;len(source_string)&lt;/code&gt;, and greater than
&lt;code&gt;len(source_string)&lt;/code&gt;.  Of those groups, only if the &lt;code&gt;index_in_string&lt;/code&gt; argument is in
the &lt;code&gt;equal to 0&lt;/code&gt; group or the &lt;code&gt;greater than 0 and less then len(source_string)&lt;/code&gt; group do
I need to check to see if the character at the specified index is equivalent to the
argument &lt;code&gt;valid_character&lt;/code&gt;.  As the value to compare against is a single character, the
only two groups for that part of the comparison are that it matches that single
character or it does not.&lt;/p&gt;
&lt;p&gt;Based on this information, I can use those groups as equivalence partitions or
equivalence groups or  to partition the data to test into 7 distinct test groups.  The
first 3
equivalence groups are the ones that cause the first comparison to fail: &lt;code&gt;less than 0&lt;/code&gt;,
&lt;code&gt;equal to len(source_string)&lt;/code&gt;, and &lt;code&gt;greater than len(source_string)&lt;/code&gt;.  For this group,
the negative group, a simple test with one value in each group is required.  For the
other 2 tests, the positive group, in addition to the comparison to get it into one of
the 5 groups, one test is required where the index specifies the
a character matching the &lt;code&gt;valid_character&lt;/code&gt; argument, and one where it does not match.
In all, 3 tests in the first group, and 2 sets of 2 tests in the second group, for a
grand total of 7 tests.&lt;/p&gt;
&lt;p&gt;This works well because it reduces the scope of the testing to a manageable number.
Given the &lt;code&gt;less than 0&lt;/code&gt; group, it does not matter if the &lt;code&gt;index_in_string&lt;/code&gt; argument is
&lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;-2&lt;/code&gt;, or any other negative number.  They all fit into that group and they all
evoke the same behavior: they cause the expression to be evaluated as &lt;code&gt;False&lt;/code&gt;.
By applying this process to many testing problems, it can quickly break down the
problem from an unmanageable number of possibilities down to a smaller number of more
easily handled cases.&lt;/p&gt;
&lt;h3 id="how-does-that-apply-to-this-work"&gt;How Does That Apply to This Work?&lt;a class="headerlink" href="#how-does-that-apply-to-this-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;No matter how it is viewed, having to change the serialization of 1577 instances of a
Text token is a big job.  That part of the work I cannot change.  However, I can make
the manual validation part of the changes more efficient by applying equivalence
classes to those changes.  While I was not sure at the onset what those classes were
going to be, I was confident that I could work out those groups would be one-by-one.&lt;/p&gt;
&lt;p&gt;But it was still a big task, just not as big.  Looking back at my notes, I have a
scribble that says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;~40 variations for text, ~10 for emphasis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I believe that was a note to myself to boost my confidence by estimating how many
equivalence classes that I believed I would get the tests down to.  As I wrote this
article and looked at that scribble, for a second, I was back at the point in time when
I wrote that down.  Like an echo, I vaguely remembered the feeling of optimism that
washed over me when I wrote those numbers down.  While I am not 100% certain of what I
was thinking at the time, I am confident that it was something like:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1600 validations is insane!  On the other hand, 40 is okay.  I can do 40.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At that moment, it was not about whether those numbers were accurate, just that I had
confidence that those numbers were in the general vicinity.  While having to validate
each of
approximately 1600 variations of Text tokens filled me with dread, having to validate
approximately 40 variations of those same Text tokens and approximately 10 variations
of Emphasis tokens was something I had confidence that I could easily handle.&lt;/p&gt;
&lt;h2 id="updating-the-text-token"&gt;Updating the Text Token&lt;a class="headerlink" href="#updating-the-text-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before I was ready to start with the Text tokens, I needed to get ready.
Not a lot of work, but some solid foundational stuff to make the rest of the
processing go easier.&lt;/p&gt;
&lt;h3 id="getting-ready"&gt;Getting Ready&lt;a class="headerlink" href="#getting-ready" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;My main drive for updating the Text token to support line/column numbers was never
about the small stuff.  It was that boring work, stuff was easy to do and quickly
finished, that I wanted to get out of the way.  Adding the ability
to pass in either a &lt;code&gt;position_marker&lt;/code&gt; argument or the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt;
arguments?  Done.  Making sure they got copied along with the other information when
the &lt;code&gt;create_copy&lt;/code&gt; function was called? Done.  Changing the &lt;code&gt;InlineRequest&lt;/code&gt; and
&lt;code&gt;InlineResponse&lt;/code&gt; classes to handle line numbers and column numbers?  Done.  If my
memory and notes are accurate, those changes were all completed in the first half-hour
that I used to work on these changes.&lt;/p&gt;
&lt;p&gt;Then,
to ensure things were setup to verify the consistency of the changes in
the future, I made some changes to the
&lt;code&gt;verify_line_and_column_numbers.py&lt;/code&gt; module. While I knew I was going to write the actual
validations in a separate task, I wanted to make sure that I had a good view of what
inline tokens were going to be handed off to the future consistency validators.
To accomplish this, I added two sets of print statements: one as part of the
&lt;code&gt;__verify_token_height&lt;/code&gt; function and one at the end of the
&lt;code&gt;verify_line_and_column_numbers&lt;/code&gt; function.  My plan here was to not only set myself
up for the inline consistency checks to come, but to be able to see what the group
of inline tokens to be processed was, to allow me to plan future sets of equivalence
classes.&lt;/p&gt;
&lt;p&gt;With that setup work done, it was on to the actual classes.&lt;/p&gt;
&lt;h3 id="starting-with-the-paragraph-tests"&gt;Starting with the Paragraph Tests&lt;a class="headerlink" href="#starting-with-the-paragraph-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that foundational work completed, I decided to start with the tests in the
&lt;code&gt;test_markdown_paragraph_blocks.py&lt;/code&gt; module.  Since the Paragraph Block tokens are the
default containers for Text tokens, I figured that this was the best bet to get started
with some of the simple stuff.  That bet paid off with the first equivalence class,
a Text token following a Paragraph token.&lt;/p&gt;
&lt;p&gt;If I had to point out the simplest case of a Text element in a Markdown document, I
would definitely point to an example similar to
&lt;a href="https://github.github.com/gfm/#example-189"&gt;example 189&lt;/a&gt;.
Despite its high index number, to me this is the simplest example of all Markdown
documents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;aaa&lt;/span&gt;

&lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Simply speaking, it is two paragraphs separated by a single newline.  While it is true
that a single line of text would be simpler, to me, that is not a realistic example of
a Markdown document.  To me, a document means multiple paragraphs of text that
conveys some information.  From experience, it is very hard to convey anything except
the most basic forms of
information in a single paragraph.  Also, as a realistic example, example 189 shows how
you can separate two paragraphs in a Markdown document.  As such, I consider this the
root example.&lt;/p&gt;
&lt;p&gt;As this was the root example to me, it also contained the first and root equivalence
class: a Text token
contained as the first token after a Paragraph token.  While there are numerous
variations of this equivalence class, for me this is the base class itself.  And as I
looked through the code on how to isolate this equivalence class, I came to an
interesting observation. It should have been an obvious observation, but it took me a
bit to work through from “huh?” to obvious.  I forgot that equivalence classes deal with
input and output, but that source code rarely follows those same patterns.&lt;/p&gt;
&lt;h3 id="this-is-a-good-thing"&gt;This Is A Good Thing&lt;a class="headerlink" href="#this-is-a-good-thing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I started to look for the source code behind my first equivalence class, I found
that it was hard to isolate the source code to just that equivalence class.  But as
I looked at the source code more, that made sense.  One reason that it made sense was
that if the cases were isolated based on equivalence class, it would mean that there
was a lot of duplicated code in the project.  Another reason was that such separation
would force distinct paths through the source code that would not be natural from any
other viewpoint than that of equivalence classes.&lt;/p&gt;
&lt;p&gt;The way the project was designed was to have an initial parsing phase to get all the raw
information together, then a coalesce phase to combine any text tokens where possible,
and finally an inline parse phase to handle the inline tokens.  Dragging any artificial
grouping of output across those phases seemed very counter-productive to me.  But
I still needed to figure things out.  It was time for a bit of a regroup.&lt;/p&gt;
&lt;h3 id="rethinking-my-approach"&gt;Rethinking My Approach&lt;a class="headerlink" href="#rethinking-my-approach" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After performing a global search for &lt;code&gt;TextMarkdownToken(&lt;/code&gt; on the project, I was rewarded
with a small number of occurrences of a &lt;code&gt;TextMarkdownToken&lt;/code&gt; being created within the
project.  This was good because it meant the number of actual changes that I would
need to make was small, and hopefully each change would carry over multiple equivalence
classes.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;__handle_fenced_code_block&lt;/code&gt; function and the &lt;code&gt;__handle_html_block&lt;/code&gt; function
(through the &lt;code&gt;check_normal_html_block_end&lt;/code&gt; function) were
both responsible for handling the additional Text tokens as part of container
processing, so they were the first to be changed.  In addition, the
&lt;code&gt;parse_indented_code_block&lt;/code&gt; function, the &lt;code&gt;parse_atx_headings&lt;/code&gt; function, and the
&lt;code&gt;parse_paragraph&lt;/code&gt; functions all included the creation of new instances of the
&lt;code&gt;TextMarkdownToken&lt;/code&gt;.  Making those changes took care of all cases where the
Parsing Processor created Text tokens.  From there, a quick check confirmed that the
Coalescing Processor only modified existing Text tokens and did not create any new
ones.&lt;/p&gt;
&lt;p&gt;After a bit of double checking to make sure I did not miss anything, I acknowledged
that the preparation work was done, and it was now onto inline processing.&lt;/p&gt;
&lt;h3 id="how-the-inline-processing-works"&gt;How The Inline Processing Works&lt;a class="headerlink" href="#how-the-inline-processing-works" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When the Inline Processor starts, it loops through all the tokens, explicitly looking
for Text tokens, as they are the only tokens that can contain inline sequences.  Once
such a Text token is found, a further check is done to make sure that the Text token
is within a Paragraph element or a SetExt Heading element (the only two block elements
in which inline tokens are allowed) before proceeding with
the actual processing of the Text Token.&lt;/p&gt;
&lt;p&gt;For any readers that have not been following along on the project’s journey, let me
provide a bit of a recap on how that processing works.  Back in the article
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/"&gt;on starting inline processing&lt;/a&gt;,
I go through the algorithm that I use in the inline processor:&lt;sup id="fnref:hidden"&gt;&lt;a class="footnote-ref" href="#fn:hidden"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set the &lt;em&gt;start point&lt;/em&gt; to the beginning of the string&lt;/li&gt;
&lt;li&gt;look from the &lt;em&gt;start point&lt;/em&gt; for a new &lt;em&gt;interesting sequence&lt;/em&gt;&lt;ul&gt;
&lt;li&gt;if none is found&lt;ul&gt;
&lt;li&gt;emit the rest of the line from the &lt;em&gt;start point&lt;/em&gt; and exit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;if one is found&lt;ul&gt;
&lt;li&gt;emit the text from the &lt;em&gt;start point&lt;/em&gt; to the start of the &lt;em&gt;interesting sequence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;handle the current &lt;em&gt;interesting sequence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;update the &lt;em&gt;start point&lt;/em&gt; to the end of the &lt;em&gt;interesting sequence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;go back to the top&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the Text token perspective, the important parts of that algorithm are
the &lt;code&gt;emit the rest of the line&lt;/code&gt; part and the &lt;code&gt;emit the text from...&lt;/code&gt; part.  When most
of the other parts
of the algorithm emit their own token&lt;sup id="fnref:twoExceptions"&gt;&lt;a class="footnote-ref" href="#fn:twoExceptions"&gt;4&lt;/a&gt;&lt;/sup&gt;, a check it made to see what
text has been “emitted” before that point.  Then a new Text token is created with
that emitted text, followed by the newly created token that represents the &lt;em&gt;interesting
sequence&lt;/em&gt;, followed by the algorithm looks for the next &lt;em&gt;interesting sequence&lt;/em&gt; to deal
with.&lt;/p&gt;
&lt;p&gt;In the end, there were only 4 places where I had to change the creation of the
Text tokens to provide the line/column number information.  In all, there were only
9 places in the project where I had to change the creation of the Text token.
Far from being lulled into thinking the hard work was done, I figured it would be
in the updating of the scenario tests that things would get interesting.  And I was
not disappointed!&lt;/p&gt;
&lt;h3 id="scenarios"&gt;Scenarios&lt;a class="headerlink" href="#scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the code changes made to the Inline Processor, it was time to focus on the
scenario tests and getting their data changed and manually validated.  Using the
command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -k test_paragraph_blocks
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I executed each of the paragraph specific scenario tests, looking for the expected
failures in each test that contains a Text token.  Except for three tests,
each of these tests were simple cases of the base equivalence class, which meant that
they were quickly updated and verified.  Of those three tests, two new equivalence
classes emerged: the first Text token within an Indented Code Block token, and a Text
token following a Hard Break token.&lt;/p&gt;
&lt;p&gt;The scenario test for
&lt;a href="https://github.github.com/gfm/#example-195"&gt;example 195&lt;/a&gt;
is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which was properly parsed into new equivalence class of an Indented Code Block token
containing a single Text token and a normal Paragraph token containing a single Text
token.  As code blocks
do not contain any inline processing and no extra inline processing was specified, this
was an easy validation of that new equivalence class.  Quick, easy, done.&lt;/p&gt;
&lt;p&gt;The other failing scenario test, the test for
&lt;a href="https://github.github.com/gfm/#example-196"&gt;example 196&lt;/a&gt;
is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;aaa&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;bbb&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the sequence &lt;code&gt;{space}&lt;/code&gt; was replaced with actual space characters.  I replaced
the tokens with what I thought was their proper line/column numbers and was surprised
to find out that the tests were still failing.
As I started
to work through the research on why this was happening, I came to an interesting
conclusion.  I was not going to get away from handling the other inline tokens after
all.&lt;/p&gt;
&lt;h3 id="the-truth-always-wins"&gt;The Truth Always Wins&lt;a class="headerlink" href="#the-truth-always-wins" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Based on the above Markdown, the tokens that were generated for that scenario test were
a Text Token, a Hard Line Break token, and another Text Token.  The first Text token
was fine, I had that covered, and the Hard Line Break token was not what we were
focusing on, so the fact that it did not have a line/column number associated with it
was fine.  But that left the second Text token in a bit of a conundrum.  Based on the
code at that time, the line/column number was &lt;code&gt;1,4&lt;/code&gt;, which based on the existing logic
was correct.  But from a validation point of view it was incorrect: it should be &lt;code&gt;2,1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It took me a bit to realize that if I was going to change each Text token, I would at
least have to partially handle the other inline tokens.  In this case, unless
I added some code that understood the Hard Line Break token, the source code would
correctly state that the line/column number was &lt;code&gt;1,4&lt;/code&gt;.  To be clear, it is not that
the line/column number of &lt;code&gt;1,4&lt;/code&gt; is actually correct, but according to the information
that the algorithm has, that is the correct value to compute for that token. So,
while I did not have to output the line/column number for the other inline tokens
yet, I at least had to figure out what change that token was
going to impart to the stream of inline tokens in that group.&lt;/p&gt;
&lt;h3 id="and-it-happened-with-the-most-complicated-inline-token"&gt;And It Happened with The Most Complicated Inline Token&lt;a class="headerlink" href="#and-it-happened-with-the-most-complicated-inline-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Hard Line Break token just happened to be the token I needed to figure out.  And
it would end up being the most
difficult inline token to figure out the new line/column number for.  One reason was
that, for whatever reason, I placed the newline for the Hard Line Break token with the
following
Text token, and not the Hard Line Break token itself.&lt;sup id="fnref:yesIDid"&gt;&lt;a class="footnote-ref" href="#fn:yesIDid"&gt;5&lt;/a&gt;&lt;/sup&gt;  This meant that
to properly deal with that token, I needed to reduce the vertical height of the
following Text token by 1, as the Hard Line Break token had already increased the
line number. The other reason for it being complicated is that the proper setting of
the column
number relied on checking with the owning Paragraph token, grabbing any leading space
for that next line from that token.&lt;/p&gt;
&lt;p&gt;All in all, in took a bit of work, but not too much before all the tests in that
scenario test group were passing.  While I knew there were 10s of hundreds more changes
to make, I knew I could do this.  Yeah, it would be slow, but if I just kept my
focus on the task at hand, I could do this.&lt;/p&gt;
&lt;h3 id="lather-rinse-repeat"&gt;Lather-Rinse-Repeat&lt;a class="headerlink" href="#lather-rinse-repeat" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I could go through each of the other equivalence classes that I discovered and
processed, I will leave that for a future article where I talk about the inline
consistency checks.  It was enough of a brutal and time-consuming process that I will not make it more so by talking about it.  Each time, I literally picked a new section of
scenario tests, replaced the &lt;code&gt;test_paragraph_blocks&lt;/code&gt; in the command line with the
prefix for another group of
tests and ran it again.  With the results of that test run, I picked off one of the
failing tests, correcting the line/column number for the Text tokens, and running
the tests again to repeat the process.  As I went, I manually validated each
test’s changes, and I rechecked my results as I staged the changes into the project’s
GitHub repository.&lt;/p&gt;
&lt;p&gt;A good example of this process was the next group of tests that I tackled: the Hard
Line Block group.  The
first couple of tests were a rehash of what I had already done, so determining the
proper line/column numbers for those tests were easy, and quickly verified.  That
left tests that included Emphasis tokens and Text tokens within Atx Heading tokens.
I just buckled down and followed at the same process as documented before, adjusting
as I went.&lt;/p&gt;
&lt;p&gt;Yes, it was slow, but it was also good.  While it dragged on, I was getting predictable
results with the application of my process.  In my mind, I had confidence that it was
no longer a matter of “um… around 1600 tokens? how am I going to…”.  I was making
that transition to “how can I get these done more efficiently and reduce my time on
each test without sacrificing quality?”&lt;/p&gt;
&lt;h2 id="updating-the-emphasis-token"&gt;Updating the Emphasis Token&lt;a class="headerlink" href="#updating-the-emphasis-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Compared to the work required to change the Text token, updating the Emphasis token
to include line/column numbers was trivial.  As the work had already been done to
determine the width to apply to the start and end tokens, the main change was to pass
the line/column number information to the constructor of the EmphasisMarkdownToken
and the EndMarkdownToken.&lt;/p&gt;
&lt;p&gt;With that change in place, I started running the scenario tests in the emphasis group
and only had to make one small change.  In the cases where the end Emphasis token
were completely consumed, everything was fine.  But in the cases where an end Emphasis
token were partially consumed, the column number was off by one.  That took a bit
of puzzling, but after some thinking, the answer leapt out at me.  I will not kid you
though, without me scribbling down the various cases and working through the scenarios,
it would have taken me a lot longer.&lt;/p&gt;
&lt;p&gt;For the start and end Emphasis tokens, the Inline Processor creates a Special Text token
that contains either the &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; character and the number of those characters found.
Because emphasis is processed from the inside out&lt;sup id="fnref:empExample"&gt;&lt;a class="footnote-ref" href="#fn:empExample"&gt;6&lt;/a&gt;&lt;/sup&gt;, the emphasis characters
taken from those Special Text tokens occur at the end of the Special Text token for the
start Emphasis token and the beginning for the end Emphasis token.  As a result of that,
the start Emphasis token’s column number needed to be adjusted by the number of
characters consumed, to ensure it pointed at the right location.  Once that adjusted
was added, the remaining scenario tests passed.&lt;/p&gt;
&lt;p&gt;While I was not sure if the other inline tokens would be as easy as the Emphasis
tokens, I was hopeful.  And in a long project, that is a good thing!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I start to write these sections in my articles, I always refer to my notes and try
to put my mind back into the frame of mind I was in at that time.  While there are
sparse notes here and there about this section of work, there is really only one of
those notes that properly sums up the work:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Phew!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While there were times during that slog that I did not think it would ever end, I was
adamant that I was going to get through it and complete it.  In my mind, it was not
a question of confidence, it was a question of endurance.  My change algorithm was
simple enough, and I had confidence that the validation part of that algorithm was
solid.  It was just a matter of working through what seemed to be a mind-numbing number
of changes until they were all done.&lt;/p&gt;
&lt;p&gt;But I persisted and got through it.  And while I believe it was the right decision
to only focus on the Text token and the Emphasis tokens, in hindsight, it might have
been okay to add the other inline tokens at the same time.  With all the work to
make sure their space was properly accounted for, I believe that most of the work that I
have left with those tokens is to plug in the calculated line/column numbers into the
inline tokens themselves, changing the serialized text, and writing the consistency
checks.  Be it as it may, unless I messed up a calculation, the hard part of making
sure the calculations work has already been done.&lt;/p&gt;
&lt;p&gt;On the technical debt point of view, I am a bit worried, but not too much.  The list
of things to check in the issues list is a bit larger than I like it, but there are
some future ideas and a lot of double-check reminders on there.  At the very least,
I am sure I can start to make short work of a lot of those issues, or properly
prioritize them for later, whichever is best for that issue.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the Text tokens and the Emphasis tokens out of the way, I decided that it was
better that I add the consistency checks for those tokens before progressing forward.
After having to do a fair amount of work to support “bypassing” those tokens to properly
calculate the line/column number of any following Text token, I had a feeling it would
come in handy if I moved it up the priority list a bit.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:mostlyTrue"&gt;
&lt;p&gt;This function makes simple assumptions that the &lt;code&gt;source_string&lt;/code&gt; argument is a string of any length, the &lt;code&gt;index_in_string&lt;/code&gt; argument is an integer, and the &lt;code&gt;valid_character&lt;/code&gt; argument is a string of length 1.  Because the argument names are explicit enough and their usage is within a predefined scope, I decided to not verify the type of value for each.  As such, the statement that the function will either return &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; assumes that those assumptions are followed. &lt;a class="footnote-backref" href="#fnref:mostlyTrue" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:largeFinite"&gt;
&lt;p&gt;For more information, &lt;a href="https://en.wikipedia.org/wiki/History_of_large_numbers"&gt;see Wikipedia&lt;/a&gt;.  The short answer to this is that I would start with the first argument containing an empty string, for a count of 1.  Then I would move on to a string with 1 character, and have to populate that string with every viable Unicode character.  Moving on to strings with 2 characters, I would need to take every 1 character string, and repeat that same process with the second character.  Repeating this process, the number of variations on possible strings is not infinite, but mathematically it is called a large finite number, or largely finite. &lt;a class="footnote-backref" href="#fnref:largeFinite" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:hidden"&gt;
&lt;p&gt;Looking back at it myself, it is a bit hidden, but it is in the section on &lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/#code-spans"&gt;code spans&lt;/a&gt; in the fourth paragraph. &lt;a class="footnote-backref" href="#fnref:hidden" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:twoExceptions"&gt;
&lt;p&gt;The two exceptions to this are the handling of the backslash sequence and the character entity sequence, both which add to the text that is being accumulated. &lt;a class="footnote-backref" href="#fnref:twoExceptions" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:yesIDid"&gt;
&lt;p&gt;Yes, I did add an item to the issues list for this. &lt;a class="footnote-backref" href="#fnref:yesIDid" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:empExample"&gt;
&lt;p&gt;For a good example of this, look at &lt;a href="https://github.github.com/gfm/#example-422"&gt;example 422&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:empExample" title="Jump back to footnote 6 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Consistency to Token Heights</title><link href="https://jackdewinter.github.io/2020/08/31/markdown-linter-adding-consistency-to-token-heights/" rel="alternate"></link><published>2020-08-31T00:00:00-07:00</published><updated>2020-08-31T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-31:/2020/08/31/markdown-linter-adding-consistency-to-token-heights/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying for the second half of the
container block tokens: the Block Quote tokens.  In this article, I fill out the
line/column number consistency checks by adding support for determining and verifying
the height of …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying for the second half of the
container block tokens: the Block Quote tokens.  In this article, I fill out the
line/column number consistency checks by adding support for determining and verifying
the height of all block tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From a high-level point of view, I believe that the project is coming together nicely.
Each of the examples in the base
&lt;a href="https://github.github.com/gfm/"&gt;GFM specification&lt;/a&gt;
have been tested, and their proscribed HTML output verified.  The consistency check that
verifies that that Markdown tokens contain the correct information is also in place,
covering all existing tokens.  What was left was a bit of unfinished business with
the consistency checks to verify those same tokens.  Two parts of that check were left:
verifying the token height and verifying the inline tokens.&lt;/p&gt;
&lt;p&gt;I had always intended the verification of inline tokens to be the final verification.
That was always immediately clear to me.  To properly verify any of the inline
tokens, the tokens around it needed to be verified to give that token a solid
foundation.  Without those other tokens as a foundation, any attempt at verifying
inline tokens would be shaky at best. It only made sense for me to start working on
the verification of token heights before verifying the inline tokens.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4ae90e7b0a6e242f4364ec8bb4fe667d9d024580"&gt;15 Aug 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/3fe81f2d4ffa65f1fb2d7818cab739e9e8b20470"&gt;19 Aug 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="looking-back-at-last-weeks-issue"&gt;Looking Back at Last Week’s Issue&lt;a class="headerlink" href="#looking-back-at-last-weeks-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After finishing the work on last week’s article, I took it easy for a few days,
working on the project when I could, but not pushing to hard.  As someone who uses
his brain heavily in both his professional capacity and his personal capacity, it was a
bit of a wakeup call for me.  When I saw the end of the project getting closer and
closer, I started to put in extra effort towards the project, thinking that I could get
there faster.  This normally would not be a bad thing. But to achieve that extra effort,
I diverted some of my energy away from the energy that I normally use to take care of
myself.  I did not really think about it before I started doing it, it just happened.&lt;/p&gt;
&lt;p&gt;While the result was me taking an extra day to complete the article, it could have
been worse.  From an article
point of view, I needed to rework 2-3 sections, but it was not too bad.  From a personal
point of view, if I had continued to push myself, I believe it would have multiplied
the time needed to recover substantially. I forgot that taking care of yourself and
your mental well-being is very important, especially in times of crisis.  In normal
times, I might have been able to make that trade off work, but currently, I do not
believe it is a viable option for me.  I just do not have tons of extra energy to spare.
Like it or not, those are just the times we are living in right now.&lt;/p&gt;
&lt;p&gt;And that is okay.  It is taking me a bit to accept that, but I am working on it.
What is important to me is this project and writing about it… all about it.  Not
just the rosy stuff you read in other blogs, but the actual problems I encountered
and how I approached them.  At that includes problems like these.&lt;/p&gt;
&lt;h2 id="getting-ready-for-the-changes"&gt;Getting Ready for the Changes&lt;a class="headerlink" href="#getting-ready-for-the-changes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Knowing that I was going to be making a lot of changes to the verification logic for
line/column numbers, I wanted to prepare for that work by moving that code into its own
module.  Having seen this feature organization work well for the Markdown transformer
and the HTML transformer, I figured that moving the line/column verification code into
its own
module was an easy choice.  Further increasing the benefit of that choice was the fact
that I was going to add more logic to the code.  Keeping all that logic in one place
just made a lot of sense to me.&lt;/p&gt;
&lt;p&gt;The movement of the code was a pretty painless process, will all functions that
handle the verification
of line/column numbers being moved into the &lt;code&gt;verify_line_and_column_numbers.py&lt;/code&gt; module.
Once moved, any functions that did not need to be public were prefixed with &lt;code&gt;__&lt;/code&gt; and
their invocations were also changed to add the &lt;code&gt;__&lt;/code&gt; prefix.  Having a good set of
scenario tests added to the ease of this change, as I was able to verify that the
code was still working properly at each stage of the change.&lt;/p&gt;
&lt;p&gt;With the new module created, it was time to add to that new module.&lt;/p&gt;
&lt;h2 id="verifying-the-height-of-tokens"&gt;Verifying the Height of Tokens&lt;a class="headerlink" href="#verifying-the-height-of-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As with any of the consistency checks, the verification of the token height started as
a very small and compact function.  At the beginning, the &lt;code&gt;__verify_token_height&lt;/code&gt;
function had 2 parameters: &lt;code&gt;current_token&lt;/code&gt; and &lt;code&gt;last_token&lt;/code&gt;.  Knowing that I had the
SetExt Heading token to process, I encapsulated that logic within that function,
calling the &lt;code&gt;__validate_block_token_height&lt;/code&gt; function to do the heavy lifting.  This
encapsulation allowed me to replace the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt; variables
used by the other tokens with the &lt;code&gt;original_line_number&lt;/code&gt; and &lt;code&gt;original_column_number&lt;/code&gt;
variables used by the SetExt Heading token.&lt;/p&gt;
&lt;p&gt;That verification function, the &lt;code&gt;__verify_token_height&lt;/code&gt; function, needed to be called
from 2 locations: after the &lt;code&gt;__validate_new_line&lt;/code&gt; was called and at the end of
the normal processing.  The call after the &lt;code&gt;__validate_new_line&lt;/code&gt; function was called
ensured that the height of any 2 block tokens not on the same line was calculated. If
the 2 tokens were on the same line, one of them was a container block
token, and they would always be on the same line.  As such, I could just focus on the
tokens on different lines without losing missing anything.  The call at the end of
processing would ensure that the height of the final block would also be verified.&lt;/p&gt;
&lt;p&gt;It was a good start.  With all the little stuff out of the way, it was on to
the heavy lifting part of the change.&lt;/p&gt;
&lt;h3 id="doing-the-heavy-lifting"&gt;Doing the Heavy Lifting&lt;a class="headerlink" href="#doing-the-heavy-lifting" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;__validate_block_token_height&lt;/code&gt; function was always intended to be a function that
needed to know about every block level token.  From the initial design for this change,
I figured that it was best to have one big function that could be
refactored later, than to have duplicate code in separate handler functions.  As I have
had good success with that pattern so far, I decided to use it again here.&lt;/p&gt;
&lt;p&gt;Like my other uses of the pattern, I started off the function with a large
&lt;code&gt;if-elif-else&lt;/code&gt; statement containing all the leaf block token names, one to each
&lt;code&gt;if&lt;/code&gt; statement.  Each &lt;code&gt;if&lt;/code&gt; statement contained a single line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and a final:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Token "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" not supported."&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Just like before, I had a plan.  I started running tests in groups
based on their name.  So to start, I used the command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -k test_paragraph_blocks_
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to run all the tests that dealt with paragraph blocks.  If I hit a type of leaf block
that I had not worked on yet, the &lt;code&gt;assert False&lt;/code&gt; triggered with the line number
indicating which token type failed.  If I hit a type of block that I was not expecting,
the &lt;code&gt;assert False&lt;/code&gt; in the final &lt;code&gt;else&lt;/code&gt; would be triggered, letting me know which
token I missed.&lt;/p&gt;
&lt;p&gt;And it was a lot of
&lt;a href="https://en.wikipedia.org/wiki/Lather,_rinse,_repeat"&gt;lather-rinse-repeat&lt;/a&gt;.
I ran the tests over and over again using the above command line.  If any tests failed,
I picked either the first test or the last test and examined why the test failed.  If
it was the first time that I was dealing with that specific token, I coded a good guess
as to what the height formula
should be.  Otherwise, I examined the existing formula, and tried a variation of the
code that would handle the new case.  Once all the tests for a given group were
passing, I picked another group.  This repeated until all the scenario tests in
the project were passing.&lt;/p&gt;
&lt;p&gt;For the most part, that seemingly endless processing loop worked.  But as in any
project, there were things that needed to be handled separately.&lt;/p&gt;
&lt;h3 id="counting-newlines"&gt;Counting Newlines&lt;a class="headerlink" href="#counting-newlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Shortly into the changes, I figured out that I needed a simple helper function to
calculate the
number of newline characters in each string.  Based on my observations, I was going
to need to count a different set of newline characters for most of the tokens.  Rather
than implementing the algorithm multiple times, it made sense to put it into one
function and in one location.&lt;/p&gt;
&lt;p&gt;After a couple of tries, I ended up with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_examine&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;original_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_examine&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;removed_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_examine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;original_length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;removed_length&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I forget where I encountered this pattern initially, but it was a useful one to
remember. While it does include the possibly expensive creation of a new string, the
algorithm itself is simple.
The number of a given characters in a string is the difference between the original
length of the string and length of that same string with all that specific character
replaced with an empty string.&lt;/p&gt;
&lt;p&gt;Say for example I need to know how many &lt;code&gt;a&lt;/code&gt; characters are in the string
&lt;code&gt;maybe a good day to die&lt;/code&gt;, which has a length of 23.  If I remove all the &lt;code&gt;a&lt;/code&gt;
characters, I am left with the string &lt;code&gt;mybe  good dy to die&lt;/code&gt; which has a length of 20.
Subtracting the second result from the first result leaves a value of 3, the number of
&lt;code&gt;a&lt;/code&gt; characters in the string.&lt;/p&gt;
&lt;p&gt;For Paragraph tokens, the use of this function was simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;token_height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as it was for Indented Code Block tokens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;token_height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indented_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For Link Reference Definitions, it was even more useful:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;token_height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_name_debug&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_destination_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title_raw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After dealing with those tokens, there were a handful of other tokens
that were easily handled by very simple calculations.  After those tokens
were handled, there were only two troublesome tokens left: the HTML Block token and the
Fenced Code Block token.&lt;/p&gt;
&lt;h3 id="leaf-block-stacks-and-tracking-tokens"&gt;Leaf Block Stacks and Tracking Tokens&lt;a class="headerlink" href="#leaf-block-stacks-and-tracking-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To properly process the height of those two troublesome tokens, a pair of concepts were
introduced almost at the same time.  I tried splitting these two concepts into their
own sections, but I found each attempt to do that complicated by their dependencies on
each other.&lt;/p&gt;
&lt;p&gt;The first of those concepts was the ability to track the leaf block that was currently
active at any point.  The primary driver for this concept was to provide context to the
tokens that
occurred within the HTML Block element and the Fenced Code Block element.  As these
two block elements handle their own text parsing, I needed to avoid any “extra”
checking that
occurred within these blocks.  After trying 4 or 5 other alternatives, the
tried-and-true block stack was easily the best, and most reliable, solution.&lt;/p&gt;
&lt;p&gt;The second concept was closely tied to the first concept and dealt with properly
tracking the right tokens.  To finish the handling of the HTML Block element and the
Fenced Code Block element, I needed to make sure that the concept of the “last” token
was correct.  To get that working properly, I added code to check the stack and only
set the new “remembered” token variable if that was not set.&lt;/p&gt;
&lt;h3 id="how-did-this-work"&gt;How Did This work?&lt;a class="headerlink" href="#how-did-this-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Unless there was anything to do with HTML Block elements or
Fenced Code Block elements, this code was not invoked.  Except for the 4 block
tokens that do not have close tokens (Blank Line, New List Item, Link Reference
Definition, and Thematic Break), any start token was added to the stack.  When
an end token was encountered, if the name of that end token matched the top
token on the stack, that top element was removed.  Simple stack management.  After
a test revealed that I had forgot to add one of those 4 block tokens to the “do not
stack” list, the stack worked flawlessly.&lt;/p&gt;
&lt;p&gt;The tracking of the tokens to avoid duplication worked as well.
When one of the two special blocks were encountered, the stack logic would add them
to the stack.  Once added, the algorithm assumed that the handling of the HTML Block
tokens and Fenced Code Block token would handle any encapsulated tokens and did not
track any of those encapsulated tokens.  When the end of the block occurred, it was
popped off the stack and the normal processing occurred.  There were a couple of
small issues at the start, but after they were cleaned up, it was smooth sailing after
that.&lt;/p&gt;
&lt;h3 id="why-did-they-need-special-processing"&gt;Why Did They Need Special Processing?&lt;a class="headerlink" href="#why-did-they-need-special-processing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Although I tried a number of different options, the only thing that worked for
determining the height of these two special block tokens was a brute-force iteration of
all the
inline tokens.  While there were other tokens that persisted information on how many
newlines were contained within their Leaf Block, these two Leaf Block tokens did
not.  Without that information, the only option left was to iterate through each of the
encapsulated inline tokens, counting newline characters as I went.  But with those
tokens already counted, I needed to avoid counting them a second time.&lt;/p&gt;
&lt;p&gt;It was not a great solution, but it was the one that I ended up with.  Up to this
point in the project, there was no reason to change how those two Leaf Blocks stored
(or did not store) any newline, it just was not a problem.  While it was not a
great solution, at this stage it was an efficient solution.  But to check to see if
I could do it better, I created a new item in the issues list, and moved on.&lt;/p&gt;
&lt;h2 id="there-was-one-additional-thing"&gt;There Was One Additional Thing&lt;a class="headerlink" href="#there-was-one-additional-thing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I finished up my work validating the Fenced Code Block token heights, there was one
scenario test that snuck up and surprised me:
&lt;a href="https://github.github.com/gfm/#example-97"&gt;example 97&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`````&lt;/span&gt;

&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This example, and the ones around it, show how an open block is closed when the
container block that owns it is closed or when the end of the document is reached.
While everything else was working properly with this example, the token’s line
height was off by one.  After double checking the math for the consistency check
and for the existing tokens, I confirmed that it was an off-by-one error. Given that
error and the section that the example was in, the next step was an easy one: craft an
example that included the end of the Fenced Code Block element:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`````&lt;/span&gt;

&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="o"&gt;`````&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running that test, it immediately worked, which meant only one thing to me: the
algorothm needs to know if the end token was forced.&lt;/p&gt;
&lt;h3 id="determining-if-a-token-is-forced"&gt;Determining If A Token Is Forced&lt;a class="headerlink" href="#determining-if-a-token-is-forced" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Right away, I was aware that determining if the end token was forced was not going
to be an easy task.  I immediately figured out one approach but dismissed it as too
costly.  But as I spent hours looking for any other approach that worked, I was coming
up empty with each attempt.  I found some partial solutions, but nothing that worked
in all required cases.  In the end, it was that costly approach that I returned to
as my only solution.&lt;/p&gt;
&lt;p&gt;What was that solution?  Costly as it was, that solution was to add a field to
every end token that indicates whether it was asked to be closed or forced close.
Why was it costly?  A quick scan of the scenario tests revealed almost 200 instances
of an end token… for only the scenario tests starting with &lt;code&gt;test_markdown_a&lt;/code&gt; and
&lt;code&gt;test_markdown_b&lt;/code&gt;.  Extrapolating from that sample, I believed that it would
realistically mean changing between 1250 and 1750 end tokens throughout all the
examples.&lt;/p&gt;
&lt;p&gt;It was not a decision that I made lightly, but with no other viable options, I
started to embrace it.  Making the change was the easy part.  Before the &lt;code&gt;was_forced&lt;/code&gt;
field was added to the &lt;code&gt;EndMarkdownToken&lt;/code&gt; class, the &lt;code&gt;compose_data_field&lt;/code&gt; function
looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;compose_data_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once the &lt;code&gt;was_forced&lt;/code&gt; field was added, it changed into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;compose_data_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;was_forced&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;display_data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If this looks like I snuck something extra in, it is because I did.  Given the number
of changes that I was going to make, I wanted to ensure that I could efficiently make
those
changes and verify them.  While having optional parts of the token serialization left
out was
more compact, it did make the serialization harder to read.  I figured that if I was
making a thorough change like this, being explicit with each of the fields would
reduce my chances of getting one of the serializations wrong.  Instead of asking myself
“what was the default value of the second and third fields”, I just added those fields
and ensured they were serialized.&lt;/p&gt;
&lt;p&gt;Basically, I gambled.  The cost of making the change to the token’s serialization was
cheap.  It would be in the verification of that change where most of the expense would
come.  And my bet was that serializing all fields explicitly would make that
verification easier and faster.&lt;/p&gt;
&lt;h2 id="was-it-worth-it"&gt;Was It Worth It?&lt;a class="headerlink" href="#was-it-worth-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If anyone would have asked me that question at the start of that process, I would
have
&lt;a href="https://idioms.thefreedictionary.com/hemmed+and+hawed"&gt;hemmed and hawed&lt;/a&gt;,
giving an answer that would be uncertain at best.  But by the time I had finished
the first group of scenario tests, that answer was easily becoming a more solid “Yes!”.&lt;/p&gt;
&lt;p&gt;Was it painful?  Yes!  I purposefully did not keep track of how many changes I had
completed and how many I had left to go.  I felt that keeping track of that number
would be discouraging and focusing my mind on something other than the obvious thing:
this was the right change to do.  I was aware this was going to take a while, and
as the hours ticked by, that was hammered home multiple times.  By the time I
got to the end of this process, it took 4 days and many long hours to complete.&lt;/p&gt;
&lt;p&gt;But, in my eyes, it was worth every step of it.  As this change touched on every
scenario test, I needed to manually verify each scenario test before
going on to the next test.  And while I had test automation in peace, I had not
manually gone through each of the tests and verified for myself if the tokens
looked correct.  For me, I found peace in having inspected the tests for myself,
knowing that the consistency checks were providing me with the same results as
my manual verification.&lt;/p&gt;
&lt;p&gt;Does that mean I want to do it again?  Not really.  But would I do it if I felt that
I needed to?  In a heartbeat.  In terms of confidence,
this was me doing a final read of my article before publishing it.  This was me
running the Static Code Analysis against my code one more time just to make sure
that I did not miss anything.  This was me looking over the changes I am about to
commit to the repository before I submit the commit.  It is easy to argue that
each of those actions is more emotional than logical, but that is the point.&lt;/p&gt;
&lt;p&gt;Sometimes, it is just logical to do an action for a positive emotional reaction.
And that is okay too.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I know I will only get one chance to make a good impression with this project, so
I want to make that impression a good one.  If I want to provide a good impression by
having a good linter as the outcome for this project, I will need to test as many of the
combinations of Markdown elements with each other as possible, in as many circumstances
as possible.  From the beginning of the project, a simple calculation made it clear that
the scope of testing required would be difficult if I was lucky.  If I was not lucky,
that hopeful guess of difficult would grow by at least 2 orders of magnitude.&lt;/p&gt;
&lt;p&gt;But even given that prediction that testing everything would be very difficult, I
wanted to give the project the best chance to succeed.  The best way that I know of
doing that is to fully commit to making the right changes to solve the problems
properly.  For the first set of changes, this meant working with what I had, as it
was only the token height calculation that needed that logic.  For the the second set of
changes it meant changing all the tokens, because there really was not any alternative.&lt;/p&gt;
&lt;p&gt;In a strange way, both sets of changes brought me peace, increasing my confidence
about the project.  In the grand scheme of things, the iterative calculations for the
height of the two Leaf Block tokens was not too expensive, and it is localized to that
one module.  Ammortizing the cost of those calculations over all the Leaf Block tokens
makes it even less expensive.  From that point of view, those changes were definitely
cost effective in my eyes.&lt;/p&gt;
&lt;p&gt;And while people can say I am pedantic and a perfectionist, I somewhat liked spending
that time going through each scenario and verifying it.  Before that review, I had
a lot of trust in those consistency checks, but there was always a question of whether
I had missed something important.  With the existing checks in place and a
manual review of those scenario tests, the chances of any major issues being left
are drastically reduced.&lt;/p&gt;
&lt;p&gt;I will never say that any piece of software has zero bugs in it, but I do know that
I feel that I am eliminating many of the paths for bugs to form in this project.&lt;/p&gt;
&lt;p&gt;And that I am confident about!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After completing the token height verification for block tokens, it was time to start
working on the line/column numbers for the inline tokens.  I was not sure how much of a
chore it would be, but it would be gratifying to get them done!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Consistency to Block Quotes</title><link href="https://jackdewinter.github.io/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/" rel="alternate"></link><published>2020-08-25T00:00:00-07:00</published><updated>2020-08-25T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-25:/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I took care of completing the Markdown transformer checks for one half of the container
block tokens: the List Block tokens.  In this article, I tackle both the line/column
number consistency checks and the Markdown transformer checks for the Block Quote
tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I took care of completing the Markdown transformer checks for one half of the container
block tokens: the List Block tokens.  In this article, I tackle both the line/column
number consistency checks and the Markdown transformer checks for the Block Quote
tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the implementation of list tokens went easier than I thought it would, I
remained cautiously optimistic about adding consistency check support for Block Quote
tokens.  During the initial development of the line/column number checks, I noticed
that the Block Quote tokens did not keep any information about removed data.  After
having completed the List Block token support, I knew that it would be pivotal to
get that right.  And that meant more work.  A lot of nitpicking work.&lt;/p&gt;
&lt;p&gt;To add the consistency checks, I was going to have to accomplish 3 things: capture the
removed line start text, use that information to validate the line/column numbers, and
then write the Markdown transformations for it.  The last two items were the easy part,
those parts I had confidence I could complete.  It was the capturing of removed checks
that I was not confident about.  And the capturing of text was the change that I needed
to tackle first.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/255bfce0efab68c0d76ca8d04b03017ba40e6223"&gt;12 Aug 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/08da2e04c355e0a3bd016e20afce3102696a8107"&gt;14 Aug 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="lets-talk-about-the-obvious"&gt;Let’s Talk About the Obvious&lt;a class="headerlink" href="#lets-talk-about-the-obvious" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I am generally very disciplined when it comes to writing my blog.  I keep notes when I
am writing the code, curating those notes into an outline on the
Thursday to Saturday before I post my article.  If I am lucky enough, I will start
the actual writing of my article on
Saturday night, but most often I start writing it early Sunday morning.  This allows
me to take my time to enjoy my Sunday while ending up with a solid version of the
article by Sunday night.  Then, on Monday night, I take that article and add
extra code samples and do some wordsmithing to form the article into its final form.  It
may not be the way others write their articles, but it is a process that works
for me.&lt;/p&gt;
&lt;p&gt;Until this week that is.  Everything was on track until Monday, when I started my edits
with a headache that I just could not ditch.  But process is process, so I started doing
those edits, pushing on until a couple of hours later.  At that point, I looked at
what I was doing and went… huh?  I started looking at my edits and tried to figure
things out, using even more edits to fix any problems I encountered.  Far from making
things better, I was making them worse.  But I would not see that until later.&lt;/p&gt;
&lt;p&gt;It was a while later when I finally stopped and locked my computer.  Above all else,
this was the best thing that I did in that entire situation.  It took me a
while, but I stopped.  However, by that point, a certain amount of damage
was already done.  I had written some things twice and other things not at all. In
some cases, I had sentences that looking at them later, I wonder if I had written them
while drunk.  I knew I could recover from that position, but it would require a clear
head, some extra time, and some hard work.  And it was not going to happen that night.
I came to the realization that I was not going to be able to meet my usual posting
deadline of Monday night.&lt;/p&gt;
&lt;p&gt;At first, I was angry with myself.  Many weeks of not missing a posting deadline and
now I had a bad record.  “I always post on Monday nights, except for…”  Argh!
But after thinking about the purpose of my blog, to educate and help others, I
started to find peace with it.  None of us is perfect, and we all need to take care
of ourselves.  Me included.  My health versus my article’s deadline.  I needed to
take that extra day and get better before finishing… er… unfinishing and then
refinishing the editing.&lt;/p&gt;
&lt;h2 id="capturing-the-leading-block-quote-text"&gt;Capturing the Leading Block Quote Text&lt;a class="headerlink" href="#capturing-the-leading-block-quote-text" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In its simplest form, the handling of container block elements and their tokens is a
relatively easy concept. Every line of a Markdown document enclosed within a container
block element is usually prefaced with one or more characters that denote the presence
of that container element.  For Block Quotes these are character sequences with the
&lt;code&gt;&amp;gt;&lt;/code&gt; character and an optional whitespace, and for Lists these are whitespaces.  To make
the processing of those contained lines easier, at the start of the project I took some
up-front time to ensure that
the container block element processing is independent of the leaf block element
processing.  As such, I was able to work on that leaf block processing independently of
container block processing.&lt;/p&gt;
&lt;p&gt;When I was doing the initial research for
&lt;a href="https://jackdewinter.github.io/2020/06/29/markdown-linter-rabbit-hole-3-trying-to-dig-myself-out/#keeping-the-scope-small"&gt;container block support&lt;/a&gt;,
I started with List tokens.  I quickly wrote a proof of concept for the line/column
number check and was happy to find that I had already placed the required information
in the token.  However, after using the same process with Block Quote tokens, it was
evident that I had missed the mark with them.  Unlike the List tokens, none of the
required
information was placed within the Block Quote tokens.  At that time, after having
gone down a
&lt;a href="https://jackdewinter.github.io/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/"&gt;rabbit hole for a bit&lt;/a&gt;,
I wisely decided to wait until later to implement that.   Well, that time was now and
I knew it was going to take some work to add it.&lt;/p&gt;
&lt;h3 id="addressing-the-issue"&gt;Addressing the Issue&lt;a class="headerlink" href="#addressing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like the work I did for List Block tokens, the Block Quote stack token needed a
change to support the &lt;code&gt;matching_markdown_token&lt;/code&gt; field.  This field is pivotal to
inform the processor of the latest markdown token that is containing other tokens.
But to properly use this field, it would take a bit of disassembly and reassembly.
Before this change, the code to add the necessary tokens to the two relevant stacks
were:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BlockQuoteStackToken&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;container_level_tokens&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;BlockQuoteMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adjusted_position_marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Two different tokens and two different stacks, with nothing between them.  With this new
functionality in place, that code needed some slight changes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;new_markdown_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BlockQuoteMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adjusted_position_marker&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;container_level_tokens&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_markdown_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;BlockQuoteStackToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_markdown_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of two distinct tokens, there was now a stack token that included a reference
to the Markdown token that it represented.  &lt;/p&gt;
&lt;p&gt;With that field properly initialized, the &lt;code&gt;add_leading_spaces&lt;/code&gt; function was then added
to make use of that new field.  It is
a simple function that adds any extracted text (usually whitespace) to its
field, separating any new text from the existing text using a newline character.
The function itself is very boring.  The interesting part about the function would be in
locating where that function needed to be called from and using it properly.&lt;/p&gt;
&lt;h3 id="the-first-one-is-almost-always-easy"&gt;The First One Is Almost Always Easy&lt;a class="headerlink" href="#the-first-one-is-almost-always-easy" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first location was obvious: within the &lt;code&gt;__handle_block_quote_section&lt;/code&gt; function
of the &lt;code&gt;BlockQuoteProcessor&lt;/code&gt; class.  This is where the bulk of the processing of
Bulk Quote elements and their effects go through.  In there is an easy to find block of
code that records the number of characters removed and resets the string to exclude
those characters:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;line_to_parse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
            &lt;span class="n"&gt;removed_chars_at_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That block of code was slightly modified to record that removed text and place it into
its own variable:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;removed_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;LOGGER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;line_to_parse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
            &lt;span class="n"&gt;removed_chars_at_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the removed text in hand, the code just needed to know which token to associate the
removed text with. As the code processes Block Quote elements, it was reasonable to
assume that the most relevant Block Quote stack token is the last one on the stack.
That stack token was easily found with a simple for loop:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;found_stack_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;stack_index&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="o"&gt;...&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stack_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_block_quote&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;found_stack_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stack_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the extracted text and the ‘top’ stack token, the only thing that was left to
do was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;found_stack_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matching_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_leading_spaces&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;removed_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Almost right away, I was off to a good start on extracting the leading spaces for the
Block Quote token and storing them.&lt;/p&gt;
&lt;h3 id="locating-the-next-issue"&gt;Locating the Next Issue&lt;a class="headerlink" href="#locating-the-next-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After those changes were in place, I ran the scenario tests again, seeing almost every
test that has a Block Quote token fail.  My heart dropped.  But after a second, I
realized that I wanted that to happen.  As I wanted to make sure each Block Quote token
was verified, I added the leading space data to the end of the string for the
&lt;code&gt;BlockQuoteMarkdownToken&lt;/code&gt; class, separated from the rest with the &lt;code&gt;:&lt;/code&gt; character.  If
things worked properly, that meant every Block Quote token would, at the very least,
now include an extra &lt;code&gt;:&lt;/code&gt; character.  Every serialized Block Quote token was now “wrong”,
so every Block Quote scenario test should fail.  Good!&lt;/p&gt;
&lt;p&gt;Working through each case was decently fast, with a solid methodical process in place:
look at
the results, find the next failing test, and manually determine what change needed to
be made to the Block Quote token.  After making that change to the test data, I would
then re-run that specific scenario test, and check for token differences.&lt;/p&gt;
&lt;p&gt;It was by using this process that I found the next issue: missing leading whitespace.
In some cases, the leading text that was extracted was preceded by one of more
whitespaces. Those whitespaces were stuffed into the &lt;code&gt;extracted_whitespace&lt;/code&gt; variable
and then ignored after that.  The resolution to that issue was
simple.  Instead of only adding the leading space to the &lt;code&gt;removed_text&lt;/code&gt; variable,
the contents of that &lt;code&gt;extracted_whitespace&lt;/code&gt; needed to be added to the variable, as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;removed_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running the tests again, a new block of tests started passing.&lt;/p&gt;
&lt;h3 id="and-next-blank-lines"&gt;And Next… Blank Lines&lt;a class="headerlink" href="#and-next-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As more and more of the Block Quote scenario tests were changed and started passing,
there were a handful of tests that were failing that I left for later.  When I got
to the end of those tests, I went back and started to look at those failing tests
one-by-one.&lt;/p&gt;
&lt;p&gt;The first group of failures that I examined were ones in which there was a Blank
Line element contained within a Block Quote. A good example of this is
&lt;a href="https://github.github.com/gfm/#example-222"&gt;example 222&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In these cases, the parsing was
correct, but the newly added &lt;code&gt;add_leading_spaces&lt;/code&gt; function was not being called.  The
outcome
was that the number of newlines contained within the owning Block Quote token did
not match the number of lines within the Block Quote element itself.  To ensure
that those two values lined up, the &lt;code&gt;add_leading_spaces&lt;/code&gt; function was called with
an empty string, thereby evening up those values.&lt;/p&gt;
&lt;p&gt;Running the scenario tests again, all the scenario tests explicitly for Block Quotes
were passing.  I then ran the scenario tests again, checking to make sure that the
scenario tests with Block Quotes and Blank Lines passed. While the new changes were
now passing, there were still a handful of tests to work on.&lt;/p&gt;
&lt;h3 id="and-finally-html-blocks"&gt;And Finally, HTML Blocks&lt;a class="headerlink" href="#and-finally-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having run the scenario tests again, the only tests that were not passing were
scenario tests that included Block Quotes and HTML blocks.  Doing some research into
the issue, I quickly found
that it looked like the same issue with the Blank Line elements, just with HTML blocks.
This issue was uncovered through one of my additional tests, “cov_2” used to increase
coverage on the various forms of HTML start and end tags:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/hrx&lt;/span&gt;
&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x-table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like the previous issue with Blank Line tokens, the number of new lines were not lining
up between the two sources.  Once again, calling the &lt;code&gt;add_leading_spaces&lt;/code&gt; function
with an empty string in these cases solved the issue.&lt;/p&gt;
&lt;h3 id="closing-out-the-token-changes"&gt;Closing Out the Token Changes&lt;a class="headerlink" href="#closing-out-the-token-changes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After those changes has been completed, it was obvious that all the scenario tests were
passing.  Just to be sure, I manually went through each of the scenarios and verified
the newly changed tokens.  As I have said before, maybe I am paranoid, but if I was
depending on those results, I figured an extra pass or two would not hurt.&lt;/p&gt;
&lt;p&gt;It just felt good to get these changes completed.  I had a high degree of confidence
that I was able to find most of these issues, but an even higher degree of confidence
that the remaining work would flush out anything that I missed.  It was with those
positive thoughts in my head that I started working on the consistency checks.&lt;/p&gt;
&lt;h2 id="validating-the-line-numbers-and-column-numbers"&gt;Validating the Line Numbers and Column Numbers&lt;a class="headerlink" href="#validating-the-line-numbers-and-column-numbers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With that confidence, I started working on the consistency checks for line numbers
and column numbers.  The first step in doing this was removing a couple of lines
of code that prevented the consistency checks from firing if one of the tokens was
a Block Quote token.  It was useful when I did not have anything in place, but now
it would just get in the way.&lt;/p&gt;
&lt;p&gt;After that change, tests predictably started failing, but I was ready for them.  From
the work
that I had just completed, I figured that I would have to follow a similar path in
implementing the consistency check.  Therefore, the first thing I did to help with
the consistency check is to reset the &lt;code&gt;leading_text_index&lt;/code&gt; field of the
&lt;code&gt;BlockQuoteMarkdownToken&lt;/code&gt; instance to 0 when it is encountered.  This made sure that
the tracking of the leading spaces would always start with the first entry.&lt;/p&gt;
&lt;p&gt;With that done, the code needed to take advantage of that was easy to write.
When a token exists on a new line, it’s indent must be determined by tracking the
size of the removed text and adding that measurement to the column number.  Based
on the previous work, this becomes trivially easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;split_leading_spaces&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leading_spaces&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;init_ws&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_leading_spaces&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leading_text_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, grab the top Block Quote token, split it into lines, and use the
&lt;code&gt;leading_text_index&lt;/code&gt; value of that topmost token to grab the right leading space.&lt;/p&gt;
&lt;p&gt;From there, the new work mirrored the work that I did in preparing the tokens.  When a
Blank Line token is encountered, that index is incremented.  For each line of
text within an HTML block, that index is incremented.  And in addition, that
&lt;code&gt;leading_text_index&lt;/code&gt; field needed to be tweaked at the end of HTML blocks,
Atx Heading blocks, and Paragraph blocks, which was something I figured might
come up.  Just some simple cases where a bit of extra finessing was needed.&lt;/p&gt;
&lt;p&gt;To be clear, I was not 100% percent sure that this would happen, but I was hoping that
it would.  To me it made sense that if I needed to add code to track the leading
spaces that were removed, any consistency check would need to follow that same path
to verify the information.  And as to the extra tweak for the end tokens, I was
confident that it was a solid change, and was not worried about that deviation from
the previous work.&lt;/p&gt;
&lt;h2 id="writing-the-block-quote-markdown-transformations"&gt;Writing the Block Quote Markdown Transformations&lt;a class="headerlink" href="#writing-the-block-quote-markdown-transformations" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given the work I had just completed to get to this point, it was obvious to me that
I was going to have to do a lot of fiddling with spaces to get the transformations
correct.  To make that job a bit easier, I decided for the moment to eliminate any
Markdown documents which contained both Block Quote elements and List elements.
I would get back to these quickly, but at that moment, it was just too much.&lt;/p&gt;
&lt;p&gt;The processing of the start and end of the Block Quote elements were simple,
largely mimicking the work I did for the List elements.  When a Block Quote token
was processed, it created a copy of itself and added that copy to the top of the
&lt;code&gt;container_token_stack&lt;/code&gt; list.  From there, the leading space were retrieved from
their storage in the token and added to the sequence to be emitted.  The end
of the Block Quote element was even easier, returning an empty string after removing
the top token off the &lt;code&gt;container_token_stack&lt;/code&gt; list.  The work I had previously done
on setting up the leading spaces was really paying off.&lt;/p&gt;
&lt;p&gt;With the work to recognize and process the actual tokens taken care of, the main
task ahead of me was to add and populate the &lt;code&gt;__perform_container_post_processing_block_quote&lt;/code&gt; function.  Like how List
Block tokens were handled in the
&lt;code&gt;__perform_container_post_processing_lists&lt;/code&gt; function, this new function was used
to handle the newline processing for text enclosed within Block Quote elements.
After having completed all this other work, that work was relatively simple to do.
With all the individual token processing already
performed, this function just needed to focus on detecting newline characters.
For each of these characters encountered, the top Block Quote token would be
used to determine the current &lt;code&gt;leading_text_index&lt;/code&gt; to start with.  With each
newline encountered, the current split value would be used, incrementing the
&lt;code&gt;leading_text_index&lt;/code&gt; value afterwards.  This pretty much worked flawlessly out
of the box.&lt;/p&gt;
&lt;h3 id="as-i-was-cleaning-up"&gt;As I was cleaning up&lt;a class="headerlink" href="#as-i-was-cleaning-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;An interesting issue came up as I was generating these transformations.
For some reason, I had missed some cases involving Block Quote elements that
contained Fenced Code Block elements.  With the Markdown transformer now rehydrating
the Markdown, it was obvious that things were missing.  It did not take me long to
figure out that the Fenced Code Blocks were missing their Block Quote leading
characters.  This was found for
&lt;a href="https://github.github.com/gfm/#example-98"&gt;example 98&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;aaa&lt;/span&gt;

&lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the transformer tried to rehydrate the document, it rehydrated that Markdown
text without the leading &lt;code&gt;&amp;gt;&lt;/code&gt; sequence before the text &lt;code&gt;aaa&lt;/code&gt;.  Having just gone
through that research for other elements, I was quick to spot it and realize where
the issue was.  A couple of quick changes, and that change was passing!&lt;/p&gt;
&lt;h3 id="along-the-way"&gt;Along the Way&lt;a class="headerlink" href="#along-the-way" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;And to hammer home the point that this consistency checking is good, it found some
issues along the way.&lt;/p&gt;
&lt;p&gt;The first one was an interesting issue where the starting whitespace for one
transformation was missing.  And it was such a weird case.  It was an Atx Heading
element that contained a Shortcut Link element as its only text, separated from the Atx
Heading character ( &lt;code&gt;#&lt;/code&gt; ) by the mandatory single space. That is really important.  Two
space it was okay with, but the one space, nope! Due to the way that
it was parsed, that spaces were missing and not accounted for.  The fix to this was
to add that starting whitespace as a new token containing that removed text, but with
a twist.  That twist was to use the &lt;code&gt;create_replace_with_nothing_marker&lt;/code&gt; function to
add that text as itself for the Markdown transformer, but keep it as removed for the
HTML transformer.  With both transformers appeased, it was on to the next issue.&lt;/p&gt;
&lt;p&gt;The second issue that I uncovered was that, in rare cases, the leading spaces for
certain lines were missing.  After doing some digging, it only appeared to be lines
that did not have any block quote prefix characters removed from the line.  So
after adding a new &lt;code&gt;__adjust_paragraph_for_block_quotes&lt;/code&gt; function to the
&lt;code&gt;LeafBlockProcessor&lt;/code&gt; and wiring it into the &lt;code&gt;parse_paragraph&lt;/code&gt; function, the debug
confirmed that it was only those few cases where that was an issue.&lt;/p&gt;
&lt;h2 id="and-of-course-some-cleanup"&gt;And Of Course, Some Cleanup&lt;a class="headerlink" href="#and-of-course-some-cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It would not be a proper week of coding if I did not do some cleanup.  In this case,
the cleanup was simple: relocating the line/column number logic to its own
module.  One of the things that made the Markdown transformations easy to deal with
is that those transformations are in their own &lt;code&gt;TransformToMarkdown&lt;/code&gt; class.
That worked well.  The
line/column number checks were in with some other validation code in the &lt;code&gt;utils.py&lt;/code&gt;
module.  That worked… well… okay?&lt;/p&gt;
&lt;p&gt;When I started with the consistency checks, they were new, and keeping all that code
in the &lt;code&gt;utils.py&lt;/code&gt; module made sense.  But as the amount of code in the module grew, I
never took the time to to some refactoring.  As such, the module developed two
responsibilities. The first was to be the location for all the &lt;code&gt;assert_*&lt;/code&gt; functions
and the &lt;code&gt;write_temporary_configuration&lt;/code&gt; functions.  Those are all the functions that are
called directly from the tests, mostly in the final Assert stage of the test.  The
second was to house the logic for the line/column number consistency checks.&lt;/p&gt;
&lt;p&gt;It just seemed logical, now that that part of the code was stable and well-tested, to
take that second responsibility and put it into its own module. I created the
&lt;code&gt;verify_line_and_column_numbers.py&lt;/code&gt; module and started moving the functions into it,
with the &lt;code&gt;verify_line_and_column_numbers&lt;/code&gt; function being the main entry point for
the module.  It just seemed cleaner and more compact.  One module, one responsibility.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The dominant part of my experience at the current moment is one of humility and
patience.  Yes, it is Tuesday night. And after a little over 3 hours of extra work,
I have finally recovered the article to where it was at this time last night. I
do feel an impulse to be hard on myself about this delay, but I also am working
hard to remember to be patient with myself.  This is one time where I am missing a
deadline, and it probably will not be the last.&lt;/p&gt;
&lt;p&gt;The humility that I am trying to practice is in understanding that I cannot do
everything all the time.  I know that sounds like it should be an obvious thing to
know, but I think we all forget it from time to time.  I was so focused on making
sure that I met my deadline, that I neglected to have a conversation with myself
on whether that was the right choice.  But it was not a large rabbit hole,
just a small one that I was able to easily recover from.&lt;/p&gt;
&lt;p&gt;Focusing more on the actual work that I accomplished, I was buoyed.  I was long
worried about how hard it would be to implement the consistency checks for Block
Quote tokens.  Having completed that work, I now am trying to figure out why I was
worried.  Trying to figure it out now, I would guess I would focus on what it took
to complete that work with lists.  That work was very nitpicky because it contained a
lot of “empty” whitespace, if I am remembering it clearly.  From the effort that it
took to deal with that, I can see how I might have thought it would have taken the same
effort for Block Quote tokens.&lt;/p&gt;
&lt;p&gt;But it did not.  The work I had done in that area on List tokens forced me to get things
set up to make List token processing easier, which I believe Block Quotes benefited
from.  Regardless, I was glad that I could close the books on the Block Quote tokens
and their consistency checks.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With all the block token consistency checks now taken care of, there was a bit of clean
up to do with determining the height of each block token.  While I initially thought
that it would be easy, it did not turn out that way.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Lists to the Markdown Transformer</title><link href="https://jackdewinter.github.io/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/" rel="alternate"></link><published>2020-08-17T00:00:00-07:00</published><updated>2020-08-17T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-17:/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I increased the coverage provided by the token to Markdown transformer by adding
support for the link related tokens. In this article, I take another large step
towards completing the consistency checks by adding support for list related tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having implemented the link related …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I increased the coverage provided by the token to Markdown transformer by adding
support for the link related tokens. In this article, I take another large step
towards completing the consistency checks by adding support for list related tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having implemented the link related tokens, I was now down to one large group:
the container related tokens.  Even with the confidence I gained from the work that
I performed with link related tokens, I felt that “container related tokens” was
too large of a group for me to be comfortable working with.  Given that the container
related tokens group contained only 2 types of tokens, it only seemed natural to focus
on one of those two tokens: the list tokens.  More specifically, I was going to
start with the Unordered List tokens.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/6f7fa825b3cd6bad52cd5b9772a0f35dc816b629"&gt;04 Aug 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/07d6f81c6c6b46c3ae9c526a3d176d65ddf06c54"&gt;08 Aug 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-with-unordered-lists"&gt;Starting with Unordered Lists&lt;a class="headerlink" href="#starting-with-unordered-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a wander through the scenario tests with unordered lists in their examples,
two things were clear to me.  The first thing is that with few exceptions, they were all
working well from the point of view of existing consistency checks.  Those few examples
were 1 case with nested links and 4 cases which mixed up block quotes with list.
Those examples are
&lt;a href="https://github.github.com/gfm/#example-528"&gt;example 528&lt;/a&gt;,
&lt;a href="https://github.github.com/gfm/#example-237"&gt;example 237&lt;/a&gt;,
&lt;a href="https://github.github.com/gfm/#example-238"&gt;example 238&lt;/a&gt;,
&lt;a href="https://github.github.com/gfm/#example-270"&gt;example 270&lt;/a&gt;, and
&lt;a href="https://github.github.com/gfm/#example-271"&gt;example 271&lt;/a&gt;.
The second thing that was clear was that because of the first
point, I had a high degree of confidence that I was going to be addressing issues that
almost exclusively focused on whitespace.  With the HTML output already being verified,
I was certain that properly transforming Unordered List tokens back into list Markdown
would mostly boil down to whitespaces.&lt;/p&gt;
&lt;h3 id="thinking-about-the-design"&gt;Thinking About the Design&lt;a class="headerlink" href="#thinking-about-the-design" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Before I leapt into the coding, I sat back and thought long and hard about the approach
I was going to take with the transformation of these tokens.  When I started sketching
out what my approach would be, I started to understand that there would be two issues
I would have to deal with.  They were the transformation of the tokens themselves, and
the whitespace they would inject before other tokens.  The first part was the easy
part: see
an unordered list token, use the elements in the token to figure out its transformed
form, and emit that transformed form.  Done.&lt;/p&gt;
&lt;p&gt;Managing the whitespace was going to be a lot more difficult.  The thing that helped
me was that I knew I already had experience with handling that initial whitespace from
writing the main parser.  What helped me immeasurably in the
parser was to keep the processing of the two container elements, lists and block
quotes, separate from the processing of the leaf tokens.  By only passing “container
element free” text to the
leaf token processor, that processor was kept simple.  To keep the container handling
for the Markdown transformer simple, I decided that employing the same approach was
pivotal.&lt;/p&gt;
&lt;p&gt;But even with the decision to keep that processing separate, I figured that it would
only get me
part of the way there.  To complete the management of the whitespaces, I would need to
be able to calculate the whitespace used before each line contained within a list block.
The more I looked at the problems to be solved, the more I was sure that most of my
time was going to be managing that initial whitespace.&lt;/p&gt;
&lt;p&gt;It was not going to be fun getting the transformations done for the Unordered List
tokens, but I had a feeling that it would be really satisfying when it was done!&lt;/p&gt;
&lt;h3 id="and-go"&gt;And… Go!&lt;a class="headerlink" href="#and-go" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I began this block of work with the moving of the if statement that avoided processing
any scenario test that included block quotes or lists starts.  Before that move, it
was buried in a large collection of if statements, and I wanted to make sure I called
it out until it was fixed. Making it even better, when I moved it, I broke that single
statement into three explicit statements. As I knew I was going to be enabling
each one in the next week or so, being explicit about that work just seemed like the
right thing to do.  But even though the move was mostly for aesthetics, I confess
that it was also to remind me that I only had those tokens left to go.&lt;/p&gt;
&lt;p&gt;Once that was completed, I did the easy work first and added the
&lt;code&gt;rehydrate_unordered_list_start&lt;/code&gt; function and the &lt;code&gt;rehydrate_unordered_list_start_end&lt;/code&gt;
function to the main processing loop.  After running the scenario tests again, I
was reminded by the test output that the &lt;code&gt;rehydrate_next_list_item&lt;/code&gt; function would have
to be added to deal with the Next List Item tokens in the stream.  Another quick run of
the tests and a lot of comparison failures, but no missing token failures.  A good
step in the right direction!&lt;/p&gt;
&lt;h3 id="first-step-list-indentation"&gt;First Step: List Indentation&lt;a class="headerlink" href="#first-step-list-indentation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the actual token handlers dealt with, it was time to focus on the effects that
those tokens had
on the leaf blocks.  Following my usual pattern, instead of immediately creating a
new function to specifically handle the lists, I kept that code inline with the
existing &lt;code&gt;transform&lt;/code&gt; method the Markdown transformer.  While I recognize that it
looks messy and sloppy and the outset, it helps me think more clearly without worrying
about that I need to pass where.&lt;/p&gt;
&lt;p&gt;Therefore, following my usual pattern, I first added a simple post-processing step that
took the
contents of the variable &lt;code&gt;continue_seq&lt;/code&gt; and applied them to start of the output of
specific tokens.  The &lt;code&gt;continue_seq&lt;/code&gt; variable was initialized with an empty string,
but I altered the &lt;code&gt;rehydrate_unordered_list_start&lt;/code&gt; function to reset this variable
to the amount of indent specified by the list.  With the change in place, the end
of the loop processing was simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;new_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;continue_seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This gained some traction in getting the
scenario tests passing, but that processing needed to be made a bit more complicated.  &lt;/p&gt;
&lt;p&gt;The first complication that needed to be addressed was that both list starts, and list
ends modified the &lt;code&gt;continue_seq&lt;/code&gt; variable, but needed to avoid applying it to
the line on which they element resided.  This was because the processing of the
Unordered List start token
already had the required indenting taking care of, so the postprocessing would just
add extra “garbage” whitespace. To remedy this, I added the &lt;code&gt;skip_merge&lt;/code&gt; variable to
allow the Unordered
List token handlers to inform the main loop to skip any post-processing.&lt;/p&gt;
&lt;p&gt;The second complication was the handling the list terminations using the
&lt;code&gt;rehydrate_unordered_list_start_end&lt;/code&gt; function.  In some of the easy cases, what was
there was fine, but as soon a list was nested in another list, that processing fell
apart.  What was missing was a recalculation of the indent level once the prior list
ends.  That was quickly addressed by doing a recalculation of the contents for the
&lt;code&gt;continue_seq&lt;/code&gt; variable for the new list token at the top of the stack.&lt;/p&gt;
&lt;p&gt;With those easy fixes, and with the main replacement call in the main loop, a lot
of the scenario tests were passing, while keeping the processing simple.&lt;/p&gt;
&lt;p&gt;That simplicity would soon change.&lt;/p&gt;
&lt;h3 id="indented-code-blocks"&gt;Indented Code Blocks&lt;a class="headerlink" href="#indented-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I went through the test failures, there were a few failures that stood out as an odd
grouping: indented code blocks and lists.  Doing some more research, I found out
that due to a bug in my code, the indented code blocks were not being checked
properly.  It only involved one list item scenario test, but nonetheless,
it still needed to be fixed.&lt;/p&gt;
&lt;p&gt;In that newly found bug, the problem was that the indented code blocks were always
adding their indented padding at the beginning of the lines.  This was not usually a
problem, but with any examples that contained blank lines within the indented code
block, it was an issue.  A good example of this is
&lt;a href="https://github.github.com/gfm/#example-81"&gt;example 81&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;chunk1&lt;/span&gt;

    &lt;span class="n"&gt;chunk2&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;chunk3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the parser tokenizes this example, the Blank Line tokens that are generated
already include any whitespace that is present on that line.  Taking care of their own
whitespace data, when the Markdown transformer interprets those Blank Line tokens,
it needs to accept those Blank Line elements as they are.
Modifications were needed to enforce this behavior.  The &lt;code&gt;combine&lt;/code&gt; function of the
&lt;code&gt;TextMarkdownToken&lt;/code&gt; class containing the indented blank line was changed to insert
a NOOP character and then a newline character.  As text used in an indented code
block was the only &lt;code&gt;paragraph-like&lt;/code&gt; encapsulating token that inserted a blank line
into the composed text, had confidence this was isolated.&lt;/p&gt;
&lt;p&gt;With those NOOP characters in place, the Markdown transformer needed some modifications
to
understand how to deal with this.  Before proceeding with the normal insertion of
any whitespace in the &lt;code&gt;continue_seq&lt;/code&gt; variable, a quick check was made to see if
the &lt;code&gt;new_data&lt;/code&gt; variable contained a NOOP character.  If so, the string in the
&lt;code&gt;new_data&lt;/code&gt; variable was split and processed.  For each element in the split list,
the element was checked to see if it started with a NOOP character.  If it did it
simply removed the NOOP character by setting the &lt;code&gt;replacement_data&lt;/code&gt; variable to
the contents of the &lt;code&gt;new_data&lt;/code&gt; variable after that first NOOP character.  If it did not
find it, it set the &lt;code&gt;replacement_data&lt;/code&gt; variable to the contents of the &lt;code&gt;continue_seq&lt;/code&gt;
variable plus the contents of the &lt;code&gt;new_data&lt;/code&gt; variable.  Once that was done, the value
was put back in into the array at the same index.  Then,
when the processing was done, it reconstituted the &lt;code&gt;new_data&lt;/code&gt; variable by joining the
elements of the list back together using the &lt;code&gt;\n&lt;/code&gt; character as a joining character.&lt;/p&gt;
&lt;p&gt;While I was not looking for that, I was glad I found it. A bit embarrassed that I
did not find it right away, but I did find it!&lt;/p&gt;
&lt;h3 id="handling-lazy-continuations-lines"&gt;Handling Lazy Continuations Lines&lt;a class="headerlink" href="#handling-lazy-continuations-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With most of the scenario tests now passing, my focus was centered on a set of tests
that dealt with lists and lazy handling.  While this took me a bit to get my head
around, it basically says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a string of lines Ls constitute a list item with contents Bs, then the result of deleting some or all the indentation from one or more lines in which the next non-whitespace character after the indentation is paragraph continuation text is a list item with the same contents and attributes. The unindented lines are called lazy continuation lines.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Huh?  Let me translate:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you have a list already started, and you encounter lines that should be in the list except for the fact that they are not indented properly, they are lazy continuation lines, and are included.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The best way to explain is with an example:&lt;sup id="fnref:lazyList"&gt;&lt;a class="footnote-ref" href="#fn:lazyList"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;first&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;item&lt;/span&gt;
&lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;first&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;item&lt;/span&gt;
 &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;first&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;item&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In that example, all three of those lines are considered part of the list item, even
though the line is indented less than the indent of 2 specified by the initial list
item element.  But that presented a bit of a problem.&lt;/p&gt;
&lt;p&gt;When parsing the Markdown document, the indent level was being tracked, and any
additional whitespace was added to the contained token.  But as I was writing the
Markdown transformer, I noticed that I had missed the case where the amount of indent
was less than the current list’s indent level.  This was not an issue with the HTML
transformer, as that transformer does not rely on any of the extracted whitespace.
However, the Markdown transformer does.&lt;/p&gt;
&lt;p&gt;To fix this issue, I needed to first make a change in the &lt;code&gt;parse_paragraph&lt;/code&gt; function of
the &lt;code&gt;LeafBlockProcessor&lt;/code&gt; class.  In that function, I reconstituted the actual indent
of the given line and compared it against the indent level from the dominant unordered
list item token.  If that actual indent level was less than the dominant indent level,
I adjusted the actual whitespace by prefacing that whitespace with…well… blech
characters.&lt;/p&gt;
&lt;p&gt;Yes, blech characters.  Blech, according to
&lt;a href="https://www.merriam-webster.com/dictionary/blech"&gt;Webster’s&lt;/a&gt; means “used to express
disgust”.  While I knew I had to track those indenting characters somehow, I really
was not happy with it.  Disgust may be a bit too intense of an emotion, but when I
figured out what I had to do, that was the most printable word that I uttered.&lt;/p&gt;
&lt;p&gt;Using the above example, the tokenized text looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- first list item{newline}
{blech}{blech}next line of first list item{newline}
{blech}next next line of first list item{newline}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this way, the indent was properly represented in the token, and the Markdown
transformer had enough information to rehydrate the data afterwards.  With those
changes locked into the tokens, the Markdown transformer was then able to be
changed to understand those tokens.  That processing was simple.  If a line of
the text output started with a blech character, those blech characters were
replaced with a space character.  If no blech characters were there, the normal
replacement of the newline character would occur.&lt;/p&gt;
&lt;p&gt;And I could
have changed the name of the character from “blech character”, but after a while,
it just kind of stuck with me.&lt;/p&gt;
&lt;h3 id="new-list-item-tokens"&gt;New List Item Tokens&lt;a class="headerlink" href="#new-list-item-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It was about this time when I decided to tackle the New List Item tokens.  While I had
been working around them somewhat, it was starting to get to the point where they were
unavoidable.  At first, I did not think these tokens would be an issue, but I forgot
about one little part of the New List Item tokens: they reset the indent for the
list.&lt;/p&gt;
&lt;p&gt;A good example of this is &lt;a href="https://github.github.com/gfm/#example-290"&gt;example 290&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, the first line starts a list and each line after that starts a new list
item.  As the new list items are gradually increasing and then decreasing the indent,
the 3 middle lines (&lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt;) are interpreted as a new list item element,
rather than a sublist.  If it was not for the new list item elements resetting that
indent, those 3 lines are indented to the point where their indent would make them
eligible to start a new sublist.&lt;/p&gt;
&lt;p&gt;But to properly track this indent change, it required some interesting thinking.  If
I tracked the indent change in the actual token, it would mean changing that token.
To me, that was a non-starter.  Instead, I added a separate stack for container tokens
in the Markdown transformer and added copies of the container tokens to this stack.
As I added copies of the tokens to the stack, I was free to change the indent value
located within the Unordered List token without worrying about side effects.&lt;/p&gt;
&lt;p&gt;With those changes in place, the Markdown transformer was able to reset the indent
level and make sure it was being properly tracked.  This meant that the indents
were able to be properly reset to the correct value once a List Item end token was
received for a sublist.&lt;/p&gt;
&lt;p&gt;Taking a bit of a deep breath and a pause, I noticed that I was close to finishing
off the Unordered List Item tokens.  That gave me a bit of a jump in my step to
clean things up!&lt;/p&gt;
&lt;h2 id="taking-care-of-stragglers"&gt;Taking Care of Stragglers&lt;a class="headerlink" href="#taking-care-of-stragglers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With all the major and minor cases of lists dealt with, I started going through
the other scenario tests, fixing up the token lists after verifying that the new
tokens were correct.  Everything else was easily resolved at this point, except for
some lists in a couple of cases.  Those cases were interesting in that there was
actually too much whitespace, not too little.  And in this case, it was a newline
character, not a space.&lt;/p&gt;
&lt;p&gt;The Fenced Code Block element and the SetExt Heading element are unique in that they
have a line-based sequence that delimits the end of the element.  Usually this is not
a problem, but in the case of interacting with lists, the transformer was inserting
a newline after the element itself, and then another newline to make the end of that
line.  While this duplication did not occur all the time, it took a bit to figure
the exact sequence that triggered this.&lt;/p&gt;
&lt;p&gt;After doing some research, it was weird to me, but it only occurred if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it was one of these two elements&lt;/li&gt;
&lt;li&gt;the new block of data ends with a newline character&lt;/li&gt;
&lt;li&gt;the next token to be processed is a New List Item token&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While the sequence of thing that had to occur was weird, the solution was easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;block_should_end_with_newline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"end-fcode-block"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;block_should_end_with_newline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
            &lt;span class="n"&gt;delayed_continue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"end-setext"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;block_should_end_with_newline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="n"&gt;block_ends_with_newline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; \
            &lt;span class="n"&gt;block_should_end_with_newline&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;new_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;block_ends_with_newline&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;next_one&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;next_one&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_new_list_item&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;new_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;continue_seq&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, if we hit that situation, just remove the excess character.  I was
hoping to refactor it into something more elegant, but it worked at the time and
I wanted to get on to the handling of Ordered List Item tokens.&lt;/p&gt;
&lt;h2 id="second-verse"&gt;Second Verse…&lt;a class="headerlink" href="#second-verse" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I fondly remember being a kid at a summer camp and hearing the words “Second verse, same
the first, a little bit louder, and a little bit worse!”.  Working on the ordered list
tokens made me think of that saying almost immediately.  Except for the fact that it
was not a little bit worse, it was a lot easier.&lt;/p&gt;
&lt;p&gt;There were two main reasons for that.  The first reason is that looking at the samples as
a group, there are objectively fewer examples with ordered lists than unordered lists.
In the
&lt;a href="https://spec.commonmark.org/0.29/#list-items"&gt;list items section&lt;/a&gt;
of the GFM specification, there are 20 of each, but in the
&lt;a href="https://spec.commonmark.org/0.29/#lists"&gt;lists section&lt;/a&gt;
of the specification, there are 20 examples of unordered lists and 7 examples of ordered
lists.  The second reason was that most of the work was either completed when working on
the unordered list token transformations, or it was used in a copy-and-paste manner.&lt;/p&gt;
&lt;p&gt;However, knowing that lists are one of the two container elements in Markdown, I took
some extra time and reverified all the scenario tests, both ordered lists and unordered
lists.  I was able to find a couple of small things that were quickly fixed, but other
than that, everything looked fine!&lt;/p&gt;
&lt;h2 id="cleanup"&gt;Cleanup&lt;a class="headerlink" href="#cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As with a lot of my free project time recently, I used some extra time that I had to
focus on a few cleanup items for the project.  While none of them was important
on its own, I just felt that the project would be cleaner with them done.&lt;/p&gt;
&lt;p&gt;The first one was an easy one, going through the HTML transformer and the Markdown
transformer, and ensuring that all the token handlers were private.  There really
was not any pressing need to do this, but it was just cleaner.  The only code that was
using those handlers was in the same class, so it was just tidier that way.&lt;/p&gt;
&lt;p&gt;Next was the creation of the &lt;code&gt;__create_link_token&lt;/code&gt; function to help tidy up the
&lt;code&gt;__handle_link_types&lt;/code&gt; function.  The &lt;code&gt;__handle_link_types&lt;/code&gt; function was already messy
enough handling the processing of the link information, the creating of the normal or
image link was just complicating things.  While I still want to go back and clean
functions like that up, for the time, moving the creation code to &lt;code&gt;__create_link_token&lt;/code&gt;
was a good step.&lt;/p&gt;
&lt;p&gt;Finally, there was the case of the justification function calls throughout the code.
Not to sound like a purist, but I felt that they were messy.  I often had to remind
myself of what the three operands were: string to perform on, the justification amount,
and the character to use for the justification.  The actual use of the function was
correct, it just felt like its usage was not clear.  So instead of having code
like this around the code base:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;some_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rjust&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;repeat_count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;character_to_repeat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I replaced it with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;some_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;repeat_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;character_to_repeat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;repeat_count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the code for this operation was a one-line function, now located in the
&lt;code&gt;ParserHelper&lt;/code&gt; class, I felt it now made sense and was in an easy to find
place.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;repeat_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string_to_repeat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;repeat_count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Repeat the given character the specified number of times.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rjust&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;repeat_count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string_to_repeat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="fixing-example-528"&gt;“Fixing” Example 528&lt;a class="headerlink" href="#fixing-example-528" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;I do not want to spoil the surprise too much, but the fact that I have a section called
&lt;code&gt;"Fixing" Example 528&lt;/code&gt; probably gives it away.  I fixed it.  But the story is more
interesting than that.&lt;/p&gt;
&lt;p&gt;In the last article, I talked about
&lt;a href="https://github.github.com/gfm/#example-528"&gt;example 528&lt;/a&gt;
and how I was having problems getting it to
&lt;a href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/#example-528"&gt;parse properly&lt;/a&gt;.
Even having done thorough research on the example and the algorithm, I came up with
nothing.  To me, it looked like the parsing was being performed according to the
&lt;a href="(https://github.github.com/gfm/#phase-2-inline-structure)"&gt;GFM specification’s algorithm&lt;/a&gt;,
but the parsing was just off.  After yet another attempt to figure this example out
and get it working, I posted my research and a request for help to the CommonMark
&lt;a href="https://talk.commonmark.org/t/spec-algorithm-error-in-links-within-links-within-images/3571"&gt;discussion forums.&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Keeping my head down and focused on writing that week’s article, I did not notice that I
had received a reply the very next day.  As a matter of fact, while I did notice that I
had a response to my post, it was not until Friday night that it clicked that it was a
response to “THAT” post.  After getting the cleanup documented in the previous section
taken care of, I reserved some dedicated time to walk through the reply.&lt;/p&gt;
&lt;h2 id="kudos"&gt;Kudos&lt;a class="headerlink" href="#kudos" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First off, I would like to extend kudos to the replier, John MacFarlane, one of the
maintainers of the Markdown GFM specification.  While he would have been within his
right to tell me to RTFM&lt;sup id="fnref:RTFM"&gt;&lt;a class="footnote-ref" href="#fn:RTFM"&gt;2&lt;/a&gt;&lt;/sup&gt;, he took some time to walk me through the algorithm
as it applied to that example, even providing me with some debug output from his
program for that example.  His response was just a classy response with just the
right amount of information.&lt;/p&gt;
&lt;h2 id="side-by-side-comparisons"&gt;Side by Side Comparisons&lt;a class="headerlink" href="#side-by-side-comparisons" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Armed with that new information, I turned on the debug output and ran through the output
from my implementation of the algorithm again.  Slowly, with my own written notes as an
additional guide, I began to walk through the output.  &lt;code&gt;Found closer at 8&lt;/code&gt;.  Check.
&lt;code&gt;Found matching opener at 4&lt;/code&gt;. Check.  &lt;code&gt;Deactivating opener at 3&lt;/code&gt;. Check.
&lt;code&gt;Found closer at 15&lt;/code&gt;.  Check.  &lt;code&gt;Popping inactive opener at 3&lt;/code&gt;.  Ch…er… what?
“Popping”?&lt;/p&gt;
&lt;p&gt;Going back to the algorithm and the text that John provided, it hit me.  The popping that
he was referring to was this part of the algorithm:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If we do find one, but it’s not active, we remove the inactive delimiter from the stack, and return a literal text node ].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For some reason, when I read that before, I thought it was referring to removing the
token from consideration, not actually removing it from the stack.  It probably also
confused things in that I did not maintain a separate stack for the link resolution.
Instead, I added an instance of the &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token to the inline block
list whenever I hit a link sequence.  In either case, I was not doing that.  To compound
the issue, I did not stop at that inactive token, I just kept on looking for the next
active &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token, finding the image start token.  Ah… everything
was now falling into place in my mind.&lt;/p&gt;
&lt;h2 id="fixing-the-issue"&gt;Fixing the Issue&lt;a class="headerlink" href="#fixing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The fix was very anticlimactic.  I created the new
&lt;code&gt;__revert_token_to_normal_text_token&lt;/code&gt; function, which removed the
&lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token and replaced it with a normal &lt;code&gt;TextMarkdownToken&lt;/code&gt;
token.  In addition, I changed the algorithm to make sure that when this happened,
it stopped processing for that link end sequence, as per the algorithm.  With the start
character sequence now being effectively invisible to the algorithm, the rest of the
parsing went fine, with the correct results coming out.  Well, almost.  A small fix was
needed to the
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function to make it properly emit the correct text
if an instance of a &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token was encountered.&lt;/p&gt;
&lt;p&gt;With the big fix and the little fix both completed, the scenario test for Example 528
was fully enabled and fully passing.  Finally!&lt;/p&gt;
&lt;h3 id="reminder-to-self-be-humble"&gt;Reminder to Self: Be Humble&lt;a class="headerlink" href="#reminder-to-self-be-humble" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having taken a quite a few attempts at implementing the algorithm and making sure it
passed all test cases, I hit a wall. A seemingly rock-solid wall.  That was fine.
During any project, be it software or hardware, things happen.  When it got to
that point, I gave myself some time, I knuckled down&lt;sup id="fnref:knuck"&gt;&lt;a class="footnote-ref" href="#fn:knuck"&gt;3&lt;/a&gt;&lt;/sup&gt;, and I did some solid
research on the problem.  Keeping good notes, I was then able to share those notes with
peers in the community, along with a sincere and humble request for help.&lt;/p&gt;
&lt;p&gt;I do not always get a good response to requests for help.  However, I have noticed that
doing good research and presenting that research with humility increases the chance of
getting a positive response.  At no point did I rant and say, “it’s broken” or
“my way works, what is wrong with yours”.  Instead I said, “Is there something wrong
with the algorithm?” and
“Based on my implementation of that algorithm”.  By acknowledging that it could be an
issue with my implementation, I feel that I opened the doors for someone to help, rather
than slamming them shut with negative talk.&lt;/p&gt;
&lt;p&gt;And as I mentioned in the Kudos section above, mostly in what I believe was a humble
approach to asking for help, I got a real good response.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Wow… that work was intense.  For one, I was right, it was a lot of addressing issues
with whitespace and running scenario tests repeatedly.  But it was more than
that for me.  I knew I had the leaf blocks taken care of, but I was really concerned
about how difficult the implementation of the container transformations would be. If
I did it right and kept to my design, I was confident that I could keep the complexity
down, but I still figured it would be complex.&lt;/p&gt;
&lt;p&gt;I guess that led to me second guessing every line of code and getting in the way of
myself a bit.  I did prevail, but that concern or fear of damaging existing tests was
somewhat paralyzing at times.  And while the logical half of my brain was telling me
that I had plenty of tests to reinforce my completed work, the emotional half was
another story.  That is where that fear was coming from, my emotional side.  Only
when I took a moment to take another breath and focus on the tests was I able to banish
that concern for a while.&lt;/p&gt;
&lt;p&gt;And it also helped me to do a bit of self-analysis on why I was concerned.  After a lot
of thinking, I came to a simple conclusion. The closer I get closer to getting a
complete project, the more I am concerned that I have not architected and designed it
properly.  If I have done that, small changes can be accomplished with few or no
unintended side effects.  If not, encountering side effects should be frequent.
Seeing as I know I have identified some areas of the code
base that I want to refactor, I questioned whether the current state was good enough.&lt;/p&gt;
&lt;p&gt;Knowing that, it helped me figure it out for myself.  I do believe that I have
confidence with my
architecture and design, and at the same time, I believe that I can improve it.
It might seem like a dichotomy, but I am starting to think that both can be correct
at the same time.  But knowing that was the issue that was causing me concern helps
me combat it.  I am a lot less worried about it, but it is a work in progress,
much like the project.&lt;/p&gt;
&lt;p&gt;With that information in hand, I felt better.  Cautious about the next steps in getting
the checks closer to the finish line, but better! And let’s not forget about finally
closing the issue with Example 528.  That was good!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the Markdown transformer almost completed, the only tokens left that need a
transformation are the Block Quote tokens.  In addition, as the line/column number
consistency checks do not currently deal with Block Quote tokens either, I will need
to add both checks in the next block of work.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:lazyList"&gt;
&lt;p&gt;The only example 249, but ordered list. &lt;a class="footnote-backref" href="#fnref:lazyList" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:RTFM"&gt;
&lt;p&gt;Read The F&amp;amp;$#ing Manual… or I guess RTFS in this case. &lt;a class="footnote-backref" href="#fnref:RTFM" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:knuck"&gt;
&lt;p&gt;According to &lt;a href="https://www.merriam-webster.com/thesaurus/knuckle%20down"&gt;Webster’s&lt;/a&gt;: “pitch in, dig in”. &lt;a class="footnote-backref" href="#fnref:knuck" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Python Projects - Using PipEnv</title><link href="https://jackdewinter.github.io/2020/08/14/python-projects-using-pipenv/" rel="alternate"></link><published>2020-08-14T00:00:00-07:00</published><updated>2020-08-14T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-14:/2020/08/14/python-projects-using-pipenv/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With almost a year of Python development under my belt, I wanted to start talking about
the Python elements that I feel have made my development of the
&lt;a href="https://github.com/jackdewinter/pymarkdown"&gt;PyMarkdown project&lt;/a&gt;
successful.  When thinking about where to start, the first thing that came to mind was
my use of PipEnv …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With almost a year of Python development under my belt, I wanted to start talking about
the Python elements that I feel have made my development of the
&lt;a href="https://github.com/jackdewinter/pymarkdown"&gt;PyMarkdown project&lt;/a&gt;
successful.  When thinking about where to start, the first thing that came to mind was
my use of PipEnv to maintain the project environment.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I am relatively new to Python, I am an old hat at trying to maintain a cohesive
way to keep my projects usable yet portable.  From my early days in C and Pascal to my
current days in Go and Java, I have always tried to have a cohesive story around how to
package my project’s source code to be used by multiple developers.  In the end, I
found that the main goals were always the same: how do I keep a project usable by all
interested developers, while keeping the maintenance of that project to a minimum?&lt;/p&gt;
&lt;p&gt;From my point of view,
&lt;a href="https://pipenv.pypa.io/en/latest/"&gt;PipEnv&lt;/a&gt;
meets those goals for Python by solving a lot of the common issues that project
maintainers and developers have.  This in turn makes two of the harder parts of
developing programs mostly disappear: dependency management and portability.  Using the
simple command &lt;code&gt;pip install --user pipenv&lt;/code&gt; to install into any Python system, PipEnv quickly became a useful tool in my toolbox and has stayed there.
During this article, I will talk about why PipEnv keeps that position in my toolbox.&lt;/p&gt;
&lt;h2 id="quick-note"&gt;Quick Note&lt;a class="headerlink" href="#quick-note" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I realize some projects may still be on Python version 2, this article is
targeted for people developing on Python 3 and above.  More precisely, these examples
were all tested with Python 3.7.&lt;/p&gt;
&lt;h2 id="what-is-pipenv"&gt;What Is PipEnv?&lt;a class="headerlink" href="#what-is-pipenv" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the full answer can be seen at the top of the
&lt;a href="https://pipenv.pypa.io/en/latest/"&gt;PipEnv home page&lt;/a&gt;,
my summary of that answer is as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PipEnv is a Python module that cleanly manages your Python project and its dependencies, ensuring that the project can be easily rebuilt on other systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While that might seem like an easy thing to accomplish, PipEnv or tools like it are
usually only employed after a journey through other, less efficient solutions.&lt;/p&gt;
&lt;p&gt;To understand those solutions and the problems that they present, let’s start at
the beginning with dependency management.&lt;/p&gt;
&lt;h3 id="starting-with-dependencies"&gt;Starting with Dependencies&lt;a class="headerlink" href="#starting-with-dependencies" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In Python, as with most modern languages, a lot of the heavy lifting is done in
libraries.  For Python, these libraries must be installed directly into the current
instance of Python for those libraries to be visible to the Python programs.  The most
common way of installing and managing those libraries locally is to use the
&lt;a href="https://pip.pypa.io/en/stable/"&gt;&lt;code&gt;pip&lt;/code&gt;&lt;/a&gt;
tool. For example, to add the latest version of the &lt;code&gt;colorama&lt;/code&gt; library to the local
Python installation, the following command is used:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install colorama
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But that command has a problem in that it installs the specified library into the global
instance of Python.  Even addressing that problem using a user-specific variation of
that command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install --user colorama
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;that caching still takes effect for all Python programs that are run as that user.
That is a bit better, but not optimal.&lt;/p&gt;
&lt;p&gt;The big issue is that it is hard to replicate which libraries are installed for any given project without maintaining a per-project
script with many lines in it, one for each library. With multiple projects sharing the
same global cache of libraries, a clear way to enforce the libraries and versions
needed for a specific project is needed.&lt;/p&gt;
&lt;p&gt;Enter the &lt;code&gt;requirements.txt&lt;/code&gt; file.&lt;/p&gt;
&lt;h3 id="explicitly-specifying-requirements-as-code"&gt;Explicitly Specifying Requirements as Code&lt;a class="headerlink" href="#explicitly-specifying-requirements-as-code" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first step that many people take on their Python project journey is to create a
&lt;code&gt;requirements.txt&lt;/code&gt; file to hold all the library requirements for their project. The
file has a format of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;colorama=0.4.3
Pygments==2.4.2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;with each library being listed on its own line, optionally followed by the version
of the library to install. To apply these library requirements to a given Python
environment, the command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install --user -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is used.  This usage of &lt;code&gt;pip&lt;/code&gt; is used as a shortcut for having to call &lt;code&gt;pip install&lt;/code&gt;
once for every library needed in the project.  By
this point in the project process, most developers understand that nailing down a
specific version of the library being used is critical to the project’s success.  By
specifying an exact version of the library to be referenced, the &lt;code&gt;pip&lt;/code&gt; tool guarantees
that it will always reference that specific version of the library, locking down the
behavior of the library and making it predictable.&lt;/p&gt;
&lt;p&gt;While the tool usage is simple enough, there are problems with using the &lt;code&gt;pip&lt;/code&gt; tool
in this way.  The first problem is that to ensure that I have the right libraries for
my program, every time I run that program, I need to re-run that
&lt;code&gt;pip install --user -r requirements.txt&lt;/code&gt; command before I run my program.  If I do not
run that command, I risk the chance that another program has changed
the libraries on my program, either causing the program to fail or rendering its output
questionable.  Even when I created a script to run the above command and my program
together, I felt that the combination often feels slow, bothersome, and inelegant.&lt;/p&gt;
&lt;p&gt;The second problem is that of “phantom” dependencies.  For argument’s sake, let’s assume
that I am maintaining 2 projects and their dependencies.  Project A has a dependency
on Library 1 and Project B has a dependency on Library 2, with Library 1 and
Library 2 being separate libraries.  Furthermore, let’s assume that both
projects use a &lt;code&gt;requirements.txt&lt;/code&gt; file and the above &lt;code&gt;pipenv install&lt;/code&gt; method to manage
their project
dependencies.  Because of the way these files are applied, if Project B is used after
Project A, it retains access to Library 1 that was installed by Project A.  After
all, with nothing to remove Project A’s dependencies, they stay in the user’s global
cache of libraries.  This means Project B’s dependencies are not clearly defined and
may prove difficult to replicate on someone else’s machine.&lt;/p&gt;
&lt;p&gt;Given those problems, how can the project move away from using global library caches?&lt;/p&gt;
&lt;h3 id="another-step-forward-virtual-environments"&gt;Another Step Forward: Virtual Environments&lt;a class="headerlink" href="#another-step-forward-virtual-environments" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The next step forward is to use the tools accumulated so far and to add virtual
environments into that group of tools.  Installed using the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install --user virtualenv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the user can then run the following command to create a virtual environment under the
current directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virtualenv venv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This command may take some time to complete, but once it is done, there will be a local
&lt;code&gt;virtualenv&lt;/code&gt; directory that contains a completely distinct version of the Python
installation that it was created from.&lt;/p&gt;
&lt;p&gt;Even with that environment in place, there is some work to do before executing the
project’s Python program.  To use the virtual environment, the execution of an
activator script is
required to set the shell’s environment to point at the correct environment.
Located in either the
&lt;code&gt;virtualenv\Scripts&lt;/code&gt; directory (on Windows systems) or the &lt;code&gt;virtualenv\bin&lt;/code&gt; directory
(on Posix systems) are a group of scripts with the name &lt;code&gt;activate&lt;/code&gt; or matching the
pattern &lt;code&gt;activate.*&lt;/code&gt;.  Executing the correct script activates the virtual environment
for a given shell, isolating any changes to the Python environment into that
virtual environment.&lt;/p&gt;
&lt;p&gt;The usage of this tool seems beneficial so far, so what are the issues with this tool?
The
big issue for me is that you must remember to deactivate the environment before
leaving the project folder.  If you do not deactivate the environment before leaving the
project’s directories, you can be doing something else in another directory and forget
the directory that you anchored that environment to .  Without noticing it, a simple
&lt;code&gt;pip install&lt;/code&gt; command will then alter the requirements of that environment, and not of
the environment in the current directory.   This is a realistic scenario.  In my early
days of Python development, I did this numerous times!  And each time, it took a while to
figure out what I had done and how to reverse it.&lt;/p&gt;
&lt;p&gt;A smaller issue with these environments is that they are specific to the local system
but are anchored within the project.  This means that when dealing with version control
systems such as Git, the project needs to explicitly ignore the files in the project’s
&lt;code&gt;virtualenv&lt;/code&gt; directory to prevent local environment files from being committed.
However, even with that directory ignored, the project requires extra scripts as part
of its project code that specify how developers need to create the required virtual
environment.&lt;/p&gt;
&lt;p&gt;Given those issues, how do we take the best parts of &lt;code&gt;pip&lt;/code&gt; and &lt;code&gt;virtualenv&lt;/code&gt; and merge
them together?&lt;/p&gt;
&lt;h3 id="enter-pipenv"&gt;Enter PipEnv&lt;a class="headerlink" href="#enter-pipenv" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Installed using the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install --user pipenv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;PipEnv&lt;/code&gt; combines the best aspects of the previous concepts while getting rid of a fair
number of the problems.  To illustrate this, I created a sample project from scratch to
say, “Hello world!”  Setting up the project was easy.  I created a new directory,
changed my current directory to that directory, and entered the command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv --three
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It took a while for the command to complete, but upon its completion I had a directory
that contained the file &lt;code&gt;Pipfile&lt;/code&gt; and a “hidden”&lt;sup id="fnref:hidden"&gt;&lt;a class="footnote-ref" href="#fn:hidden"&gt;1&lt;/a&gt;&lt;/sup&gt; virtual environment.  To see
the location of that virtual environment, I entered the command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv --venv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and PipEnv returned the path to the virtual environment.  To be specific, it created
a virtual environment that was not in my project directory, but in my local system’s
user space. This meant that the virtual environment directory did not show up in any
scans of the project directory, meaning that I did not have to ignore that directory
by any version control systems.  That was definitely a win!&lt;/p&gt;
&lt;p&gt;From there, I decided I wanted to add a splash of color to the program, brightening up
a normally dull Hello World program.  While a simple Hello World program would look
like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Hello World!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I decided to go with using the &lt;code&gt;colorama&lt;/code&gt; library to add that color.  Installing the
&lt;code&gt;colorama&lt;/code&gt; library to the current project was easy, using the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv install colorama
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That command looked for the latest version of the &lt;code&gt;colorama&lt;/code&gt; library, installed it in
the virtual environment, updated the &lt;code&gt;Pipfile&lt;/code&gt; and generated a new &lt;code&gt;Pipfile.lock&lt;/code&gt; file.
Once that was completed, I created the file &lt;code&gt;main.py&lt;/code&gt; with the following contents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;colorama&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Fore&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Back&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Style&lt;/span&gt;

&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Hello "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Fore&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BLACK&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Back&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GREEN&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"World!"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Style&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RESET_ALL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and saved that file.  After a quick check for spelling and grammar mistakes, I executed
that program with the command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run python main.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and I was greeted with this response:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://jackdewinter.github.io/images/project-1/hello_world.png"/&gt;&lt;/p&gt;
&lt;p&gt;To be clear, with 3 commands and 3 lines of Python code, I was able to create a simple
program that referenced a library to colorize the output for my simple program and to
write a single line of text to the console.  An even bigger win for me was that I knew
that if I needed this project to be portable, I could easily bundle up the source in
the directory and recreate the project elsewhere.  Having used PipEnv for months, this
was not a theory for me, this was something that I have done in practice multiple times.&lt;/p&gt;
&lt;p&gt;But unless you have performed that action, it may be hard to appreciate.  So let’s
prove it!&lt;/p&gt;
&lt;h3 id="proving-that-the-project-really-is-portable"&gt;Proving That the Project Really Is Portable&lt;a class="headerlink" href="#proving-that-the-project-really-is-portable" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To prove that the project is portable, I created a separate directory and copied the
contents of my sample directory into that directory.  While that is not exactly what
happens when I clone a project from Git, I believe it is a close enough estimate for
the purpose of this example.  To be specific, there were only 3 files in the source
directory for my sample project, and all of them were copied over: &lt;code&gt;main.py&lt;/code&gt;,
&lt;code&gt;Pipfile&lt;/code&gt;, and &lt;code&gt;Pipfile.lock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To properly setup the project, I entered the directory and executed the command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv sync
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After a while, control returned to my shell, with the &lt;code&gt;pipenv&lt;/code&gt; output clearly detailing
that it created a new virtual environment and downloaded the needed libraries.&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://jackdewinter.github.io/images/project-1/sync.png"/&gt;&lt;/p&gt;
&lt;p&gt;From there, entering the command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run python main.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yielded the same output as the example project in the original directory.&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://jackdewinter.github.io/images/project-1/hello_world.png"/&gt; &lt;sup id="fnref:myWord"&gt;&lt;a class="footnote-ref" href="#fn:myWord"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;While the
typical project will be more complicated than this small project, the underlying
principles are the same.  If a project uses PipEnv to manage library dependencies,
the &lt;code&gt;Pipfile&lt;/code&gt; and &lt;code&gt;Pipfile.lock&lt;/code&gt; files become part of the project’s source and
allows the project’s dependencies to be replicated in another directory or on another
system.&lt;/p&gt;
&lt;p&gt;Satisfied with the portability test passing, and not wanting to be a bad consumer of
system resources, I then used the following command to remove the virtual environment
from my local machine:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv --rm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By using the &lt;code&gt;pipenv --venv&lt;/code&gt; command both before and after this command, I was
able to verify that the directory containing the virtual environment was removed from
my local system.&lt;/p&gt;
&lt;h2 id="why-do-i-like-it"&gt;Why Do I Like It?&lt;a class="headerlink" href="#why-do-i-like-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I like using PipEnv because it is simple to setup, simple to maintain, and easy to
use.  I am lazy in that I want to have the right tools at my fingertips to do the simple
and easy stuff for me.  Having to remember to activate a virtual environment when I go
into a directory and deactivate it when I leave was a headache.  There were many times
I forgot to do just that, and it caused a bit of chaos.&lt;/p&gt;
&lt;p&gt;I feel that PipEnv keeps everything I need together and keeps it in the right place
for me: the base of the project.  If I need to run a Python script from the project,
I use &lt;code&gt;pipenv run python {script-name}.py&lt;/code&gt;, a format that makes sense to me. If I need
to check the project’s dependencies, the &lt;code&gt;pipenv graph&lt;/code&gt; command is there, with an
intuitive output format. If I need to recreate the project in a new directory, the
&lt;code&gt;pipenv sync&lt;/code&gt; command is there, and completes its job properly&lt;/p&gt;
&lt;p&gt;Basically, it is a tool that I find useful and that I think makes sense.&lt;/p&gt;
&lt;h2 id="wrap-up"&gt;Wrap Up&lt;a class="headerlink" href="#wrap-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there are options out there on how to maintain Python projects, the
one that I prefer is PipEnv.  Newer options exist, such as
&lt;a href="https://python-poetry.org/"&gt;Poetry&lt;/a&gt;,
but for projects that I rely on, I want something that has been battle tested
thoroughly.&lt;/p&gt;
&lt;p&gt;I feel that PipEnv is the best option that easily meets my requirements.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:hidden"&gt;
&lt;p&gt;The directory is not hidden according to the file system.  However, from the project’s point of view, it does not appear anywhere within the bounds of the project. &lt;a class="footnote-backref" href="#fnref:hidden" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:myWord"&gt;
&lt;p&gt;You’ll have to take my word that the output was the same.  I am using the same picture for both, but that is only because the output was the same. &lt;a class="footnote-backref" href="#fnref:myWord" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="python"></category><category term="python projects"></category></entry><entry><title>Markdown Linter - Adding Links to the Markdown Transformer</title><link href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/" rel="alternate"></link><published>2020-08-10T00:00:00-07:00</published><updated>2020-08-10T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-10:/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/03/markdown-linter-improving-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I increased the coverage provided by the token to Markdown transformer by adding
support for all tokens except for container related tokens and link related tokens.
In this article, I take a large step forward towards complete consistency checks by
adding support for link related …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/03/markdown-linter-improving-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I increased the coverage provided by the token to Markdown transformer by adding
support for all tokens except for container related tokens and link related tokens.
In this article, I take a large step forward towards complete consistency checks by
adding support for link related tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Starting with a large group of tokens to implement, I was now down to two smaller
groups of tokens left to implement in the Markdown transformer: container related
tokens and link related tokens.  Before starting with the container related tokens, I
wanted to make sure that all the leaf block tokens were complete, so the link related
tokens were the solid choice for the next block of work.  But even with confidence in
that choice I was still concerned.&lt;/p&gt;
&lt;p&gt;Why was I concerned?  Because outside of container related tokens and text tokens, I
feel that link related tokens are the most used group of tokens.  While a good
argument can also be made that Atx Heading token is the most used token, I feel that
the importance of links in any document somewhat overpowers the argument for the Atx
Heading token, if only a bit. In my own writing, I believe headings are useful,
but I feel that it is the links that I add to a document that really increase the
quality of my documents to the next level.  It is possible that others may not agree
with my reasoning, but it was one of the sources of my concern.&lt;/p&gt;
&lt;p&gt;Another reason for my concern?  Links are complex.  Just on a normal link alone, I
counted at least 12
different properties that I am going to have to represent in the token to allow me to
properly rehydrate it.  And then there are the Link Reference Definitions, the only
multiline element in the base GFM document.  I hoped that I already had dealt with most
of the complexity of that token, but I knew that adding support for this group of tokens
to the Markdown transformer was going to include some serious work.&lt;/p&gt;
&lt;p&gt;Regardless of how often the link related tokens are used or how difficult I thought they would be to be implemented, they needed to be implemented.  And as the last group
of tokens before the container tokens, the time was now to work on them.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/73e7634b99bc05c2484f9ce672648170a84beb17"&gt;31 Jul 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7151ea88a180bdc4b977940e90e9db4908b13ede"&gt;31 Jul 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="where-to-start"&gt;Where to Start?&lt;a class="headerlink" href="#where-to-start" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before I started making any changes, I knew I was going to take a significant amount of
time to complete the work on links.  I also knew that all that work was not going to
just happen. To get it right, I needed to plan it out properly.&lt;/p&gt;
&lt;p&gt;I started that process by breaking down the Link tokens groups into 4 smaller groups:
Inline Links, Reference Links, Link Reference Definitions, and Image Links.  The Image
Link tokens were the first one to get prioritized into the first position, as they had
no dependencies and could set the foundations for the other groups.  Next, I looked at
the Image Link
tokens. As Image Link tokens were normal Link tokens with a couple of differences, it
made sense to me that they would go last.  By going last, the link token foundations
would be tested and stable before adding support for the Image tokens on top of that.
That just left the Link Reference Definition tokens and Reference Link tokens.&lt;/p&gt;
&lt;p&gt;The ordering between Link Reference Definition tokens and Reference Link tokens was
going to be a bit tricky, but it would be a process that I knew I could manage.  To
ensure that I could
properly test the Link Reference Definition tokens, I needed to start with a
rudimentary rehydration of the Shortcut Link token.  Once that was done, I
could complete the work for the Link Reference Definition tokens, hopefully not
hitting any difficult Shortcut Link tokens cases or other link types along the way.  At
that point, I could switch back to the Shortcut Link token scenario tests before
completing the other Link scenario tests.&lt;/p&gt;
&lt;p&gt;With research done, the relative ordering of the tasks was easy.
Start with Inline Link tokens with their lack of dependencies.  Then work on the
pair of Link Reference Definition tokens and Reference Link tokens, using the Inline
Link tokens as a foundation.  Finally, work on Image tokens using all that other work
as a solid foundation to make the changes required of the transformer.&lt;/p&gt;
&lt;p&gt;It was not a complicated plan, but it was a decent plan that I believed in.  And
with that plan in place, I started to work on Inline links!&lt;/p&gt;
&lt;h2 id="inline-links"&gt;Inline Links&lt;a class="headerlink" href="#inline-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the same way that I start all my transformer additions, like the addition of
&lt;a href="https://jackdewinter.github.io/2020/08/03/markdown-linter-improving-the-markdown-transformer/#adding-emphasis-support"&gt;emphasis support&lt;/a&gt;
in the last article, I found a
good, easy example and started with the scenario test for that example.  The needs to
pass that first scenario test,
&lt;a href="https://github.github.com/gfm/#example-493"&gt;example 493&lt;/a&gt;,
were simple.  The &lt;code&gt;LinkStartMarkdownToken&lt;/code&gt; class already had all the necessary fields,
so no changes were needed there.  I then proceeded to add the
&lt;code&gt;rehydrate_inline_link_text_from_token&lt;/code&gt; function into the transformer, containing a
simple transformation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;link_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s2"&gt;"["&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_from_blocks&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"]("&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_uri&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" &lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s2"&gt;)"&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there, each additional scenario test introduced another variation on
what an acceptable Link token was.  For example, the scenario test for
&lt;a href="https://github.github.com/gfm/#example-494"&gt;Example 494&lt;/a&gt;
introduced a link title that was not present.  That changed the transformation into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;link_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s2"&gt;"["&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_from_blocks&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"]("&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_uri&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;link_text&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;" &lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;link_text&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;"\)"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And so on, and so on.  For any readers of my articles, this is the same pattern I
have been following since I started this project: get a simple case working, then keep
on adding on little changes until the big change is complete.  This set of changes was
no different in that regard.&lt;/p&gt;
&lt;h3 id="then-why-did-i-think-it-was-difficult"&gt;Then Why Did I Think It Was Difficult?&lt;a class="headerlink" href="#then-why-did-i-think-it-was-difficult" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The daunting aspect of this group was its volume. To be able to recreate the inline link
token properly, I needed to ensure that every part of the data was properly catalogued
and stored in the token.  Doing this exercise for the Inline Link token, I came
up with the following diagram and mapping:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[foo](   &amp;lt;/my url&amp;gt;     "  a title "     )
|---|||-|||-----|||---|||--------|||---||
  |  | | |   |   |  |  |     |    |  |  |
  A  B C D   E   D  F  G     H    G  I  B
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;A - &lt;code&gt;ex_label&lt;/code&gt; and &lt;code&gt;text_from_blocks&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;extracted link label, in final and original states&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B - &lt;code&gt;self.label_type&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;the use of &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; denoting an inline link&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C - &lt;code&gt;before_link_whitespace&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;whitespace before the link starts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D - &lt;code&gt;did_use_angle_start&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;True&lt;/code&gt; indicating that this URI was encapsulated&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;E - &lt;code&gt;self.link_uri&lt;/code&gt; and &lt;code&gt;self.pre_link_uri&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;extracted link URI, in final and original states&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;F - &lt;code&gt;before_title_whitespace&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;whitespace before the title starts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G - &lt;code&gt;inline_title_bounding_character&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;character used to bound the title&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;H - &lt;code&gt;link_title&lt;/code&gt; and &lt;code&gt;pre_link_title&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;extracted link title, in final and original states&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I - &lt;code&gt;after_title_whitespace&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;whitespace after the title is completed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While this may seem overly thorough, I felt that without a complete map of the Inline
Link, any Markdown transformation would be incomplete.  Especially with so many moving
parts, I was convinced that without a solid plan, I would miss a combination or
a permutation of the test data.  &lt;/p&gt;
&lt;h3 id="how-did-those-changes-go"&gt;How Did Those Changes Go?&lt;a class="headerlink" href="#how-did-those-changes-go" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The scenario tests were not really difficult to get working properly, it was just the
sheer volume of them.  Behind each of those scenario tests were a set of Markdown
parser functions that needed to be properly exercised.  While those functions had
already been tested against their HTML output, this work was to add more information in
each token, to ensure that the data in the tokens are complete.  And that completeness
came at a cost.&lt;/p&gt;
&lt;p&gt;One of those costs was an increase in the number of results returned by functions,
such as by the &lt;code&gt;__process_inline_link_body&lt;/code&gt; function.  To accomplish the extraction
requirements of these changes, this function went from returning a tuple containing 5
variables to returning a tuple containing 10 variables.  And while that may seem
like a simple refactor to complete, I am still debating with myself on how to handle
that change.  Do I create a new class that is only used internally in this one case,
or do I throw it into an instance of the &lt;code&gt;LinkStartMarkdownToken&lt;/code&gt; class that I can pass
around more easily?  While the token data is not complete, the &lt;code&gt;LinkStartMarkdownToken&lt;/code&gt;
class has all the necessary fields, with 2 fields to spare.  Which to choose?
As I said, still thinking on that one.&lt;/p&gt;
&lt;p&gt;Another function that I want to clean up is the &lt;code&gt;rehydrate_inline_link_text_from_token&lt;/code&gt;
function.  At 57 lines, it is a bit larger than I usually like in my projects.  But in
this case, maybe it is warranted.  This function does have a single responsibility, the
rehydration of the token, and it sticks solidly to that purpose.  With the 12 fields
that it uses to rehydrate, the implementation difficulty is there.  And that
is only for the Inline Link tokens, not the other 3 types of link tokens.  They will
need implementations too.&lt;/p&gt;
&lt;p&gt;For me, the really tough part was that I needed to slog&lt;sup id="fnref:slog"&gt;&lt;a class="footnote-ref" href="#fn:slog"&gt;1&lt;/a&gt;&lt;/sup&gt; through the sheer number
of combinations presented in the examples.  Using link labels as an example,
the link label can contain normal text, backslashes, character entities and inline
tokens.  To make sure I had all these covered, I needed to make sure I had
representative scenario tests for each of these groups of combinations.  And then there
are the link URIs and link titles.  It just got to the point where I used a small
spreadsheet to keep track of things, ticking off combinations as I went… just to be
sure.&lt;/p&gt;
&lt;h2 id="reference-links-and-link-reference-definitions"&gt;Reference Links and Link Reference Definitions&lt;a class="headerlink" href="#reference-links-and-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Implementing the transformations for these two tokens was different than the other
tokens in that I had to develop the transformations in coordination with each other.
For example, I started adding support for these tokens using the scenario test for
&lt;a href="https://github.github.com/gfm/#example-161"&gt;example 161&lt;/a&gt;, which has the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As I mentioned in a previous section, to properly get this test passing, I needed to
start by implementing a bare bones version of the
&lt;a href="https://github.github.com/gfm/#shortcut-reference-link"&gt;Shortcut Reference Link&lt;/a&gt;.
After all, if I could not reference the Link Reference Definition, how could I know if
it was working properly?&lt;/p&gt;
&lt;h3 id="starting-with-simple-shortcut-links"&gt;Starting with Simple Shortcut Links&lt;a class="headerlink" href="#starting-with-simple-shortcut-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Thankfully, after looking at Link Reference Definition examples
&lt;a href="https://github.github.com/gfm/#example-161"&gt;example 161&lt;/a&gt; to
&lt;a href="https://github.github.com/gfm/#example-188"&gt;example 188&lt;/a&gt;,
the only extra link requirement in each of these tests was a Shortcut Reference
Link.  Having already written the transformer to handle Inline Link tokens, adding
code to deal with Shortcut Link tokens was almost trivial.&lt;/p&gt;
&lt;p&gt;A Shortcut Reference Link is merely an Inline Link without the inline specifier, so
modifying the &lt;code&gt;rehydrate_inline_link_text_from_token&lt;/code&gt; function to handle the extra link
type was quick and efficient.  Reusing code already in that function, I came up
with these changes within 5 minutes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"shortcut"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;link_label&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_from_blocks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;InlineHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backspace_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x08&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;link_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"["&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;link_label&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"]"&lt;/span&gt;
         &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;link_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"inline"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
         &lt;span class="o"&gt;...&lt;/span&gt;
         &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
             &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Everything looked good from the shortcut link point of view.  However, since most of
the tests that have Shortcut Links also have Link Reference Definitions to provide the
reference for those links, I needed to switch to get the Link Reference Definition
tokens done.&lt;/p&gt;
&lt;p&gt;While I was not 100% comfortable with leaving that implementation untested, I understood
that I would have to wait a while to complete the testing.  To do that, on to
Link Reference Definitions!&lt;/p&gt;
&lt;h3 id="moving-over-to-link-reference-definitions"&gt;Moving Over to Link Reference Definitions&lt;a class="headerlink" href="#moving-over-to-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With a good stab at a transformation for Shortcut Links in place, I turned my attention
to the Link Reference Definition transformation.  When I started putting the code for 
this transformation together, I was greeted by good news.&lt;/p&gt;
&lt;p&gt;The first bit of good news is that since the support for Link Reference Definition
tokens was added more recently
&lt;a href="https://jackdewinter.github.io/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/#link-reference-definitions"&gt;than the other tokens&lt;/a&gt;,
I had created that token with a better idea of what information I might need later.  As
such, all the fields that I required to properly represent a Link Reference Definition
element were already in place.  That allowed
me to implement a near-complete version of the &lt;code&gt;rehydrate_link_reference_definition&lt;/code&gt;
function after only 3 tries and 10 minutes.  That was very refreshing.&lt;/p&gt;
&lt;p&gt;The second bit of good news was that the previous work on this token had already dealt
with all the token’s complexity.  As I had a lot of issues in implementing the parser’s
support for
the Link Reference Definition element, I assumed that the rehydration of the token
would also be a lot of work.  It turned out that because of all that hard work, that
near-complete version of the &lt;code&gt;rehydrate_link_reference_definition&lt;/code&gt; function was very
simple.  I had even collected both pre-processed and post-processed versions of the
link label, link destination URI, and link title!  &lt;/p&gt;
&lt;p&gt;Now back to the other Link tokens.&lt;/p&gt;
&lt;h3 id="back-to-finishing-up-links"&gt;Back to Finishing Up Links&lt;a class="headerlink" href="#back-to-finishing-up-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With all the hard work done, finishing off the rest of the links was easier than I
had previously anticipated.  With Link Reference Definition support in place, the
scenario tests that included both Link Reference Definition elements and Shortcut
Links were executed and, with a few tweaks, passed.  Like the effort required to
support Shortcut Reference Link tokens, the support for Full Reference Link tokens and
Collapsed Reference Link tokens was added quickly.&lt;/p&gt;
&lt;p&gt;Within a couple of hours, a good percentage of the scenario tests that involved any
4 of the Link tokens were completed and passing.  The remaining tests were those
scenario tests that gave me some real issues with determining the original text.  A
good example of this was the scenario test for
&lt;a href="https://github.github.com/gfm/#example-540"&gt;example 540&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[foo [bar](/uri)][ref]&lt;/span&gt;

&lt;span class="na"&gt;[ref]: /uri&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which produces the HTML output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[foo &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;]&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;ref&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first link that gets interpreted from
that text is the Inline Link &lt;code&gt;[bar](/uri)&lt;/code&gt;.  When the &lt;code&gt;]&lt;/code&gt; character is encountered
after that link text, due to
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;the provided algorithm&lt;/a&gt;,
it is kept as a &lt;code&gt;]&lt;/code&gt; character as there is a valid link between it and its matching
opening &lt;code&gt;[&lt;/code&gt; character.  Finally, the &lt;code&gt;[ref]&lt;/code&gt; is a valid Shortcut Link, matching the
reference set up by the Link Reference Definition.&lt;/p&gt;
&lt;p&gt;Getting the correct, original text to insert into the Link tokens was a bit of an
effort.  The &lt;code&gt;__collect_text_from_blocks&lt;/code&gt; function took a bit of fiddling to make
sure that the original text that was extracted matched the actual original text.
As with other things in this project, it took a couple of tries to find something
that worked and worked well, but that time was well worth it.  A bit frustrating
at time, but worth it.&lt;/p&gt;
&lt;p&gt;Having completed adding the support for all the non-image link scenario tests, it was
time to add the image links into that mix.&lt;/p&gt;
&lt;h2 id="images"&gt;Images&lt;a class="headerlink" href="#images" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking at the
&lt;a href="https://github.github.com/gfm/#images"&gt;GFM specification for images&lt;/a&gt;,
it clearly states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The rules for this are the same as for link text, except that (a) an image description starts with ![ rather than [, and (b) an image description may contain links.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, as I stated before, the Image Link tokens get to use a lot of the work done
for the other link tokens as a foundation, with just 2 changes.  The first part of that
difference was easy to deal with in the transformer: emit the sequence &lt;code&gt;![&lt;/code&gt; instead of
the sequence &lt;code&gt;[&lt;/code&gt;.  Done.&lt;/p&gt;
&lt;p&gt;The second part of that difference was handling examples of links within image links
and image links within links.  While avoiding the scenario test for
&lt;a href="https://github.github.com/gfm/#example-528"&gt;example 528&lt;/a&gt;&lt;sup id="fnref:example528"&gt;&lt;a class="footnote-ref" href="#fn:example528"&gt;2&lt;/a&gt;&lt;/sup&gt;, there were plenty of
other cases such as
&lt;a href="https://github.github.com/gfm/#example-525"&gt;example 525&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;![moon&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;moon&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jpg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and &lt;a href="https://github.github.com/gfm/#example-583"&gt;example 583&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo [bar&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;that I needed to deal with.  The actual parsing of those images and their transformation
to HTML were already tested and working. It was just the extraction of the original
text that gave me issues.  However, having dealt with similar examples in the previous
changes for the &lt;code&gt;__collect_text_from_blocks&lt;/code&gt; function, I was able to finish up those
cases quickly.&lt;/p&gt;
&lt;p&gt;The good part about getting to the end of this work took a bit to sink in.  I had
budgeted and entire week to complete these changes.  But even after making
sure the commit was clean, it was early on Saturday morning.  It was Saturday morning
and the link token group was completed.  Well, almost completed.  More on example 528
later.  But it was good enough to mark this block of work done and complete.  With some
extra time left in my schedule, I decided to put it to good use.&lt;/p&gt;
&lt;h2 id="code-coverage"&gt;Code Coverage&lt;a class="headerlink" href="#code-coverage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first good use that I put that extra time to was improving code coverage.  While
there were only 3 cases where I needed to tighten up the code coverage, it was just
something I wanted to make sure got done.  It is true that I almost always argue that
the scenario
coverage metric is more important than the code coverage metric.  But with the code
coverage percentage in the high 99’s, I just wanted to nail this down while the required
changes would be small and manageable.&lt;/p&gt;
&lt;h2 id="moving-special-character-support"&gt;Moving Special Character Support&lt;a class="headerlink" href="#moving-special-character-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The second good use for my extra time was to move the special character support in the
parser into the &lt;code&gt;ParserHelper&lt;/code&gt; class.  Along the way, adding proper support for the
Markdown transformer was accomplished using a
small set of special characters.  These special characters allowed the normal processing
of the tokens by the HTML transformer to generate the proper HTML output, while at the
same time allowing the Markdown transformer to rehydrate the token into its original
Markdown.&lt;/p&gt;
&lt;p&gt;With the use of the characters scattered around the project’s code base, I felt it was
useful to centralize the usage of those characters into the &lt;code&gt;ParserHelper&lt;/code&gt; class.
To complete that centralization, I also introduced a number of functions that either
resolved the characters (for HTML) or removed the characters (for Markdown).&lt;sup id="fnref:better"&gt;&lt;a class="footnote-ref" href="#fn:better"&gt;3&lt;/a&gt;&lt;/sup&gt;
Those characters and their behaviors are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;\b&lt;/code&gt; or backspace character, used primarily for the &lt;code&gt;\\&lt;/code&gt; or backslash character&lt;ul&gt;
&lt;li&gt;when resolved, removes the character and the character before it&lt;/li&gt;
&lt;li&gt;when removed, leaves the previous character in place&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;\a&lt;/code&gt; or alert character, used to provide an “X was replaced with Y” notation&lt;ul&gt;
&lt;li&gt;when resolved, removes the alert characters and the X sequence, leaving the Y sequence&lt;/li&gt;
&lt;li&gt;when removed, removes the alert characters and the Y sequence, leaving the X sequence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;\x02&lt;/code&gt; character, used to split whitespaces&lt;ul&gt;
&lt;li&gt;when resolved, is replaced with an empty string&lt;/li&gt;
&lt;li&gt;when removed as part of SetExt Heading whitespace processing, delineates leading whitespace that was removed from trailing whitespace that was removed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;\x03&lt;/code&gt; or “NOOP” character, used with the alert character sequence as a Y sequence&lt;ul&gt;
&lt;li&gt;when resolved, replaces the entire sequence with an empty string&lt;/li&gt;
&lt;li&gt;when removed, same as above but used to indicate that the X sequence was a caused by a blank line token&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The centralization of these characters and their usage did help to clean up the code.
In all cases, I created a single variable to represent the character, and enforced
its use throughout the codebase, except in test output.  For example, instead of using
the &lt;code&gt;\b&lt;/code&gt; for the backspace character, I created a new static member variable of
the &lt;code&gt;ParserHelper&lt;/code&gt; class called &lt;code&gt;__backspace_character&lt;/code&gt;.  The use of these variables
in the code made it clear that those characters were being used with purpose, and not
because of convenience.&lt;/p&gt;
&lt;p&gt;But even after that work, I still had a bit of time left.  What else could I do to
help the project?&lt;/p&gt;
&lt;h2 id="example-528"&gt;Example 528&lt;a class="headerlink" href="#example-528" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With my last remaining bits of extra time, I wanted to take another shot at the proper
processing of
&lt;a href="https://github.github.com/gfm/#example-528"&gt;example 528&lt;/a&gt;.  Having tackled the
Link related group of tokens, I felt that I had a good grasp of the processing
required.  With a sense of purpose and confidence, I felt it was time to put that
belief to the test.&lt;/p&gt;
&lt;p&gt;For some background, example 528 is similar to
&lt;a href="https://github.github.com/gfm/#example-525"&gt;example 525&lt;/a&gt;
and
&lt;a href="https://github.github.com/gfm/#example-583"&gt;example 583&lt;/a&gt;
referenced in the previous sections.  However, while each of those examples deals with
one type of link within the other type of link, example 528 can be considered the
composition of both of those examples together.  The example is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;[[foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;producing the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"uri3"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"[foo](uri2)"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To be clear, this is an inline image link that contains 2 possibly valid inline links
within its link label.  The final result was that the image’s URI is &lt;code&gt;uri3&lt;/code&gt; as expected,
but the &lt;code&gt;alt&lt;/code&gt; parameter’s text is set to &lt;code&gt;[foo](uri2)&lt;/code&gt;, an interpretation of the
text within the link label.  And to make it even more interesting, the
GFM specification also provides an algorithm for
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;evaluating emphasis and links&lt;/a&gt;
which has been tested.&lt;/p&gt;
&lt;p&gt;Yes, I have had the algorithm given to me, and I cannot make it work.  I confess.
I have been over the specification’s algorithm and my own implementation of that
algorithm, and I cannot make it work.  Every couple of weeks, I have spent a couple
of hours looking at the log output, the source code, and the algorithm description,
and… nothing.&lt;/p&gt;
&lt;p&gt;Giving it another shot, I decided that instead of assuming I knew what was going on,
I would try and test it as a new problem.  And with any new problem, I tackle it by
doing research on it, so that is what I set out to do.  I turned
on the logging for the scenario test associated with example 528 and started observing
and scribbling.  By the time I had gone through the algorithm 3 times, I was
convinced that I was either missing something important or there was a problem with
the well-tested algorithm.  If I were a betting man, my money would be on the algorithm
being correct, but I just could not figure out where the issue was!&lt;/p&gt;
&lt;p&gt;What I saw in each of my examinations, was that as the processing progressed, the
string &lt;code&gt;[foo](uri1)&lt;/code&gt; was parsed as a link.  Following the algorithm’s instructions,
any link starts before that point needed to be marked as inactive, so the code
marked the second &lt;code&gt;[&lt;/code&gt; character was marked as inactive.  I also double checked the
handling of the initial &lt;code&gt;![&lt;/code&gt; sequence.  As that sequence denotes an image token and not
a link token, that initial &lt;code&gt;![&lt;/code&gt; sequence was not marked as inactive.  Then, when the
second &lt;code&gt;]&lt;/code&gt; character was processed, the implementation skipped over the inactive &lt;code&gt;[&lt;/code&gt;
character, hitting the &lt;code&gt;![&lt;/code&gt; sequence for the image.  With the start link characters
exhausted, the rest of that string became plain text.&lt;/p&gt;
&lt;p&gt;But that is not the result that was specified in the GFM specification.  It wanted&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"uri3"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"[foo](uri2)"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the code was generating:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"uri2"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;](uri3)&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At that point, I decided to seek help from a higher power: the CommonMark specification
site.  I posted a quick message to the forums, making sure I indicated that I was having
a problem, clearly stating my findings from above and that they were based on my
implementation.  A couple of quick checks for spelling and grammar, and I posted
a request for help.  I did get a response to my request rather quickly, and I will
address that in a future article.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The goal that I had set for myself for this chunk of work was to make sure that I
added the link token group to the Markdown transformer’s features.  While it did
take me most of the week to accomplish that, I do believe that I accomplished that
with some time to spare.  It felt good to be able to take some time and do some small
tasks to clean up the code a bit.&lt;/p&gt;
&lt;p&gt;The weird thing about being able to see the end of the project’s initial phase is
that while I want a quality project, I also want to hurry up.  I can see the items
in the issue list being resolved and then removed, and I just want to get them all
removed.  I want to push myself harder to finish them quicker, even though I know
that is the wrong thing to do.&lt;/p&gt;
&lt;p&gt;As with all side projects, my time and effort spent on the project is a balancing
act between my personal responsibilities, my professional responsibilities, and the
project’s responsibilities.  And yes, while it is a balancing act, those three
groups of responsibilities are in the correct order.  I need to make sure to take
care of myself and my job first, using any extra bandwidth to work on the project.
While I do want to push myself to hurry and finish the project, from a resource
allocation point of view, it just would not work.&lt;/p&gt;
&lt;p&gt;And there is also the quality point of view.  While I am good at my job, I am keenly
aware that every project has four dials that can be adjusted: scope, cost, time, and
quality.  If I want the project to completed faster, changing the time dial, I need
to adjust the other dials to compensate.  This is a personal side project, so I cannot
adjust the cost dial, leaving the quality and scope dials.  Seeing as I do not want to
change my requirements for either of those two dials, I know I need to keep the time
dial where it is.&lt;/p&gt;
&lt;p&gt;Between the balancing act and the resource logic puzzle, I know I need to stay the
course.  While I was feeling the need to hurry up, I also knew that is not what has
got me to this point in the project.  What has got me here is good planning, solid
effort, and not exhausting myself.  If I upset that balance, I might lose my
desire to finish the project, and that would be a shame.&lt;/p&gt;
&lt;p&gt;So, as always, I started to look at and plan the next chunk of work, making
sure it was a good chunk of work that I could easily accomplish.  After all, slow
and steady went the tortoise…&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Add all the normal tokens to the Markdown transformer?  Check.  Add the Link-related
token group to the Markdown transformer?  Check.  That just left the Container-related
token group.  Add since I knew that Block Quotes were going to need a lot of work,
taking care of the List-related tokens was a good first step.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:slog"&gt;
&lt;p&gt;According to &lt;a href="https://www.merriam-webster.com/dictionary/slog"&gt;Webster’s dictionary&lt;/a&gt;: “to plod (one’s way) perseveringly especially against difficulty”. &lt;a class="footnote-backref" href="#fnref:slog" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:example528"&gt;
&lt;p&gt;More on &lt;a href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/#example-528"&gt;example 528&lt;/a&gt; later. &lt;a class="footnote-backref" href="#fnref:example528" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:better"&gt;
&lt;p&gt;While I am sure I can come up with a better name for the two sets of functions, I am not sure what those better names would be.  Ideas? &lt;a class="footnote-backref" href="#fnref:better" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Improving the Markdown Transformer</title><link href="https://jackdewinter.github.io/2020/08/03/markdown-linter-improving-the-markdown-transformer/" rel="alternate"></link><published>2020-08-03T00:00:00-07:00</published><updated>2020-08-03T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-03:/2020/08/03/markdown-linter-improving-the-markdown-transformer/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/27/markdown-linter-addressing-the-initial-markdown-transformer-issues/"&gt;last article&lt;/a&gt;,
I walked through the items that I chose to work on from the issues list, detailing my
process for resolving each one.  In this article, I detail how I continued the march
forward to increase my consistency check confidence by further implementing the token
to …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/27/markdown-linter-addressing-the-initial-markdown-transformer-issues/"&gt;last article&lt;/a&gt;,
I walked through the items that I chose to work on from the issues list, detailing my
process for resolving each one.  In this article, I detail how I continued the march
forward to increase my consistency check confidence by further implementing the token
to Markdown transformer.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having removed a good number of items from the issues list, I decided that
it was time to get back to verifying the tokens using the Markdown transformer.  While
my initial attempt at implementing the transformer yielded 8 new items on my issues
list, I was hopeful that this next batch of features for the transformer would uncover
fewer errors. Do not get me wrong. If there are issues with any part of the project, I
want to know about them so I can properly prioritize them.  I was just hoping that the
number of new items that I found would be lower this time.&lt;/p&gt;
&lt;p&gt;It is with that hopeful mindset that I started to work on implementing the
transformations for the other Markdown features, excluding the container blocks and the
link related blocks.  While awkwardly stated, that statement outlined a block of work
that I knew I would be comfortable working on and confident that I could complete.
Looking ahead, I knew that link transformations were next on the list, with container
blocks taking up the final position.  I knew I still needed to tackle those token
groups, but I was far more confident about handling the simpler cases first.  By
handling those simpler cases first, I hoped to build up my confidence to work on the
links in the subsequent section.  At least it would build up if I did not discover as
many errors as with the last chunk of work!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c9cd5e54a7a6167594dbce593e8869856db6db32"&gt;19 Jul 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7151ea88a180bdc4b977940e90e9db4908b13ede"&gt;26 Jul 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="did-i-take-the-week-off"&gt;Did I Take the Week Off?&lt;a class="headerlink" href="#did-i-take-the-week-off" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking at the commits for this chunk of work, it may look like I did the HTML block on
the Sunday, then took the week off, restarting the work on Saturday.  For no other
reason than dumb luck, I just hit a wall when trying to transform the SetExt Heading
tokens. Everything else just flew right by!  More on that in a bit.&lt;/p&gt;
&lt;h2 id="adding-html-support"&gt;Adding HTML Support&lt;a class="headerlink" href="#adding-html-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the writing of that week’s article, I just felt that I needed a bit of a break.
Being a bit fidgety about the block of work that was coming up next, I decided that I
wanted to start doing some work on a random token type.
The HTML block token support was that work, the type of token to work on chosen randomly
using the time-tested
&lt;a href="https://en.wikipedia.org/wiki/Eeny,_meeny,_miny,_moe"&gt;Eeny, Meeny method&lt;/a&gt;.
I honestly did not think that adding that support would be so easy that I could
complete it with only 25
lines of code changed, even less if I do not include blank lines.  I was just looking
to find something to give my mind a break from writing the article.  Nothing more.&lt;/p&gt;
&lt;p&gt;However, I cannot lie about it.  It was refreshing.  Go in, add the transformation, run
the tests, fix 1 or 2 problems that I found, and… done!  It worked so well, I thought
I would do it with the next token.  And that token is the SetExt Heading Token&lt;/p&gt;
&lt;h2 id="adding-setext-heading-support"&gt;Adding SetExt Heading Support&lt;a class="headerlink" href="#adding-setext-heading-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While you can estimate and plan for hours, there are times where the effort required to
do something seems almost random.  In one of the teams that I worked on, we referred to
this type of work as the spins on the “Wheel of Effort”.  One spin of the wheel and you
may get 1 hour, and another spin for a similar item may get 1 day.  It just depends.
I know there were underlying conditions that were contributing to that calculation of
effort.  However, from my viewpoint, it just seemed like a spin of the wheel.&lt;/p&gt;
&lt;p&gt;And the wheel was about to give me a spin that I really did not like.&lt;/p&gt;
&lt;h3 id="the-initial-push"&gt;The Initial Push&lt;a class="headerlink" href="#the-initial-push" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From experience dealing with SetExt Heading issues, I had a feeling that adding the
support for the SetExt Heading tokens was going to be more difficult than most other
tokens.  That experience also reminded me that most of the issues that I have had with
SetExt Headings were not with the SetExt Heading tokens themselves, but the text block
contained within.  While the SetExt Heading token itself is created to replace an
existing Paragraph token, the handling of the two text blocks was different enough that
I was immediately cautious about those differences.&lt;/p&gt;
&lt;p&gt;The first change that I made for this feature was to write a simple implementation of
the token handlers.  It was during that implementation that I discovered that while the
SetExt Heading tokens contained information about which heading character was used, the
quantity of those characters in the Markdown document was absent.  That was an easy
fix to implement.  A quick jump over to the &lt;code&gt;SetextHeadingMarkdownToken&lt;/code&gt; class to add
the &lt;code&gt;heading_character_count&lt;/code&gt; argument and member variable.  Then another quick jump
back to the new token handlers to use that new member variable when rehydrating the end
token.  Done.  Easy.&lt;/p&gt;
&lt;p&gt;Except it was not.  A single set of tests were failing in each test run: the
&lt;a href="https://github.github.com/gfm/#example-52"&gt;example 052&lt;/a&gt;
series of tests dealing with SetExt text that starts with whitespace.  To simplify
the test for a previous fix, I created the scenario test &lt;code&gt;test_setext_headings_052a&lt;/code&gt;
to keep the problem simple and easy to diagnose.  The issues for both
&lt;code&gt;test_setext_headings_052&lt;/code&gt; and &lt;code&gt;test_setext_headings_052a&lt;/code&gt; were easily fixed, but I
then noticed
a glaring issue:  there was no tests for SetExt Heading text that had both leading
and trailing whitespace.  To address that, I created
&lt;code&gt;test_setext_headings_052b&lt;/code&gt; to add some trailing whitespace while maintaining the same
HTML output with &lt;code&gt;test_setext_headings_052a&lt;/code&gt;.  From there, the &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;
variations were added to test various other patterns that I hoped were working
properly.  All those variations passed immediately, except for scenario test
&lt;code&gt;test_setext_headings_052b&lt;/code&gt;. That was failing and I was not sure why.&lt;/p&gt;
&lt;h3 id="the-problem"&gt;The Problem&lt;a class="headerlink" href="#the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Scenario test &lt;code&gt;test_setext_headings_052b&lt;/code&gt; is a simpler version of
&lt;a href="https://github.github.com/gfm/#example-52"&gt;example 52&lt;/a&gt;
with some changes thrown in.  In this new scenario test, the data is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the literal text &lt;code&gt;{space}&lt;/code&gt; are space characters at the end of each of those lines.
For comparison, the Markdown for test &lt;code&gt;test_setext_headings_052a&lt;/code&gt; is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="k"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the HTML output for that test is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;a
b
c&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By comparison, the new scenario test &lt;code&gt;test_setext_headings_052b&lt;/code&gt;, is a literal copy of
that original
scenario test &lt;code&gt;test_setext_headings_052a&lt;/code&gt; with the addition of a single space
character at the end of the first two lines.  As the GFM specification states that
leading and trailing spaces are removed in normal paragraphs, it makes sense that those
additional space characters would be removed as excess whitespace.  As such, I expected
that the HTML output would be the same, and it was.&lt;/p&gt;
&lt;p&gt;But when the Markdown transformer rehydrated the text, that removed whitespace was
inserted at the start of the line.  The rehydrated Markdown for this initial stage was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;a&lt;/span&gt;
   &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="k"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Digging a bit deeper, it took a fair amount of additional logging and debugging before
an answer started forming in my head.  The last line was fine, mostly because it did not
have any whitespace at the end of its line.  In the case of the first and second lines,
that trailing space was being placed at the start of the line, instead of the end of
the line.&lt;/p&gt;
&lt;p&gt;The problem?  The 2 spaces removed from the start of the line and the 1 space removed
from the end of the line were being merged.  The result?  When the Markdown
transformer went to rehydrate the token, all 3 of those removed spaces were placed at
the start of the line.  I needed some way to keep the two groups of spaces separate
from each other.&lt;/p&gt;
&lt;h3 id="another-rabbit-hole"&gt;Another Rabbit Hole?&lt;a class="headerlink" href="#another-rabbit-hole" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Yup, that thought had crossed my mind.  By the time that I had debugged the problem and
understood it clearly, it was late Wednesday night and I had already spent 2 nights
working on this issue.  To ensure that I did not go “missing” again, I set a maximum
duration of 2 days to solve this issue.  If not solved in that time, it would go on the
issues list to be dealt with later.&lt;/p&gt;
&lt;p&gt;Was this a bit overboard?  Perhaps.  But given my past history with
&lt;a href="({filename}/articles/SoftwareQuality/core-5.md)"&gt;chasing down issues like this&lt;/a&gt;,
I figured it was better to plan ahead to prevent myself from getting
in that predicament.  Given how much I like puzzles, combined with a gut feeling about
this issue, it just seemed the right thing to do at the time.&lt;/p&gt;
&lt;h3 id="over-the-next-2-days"&gt;Over the Next 2 Days&lt;a class="headerlink" href="#over-the-next-2-days" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Over the next 2 days, I tried 3 or 4 different approaches.  But in each
case, there was some manner of complication that prevented me from going forward with
it. It was frustrating, but I was adamant that I was going to find a solution.  Well,
if it did not exceed my self-imposed deadline of Friday night.  And that
deadline just kept on getting closer and closer.&lt;/p&gt;
&lt;h3 id="the-final-breakthrough"&gt;The Final Breakthrough&lt;a class="headerlink" href="#the-final-breakthrough" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Early on Friday night, I was very frustrated that nothing I tried had worked.  After
resetting the code yet again, I decided I was going to do my best to keep things
simple.  Before, I had tried altering the signatures of the functions and passing
variables around, and that did not get me anywhere.  Turning that effort around, I
figured that the simplest way to separate the two parts of the line was with a
separator character.&lt;/p&gt;
&lt;p&gt;Previously, the tokens for scenario test &lt;code&gt;test_setext_headings_052b&lt;/code&gt; were:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    expected_tokens = [
        "[setext(4,1):=:3:  :(1,3)]",
        "[text:a\nb\nc:: \n   \n  ]",
        "[end-setext::]",
    ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using a simple separator character of &lt;code&gt;\x02&lt;/code&gt;, I was able to change the serialized form
of the text token to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    expected_tokens = [
        "[setext(4,1):=:3:  :(1,3)]",
        "[text:a\nb\nc:: \n  \x02 \n  \x02]",
        "[end-setext::]",
    ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That one change was simple and pivotal, and it struck a chord in me right away.
That separator character clearly separated the two different whitespace sequences from
each other, with no complex variable passing to enforce it.  But that was only part of
it.  Would it the Markdown transformer portion of this fix be as clean and easy?&lt;/p&gt;
&lt;h3 id="the-solution"&gt;The Solution&lt;a class="headerlink" href="#the-solution" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I needed a come up with a fix to compensate for that change in the token’s text.
Before this change, the token’s text and the token’s whitespace were reintegrated with
each other using a simple algorithm:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;rejoined_token_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;split_token_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;main_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;split_parent_whitespace_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end_whitespace&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_token_text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;joined_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_parent_whitespace_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;rejoined_token_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;joined_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;main_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rejoined_token_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, split the text string and the whitespace string into arrays, splitting
them on the newline character.  Then take those two arrays and create a new array with
the concatenation of the element from the whitespace array with the text from the text
token element.  When done with all the elements, create a new string by merging the
contents of the array together, using a newline character to join the lines.&lt;/p&gt;
&lt;p&gt;After this change, that algorithm got a bit more complex, but not by much.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;rejoined_token_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;split_token_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;main_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;split_parent_whitespace_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end_whitespace&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_token_text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;ws_prefix_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="n"&gt;ws_suffix_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;split_parent_whitespace_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]]:&lt;/span&gt;
            &lt;span class="n"&gt;split_setext_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_parent_whitespace_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x02&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_setext_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;ws_suffix_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_setext_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;ws_prefix_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_setext_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;ws_prefix_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_setext_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="n"&gt;ws_suffix_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_setext_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;joined_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ws_prefix_text&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ws_suffix_text&lt;/span&gt;
        &lt;span class="n"&gt;rejoined_token_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;joined_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;main_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rejoined_token_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of the very simple concatenation of the whitespace and the text, there was a bit
more work to do.  First, the whitespace needed to be split into two, based on the new
separator character &lt;code&gt;\x02&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It was more difficult than the original algorithm, but not by much.  Once I did a
refactoring pass on the Markdown transformer, I was sure that I could clean that
algorithm up a lot.  But even without that refactoring, the changes in the algorithm
were easy to understand.&lt;/p&gt;
&lt;p&gt;The root of the changes centered on the splitting on the whitespace in the newly
inserted &lt;code&gt;\x02&lt;/code&gt; character.
Once that given line was split, there were 3 cases to handle.  The easy case
was the one where the &lt;code&gt;\x02&lt;/code&gt; character was present, yielding an array with 2 entries.
In that case, the &lt;code&gt;ws_prefix_text&lt;/code&gt; variable was set to the first element and the
&lt;code&gt;ws_suffix_text&lt;/code&gt; variable was set to the second element.  The second case was where
there was only 1 element in the array and it was the very first entry in the array.  In
that case, the prefix whitespace had already been applied when the SetExt Heading token
was dealt with, therefore the whitespace was assigned to the &lt;code&gt;ws_suffix_text&lt;/code&gt; variable.
Finally, in all other cases, that whitespace was good at the start of the line,
hence it was assigned to the &lt;code&gt;ws_prefix_text&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Testing this algorithm endlessly in my head, I was pleased when I tested the algorithm
with the actual code and it almost worked.  The first iteration of this algorithm did
not include the properly handling of the second case, as detailed above.  As such,
the other lines were formatted properly, but that first line was still a bit off.
However, the good news is that it only took a little bit of debugging before I had that
cause identified and fixed.  And after 4 days, seeing all the tests pass for this
change was a sweet sight for my eyes!&lt;/p&gt;
&lt;h3 id="hindsight-is-always-clearer"&gt;Hindsight is Always Clearer&lt;a class="headerlink" href="#hindsight-is-always-clearer" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Looking back at the solution, the simplicity and correctness of it is even more
evident. Add an extra marker during the initial processing and interpret it during
the Markdown transformer processing just makes sense.  Looking back, the thing that
made the most sense was that the simplest solution was the one that one.  It was
as complex as it needed to be, and not more complex.&lt;/p&gt;
&lt;p&gt;And after taking the time to add this support properly, I could only hope I would
have enough time to finish adding the support for the other tokens that I had planned
for.&lt;/p&gt;
&lt;h2 id="adding-emphasis-support"&gt;Adding Emphasis Support&lt;a class="headerlink" href="#adding-emphasis-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After the effort required to add the SetExt Heading transformation, I was hesitant to
start working on another token.  It was not a lack of confidence that was causing me to
pause for a bit, it was the work!  After taking 4 days to complete the SetExt Heading
token support, I was exhausted.  Also, by the time the code changes were committed,
I only had about 24 hours to complete the rest of the work!&lt;/p&gt;
&lt;p&gt;After adding my initial attempt to perform a simple transformation of Emphasis tokens,
I was very pleased when I found out that my work for this token was almost complete. The
writing of that initial attempt used the information already present in the
token and was able to satisfy most of the tests in dealing with emphasis.  The only
tests
that had a problem were the tests that used the alternate emphasis character &lt;code&gt;_&lt;/code&gt; and its
slightly altered emphasis rules.  When I originally added the &lt;code&gt;EmphasisMarkdownToken&lt;/code&gt;
class, the HTML transformer did not need to know which character was used for emphasis,
only the level of emphasis in the &lt;code&gt;emphasis_length&lt;/code&gt; field.  As such, any indication of
the emphasis character used was absent from the token.&lt;/p&gt;
&lt;p&gt;To address that problem, I simply added the &lt;code&gt;emphasis_character&lt;/code&gt; field to the
&lt;code&gt;EmphasisMarkdownToken&lt;/code&gt; class.  This was followed up by some small changes in the
&lt;code&gt;__process_emphasis_pair&lt;/code&gt; function to ensure that the new field was being properly
initialized in both the &lt;code&gt;EmphasisMarkdownToken&lt;/code&gt; constructor and the emphasis block’s end
token constructor.  The change in the end token was a bit trickier in that it does not
have a specific place for the character, just a generic &lt;code&gt;extra_end_data&lt;/code&gt; variable.
Those changes modified the code from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;EmphasisMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;emphasis_length&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
            &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_emphasis&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;emphasis_length&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;EmphasisMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;emphasis_length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;emphasis_character&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
            &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_emphasis&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
                 &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;emphasis_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;emphasis_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These changes made sure that both the start of the emphasis block and the end of the
emphasis block had access to the emphasis character that had been used.  To accommodate
these changes, a trivial change was needed in the HTML transformer.  Once that was done,
I temporarily disabled the consistency checks and ran the full set of tests against
those changes.&lt;/p&gt;
&lt;p&gt;Perhaps I am paranoid, but even with such a small change, I wanted to
run the full battery of GFM specification tests to ensure that those changes were solid
on their own before adding in more changes.  But with all those changes in place and
all tests passing, I then returned to the Markdown transformer.  Due to the above work,
the Markdown transfer was changed to be aware of the
emphasis character used.  Similar to the HTML transformer, the Markdown transformer
only required a few lines to be changed to accommodate the new versions of the tokens.
After that work was completed, the consistency checks were enabled, and I was glad to
find out that all emphasis tests were passing on the first try.  Compared to the last
element, this element was a breeze!&lt;/p&gt;
&lt;h2 id="adding-autolink-and-raw-html-support"&gt;Adding Autolink and Raw HTML Support&lt;a class="headerlink" href="#adding-autolink-and-raw-html-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Seemingly on a roll, the Autolink token support was added in 15 minutes and the raw HTML
token support was added in just over 10 minutes.  In both cases, the tokens contained
all the required information, allowing the transformation to be accomplished with very
simple functions.  The testing for these changes was likewise, quick, as the amount of
code that was changed was small.  As these changes took less than 30 minutes combined,
there really is not anything more to add.&lt;/p&gt;
&lt;h2 id="adding-code-span-support"&gt;Adding Code Span Support&lt;a class="headerlink" href="#adding-code-span-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Trivial, Hard, Decent, Trivial.  That was the effort that I required to add support for
the tokens documented in the last 4 sections.  Picking Code Spans by random out of the
group of remaining tokens, I was not
sure where the “Wheel of Effort” would land this time.  It turned out that adding
support for the code span tokens was a bit more difficult than adding support for the
Autolink token and the Raw HTML token, but it was not much more difficult.&lt;/p&gt;
&lt;h3 id="the-initial-attempt"&gt;The Initial Attempt&lt;a class="headerlink" href="#the-initial-attempt" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To add the support for the Code Span tokens, I first needed to change the constructor
for the
&lt;code&gt;InlineCodeSpanMarkdownToken&lt;/code&gt; class to keep track of three additional fields:
&lt;code&gt;extracted_start_backticks&lt;/code&gt;, &lt;code&gt;leading_whitespace&lt;/code&gt;, and &lt;code&gt;trailing_whitespace&lt;/code&gt;. While
those 3 fields were easy add to the token and populate with the right information,
their use in many of the scenario tests required small changes in each of those tests.
Even those changes were annoying, once they were out of the way, the changes to the
Markdown transformer to properly support the Code Span token were minimal.&lt;/p&gt;
&lt;p&gt;After running the all the tests with the above changes implemented, everything looked
good except for a couple of tests.  When I looked at those tests more closely, in each
test the Markdown contained a code span with a newline
character in the middle of it.  While Code Span tokens keep everything within their
boundaries exactly as they are, including backslashes and character reference sequences,
newline characters are a separate matter.&lt;/p&gt;
&lt;h3 id="addressing-the-issue"&gt;Addressing the Issue&lt;a class="headerlink" href="#addressing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When a Code Span element has a newline character in it, that newline character gets
replaced with a single space character.  This introduced a bit of a problem for the
Markdown transformer, as the HTML transformer was expecting a space character and the
Markdown transformer was expecting a newline character.  Luckily, I was able to
repurpose some work I did a couple of weeks ago for
&lt;a href="https://jackdewinter.github.io/2020/07/20/markdown-linter-transforming-back-to-markdown/#Handling-Character-References"&gt;character references&lt;/a&gt;
in indented code blocks.
As I wanted to ensure that I represented both states of the code span data in the
tokens, I replaced the
newline characters with the text &lt;code&gt;\a\n\a \a&lt;/code&gt; instead of replacing it with a single space
character.  At that point, depending on which viewpoint I was taking, I was able to know
both the before processing and after processing states of that character.&lt;/p&gt;
&lt;p&gt;Going forward with those changes, I went to look at any errors with the HTML
transformer, but there were not any.  It turned out that the work I did on
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/20b129ee1b2058b4495395251d25a8fafa88bfa3"&gt;16 Jul 2020&lt;/a&gt;
included adding a call to the &lt;code&gt;resolve_references_from_text&lt;/code&gt; function, then housed in
the &lt;code&gt;tranform_to_gfm.py&lt;/code&gt; module.  To be honest, I was not aware that I did that, but it
was nice that it was already in place.  That just left the changes to the Markdown
transformer to resolve any replacement markers in that data.  And given the the
literal text string &lt;code&gt;\a\n\a \a&lt;/code&gt;, that was a simple task.&lt;/p&gt;
&lt;p&gt;Running the tests at each interval along the way, I was confident that I had made the
right changes.  But there is always that moment where I say to myself “did I remember
everything?”.  Fighting past that though, I ran the all the tests and was happy to
see that Code Spans were now being transformed properly.&lt;/p&gt;
&lt;h2 id="adding-fenced-code-block-support"&gt;Adding Fenced Code Block Support&lt;a class="headerlink" href="#adding-fenced-code-block-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Like the work done for the Code Span tokens, the Fenced Code Block tokens were
missing some information. In this case, that information was tied to both the
start token and the end token.  For the start token, the information was being
serialized properly, but I needed to add specific member variables for each of the
arguments being passed in.  This small change allowed me to use that information
in the transformers in subsequent steps.  For the end token, instead
of trying to add a lot of generic information to the token, I opted to add a new
member variable &lt;code&gt;start_markdown_token&lt;/code&gt; to allow for a reference to the start token.  In
this way, I was able to easily reference the data of the start token without having to
duplicate information in a generic way in the end token.&lt;/p&gt;
&lt;p&gt;When I started testing these changes, there were a couple of tests that were trickier
than the others to get working.  Debugging into those tests, I quickly found that the
whitespace removed from the start of lines within the fenced code block was causing
issues for the Markdown transformer.  Having faced a similar problem with the Code
Span tokens, I was quickly able to pivot and replace that removed whitespace with
a similar replaced sequence and a &lt;code&gt;noop&lt;/code&gt; character.&lt;/p&gt;
&lt;p&gt;Based on the work in dealing with Code Spans, if knew that if I needed to replace a
single newline character with a space character, I would replace the newline with the
sequence &lt;code&gt;\a\n\a \a&lt;/code&gt;.  As there are boundary cases where replacements can be nested, I
did not
want to use the sequence &lt;code&gt;\a \a\a&lt;/code&gt; to replace a removed space character.  Instead,
I used the &lt;code&gt;\x03&lt;/code&gt; character to signal a character that did not mean anything, in effect
a
&lt;a href="https://www.urbandictionary.com/define.php?term=noop"&gt;NOOP character&lt;/a&gt;.
Thus, the replacement string became &lt;code&gt;\a \a\x03\a&lt;/code&gt;.  After a few small fixes, everything
passed.&lt;/p&gt;
&lt;h2 id="adding-atx-heading-support"&gt;Adding Atx Heading Support&lt;a class="headerlink" href="#adding-atx-heading-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the way the “Wheel of Effort” had been spinning for me during this chunk of work,
I had no
clue where the effort for this token would land on that metaphorical wheel.  On one
side, there were plenty of simple changes required to add support for many of the
tokens.  On the other side were the SetExt Heading tokens, which took days.  It was
with trepidation and caution that I started to work on the support for this token.&lt;/p&gt;
&lt;p&gt;And it was within a couple of minutes of starting that I figured out this work was
destined for the the trivial category.  Piggybacking on the work documented in the last
section regarding the &lt;code&gt;start_markdown_token&lt;/code&gt; field, the big change for the parser was
to set this field in the end token for the heading.  Seeing as the change was solely
additive, I jumped to the Markdown transformer, and added the handlers for both the
&lt;code&gt;AtxHeadingMarkdownToken&lt;/code&gt; and its corresponding end token.  The handlers were both
simple, just regurgitating the token’s member variables back into a Markdown form.&lt;/p&gt;
&lt;p&gt;Running the tests, I was pleased to see that most of the tests worked on the first
run.  The ones that did not caused me to look at the tests more closely.  It was there
that I realized that the only tests that were failing were tests with closing
Atx Heading characters.  Looking specifically at the code to handle those closing
characters, I discovered that I had transposed two variables, producing weird results
in the output.  Fixing that error, the tests ran without any issues.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I mentioned in the last article that I started to believe that I could see the
end of the project, it was this chunk of work that brought it into sharper focus for me.
In my mind, anyone can say that they can properly parse a Markdown document, but for me,
anything short of being able to empirically prove that the project can parser the
Markdown project properly is a failure.  For me, it is not about guesswork, it is
whether I can back up my claim with data.&lt;/p&gt;
&lt;p&gt;The comparisons between the HTML parser output
and the HTML output from the GFM specification? They proved the project could get the
HTML right for those specific cases.  The comparisons between the line numbers and
column numbers from the parser’s tokens and the consistency check algorithms?  They
proved that the project could pinpoint the origin of any element in the original
Markdown document.  The consistency check using the Markdown transformer?  It proved
that the project could, with certainty, transform the Markdown document into an
intermediate form and then back again, with no loss of data.&lt;/p&gt;
&lt;p&gt;From my point of view, each one of these checks was building on the work of the other,
providing solid, empirical proof that the parser had properly tokenized the document.
I understand that to some it may seem excessive.  But to me, this was just dotting
my Is and crossing my Ts.  I wanted to make a good first impression with this parser,
and I wanted to take steps to ensure that.&lt;/p&gt;
&lt;p&gt;In addition, that new level of confidence spoke to me. The scenario tests were
effective.  The consistency checks were working.  And in my mind, the project was
clearly past the half-way point on its journey to the finish line!  It was all
starting to come together.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As mentioned above, Link transformations were next on the list of Markdown
transformations to add.  Given the work documented in this article, I was sure that
I would run into at least a couple of issues.  It was just a question of how much
effort it would take for me to push through it!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Addressing the Initial Markdown Transformer Issues</title><link href="https://jackdewinter.github.io/2020/07/27/markdown-linter-addressing-the-initial-markdown-transformer-issues/" rel="alternate"></link><published>2020-07-27T00:00:00-07:00</published><updated>2020-07-27T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-07-27:/2020/07/27/markdown-linter-addressing-the-initial-markdown-transformer-issues/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/20/markdown-linter-transforming-back-to-markdown/"&gt;last article&lt;/a&gt;, I started to work on the
token transformer, a transformer specifically used to verify the PyMarkdown tokens by
rehydrating or reconstituting the original Markdown document from them.  In this
article, I talk about how I went through the items that I added to the issues …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/20/markdown-linter-transforming-back-to-markdown/"&gt;last article&lt;/a&gt;, I started to work on the
token transformer, a transformer specifically used to verify the PyMarkdown tokens by
rehydrating or reconstituting the original Markdown document from them.  In this
article, I talk about how I went through the items that I added to the issues list as
a result of that work and resolved them.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Normally, I use this space to explain some of the reasoning behind the work which
formed the basis for the article.  Without that bit of preamble, I feel that I am just
dropping the reader off in an unfamiliar location without a compass, a map, or any
indication of where they are.  While that remains true for this article, the reasoning
for this article is so simple that I feel that I do not need a lot of words to explain
it.&lt;/p&gt;
&lt;p&gt;Last week, I added 7 new items to my issues list, with 1 other issue pending from the
week before.  Plain and simple, I just wanted those issues off the list before I
continued with the project’s Markdown transformer.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/20b129ee1b2058b4495395251d25a8fafa88bfa3"&gt;16 Jul 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/d07237bb4201221d5bcdc88f51a8d8461dfe7c41"&gt;18 Jul 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="things-continue-to-be-busy"&gt;Things Continue to Be Busy&lt;a class="headerlink" href="#things-continue-to-be-busy" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there are often weeks where I wish something interesting would happen, those types
of weeks are not showing up in my life this summer.  Instead, I am having the type of
summer where I wish I had less to do, giving myself some extra time to relax and
recharge.  Thankfully, I have a spouse that is very supportive of my hobbies and
writing, giving me time on the evenings and the weekends to make my project and this
blog happen.  If you check the Git repository for this project, the times when I have
been able to eke out some time to work should be obvious.&lt;/p&gt;
&lt;p&gt;I am hoping, that as the summer continues, more “free” time comes my way.&lt;/p&gt;
&lt;h2 id="nothing-to-worry-about"&gt;Nothing to Worry About&lt;a class="headerlink" href="#nothing-to-worry-about" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking at the issues list and the items that I added during my last session,
I did not believe there were any serious issues to address.  Sure, there were some
questions that I wanted to follow up on, but I did not feel that any of
them indicated a serious issue. Similarly, there were some possible bugs
that I had noticed, but I did not feel that any of these possible bugs were severe.  In
the worst case, I figured that each of these issues would each take a couple hours’
worth of effort or less to solve.  Nothing I could not handle.&lt;/p&gt;
&lt;p&gt;But adding those items as I was working on the consistency checks was not
something that I liked doing.  After all, if I was checking the consistency of my work
and there were problems with those checks, did that mean the checks were faulty?
It just made sense to me to address those questions right away, ensuring that my
confidence in the consistency checks remained high.  Besides, if my guesses
were right about the severity of the items, I should be able to address them quickly.&lt;/p&gt;
&lt;p&gt;And with that mindset in place, I started working on removing those items from the
issues list.&lt;/p&gt;
&lt;h3 id="lone-link-reference-definitions"&gt;Lone Link Reference Definitions&lt;a class="headerlink" href="#lone-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Link Reference Definitions are interesting in that they break the mold created by the
other Markdown tokens.  When these elements are parsed from their original Markdown
document into Markdown tokens, they do not add any information to the output HTML
document.  For the elements themselves to be useful, a
separate link element is required that references them.  The absence of such a distinct
link element is the basis for
&lt;a href="https://github.github.com/gfm/#example-176"&gt;example 176&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-188"&gt;example 188&lt;/a&gt;.  Apparently, this issue was
so important, that the specification includes it twice with the exact same example text
for both examples:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These examples deal with the other unique part of the Link Reference Definition: it is
the only multiline element in the base GFM specification.  This means that the next line
may need to be parsed to determine if the Link Reference Definition on the current line
has ended.  In this specific case, the link
label (&lt;code&gt;[foo]&lt;/code&gt;) and link destination (&lt;code&gt;/url&lt;/code&gt;) have both been provided, but there is the
possibility of the link title occurring on the next line.  So, when the end of the
document is reached, for whatever reason, the partial Link Reference Definition was
being left partially open, resulting in the token was not being emitted.  But why?&lt;/p&gt;
&lt;h4 id="debugging-and-resolving-the-issue"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Adding some debug statements and doing some research with the scenario tests, the cause
of this issue was quick to pop out at me.  At first, I thought it was an issue to do
with the &lt;code&gt;__close_open_blocks&lt;/code&gt; function, as it was a likely candidate.  But a quick
change to example 176 to add a couple of blank lines after the Link Reference Definition
put a quick end to that.  That modified case worked without any problems.  Doing a bit
more digging, the problem seemed to be in the handling of the return value from the
&lt;code&gt;__close_open_blocks&lt;/code&gt; function.  At that time, when the
&lt;code&gt;__close_open_blocks&lt;/code&gt; function was called from the main &lt;code&gt;__parse_blocks_pass&lt;/code&gt; function
to close the document, the return value containing any immediately closed tokens was
discarded.  That definitely did not seem helpful.&lt;/p&gt;
&lt;p&gt;To address this, instead of using the &lt;code&gt;_&lt;/code&gt; variable to capture and ignore the list
returned from the &lt;code&gt;__close_open_blocks&lt;/code&gt; function, I replaced it with the variable
&lt;code&gt;tokens_from_line&lt;/code&gt; to capture that value. Making sure that the list was not being
extended with itself (which caused failures in almost every scenario test) the lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;tokens_from_line&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenized_document&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenized_document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tokens_from_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;were added to extend the document list with the previously missing tokens.  A quick
run of all the scenario tests to verify that it was fixed, and this issue was removed
from the issues list!&lt;/p&gt;
&lt;h3 id="getting-rid-of-extra-blank-line-tokens"&gt;Getting Rid of Extra Blank Line Tokens&lt;a class="headerlink" href="#getting-rid-of-extra-blank-line-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While
&lt;a href="https://github.github.com/gfm/#example-559"&gt;example 559&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-560"&gt;example 560&lt;/a&gt; are the two main recorded
issues, there were a total of 6 scenario tests that had this same issue.  With a Link
Reference Definition (or possible Link Reference Definition) being started at the end
of the document, an extra Blank Line token was being inserted before the document was
closed.&lt;/p&gt;
&lt;p&gt;Basically, given the source Markdown document for
&lt;a href="https://github.github.com/gfm/#example-559"&gt;example 559&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or a modification of &lt;a href="https://github.github.com/gfm/#example-188"&gt;example 188&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;an extra Blank Line token appeared in the token array without fault.&lt;/p&gt;
&lt;h4 id="debugging-and-resolving-the-issue_1"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The cause of this issue was a bit more subtle than the others, so it took me a bit
longer to figure it out.  Most of my initial time on this issue was spent trying to
figure out why this
issue happened with Link tokens and Link Reference Definition tokens, not just Link
Reference Definition tokens.  It was not until I took a look at the log output that
I realized they were the same issue.&lt;/p&gt;
&lt;p&gt;While the text &lt;code&gt;[foo]&lt;/code&gt; can be used as a shortcut
link, that same text can also be used as a link
label for a Link Reference Definition.  As the Link Reference Definitions are processed
in the initial phase and links are processed in the final phase, that text is
considered part of a Link Reference Definition until it can be proven otherwise.  In
this case, that consideration was dropped quickly, as the link label is not followed by
the &lt;code&gt;:&lt;/code&gt; character.  However, it still underwent the initial consideration before being
dropped and requeued for further processing.&lt;/p&gt;
&lt;p&gt;With this new insight, I went through the logs for the &lt;code&gt;__parse_blocks_pass&lt;/code&gt; function
again.  I quickly noticed that in these cases, there was a single blank line getting
requeued. Thinking about it for a while, this did make sense.  At the end of the
document, when a partial Link Reference Definition is closed, an empty string (&lt;code&gt;""&lt;/code&gt;) is
passed into the Link Reference Definition functions to make sure the Link Reference
Definition is terminated properly.  As a blank line in a normal document naturally
closes the element, the passing of the empty string into those functions has proven
to be a smart and efficient solution.  However, following the flow of data in the log
statements, it became obvious that these empty strings were surfacing to the
&lt;code&gt;__parse_blocks_pass&lt;/code&gt; function where that blank line was eventually stored as an entry
in the &lt;code&gt;lines_to_requeue&lt;/code&gt; variable.  Once placed in that variable, it was requeued and
the extra blank line appeared in the array of tokens.&lt;/p&gt;
&lt;p&gt;From this information, I figured out that there were two parts to solving this
problem.  The first was to add this code near the
start of the closing code in the &lt;code&gt;__parse_blocks_pass&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                &lt;span class="n"&gt;was_link_definition_started_before_close&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;was_link_definition_started&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;was_link_definition_started_before_close&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As this problem only ever occurred with a Link Reference Definition in progress, it
made sense to use that condition as a trigger for the fix.  That change allowed me to
add the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;was_link_definition_started_before_close&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;lines_to_requeue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
                    &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;lines_to_requeue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                    &lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, in the cases where an open Link Reference Definition is closed at the
end of the document, if there is a blank line at the start of the lines to requeue,
remove it.  As a side effect of removing that line, it also becomes necessary to adjust
the line number by 1 to ensure that the line number is pointing at the correct line.&lt;/p&gt;
&lt;p&gt;My initial thought was that this code was a kludge, but in the end, I grew to be okay
with it.  As the mainline is where the requeued lines are managed, it started to grow
on me that this was the correct place to address that issue.  Fixing it at any other
point seemed to me like I was just going to pass a variable around through various
functions just to handle this one extant case.  This was indeed clearer.&lt;/p&gt;
&lt;h3 id="the-case-of-the-possibly-missing-link-text"&gt;The Case of the Possibly Missing Link Text&lt;a class="headerlink" href="#the-case-of-the-possibly-missing-link-text" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sometimes, as with
&lt;a href="https://github.github.com/gfm/#example-575"&gt;example 575&lt;/a&gt;,
I look at an example or its scenario test, and I get a feeling that it does not look
quite right.  If am in the middle of something else, which I usually am, I note it down
in the issue list to be worked on later.  When I find the time to start working on it,
I almost always begin by looking around for other supporting cases or documentation
to support any possible answers to the asked question.&lt;/p&gt;
&lt;p&gt;This issue was no different than the rest.  To me:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;just looked weird.  Should not it be the shortcut link that took precedence?  The
following example,
&lt;a href="https://github.github.com/gfm/#example-576"&gt;example 576&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;produced the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url1"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;(not a link)&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If that was the case for example 576’s output, in the HTML output for example 575:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where were the parentheses?&lt;/p&gt;
&lt;h4 id="debugging-and-resolving-the-issue_2"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;It took bit of looking around, but I finally found some good supporting
documentation.  In the case of example 576, the text &lt;code&gt;not a link&lt;/code&gt; does fulfil the
link destination requirements of an inline link with &lt;code&gt;not&lt;/code&gt;, but then fails on the link
title requirements because of missing enclosing characters, such as &lt;code&gt;"&lt;/code&gt;.  In a
subsequent processing pass through the tokens, the inline processors looks for a
shortcut link, which it does find with &lt;code&gt;[foo]&lt;/code&gt;, ignoring the text &lt;code&gt;(not a link)&lt;/code&gt;.
This leaves that text as normal text to be dealt with outside of the Link element.&lt;/p&gt;
&lt;p&gt;The case for example 575 is slightly different.  Based on
&lt;a href="https://github.github.com/gfm/#example-495"&gt;example 495&lt;/a&gt;, this Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is a valid inline, producing the HTML output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This almost exactly matches the desired output for example 576.  In the previous case,
the text between the parentheses, &lt;code&gt;(not a link)&lt;/code&gt; was determined to be invalid, and
hence was not
processed as a valid inline link.  However, in this case, it is perfectly valid for
an inline link to have no text within its parentheses, as example 495 demonstrates.
As that text was a valid part of an inline link element, the entire text
was consumed, leaving nothing else for processing to deal with later.  With nothing
outside of the inline link left for processing, nothing gets added to the surrounding
paragraph as “leftover” text.&lt;/p&gt;
&lt;p&gt;Based on that research, the parsing of the above Markdown into the above HTML is 100%
correct and explainable.  Did it initially look weird? Yes.  But was it correct?  Yes
again. Question resolved and removed from the issues list.&lt;/p&gt;
&lt;h3 id="where-was-that-extra-text-coming-from"&gt;Where Was That Extra &lt;code&gt;text&lt;/code&gt; Coming From?&lt;a class="headerlink" href="#where-was-that-extra-text-coming-from" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While the 8 scenario tests in which this issue was found were passing, they were only
passing because I had modified the acceptance data in the tests.  In each case, I
simply added &lt;code&gt;text&lt;/code&gt; at the appropriate place in the token data to match what was
expected.  The decision to do that never really sat well with me, so I was happy that
it was time to fix this issue.&lt;/p&gt;
&lt;p&gt;For this issue, I started by looking at the easy (ok, easier) to digest
&lt;a href="https://github.github.com/gfm/#example-524"&gt;example 524&lt;/a&gt;.  The Markdown for this
example is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="o"&gt;`#`*&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and its HTML output is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;#&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Double checking those two against each other, and against the GFM specification,
everything looked fine.  However, when I looked at the serialized token for the link:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[link:inline:/uri:::::link *foo **bar** text*]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I noticed that the word &lt;code&gt;text&lt;/code&gt; was showing up in the output instead of the text &lt;code&gt;#&lt;/code&gt;.
At that time, as noted above, I simply added the token information as-is to the output,
created an item in the issues list, and planned to deal with it later.  It was not
that later.  I really wanted to figure out where that &lt;code&gt;text&lt;/code&gt; was coming from.&lt;/p&gt;
&lt;h4 id="debugging-and-resolving-the-issue_3"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;When I looked at the logs, I arrived at the answer within the first 5 minutes of looking
at the problem.
It turned out that I forgot to add some functionality to the
&lt;code&gt;__collect_text_from_blocks&lt;/code&gt; function.  This function is used to determine the
representative text from a list of inline blocks.  That text is then used to create a
proper record of what the actual text for the link label was before any processing, as
well as a normalized version being used for looking up link information.  In the case
of various inline tokens, instead of placing the original text for the inline element
in the resultant string, the literal text &lt;code&gt;text&lt;/code&gt; was added to that string.&lt;/p&gt;
&lt;p&gt;Fixing this was easy, as in most inline tokens use the &lt;code&gt;token_text&lt;/code&gt; member
variable to contain the correct text.  After running the scenario tests for each of the
failing cases, the &lt;code&gt;__collect_text_from_blocks&lt;/code&gt; function was modified to properly handle
replacement of the text for the various inline cases.  I then manually went through all
eight cases and verified that they were working properly, without the text &lt;code&gt;text&lt;/code&gt;
showing up in the token unless the string &lt;code&gt;text&lt;/code&gt; was in the source Markdown.&lt;/p&gt;
&lt;p&gt;It took a while, but I got it working cleanly, and for all inline tokens.  It just
felt good to get this “dirty” issue off the books!&lt;/p&gt;
&lt;h3 id="where-was-that-extra-not-coming-from"&gt;Where Was That Extra &lt;code&gt;not&lt;/code&gt; Coming From?&lt;a class="headerlink" href="#where-was-that-extra-not-coming-from" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After working on the last issue, I thought that this issue would take the same level of
effort and research to resolve.  In the tokenization for the link in
&lt;a href="https://github.github.com/gfm/#example-576"&gt;example 576&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;link:shortcut:/url1::not:::foo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I wondered why the text &lt;code&gt;not&lt;/code&gt; was in the token.  Spotted when I was debugging
the last issue, that &lt;code&gt;not&lt;/code&gt; value just looked out of place.&lt;/p&gt;
&lt;h4 id="debugging-and-resolving-the-issue_4"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Thankfully, this was an easy problem to find, debug, and fix.  In the
&lt;code&gt;handle_link_types&lt;/code&gt; function for the &lt;code&gt;link_helper.py&lt;/code&gt; module, the Markdown for the
example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was parsed to see if it could be a shortcut link and failed.  However, before it
failed, the link label was set to &lt;code&gt;foo&lt;/code&gt; and the link destination was set to &lt;code&gt;not&lt;/code&gt;.
In the code for &lt;code&gt;handle_link_types&lt;/code&gt;, this meant that the &lt;code&gt;inline_link&lt;/code&gt; variable was
set to the link destination and the &lt;code&gt;pre_inline_link&lt;/code&gt; variable was set to the
original text for the link destination before processing &lt;code&gt;not&lt;/code&gt;.  After the failed
processing, the &lt;code&gt;pre_inline_link&lt;/code&gt; variable was never cleared but was passed into
the constructor for the link token when it was created.&lt;/p&gt;
&lt;p&gt;With that research performed, it was easy to determine out that the statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;pre_inline_link&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was all that was required to resolve this issue quickly and cleanly.&lt;/p&gt;
&lt;h3 id="what-to-do-with-backslashes-in-code-spans"&gt;What to Do With Backslashes in Code Spans?&lt;a class="headerlink" href="#what-to-do-with-backslashes-in-code-spans" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sometimes the questions I pose to myself have simple answers.  In this case, the
question was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;backslash&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;what&lt;/span&gt; &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;look&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="debugging-and-resolving-the-issue_5"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Doing a quick check in the backslash section of the GFM specification, I did not see
anything relevant.  However, in the code spans section,
&lt;a href="https://github.github.com/gfm/#example-348"&gt;example 348&lt;/a&gt; provided me with the
information that I needed.&lt;/p&gt;
&lt;p&gt;The preface to the example states simply:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that backslash escapes do not work in code spans. All backslashes are treated literally:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is backed up with example 348, whose Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;`foo\`bar`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;produces the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo\&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar`&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The answer to my question?  Leave them alone.  They exist as they are, no parsing
or interpretation needed.  As far as code spans go, they are just another normal
character.&lt;/p&gt;
&lt;h4 id="is-it-worth-it"&gt;Is It Worth It?&lt;a class="headerlink" href="#is-it-worth-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;As I quickly resolved this issue, I paused before moving on to the next issue.  I
started to wonder whether this practice of noting questions and issues in the
issues list was worth it.  In this case, this was a question whose answer I should have
known. The fact that I did not know it right away was somewhat embarrassing.&lt;/p&gt;
&lt;p&gt;Thinking about it some more, I decided to really devote some serious time to
understand what I felt about this question, and to really think thought through it.
Doing that, it was only 5 minutes later when I noticed that I had changed how I was
feeling from embarrassed to proud and confident.&lt;/p&gt;
&lt;p&gt;It took a bit of time, but I mentally reviewed the other times I have used the
issues list to document questions and possible bugs.  Overwhelmingly, the issues that I
logged either helped identify an issue or helped me solidify my understanding of the
project and the GFM specification.  Should I have known that fact about code spans and
backslashes? Maybe?  While I have a good grasp of the specification, it is also a large
specification with a decent number of exceptional cases along the way.&lt;/p&gt;
&lt;p&gt;But as I thought about that further, I realized that my sincerity about the quality for
the PyMarkdown project was not absolute, but ever increasing.  When I started the
project, I had to look up every fact about every element, just to make sure I had it
right.  I knew that I was now at a level where I usually only had to look up the more
esoteric and exceptional parts of the specification.  If I was sincere about the
quality of the project, I also needed to acknowledge the quality that my learning about
the specification brought to the project.&lt;/p&gt;
&lt;p&gt;Given that altered point of view, I was confident that it was worth it.  Both as an
early problem indicator and as a learning tool, it was indeed worth it.  And besides
folks, I know I am not perfect.  That does not mean I am going to stop trying and stop
learning.  And to me, that is what made the issue list worth it!&lt;/p&gt;
&lt;h3 id="link-labels-and-special-characters"&gt;Link Labels and Special Characters&lt;a class="headerlink" href="#link-labels-and-special-characters" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I add a question to my issues list, it is always with the hope that I have
forgotten something simple, and some quick research will resolve the issue.  In this
case, the question was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- backslash and char ent in link label? tests?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or, for those that do not read native “Jack”:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- what about the backslash character and the character entities in link labels?
    - are they covered by tests?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Reading this now, I believe that this was an honest question to verify how backslashes
and character entities are handled in link labels.  Based on my current work solving
these issues, I have a good idea on the answer, but at the time, I probably was not
as sure. The answer?  From previous issues, both backslashes characters and character
entities are allowed in most areas, including link labels.&lt;/p&gt;
&lt;p&gt;But as always, it was time to back up my guess with research.  And something told me
it was not going to be the quick answer I was hoping for.&lt;/p&gt;
&lt;h4 id="researching-the-issue"&gt;Researching the Issue&lt;a class="headerlink" href="#researching-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Starting my search at the beginning, I looked for a scenario test that contained
a backslash in a link label.  It was tricky, but eventually I found
&lt;a href="https://github.github.com/gfm/#example-523"&gt;example 523&lt;/a&gt;
in the section on inline links:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link \[bar&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Checking the HTML output, it is easy to see that the backslash effectively escapes the
character following it, even in the link label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link [bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Backslashes?  Check.  One part of the issue down, one to go.&lt;/p&gt;
&lt;p&gt;To start researching the issue of character entities in link labels, I decided to start
with inline Unicode characters.  Based on my usage of Markdown, I generally use
character entities
to represent characters that I cannot find on my keyboard, usually Unicode characters.
As such, starting with inline Unicode characters seemed like a good first step before
tackling character entities.  This decision was validated by my ease in finding not 1,
but 2 examples in the GFM specification,
&lt;a href="https://github.github.com/gfm/#example-175"&gt;example 175&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;ΑΓΩ&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;φου&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;αγω&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and &lt;a href="https://github.github.com/gfm/#example-548"&gt;example 548&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[ẞ]&lt;/span&gt;

&lt;span class="na"&gt;[SS]: /url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But try as I might, I could not find an example of a character entity reference within
a link label.  As I looked, I did find the text above
&lt;a href="https://github.github.com/gfm/#example-327"&gt;example 327&lt;/a&gt;
which backed up my previous research stating:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Entity and numeric character references are recognized in any context besides code spans or code blocks, including URLs, link titles, and fenced code block info strings:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, while the GFM specification did not explicitly state that character entities in link
labels were rejected, there were no actual examples of the positive case either.  To
me, that was not a showstopper… it was just an invitation to be creative!&lt;/p&gt;
&lt;h4 id="testing-the-issue"&gt;Testing the Issue&lt;a class="headerlink" href="#testing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The first thing I needed to do was to come up with some good examples to test against.
To do this, I
started by creating the scenario test &lt;code&gt;test_character_references_328a&lt;/code&gt; as a variation
of scenario test &lt;code&gt;test_character_references_328&lt;/code&gt;.  The sole difference between these
two scenario tests was the specification of the link label as &lt;code&gt;[f&amp;amp;ouml;&amp;amp;ouml;]&lt;/code&gt; instead
of &lt;code&gt;[foo]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In a similar fashion, I copied the test &lt;code&gt;test_reference_links_558&lt;/code&gt; into the new test
&lt;code&gt;test_reference_links_558a&lt;/code&gt;, altering the link label from &lt;code&gt;[bar\\\\]&lt;/code&gt; to &lt;code&gt;[bar&amp;amp;#x5C;]&lt;/code&gt;.
If I understand the specification properly, both &lt;code&gt;\\\\&lt;/code&gt; and &lt;code&gt;&amp;amp;#x5C;&lt;/code&gt; should produce the
same &lt;code&gt;\&lt;/code&gt; in the HTML output, so to me it was a good test case.  In addition, I added the
test function &lt;code&gt;test_reference_links_558b&lt;/code&gt; with the link label of &lt;code&gt;[bar&amp;amp;beta;]&lt;/code&gt; to
make sure named entities were addressed.&lt;/p&gt;
&lt;p&gt;Finally, before I started debugging and changing code, I created the following Markdown
document from bits and pieces of those new tests:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="ss"&gt;"f&amp;amp;ouml;&amp;amp;ouml;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;#&lt;/span&gt;&lt;span class="n"&gt;x5C&lt;/span&gt;&lt;span class="p"&gt;;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Verifying its content, I submitted it to my favorite test harness,
&lt;a href="https://johnmacfarlane.net/babelmark2/?text=%5Bf%26ouml%3B%26ouml%3B%5D(%2Ff%26ouml%3B%26ouml%3B+%22f%26ouml%3B%26ouml%3B%22)%0A%5Bbar%5C%5C%5D(%2Furl)%0A%5Bbar%26%23x5C%3B%5D(%2Furl)%0A"&gt;BabelMark 2&lt;/a&gt;,
getting the following results for reference parser, &lt;code&gt;commonmark.js 0.29.0&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/f%C3%B6%C3%B6"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"föö"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;föö&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar\&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar\&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Taking the specific HTML lines generated for each scenario test, I inserted that text
into the owning scenario test, and verified that the proper HTML was being output.
With that taken care of, it was on to cleaning up the consistency check!&lt;/p&gt;
&lt;h4 id="debugging-and-resolving-the-issue_6"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue_6" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;After putting in that hard work to get the scenario tests set up, the resolution to
this issue was anticlimactic.  In the &lt;code&gt;inline_helper.py&lt;/code&gt; module, the
&lt;code&gt;handle_character_reference&lt;/code&gt; was already being called, but its return value was
being ignored.  That was easily addressed by replacing the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;current_string_unresolved&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InlineHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;current_string_unresolved&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_string_unresolved&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;with the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;current_string_unresolved&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;new_string_unresolved&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The other change that happened at the same time was that the &lt;code&gt;new_string_unresolved&lt;/code&gt;
variable was added directly to the &lt;code&gt;current_string_unresolved&lt;/code&gt; variable instead of
using the &lt;code&gt;append_text&lt;/code&gt; function.  As the &lt;code&gt;append_text&lt;/code&gt; function is used to add
text to a string while respecting any needed encoding, it was adding a step of extra
encoding to the text where it was not needed.  With those two changes in place,
a couple of extra changes were needed to the &lt;code&gt;handle_character_reference&lt;/code&gt; function to
make sure it was returning the correct original string, instead of a mangled version.&lt;/p&gt;
&lt;p&gt;Having made those changes, and a couple of test runs later, the problem was fixed and
verified.  While the research and setup of the new tests took a while, the actual
resolution of the issue took less than 20 minutes to complete.  With everything setup,
the logs were very helpful by showing me where the extra transformation of the text was
taking place, leading to a quick resolution.  Yeah verbose log files!&lt;/p&gt;
&lt;p&gt;Now on to the last issue for this week!&lt;/p&gt;
&lt;h3 id="indented-code-blocks-and-disappearing-leading-spaces"&gt;Indented Code Blocks and Disappearing Leading Spaces&lt;a class="headerlink" href="#indented-code-blocks-and-disappearing-leading-spaces" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I knew that the spaces were not disappearing, they just were not being recorded
properly.  But the phrase “disappearing leading spaces” sounded cool, so that is
what I called it to myself.  It was also the last thing that I felt I needed to fix
before getting back to implementing the Markdown transformer.  Having been discovered in
&lt;a href="core-11.md#indented-code-blocks-and-blank-lines"&gt;the last article&lt;/a&gt;,
this was the issue with the Markdown transformer check and
&lt;a href="https://github.github.com/gfm/#example-81"&gt;example 81&lt;/a&gt; where leading spaces were not
always being record for later rehydration.&lt;/p&gt;
&lt;p&gt;Doing a bit of research, I deduced that when a blank line is encountered in an
indented code block, there are three possibilities: too much whitespace, too little
whitespace, and just the right amount of whitespace.&lt;/p&gt;
&lt;p&gt;The scenario test for
&lt;a href="https://github.github.com/gfm/#example-82"&gt;example 82&lt;/a&gt; was passing without any
problems:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;chunk1&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;chunk2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which took care of the “too many” case.  A quick change of this scenario test&lt;sup id="fnref:recent"&gt;&lt;a class="footnote-ref" href="#fn:recent"&gt;1&lt;/a&gt;&lt;/sup&gt;
to present 4 spaces on the blank line instead of 6 spaces resulted in the expected
behavior. That took care of the “just the right amount” case.  Left was the “too little”
case and the issues demonstrated by example 81.&lt;/p&gt;
&lt;h4 id="debugging-and-resolving-the-issue_7"&gt;Debugging and Resolving the Issue&lt;a class="headerlink" href="#debugging-and-resolving-the-issue_7" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Originally, my time on this issue was spent looking at the logs with a specific focus
on how the tokens were created.  I had theorized that most of the issue was going
to be concerned with how I extracted and stored the whitespace in the text tokens…
and I was wrong.  Looking at the logs, the tokens looked fine when they exited
the initial processing phase, containing the right number of space characters and the
right number of newline characters.&lt;/p&gt;
&lt;p&gt;Debugging further, after the &lt;code&gt;coalesce_text_blocks&lt;/code&gt; function was invoked on those
tokens, the leading whitespace was missing.  Digging deeper, the first thing that I
noticed is that the variable &lt;code&gt;remove_leading_spaces&lt;/code&gt; was being populated with data from
the text token’s &lt;code&gt;extra_data&lt;/code&gt; field, not the &lt;code&gt;extracted_whitespace&lt;/code&gt; field.  Fixing that
issue got me part of the way there.  The next part was to alter the &lt;code&gt;TextMarkdownToken&lt;/code&gt;
code to allow the &lt;code&gt;combine&lt;/code&gt; function to return any whitespace that it removed.  This
change was pivotal in making sure that any removed whitespace was stored somewhere.
Finally, in the case where the coalescing takes place within an indented code
block, that removed whitespace is added to the active Indented Code Block token.&lt;/p&gt;
&lt;p&gt;Unlike the previous issue, this one took a bit of effort to arrive at the right
solution.  Looking back in hindsight, the path to fix it seems as clear as glass,
but it took getting past a number of failed solutions to get there.  Each one of the
steps outlined in the last paragraph had to be coded, debugged, and tested before
going forward. And in most cases, those steps were not the first solution, but the
third or fourth.&lt;/p&gt;
&lt;p&gt;But still, it was worth it.  Another item off the issues list, and the project’s
quality was raised just a bit higher than before!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For any readers that have followed the progression of this project from a simple idea to
its current form, you may have noticed that my confidence and happiness spikes a bit
after a round of refactoring.  There is just something about cleaning up the code and
resolving ambiguity that makes me smile and makes me feel better about the project.
While I can quantitatively show that the number of possible issues and tasks are
declining, I believe that I am more affected by the qualitative changes in the project.
Removing a single large task from the issues list?  Meh.  Removing 6-7 small tasks or
questions from that same list.  Yeah!&lt;/p&gt;
&lt;p&gt;But the interesting part of this block of work was not the work itself, but the
writing of the article about the work.  During the writing of this article, it
suddenly dawned on me.  For the first time
during this project’s lifetime, I believed that I could see the end of the project.
There was just this moment where I remember looking at the issues list, and the
list looked smaller.  That was followed by a moment of clarity that the consistency
checks were making a significant impact on my perception of the project.  Combined,
these two perceptions linked together to form a new level of confidence in my mind.&lt;/p&gt;
&lt;p&gt;That new level of confidence spoke to me. The scenario tests were effective.  The
consistency checks were working.  And in my mind, the project was clearly past the
half-way point on its journey to the finish line!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the current round of questions and issues addressed, it was time to get back to
adding to the consistency checker.  While I knew I had a busy week of personal stuff
and professional stuff coming up, I also knew that I did not want to lose any momentum
on the project.  And making progress on the Markdown transformer was just the right
kind of thing to help boost my spirits in a long week!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:recent"&gt;
&lt;p&gt;As part of writing this article, I added scenario test &lt;code&gt;test_indented_code_blocks_082a&lt;/code&gt; which is the result of the number of spaces on the blank line being reduced from 6 to 4. &lt;a class="footnote-backref" href="#fnref:recent" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Transforming Back to Markdown</title><link href="https://jackdewinter.github.io/2020/07/20/markdown-linter-transforming-back-to-markdown/" rel="alternate"></link><published>2020-07-20T00:00:00-07:00</published><updated>2020-07-20T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-07-20:/2020/07/20/markdown-linter-transforming-back-to-markdown/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/13/markdown-linter-improving-consistency/"&gt;last article&lt;/a&gt;,
I talked about how I believe that the benefit of adding consistency checks to the
project outweighed the costs of developing those tests and maintaining them.  In this
article, I talk about how I decided to double down on the consistency checks by adding
a …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/13/markdown-linter-improving-consistency/"&gt;last article&lt;/a&gt;,
I talked about how I believe that the benefit of adding consistency checks to the
project outweighed the costs of developing those tests and maintaining them.  In this
article, I talk about how I decided to double down on the consistency checks by adding
a token transformer that transforms the tokenized document back into its original
Markdown.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Since implementing the consistency checks for the line numbers and column numbers in
the tokens produced by PyMarkdown’s parser, I have found enough errors to
remove any questions in my mind regarding their usefulness.  From my point of view,
adding those consistency checks is not a “pull the fire alarm” concern, but more of a
“let’s put some extra water on the campfire and wait to be sure” concern.  These checks
are an important tool in a collection of tools that I use with each build to help me
ensure that my desired level of quality for the project is maintained.&lt;/p&gt;
&lt;p&gt;But while I have made great progress on the automated validation of those line numbers
and column numbers, validating the content of those tokens was a different story.
Each test already includes a comparison of the output text to the reference
implementation’s output, but I felt that it was only testing the scenario’s output, not
the input.  After all, there were times when I introduced a small change to the
structure of the token and token itself changed, but the HTML did not change one bit.
While I knew I had 100% coverage for the token’s output, I did not feel that I had the
right amount of coverage for the tokens themselves.&lt;/p&gt;
&lt;p&gt;The only way to really test this out?  Use the tokens themselves to generate the
Markdown that created them.  If the tokens contained all the needed information,
the regenerated input text should match the actual input text.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/20b129ee1b2058b4495395251d25a8fafa88bfa3"&gt;16 Jul 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="a-small-note-on-the-commit"&gt;A Small Note on the Commit&lt;a class="headerlink" href="#a-small-note-on-the-commit" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We all have weeks that are busier than others, and the week of 12 Jul 2020 was one of
those weeks for me.  All the substantial work on the commit was completed and
tested on 12 Jul 2020 before I started writing the last article.  However, it was not
until that Thursday that I was able to complete the usual cleanup and refactoring that
I require before I submit a normal commit.&lt;/p&gt;
&lt;p&gt;While this does not affect the work that was done, the timing of the actual work was
important to me, for reasons described in the next section.&lt;/p&gt;
&lt;h2 id="beware-of-rabbit-holes"&gt;Beware of Rabbit Holes&lt;a class="headerlink" href="#beware-of-rabbit-holes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I feel that I both wanted and needed to add these new checks, I also knew that I
needed to be cautious.  It was less than a month ago when
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/"&gt;I lost my way&lt;/a&gt;
trying to add tab support to the consistency checks, and I was still smarting from that
experience.  Instead of hitting a difficult problem and taking a step back
to reevaluate the situation, I just kept on going, not realizing how much time had
passed on that one problem.  When I did stop and look up at where I was, it was almost
immediately evident that I got lost in the problem… again.&lt;/p&gt;
&lt;p&gt;As this was another major task for consistency checks, I was keenly aware that I was
going to need to take better precautions this time around.  If I did not, I was likely
to fall into the same pattern and get lost again.  As such, I was determined to come up
with a firm set of rules that I would follow for this task.  After some thought on
those rules, the rules that I came up with are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no tab support&lt;ul&gt;
&lt;li&gt;no need to go down that path again so soon!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;no container block support&lt;ul&gt;
&lt;li&gt;get the basics down, then complicate things!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;primary support for the text token, the paragraph token, and the blank line token&lt;ul&gt;
&lt;li&gt;these are the primary building blocks for the document&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;no other leaf block support except for the thematic break and the indented code block tokens&lt;ul&gt;
&lt;li&gt;the indented code block token modifies the output from the text tokens, thus making sure that changing that output&lt;/li&gt;
&lt;li&gt;the thematic break token provides another external touchpoint that non-text related tokens are possible&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;no inline support except for the hard break token&lt;ul&gt;
&lt;li&gt;one inline token would prove that the others would be possible&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;proper support for the character sequences and the backslash escape character&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, I decided to help mitigate the risk of going down a rabbit hole for this
new feature by
&lt;a href="https://en.wikipedia.org/wiki/Timeboxing"&gt;timeboxing&lt;/a&gt;
the work on the task to approximately 36 hours clock time.  While I did do a bit of
research before that Friday night, the time I allocated for this task was from Friday
after work until I started writing my article on Sunday morning.  As I have never been
late with an article, despite coming close a couple of times, I knew that it would be a
good stopping point that I would not ignore easily.&lt;/p&gt;
&lt;h2 id="starting-down-the-path"&gt;Starting Down the Path&lt;a class="headerlink" href="#starting-down-the-path" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I have plans to simplify it later, as I did with my work on
&lt;a href="https://jackdewinter.github.io/2020/03/16/markdown-linter-verifying-base-scenarios/#adding-translating-into-html"&gt;validating the base scenarios&lt;/a&gt;,
the
first iteration of this code was going to be somewhat messy while I figured
things out.  But the base bones of the transformer started out very cleanly with the
following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Transform the incoming token stream back into Markdown.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="n"&gt;transformed_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# do stuff&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;transformed_data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not very glamorous, but a good starting point.  As with anything that transforms
something list related, I needed to perform some action on each token, that action
being represented by the comment &lt;code&gt;do stuff&lt;/code&gt;.  Just a good and solid place to start.&lt;/p&gt;
&lt;h3 id="baby-steps-setting-up-for-token-discovery"&gt;Baby Steps - Setting up for Token Discovery&lt;a class="headerlink" href="#baby-steps-setting-up-for-token-discovery" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The next step was a simple one: discover all the tokens I would need to eventually
transform.  As I took this same approach with the &lt;code&gt;TransformToGfm&lt;/code&gt; class, and that
approach was successful, I decided to adopt the same process with this new class.
I started by adding this code in place of the &lt;code&gt;# do stuff&lt;/code&gt; comment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;pass&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"next_token&amp;gt;&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once that was done, I then modified it to take care of the end tokens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;pass&lt;/span&gt;
            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;adjusted_token_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
                    &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;pass&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"end_next_token&amp;gt;&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjusted_token_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"next_token&amp;gt;&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, this code is not glamorous, but it is setting up a good solid framework for
later.  The purpose of this code is to make sure that when I start dealing with actual
tokens, I get a clear indication of whether an if statement and a handler function
exist for that token.  If not, the appropriate assert fails and lets me know which
token is not being handled properly.  In this way, any encountered token must have
a matching if statement and handler, or the transformation fails quickly.&lt;/p&gt;
&lt;h3 id="setting-up-the-test"&gt;Setting Up the Test&lt;a class="headerlink" href="#setting-up-the-test" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that in place, I started with a very simple test function,
&lt;code&gt;verify_markdown_roundtrip&lt;/code&gt;.  This function started with the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;verify_markdown_roundtrip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;

    &lt;span class="n"&gt;transformer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TransformToMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;original_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transformer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;Expected&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;source_markdown&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;Actual&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;original_markdown&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;original_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Strings are not equal."&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While I added better error reporting over the course of this work, it started
with a simple test and simple error reporting.  The first two lines of this function
check for a tab character and, if present, exit quickly before any real processing is
done, as tab handling is out of scope.  With that check accomplished, the next 2 lines
create an instance of the transformer
and invoke the &lt;code&gt;transform&lt;/code&gt; function on the list of tokens.  Finally, after printing
some debug information, the &lt;code&gt;source_markdown&lt;/code&gt; variable is compared to the
&lt;code&gt;original_markdown&lt;/code&gt; variable containing the regenerated Markdown.  If the two strings
match, the validation passes, and control is passed back to the caller for more
validation.  If not, the assert fails, and the test is halted.&lt;/p&gt;
&lt;p&gt;The invoking of this function was easily added at the top of the
&lt;code&gt;assert_token_consistency&lt;/code&gt; function, which conveniently was already in place and being
called by each of the scenario tests.  As such, the extra consistency checking was
added to the consistency checks with only a single line change to invoke the
&lt;code&gt;verify_markdown_roundtrip&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assert_token_consistency&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Compare the markdown document against the tokens that are expected.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="n"&gt;verify_markdown_roundtrip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;split_lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After running the tests a couple of times, it was obvious that some work needed to be
done to add if statements and handlers.  And as it is the most central part of most
Markdown documents, it made sense to start with the paragraph token.&lt;/p&gt;
&lt;h3 id="starting-to-discover-tokens"&gt;Starting to Discover Tokens&lt;a class="headerlink" href="#starting-to-discover-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Once that foundational work was done, I started running the tests and dealing with the
asserts that fired. Each time I encountered an assert failure, I added an if statement
to the normal token or end token block as shown here with the paragraph token:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;pass&lt;/span&gt;
            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;adjusted_token_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
                    &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;adjusted_token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;pass&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"end_next_token&amp;gt;&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjusted_token_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"next_token&amp;gt;&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once I was no longer getting failures from one of the two asserts, I was faced with
another issue.  There were tokens that I recognized with an if statement, but any
handler for that token was out of scope for the time being.  To deal with this,
I made a small modification to the &lt;code&gt;transform&lt;/code&gt; function to allow me to skip those
tokens that were not yet supported by setting the &lt;code&gt;avoid_processing&lt;/code&gt; variable to &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Transform the incoming token stream back into Markdown.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="n"&gt;transformed_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="n"&gt;avoid_processing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;pass&lt;/span&gt;
            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_thematic_break&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt;
                &lt;span class="o"&gt;...&lt;/span&gt;
            &lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;avoid_processing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

                &lt;span class="n"&gt;adjusted_token_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
                    &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;adjusted_token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="o"&gt;...&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"end_next_token&amp;gt;&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjusted_token_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"next_token&amp;gt;&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;transformed_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;avoid_processing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, the &lt;code&gt;avoid_processing&lt;/code&gt; flag was set to &lt;code&gt;True&lt;/code&gt; for any token that was
recognized by the function but did not have a handler implemented.  Then, with a small
change to the &lt;code&gt;verify_markdown_roundtrip&lt;/code&gt; function, that function could then be
instructed to avoid comparing the two markdown variables.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;verify_markdown_roundtrip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;

    &lt;span class="n"&gt;transformer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TransformToMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;original_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;avoid_processing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transformer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;avoid_processing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Processing of token avoided."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;Expected&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;source_markdown&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;Actual&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;original_markdown&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;-=-=-&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;original_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Strings are not equal."&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this sometimes felt like cheating to me, it was a solid plan.  If any
token in the token list was not supported, it clearly stated it was avoiding
processing.  If that statement was not present and the debug output was present,
I was sure that the comparison was made cleanly.&lt;/p&gt;
&lt;h3 id="why-was-this-a-clear-stop-gap-solution"&gt;Why Was This a Clear Stop-gap Solution?&lt;a class="headerlink" href="#why-was-this-a-clear-stop-gap-solution" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I believe it is a very clean solution. As I knew from the start that I was going to be
implementing this check in stages, returning a boolean value from the &lt;code&gt;transform&lt;/code&gt;
function allows the transformer to specify if it has any trust in the results. But
unlike my emotion-based trust in the code base for the project, this trust was binary:
it was &lt;code&gt;True&lt;/code&gt; if I encountered any tokens that I had not yet accounted for, otherwise
it was &lt;code&gt;False&lt;/code&gt;.  Basically, if there was no code to handle the token, the function
returned &lt;code&gt;True&lt;/code&gt; to indicated that it was confident that the &lt;code&gt;transformed_data&lt;/code&gt; value
was incorrect.&lt;/p&gt;
&lt;p&gt;Given the situation, and wanting to handle the tokens in stages, I believe this is
the cleanest solution that I could come up with.  No hidden parts, a very small
area of code to determine if the check would be skipped, and almost no code to trip
out when handling for all the tokens was completed.&lt;/p&gt;
&lt;h3 id="leaving-the-foundational-work-behind"&gt;Leaving the Foundational Work Behind&lt;a class="headerlink" href="#leaving-the-foundational-work-behind" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This foundational work put me in a good position to start transforming the tokens back
into their original Markdown.  While I was sure that this was not going to be easy,
I was sure that I had taken the right foundational steps to make this effort as easy
as it could be.  And if I was slightly wrong and needed a couple more things added to
the foundational code, I was sure that I could easily add them.&lt;/p&gt;
&lt;h2 id="terminology"&gt;Terminology&lt;a class="headerlink" href="#terminology" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I start to talk about actual work to reconstruct the original Markdown text from the
parsed tokens, I found out that I needed a simple name to describe the process to
myself.  I prefer to have functions named descriptively after the action they are coded for, preferably with at least one verb describing the action.  Repeating the last half
of the first sentence in each function name did not seem to be a sustainable solution,
especially not for the naming of Python variables.  I needed something more compact.&lt;/p&gt;
&lt;p&gt;After a certain amount of thinking, the process that I feel the comes closest to what
this transformation is accomplishing is rehydration.  Possibly taking influence from my
Java experience, the word &lt;code&gt;serialize&lt;/code&gt; means, according to
&lt;a href="https://en.wikipedia.org/wiki/Serialization"&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;translating data structures or object state into a format that can be stored […] and reconstructed later in the same or another computer environment&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the word is overused a lot, I looked up synonyms for serialize and &lt;code&gt;hydrate&lt;/code&gt;
was one of the words that was in the list.  In my mind, I was “just adding water” to the
data to get the original Markdown text back, so the new word &lt;code&gt;hydrate&lt;/code&gt; fit pretty wel.&lt;/p&gt;
&lt;p&gt;Therefore, I will use the word &lt;code&gt;hydrate&lt;/code&gt; in the rest of the article and in the
transformer code to signal that the transformer is reconstituting the Markdown.&lt;/p&gt;
&lt;h2 id="starting-with-the-paragraph-scenarios"&gt;Starting with The Paragraph Scenarios&lt;a class="headerlink" href="#starting-with-the-paragraph-scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In terms of picking a good place to start, I feel that the paragraph tokens were the
best place to start.  As paragraphs are usually the foundation of any Markdown
document, I was confident that cleaning up all the scenario tests in the
&lt;code&gt;test_markdown_paragraph_blocks.py&lt;/code&gt; module would be a good initial case.  Being simple
in their nature, that set of tests would cover the following types of tokens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;paragraph token (start and end) - all tests&lt;/li&gt;
&lt;li&gt;text token - all tests&lt;/li&gt;
&lt;li&gt;blank line tokens - 3 of 7 tests&lt;/li&gt;
&lt;li&gt;hard line break token - 2 of 7 tests&lt;/li&gt;
&lt;li&gt;indented code block token (start and end) - 1 of 7 tests&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It was a small set of tokens, easily constrained, and built on afterwards.&lt;/p&gt;
&lt;h3 id="paragraph-tokens-text-tokens-and-blank-line-tokens"&gt;Paragraph Tokens, Text Tokens, and Blank line Tokens&lt;a class="headerlink" href="#paragraph-tokens-text-tokens-and-blank-line-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In this group of tests, the simple tests were the easiest to verify, but the most
important to get right. With a grand total of 7 tests, 5 complete tests were simply
around the handling of these 3 basic tokens.  But it was early in the coding of
their handlers when I recognized that I needed to implement a simple stack to process
these tokens properly.&lt;/p&gt;
&lt;h3 id="simple-token-stack"&gt;Simple Token Stack&lt;a class="headerlink" href="#simple-token-stack" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The reason for the token stack was simple.  While I was just dealing with paragraph
tokens around the text token for the first 6 tests, the last test would require that I
handle a different leaf token around the text token: the indented code block token.
Instead of doing the work twice, once to just save the paragraph token somewhere and
second to implement a proper token stack, I decided to skip right to the stack
implementation.&lt;/p&gt;
&lt;p&gt;This stack was created to be simple in its nature.  The current block would remain at
the top of the stack, to be removed when it went out of scope with the end block token.
The initial test was to make sure that the text tokens for the examples can extract
information from the encompassing paragraph token as needed.  This is important because
any whitespace at the start or end of each paragraph-text line is removed for the HTML
presentation but stored for other uses in the paragraph token.&lt;/p&gt;
&lt;p&gt;Therefore, the following functions were added to handle the task of keeping the stack
synchronized with the paragraph tokens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_paragraph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;block_stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_paragraph_end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;top_stack_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="back-to-the-text-token"&gt;Back to the Text Token&lt;a class="headerlink" href="#back-to-the-text-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Getting back to the actual hydration cases, the rehydration of the basic text block
is simple to explain but takes a lot of code to accomplish.  The general algorithm
at this stage was as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;leading_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;block_stack&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# Get whitespace from last token on the stack and split it on new lines&lt;/span&gt;
            &lt;span class="c1"&gt;# Get the text from the current token and split it on new lines&lt;/span&gt;
            &lt;span class="c1"&gt;# Properly recombine the whitespace with the text&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;leading_whitespace&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;combined_text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For basic paragraphs, because of the GFM specification, any leading or trailing
whitespace on a line is removed from the text before that text transformed into HTML.
However, as I thought there was a rule about excess space at the start and end of a
line in a paragraph, I made sure to append that text to the owning paragraph token.
In addition, when the paragraph itself starts but before the text token takes over,
there is a potential for leading whitespace that must also be considered.&lt;/p&gt;
&lt;p&gt;So, in addition to the above code to rehydrate the text token, the following changes
were needed to handle the start and end paragraph tokens properly.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_paragraph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;block_stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;line_end_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;line_end_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_paragraph_end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;top_stack_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;top_stack_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;final_whitespace&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that done, the text within the paragraph and around the paragraph was being
rehydrated properly.  At that point, I raised my glass of water and toasted the
project as the first 2 scenarios were now checking their content and passing. Yes!
From there, it was a short journey to add a 3 more tests to that roster by adding the
handling of the blank line token, as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_blank_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it was not a running start, this was the first time the entire content of those
5 scenario tests was validated!  It was enough to make me go for number 6!&lt;/p&gt;
&lt;h3 id="hard-line-breaks"&gt;Hard Line Breaks&lt;a class="headerlink" href="#hard-line-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From there, the scenario test for
&lt;a href="https://github.github.com/gfm/#example-196"&gt;example 196&lt;/a&gt;,
was the next test to be enabled, adding
support for hard line breaks.  Interestingly, when I wrote the algorithm for coalescing
the text tokens where possible, the new line character for the hard break was already
setup to be added to the following text token.  This leaves the hard line token
primarily as a “marker” token, with some additional information on the extra whitespace
from the end of the line.  As such, rehydrating the hard break properly was
accomplished by adding the following text.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_hard_break&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that made 6 tests that were now fully enabled!  But knowing that the last test in
that group dealt with indented code blocks, I decided to take a bit of a break before
proceeding with that token.  I needed some extra confidence.&lt;/p&gt;
&lt;h2 id="handling-backslash-characters"&gt;Handling Backslash Characters&lt;a class="headerlink" href="#handling-backslash-characters" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The interesting part about the parsing of this Markdown character is
that once it is dealt with, the original backslash character disappears, having
done its job.  While that was fine for generating HTML, rehydrating the original text
from a tokenized version of a string that originally contained a backslash was a
problem.  If it disappears, how does the code know it was there in the first place?&lt;/p&gt;
&lt;p&gt;To solve this issue, I had to resolve to a bit of trickery.  I needed to
determine a way to make the backslash character visible in the token without it being
visible in the HTML output.  But anything obvious would show up in the HTML output, so
I had to take a preprocessing step on the data and remove whatever it was that I would
add to denote the backslash.&lt;/p&gt;
&lt;h3 id="thinking-inside-of-the-outside-box"&gt;Thinking Inside of the Outside Box&lt;a class="headerlink" href="#thinking-inside-of-the-outside-box" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Trying a couple of solutions out, the one that held the most promise for me was to use
(or misuse) the backspace character.  In Python, I can easily add the sequence &lt;code&gt;\b&lt;/code&gt; to
a string to denote the backspace character.  When use this format to write out the text
for the token containing a backslash, I would now add &lt;code&gt;\\\b&lt;/code&gt; in place of the backslash
to allow it to be placed in the token.&lt;/p&gt;
&lt;p&gt;To show an example of this, consider the Markdown text &lt;code&gt;a\\*b\\*&lt;/code&gt;, used to create HTML
output of &lt;code&gt;a*b*&lt;/code&gt; without the asterisk character getting misinterpreted as emphasis.
Before this change, the text in the token would have been &lt;code&gt;a*b*&lt;/code&gt;, without the inline
processor splitting the emphasis sequences into their own tokens for interpretation.
After this change, the text in the token is &lt;code&gt;a\\\b*b\\\b*&lt;/code&gt;, keeping the backslashes
in the data, but with the backspace character following them.&lt;/p&gt;
&lt;p&gt;But now that I had a special character in there, I would need to preprocess those
strings.&lt;/p&gt;
&lt;h3 id="dealing-with-the-complications"&gt;Dealing with the Complications&lt;a class="headerlink" href="#dealing-with-the-complications" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;How does the preprocessing work?  In the case of the HTML transformer, the
preprocessing uses the new &lt;code&gt;resolve_backspaces_from_text&lt;/code&gt; function to scan the incoming
string for any backspace characters.  When a backspace characters are encountered, it
is removed along with the character proceeding that backspace character.  In this
manner,
the HTML output is identical to how it was before this change.  Using the above example
of &lt;code&gt;a\\\b*b\\\b*&lt;/code&gt;, this preprocessing would render that string as &lt;code&gt;a*b*&lt;/code&gt;, removing
each of the backspace characters and the backslash characters before them.&lt;/p&gt;
&lt;p&gt;In the case of the new Markdown transformer, a similar algorithm is used that simply
replaces any backspace characters with the empty string.  Because the end effect is to
restore the data to the way it was
before, removing the backspace character by itself leaves the data in its original
form. Once again using the above example of &lt;code&gt;a\\\b*b\\\b*&lt;/code&gt;, when the backspace
characters are removed from the string, the string is changed into &lt;code&gt;a\\*b\\*&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While it took me a while to arrive at this preprocessing solution, it worked flawlessly
without any modifications.  It was just a simple way to handle the situation. And
because it is a simple way, it is also simple to read and understand when dealing
with the data for the scenarios.  After all,
when I type in code or a document, I use the backspace key to erase the last character
I typed.  This just extends that same paradigm a small amount, but to good use.&lt;/p&gt;
&lt;h3 id="the-fallout"&gt;The Fallout&lt;a class="headerlink" href="#the-fallout" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As this change affects everywhere that a backspace character can be used, there were
some sweeping changes needed in multiple locations to deal with the now escaped
backslash characters.  The &lt;code&gt;InlineHelper&lt;/code&gt; module’s &lt;code&gt;handle_inline_backslash&lt;/code&gt; function
was changed to take an optional parameter &lt;code&gt;add_text_signature&lt;/code&gt; to determine whether
the new &lt;code&gt;\\\b&lt;/code&gt; sequence was added when a backslash was seen in the Markdown.
That was the easy part.&lt;/p&gt;
&lt;p&gt;In any of the places where that function was called, I traced back and figured
out if there was a valid escape for adding the new text signature.  In a handful of
cases, the original string was already present, so no new transformations were
required, passing in a &lt;code&gt;False&lt;/code&gt; for the &lt;code&gt;add_text_signature&lt;/code&gt;.  But the more prevalent
case was for the calls that passed in &lt;code&gt;True&lt;/code&gt;.  And it did not end there.  This process
needed to be repeated with each function that called each of those functions, and so
on.&lt;/p&gt;
&lt;p&gt;In the end, it was worth it.  It was a clean way to deal with having the backslash in
the token if needed and removing the backslash when it was not needed.&lt;/p&gt;
&lt;h2 id="indented-code-block-tokens"&gt;Indented Code Block Tokens&lt;a class="headerlink" href="#indented-code-block-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For the most part, the indented code blocks were simple.  Like how the
text tokens were handled for paragraphs, the trick was to make sure that the right
whitespace was added to the text tokens.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;reconstitute_indented_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;main_text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prefix_text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;leading_whitespace&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;split_main_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;main_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;recombined_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;next_split&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;split_main_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;next_split&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;recombined_text&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;prefix_text&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;leading_whitespace&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;next_split&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
                &lt;span class="n"&gt;leading_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;recombined_text&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;next_split&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;recombined_text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The nice thing about the new &lt;code&gt;reconstitute_indented_text&lt;/code&gt; function was that it was
simple to start with, as shown above.  Take the text from the text token, and put
it back together, keeping in mind the extra whitespaces at the start of each line.
In short order, the single scenario test in the &lt;code&gt;test_markdown_paragraph_blocks.py&lt;/code&gt;
module dealing with indented code block tokens was passing, and most of the
indented code block scenario tests were also passing.  It was then down to 2
scenario tests to get enabled.&lt;/p&gt;
&lt;h3 id="handling-character-references"&gt;Handling Character References&lt;a class="headerlink" href="#handling-character-references" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Character references on their own are a vital part of Markdown.  When you want to
be specific about a character to use, there is no substitute for using the ampersand
character and the semi-colon character and specifying the specifics of the character
you want between the two.  But as with backslashes, these character references
represented an issue.&lt;/p&gt;
&lt;p&gt;Like the backslash disappearing after it is used, the character references also
disappear once used.  But in this case, the mechanics were slightly different. If
the resultant token and HTML contains the copyright character &lt;code&gt;©&lt;/code&gt;, there are three
paths to getting that Unicode character into the document.  The first is simply to use a
Unicode aware editor that allows the typing of the &lt;code&gt;©&lt;/code&gt; character itself.  If that
fails, the next best approach is to use a named character entity, adding &lt;code&gt;&amp;amp;copy;&lt;/code&gt;
to the document.  Finally, the numeric character reference of &lt;code&gt;&amp;amp;#xA9&lt;/code&gt; or &lt;code&gt;&amp;amp;%169;&lt;/code&gt;
can also be used to insert that character into the token.  The problem is, if the
token contains the character &lt;code&gt;©&lt;/code&gt;, which of the 4 forms were used to place it there?&lt;/p&gt;
&lt;p&gt;Similar to the way I used the backspace character with the backslash character, in
this case I used the alert character (&lt;code&gt;\a&lt;/code&gt;) as a way to specify that a series of
characters have been replaced with another series of characters.  Using the previous
example of the copyright character, if the character was specified by using the
actual Unicode character itself, no alert characters were needed as nothing changed.&lt;/p&gt;
&lt;p&gt;But in the cases where the character entities were used, to indicate “I saw this
entity, and I replaced it with this text”.  For example, if the Markdown contained
the text &lt;code&gt;&amp;amp;copy; 2020&lt;/code&gt;, the text would be replaced with &lt;code&gt;\a&amp;amp;copy;\a©\a 2020&lt;/code&gt;. While
it takes a bit of getting used to, reading this in the samples quickly became easy
to read.  For the HTML output, all 3 occurrences of the alert character were searched
for, and the text between the second and third alert was output, and the rest ignored.
In the case of rehydrating the Markdown text, the text between the first and the second
alert was output, and the rest of that text was ignored.&lt;/p&gt;
&lt;p&gt;The fallout of this change was of a similar scope to that of the fallout for the
backspace character changes.  There were a few places where this change had to be
turned off, but due to sheer luck, most of those places were the same for the backspace
character and for the alert character.  While it took a small amount of time to get
things right, once again it was a clean solution.&lt;/p&gt;
&lt;h3 id="indented-code-blocks-and-blank-lines"&gt;Indented Code Blocks and Blank Lines&lt;a class="headerlink" href="#indented-code-blocks-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;All the other scenarios down, and one to go!  And… I hit a wall.  But unlike some of
the other walls that I hit, this one was a good one.  When I looked at this remaining
case, the scenario test for
&lt;a href="https://github.github.com/gfm/#example-81"&gt;example 81&lt;/a&gt;,
I knew that there was going to be a cost to
getting this test to pass its consistency check. And while I could go ahead and
work on it, I made the decision that the work to get this one case passing was out of
the present cope of work that I agreed to do.&lt;/p&gt;
&lt;p&gt;The scenario?  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;chunk1&lt;/span&gt;

    &lt;span class="n"&gt;chunk2&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;chunk3&lt;/span&gt;&lt;span class="ss"&gt;""&lt;/span&gt;&lt;span class="err"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(To make the spaces visible on the blank lines, I replaced them in the above Markdown
sample with the text &lt;code&gt;{space}&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Double checking the code for the indented code blocks,
if the blank lines contained at least 4 or more space characters, the tokenization
proceeded properly, and the rehydration of the text was fine.  But in the case where
the blank lines did not contain enough spaces, that was another issue.&lt;/p&gt;
&lt;p&gt;While it is not specifically spelled out in the GFM specification, example 81 makes it
clear that blank lines do not end indented code blocks, regardless of whether they
start with 4 space characters.  But looking at the tokens, the only way that I
could think of to address this issue was to put any extracted spaces in the
indented code block token itself.  This would allow them to be used later, if needed,
by transformers such as the Markdown transformer.&lt;/p&gt;
&lt;p&gt;But thinking about it clearly, I felt that this work was beyond the scope of the
current rules for this task. I figured that I had a choice between finishing up the
task with thematic break token support completed or getting mired down with this
one scenario and not properly completing the task.  While I was not initially happy
about the idea, I noted the item down in the issues list, disabled the consistency
checks for the test, and continued.&lt;/p&gt;
&lt;h2 id="thematic"&gt;Thematic&lt;a class="headerlink" href="#thematic" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To wrap up this block of work, I just needed to complete the handling of the thematic
break token.  As this is a simple token, I expected a simple implementation to
rehydrate it, and I was not disappointed.  The text that it took to complete
the rehydration of the thematic breaks was as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rehydrate_thematic_break&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rest_of_line&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Simple, short, and sweet.  No surprises.  A nice way to end.&lt;/p&gt;
&lt;h2 id="along-the-way"&gt;Along the way…&lt;a class="headerlink" href="#along-the-way" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In total, I added 6 items to the issue list because of things I noticed during this
work.  While I was
sure that 4-5 were actual issues, I was okay with the remaining issues being good
questions for me to answer later.  It just felt good to be able to write a new item
down and clear it from my mind.  It helped me stay on track and keep my focus.
And that is a good thing!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To be honest, I believe I was so worried about going down another rabbit hole that it
got in the way of my creativity a bit.  Not so much that I could not get the work done,
but it was there.  And thinking back to that time, I am not sure if that was a good
thing or a bad thing.&lt;/p&gt;
&lt;p&gt;On the bad side, it caused me to question myself a lot more.  With each decision
I made, I reviewed it against the goals that I specified at the start of this article.
Did it pass?  If no, then try again.  If yes, what was the scope?  If depth of the
scope was too unexpected or too large, then try again.  If yes, start working on it.
At various points within the task, stop to reevaluate those same questions and make sure
I was staying within the scope.   It definitely was annoying at first.&lt;/p&gt;
&lt;p&gt;On the good side, it was probably what I needed. And I hate to say it, it probably was a
good annoying.  I do not need to continue to have this internal conversation for smaller
tasks. But for this big task, that frequent dialogue helped me focus on keeping the
task on track.  If I noticed something that was not in scope, I just added it to the
issues list and moved on.  If I had a question about whether something was written
properly, I just added it to the issues list and moved on.  It is not that I do not care
about these issues, it is that I can more about completing the task and not getting
lost on something that is off task.  There will be time later to deal with those.&lt;/p&gt;
&lt;p&gt;All in all, I believe this chunk of work went well.  Sure, I pushed my 36 hour time
limit to the max, resulting in my article getting written later than I am usually
comfortable with.  I also pushed my definition of “complete” to the max, as I noted in
the section on
&lt;a href="https://jackdewinter.github.io/2020/07/20/markdown-linter-transforming-back-to-markdown/#a-small-note-on-the-commit"&gt;A Small Note on the Commit&lt;/a&gt;.
All the work
was completed before I started that week’s article, even if I took me another 3-4 hours
to clean it up enough before committing it to the repository. After all an agreed upon
rule is a rule, and I kept to each of them.  Even if I strained them a bit.&lt;/p&gt;
&lt;p&gt;I was happy with how I handled myself with this task.  I did not get too bogged down
that I got nothing done, and I did not go down any rabbit holes.  It was a good week!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having encountered a number of bugs and possible logs that were logged in the issue’s
list, it just made sense to tackle those right away.  Especially for something that is
meant to track the consistency of the tokens, it does not look good to have bugs against
it.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Improving Consistency</title><link href="https://jackdewinter.github.io/2020/07/13/markdown-linter-improving-consistency/" rel="alternate"></link><published>2020-07-13T00:00:00-07:00</published><updated>2020-07-13T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-07-13:/2020/07/13/markdown-linter-improving-consistency/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/06/markdown-linter-weeding-the-projects-issue-list/"&gt;last article&lt;/a&gt;,
I talked about how I “weeded” the project’s issues list to build up my confidence that
the PyMarkdown project was going in the right direction.  In this article, I talk about
how I used that confidence to get back to work on the consistency …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/07/06/markdown-linter-weeding-the-projects-issue-list/"&gt;last article&lt;/a&gt;,
I talked about how I “weeded” the project’s issues list to build up my confidence that
the PyMarkdown project was going in the right direction.  In this article, I talk about
how I used that confidence to get back to work on the consistency checker for the
tokenizer that is the backbone of the PyMarkdown linter.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the
&lt;a href="https://jackdewinter.github.io/2020/07/06/markdown-linter-weeding-the-projects-issue-list/#what-was-my-experience-so-far"&gt;end of the last article&lt;/a&gt;,
I talked about how confidence is more emotional than logical.  From that point of view,
resolving items off my issues list was more to fan my passion for the PyMarkdown
project that any logical reason.  And while there are logical components to my
desire to instill quality to the project at every stage, it is mostly an emotional
desire to make it better.  It is true that part of that desire is due to my experience.
I know the large cost of fixing a bug once a product is released, and I want to avoid
as many of those issues as possible as soon as possible.
But another part of that desire is because that I know that once I put the project out
there, it will be considered a reflection of my abilities. Due to both reasons
and others, I just want the project to have a healthy level of quality that I have
confidence that I can maintain.&lt;/p&gt;
&lt;p&gt;It was because of that desire to maintain or increase quality on the project that I
started to think about whether the cost of my efforts was worth the benefits that I
was seeing.  Was it worth it?&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4b681751cae38ce2007f3b0ada6158ed9a15f353"&gt;28 Jun 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/e1fad8fc839d78f52040ef849e444d1d9b623c4a"&gt;05 Jul 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="is-the-cost-worth-the-benefit"&gt;Is the Cost Worth The Benefit?&lt;a class="headerlink" href="#is-the-cost-worth-the-benefit" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the end, the tokens that are generated by the project’s parser are just a series of
letters and numbers that must be verified for each scenario.  For the parser’s
scenarios alone, there are 728 scenario tests that are used to verify that parser’s
output whenever a change is made. The validation of those same tests is made easier by
the test foundations that are already in place: checking the produced tokens against a
static list for that scenario, and checking the output from transforming those tokens
against the HTML snippet for that scenario.&lt;/p&gt;
&lt;p&gt;The HTML part of that verification is easy: it either matches the reference HTML output
or it does not.  The tokens are a lot more difficult to verify.  Is the actual content
correct?  Are the line number and column number correct?  Was the correct amount of
whitespace stored in the token to allow us to generate the HTML properly?  While I try
my hardest to ensure that the token information is correct, I do make mistakes.&lt;/p&gt;
&lt;p&gt;And that is where I see the benefit of consistency checks.  As I documented in
&lt;a href="https://jackdewinter.github.io/2020/07/06/markdown-linter-weeding-the-projects-issue-list/"&gt;my last article&lt;/a&gt;,
there are enough parser rules to remember that I regularly add items to the project’s
issues list to check later.  But I have also noticed that even the act of answering
those questions and whether those rules were applied properly can increase my
confidence in the project.  And if those answers can increase my confidence by
themselves, working on
completing those checks should have an even larger impact.&lt;/p&gt;
&lt;p&gt;From where I was, even though the cost of adding the consistency checks was starting to
grow, I felt that my increased confidence in the project was an acceptable
benefit given that cost.  As such, it was forward with the consistency checks!&lt;/p&gt;
&lt;h2 id="lists-and-blank-lines"&gt;Lists and Blank Lines&lt;a class="headerlink" href="#lists-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes it is the large issues that bother us the most. But often, I
find it is the smaller items that really grind away at my mind.  If I have not started
a task, I try to make sure that I have lined up as many of the requirements for that
task as possible up before I start on the task.  This preparation helps me to focus on
the task and
to work on that task without too many interruptions.  But, as is normal in my line of
work, I have had to adapt to make sure that I can switch away from a
task before it is completed.  I am usually okay with this, as I often I find a good
stopping point and document why I stopped and what I was thinking, hoping that it
helps me pick it up later.  But if I am close to finishing a task and I know
there are only a “couple” of things left to go on that task, it is hard for me to
resist getting it over that finish line.  Just so very tough.&lt;/p&gt;
&lt;h3 id="identifying-the-issue"&gt;Identifying the Issue&lt;a class="headerlink" href="#identifying-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This was the case with lists and blank lines, the subject of an item being researched
and further documented in
&lt;a href="{filename}/articles/SoftwareQuality/core-7.md.#scenarios-197-257-and-262-blank-lines-and-lists#scenarios-197-257-and-262-blank-lines-and-lists"&gt;the last article&lt;/a&gt;
This issue was not an overly big issue per se, but it was the issue that was gnawing at
me.  Specifically, I looked at one of the two list examples that start with a blank
line, &lt;a href="example-257"&gt;example 257&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the text before example 257, which clearly states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When the list item starts with a blank line, the number of spaces following the list marker doesn’t change the required indentation:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Based on that information, a start unordered list token occupies column 1, and the
number of spaces following the list marker is 1, for a total of 2.  As such, the
blank line, being contained within the list, starts at column number 2, with the extra
whitespaces added to the end of the line.  So why was I seeing the token &lt;code&gt;[BLANK(1,5):]&lt;/code&gt;
instead of the expected token &lt;code&gt;[BLANK(1,2):  ]&lt;/code&gt;?&lt;/p&gt;
&lt;h3 id="working-the-problem"&gt;Working the Problem&lt;a class="headerlink" href="#working-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Doing some research, the answer was easy.  The blank line token was not wired up to
capture the following spaces, something that was quickly fixed.  But even with that
fixed, when the whitespace went to the end of the line, the count of the following
spaces was simply zeroed out within the list handler.  To fix this, I had to take
some time and create a new algorithm from scratch, paying extra attention to ensure
that trailing spaces were put in the right location.&lt;/p&gt;
&lt;p&gt;I knew that the block quote tokens needed a rewrite to track the skipped block quote
characters and their trailing space characters, so I left that part alone.  But I did
update the issue to note that the list case had been fixed.  &lt;/p&gt;
&lt;h3 id="improving-consistency"&gt;Improving Consistency&lt;a class="headerlink" href="#improving-consistency" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the blank token issue fixed, I then was able to add needed logic to the consistency
checker.  Previously, the content of the &lt;code&gt;__validate_same_line&lt;/code&gt; function was pretty
sparse:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CONTAINER_BLOCK&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;last_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was time to change that!&lt;/p&gt;
&lt;p&gt;Keeping in mind that I had only addressed the above issue for blank line tokens within
a list token, the first thing I did was to exclude
the block tokens from the new code.  Then, remembering some previous work that I did,
I knew there were going to be three different asserts that
I would need to do: one for blank lines, one for indented code blocks, and one for
everything else.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_blank_line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indent_level&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_indented_code_block&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indent_level&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indent_level&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For blank lines tokens on the same line as a list token, the blank line tokens start
right after the list token, so the &lt;code&gt;index_number&lt;/code&gt; is the same as the list’s
&lt;code&gt;indent_level&lt;/code&gt;.  Because the indented code block token includes whitespace in its
column number, there is a bit of correction to do to take that into account.  Other than
that, the remaining leaf block tokens verify that they start at the &lt;code&gt;indent_level&lt;/code&gt;
specified by the list.&lt;/p&gt;
&lt;p&gt;After testing and manual verification, that change to the check was completed and
verified.  I examined around ten related scenario tests, and double checked the
results from the new modifications. But even after that extra validation, I was left
with a feeling that something was left undone.  I was not sure what it was, but
it was something to think about as I worked.&lt;/p&gt;
&lt;h2 id="making-position-markers-immutable"&gt;Making Position Markers Immutable&lt;a class="headerlink" href="#making-position-markers-immutable" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Honestly, the title that I was thinking of for this section was “Making Position
Markers as Immutable as Python Will Allow”, but I thought that was too long.  But let’s
get that out of the way upfront.  Python does not have a concept of an
immutable complex object.  Like most languages, the base objects (such as strings,
integers, and floats) are immutable, meaning they cannot be changed once instantiated.
To me, this makes perfect sense. If you create one of these base objects, it always
retains its properties.  If you add two of these objects together, you create a
third object to contain the results.  Basic computer science 101.&lt;/p&gt;
&lt;p&gt;Python complex objects are not so nice with respect to immutability.  Sure, there are
tricks to
prevent overwriting of well-known objects within a class, but there is no built-in
support for creating an immutable complex object in Python.&lt;sup id="fnref:norOthers"&gt;&lt;a class="footnote-ref" href="#fn:norOthers"&gt;1&lt;/a&gt;&lt;/sup&gt; Conveniently,
I did not need
the &lt;code&gt;PositionMarker&lt;/code&gt; class to be 100% immutable, just immutable enough that I do not add
code that overwrites the member variables from that class by accident.&lt;/p&gt;
&lt;h3 id="benefits-of-immutable-objects"&gt;Benefits of Immutable Objects&lt;a class="headerlink" href="#benefits-of-immutable-objects" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Why is this important to me?  Partly cleanliness and partly experience.  Immutable
objects are just cleaner, as you can guarantee that their values will never change. If
you instantiate an immutable object as the first object in your program, it will still
have the same value that it was instantiated with when the program ends.  From
experience, immutability provides a level of safety that is desirable.&lt;/p&gt;
&lt;p&gt;This sense of safety is because immutable objects are useful where there
is a concern about &lt;em&gt;random&lt;/em&gt; side effects introduced by child objects and functions.
In the case of the parser, I know that before some previous refactorings, I
was passing the variables &lt;code&gt;text_to_parse&lt;/code&gt; and &lt;code&gt;start_index&lt;/code&gt; all over the place.  Even
after that refactoring, I remained concerned that the parser code could &lt;em&gt;accidentally&lt;/em&gt;
alter the existing &lt;code&gt;PositionMarker&lt;/code&gt; objects without a good way for me to detect it
or prevent it.  &lt;/p&gt;
&lt;p&gt;By changing the &lt;code&gt;PositionMarker&lt;/code&gt; class into a &lt;em&gt;mostly&lt;/em&gt; immutable object, those concerns
could be largely eliminated.  Any concerns of side effects would be mitigated by the
simple fact that once the value for the member variable was specified upon creation,
it cannot be changed.  Before this change was put in place, I knew where there were
cases where I was not 100% sure that I understood where the values in the object came
from.  If I did things right, after this change I would probably have a couple of extra
instantiations in the code, but I would know that the values were solid.&lt;/p&gt;
&lt;h3 id="making-the-change"&gt;Making the Change&lt;a class="headerlink" href="#making-the-change" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Far from one of the bulletproof approaches talked about on
&lt;a href="https://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python"&gt;Stack Overflow&lt;/a&gt;,
I just needed something simple to prevent accidental overwrites.  For my lightweight
approach, I chose to change the &lt;code&gt;PositionMarker&lt;/code&gt; class to expose its member variables
exclusively through properties.&lt;/p&gt;
&lt;p&gt;Before this change, the &lt;code&gt;line_number&lt;/code&gt; member variable was defined in the constructor with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When I needed to access the line number, I would simple take the instance name of
the &lt;code&gt;PositionMarker&lt;/code&gt; class, say &lt;code&gt;position_marker&lt;/code&gt;, and append &lt;code&gt;.line_number&lt;/code&gt; to it:
&lt;code&gt;position_marker.line_number&lt;/code&gt;.  Clean, simple, and neat, but also mutable.  Just
as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;assigns the value of the &lt;code&gt;position_marker&lt;/code&gt; instance’s &lt;code&gt;line_number&lt;/code&gt; member variable to
the local variable &lt;code&gt;x&lt;/code&gt;, the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;assigns the value of the local variable &lt;code&gt;x&lt;/code&gt; to the &lt;code&gt;line_number&lt;/code&gt; member variable.&lt;/p&gt;
&lt;p&gt;To make the &lt;code&gt;line_number&lt;/code&gt; member variable &lt;em&gt;mostly&lt;/em&gt; immutable, I simply changed its
instantiation to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and added a property getter named after the original variable name, but without adding
a property setter:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@property&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Gets the line number.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__line_number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By doing this for each member variable, two things were accomplished.  The first thing
was that by prefacing the member variable’s name with &lt;code&gt;__&lt;/code&gt;, I declared it as a
private variable.  Variables declared as such are only able to be changed from within
the class that declared them.&lt;sup id="fnref:caveat"&gt;&lt;a class="footnote-ref" href="#fn:caveat"&gt;2&lt;/a&gt;&lt;/sup&gt;  Then, by adding a property that has the name
of the variable without the prefix (&lt;code&gt;line_number&lt;/code&gt; vs. &lt;code&gt;__line_number&lt;/code&gt;), I provided
a simple read-only access to the object’s properties.  It was simple, and it
did not require any renaming of read-only references to the member variables.&lt;/p&gt;
&lt;h3 id="cleanup"&gt;Cleanup&lt;a class="headerlink" href="#cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The cleanup that occurred as part of that change was mostly contained within the
&lt;code&gt;ContainerBlockProcessor&lt;/code&gt; class.  That made sense to me, as that is where most of the
manipulation of the position occurred after the block quote tokens and list tokens were
processed.  In that class, there were a handful of cases where I was directly
manipulating the
&lt;code&gt;PositionMarker&lt;/code&gt; member variables, which now required new &lt;code&gt;PositionMarker&lt;/code&gt; objects.
But since those new objects were all created within the &lt;code&gt;ContainerBlockProcessor&lt;/code&gt;
class, where I expected them to be created, it
was okay.  As a nice benefit, once that cleanup was completed, there were a few
functions where the passing in of a new &lt;code&gt;PositionMarker&lt;/code&gt; class was no longer needed,
resulting in some bonus dead code deletion.&lt;/p&gt;
&lt;p&gt;What did I gain by doing this?  Mostly confidence.  Before that change, I was
concerned that I would introduce some &lt;em&gt;random&lt;/em&gt; side effect in one of the processors.
Since the class became &lt;em&gt;mostly&lt;/em&gt; immutable and was only changed in the
&lt;code&gt;ContainerBlockProcessor&lt;/code&gt; class, I gained the confidence that a leaf block cannot
change any &lt;code&gt;PositionMarker&lt;/code&gt; object.  Furthermore, I can easily scan to see where
that class in instantiated, knowing in an instant where any changes are occurring,
and therefore why they occurred.&lt;/p&gt;
&lt;h2 id="preventing-consistency-checks-for-tabs"&gt;Preventing Consistency Checks for Tabs&lt;a class="headerlink" href="#preventing-consistency-checks-for-tabs" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With all those changes in place, I was able to go back and add extra logic
to prevent the consistency checks from executing if they encountered tab characters.
Until I was able to work on proper tab character support, I felt that this was a
good way to keep the consistency checks active without having to disable them in
scenario tests that dealt with tabs.  From a quality point of view, that felt like
a short-term solution to me, not something I wanted to use long term.&lt;/p&gt;
&lt;p&gt;The change side of this was implemented very quickly.  Within
the &lt;code&gt;utils.py&lt;/code&gt; module, I added calls to the &lt;code&gt;__calc_initial_whitespace&lt;/code&gt; function.
If the second returned value (often called &lt;code&gt;had_tab&lt;/code&gt;) was &lt;code&gt;True&lt;/code&gt;, the whitespace
contains a tab character.  Due to the simple nature of the consistency check
function, when this happened, I simply returned from the function at that point.&lt;/p&gt;
&lt;p&gt;With those changes made, I started to work on the testing and was surprised by the
result.  I was only able to uncomment one scenario test, &lt;code&gt;test_tabs_004&lt;/code&gt;. Digging
into the cases a bit, I came to an interesting realization.  I was missing the most
obvious use of tabs: in the prefixes of list content.&lt;/p&gt;
&lt;h2 id="extracting-list-item-whitespace"&gt;Extracting List Item Whitespace&lt;a class="headerlink" href="#extracting-list-item-whitespace" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the early design stages of the parser, I made a simple design choice that I
believe has saved me hours of work.  I designed the container block handlers to remove
any processed text before passing the remaining text on for further processing.  That
design allowed the leaf block processing to be kept simple.  The leaf block processor
only sees the text that it needs to see to do its processing, and nothing more.
Basically, the design
choice was to make sure that each processor, container block and leaf block, had a solid
definition of their responsibilities, and to keep to those responsibilities.&lt;/p&gt;
&lt;p&gt;Following that design, when the list block processing was added, the &lt;code&gt;indent_level&lt;/code&gt; was
used to figure out where the encompassed leaf block tokens would start.  Before the
&lt;code&gt;ListBlockProcessor&lt;/code&gt; passed the line to the &lt;code&gt;LeafBlockProcessor&lt;/code&gt;, it removed exactly
&lt;code&gt;indent_level&lt;/code&gt; characters from the start of the line, per that design.  As those
characters were part of the list’s structural indent, it was the list’s responsibility
to deal with those characters, not the &lt;code&gt;LeafBlockProcessor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This approach
worked fine until I needed to understand the composition of that extracted whitespace
to validate the token.  At that time, if the whitespace was composed of space
characters, everything remained fine.  One character of indent equals one space
character, and everything balances out.  But when one of those characters is a tab
character, that calculation was thrown out of whack.&lt;/p&gt;
&lt;p&gt;While properly handling tab characters was out of scope, being able to detect them to
properly disable the consistency check was not.  As far as I could tell, all the
remaining scenario cases that I wanted to uncomment contained a tab character in the
list part of the line.  If done properly, it would keep the responsibility of when
to enable and disable the consistency check in the purview of the check itself.
To me, that was the desired goal.&lt;/p&gt;
&lt;h3 id="correctly-extracting-the-whitespace"&gt;Correctly Extracting the Whitespace&lt;a class="headerlink" href="#correctly-extracting-the-whitespace" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To be able to detect the tab characters properly, a bit of juggling had to be done.
As the best way to know which container is active was still the token stack,
I modified all three list stack tokens to allow them to keep the instance of the
list markdown token that they started.  This allowed me to add the &lt;code&gt;add_leading_space&lt;/code&gt;
function to the two main list markdown tokens, effectively adding the whitespace
to the list markdown token that owns that whitespace. Once that foundation was setup,
I proceeded to modify the &lt;code&gt;__adjust_line_for_list_in_process&lt;/code&gt; function from the
&lt;code&gt;ListBlockProcessor&lt;/code&gt; to properly account for the leading spaces in the lines.&lt;/p&gt;
&lt;h3 id="properly-enabling-consistency-checks"&gt;Properly Enabling Consistency Checks&lt;a class="headerlink" href="#properly-enabling-consistency-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having completed that previous task, I knew that I was almost ready to go back and
clean up the work started in the previous section on
&lt;a href="https://jackdewinter.github.io/2020/07/13/markdown-linter-improving-consistency/#preventing-consistency-checks-for-tabs"&gt;Preventing Consistency Checks for Tabs&lt;/a&gt;.
The only thing that I needed to do is to make
sure that if the leading spaces contained the tab character, that the leading spaces
would be set to a single tab character.  While this assignment was a large
simplification of how to handle the tab character, the proper implementation could
wait.  I just needed it to work well enough for me to detect it.&lt;/p&gt;
&lt;p&gt;And it did work well enough.  By adding a couple of extra tab checks in the
right places, I was able to uncomment the remaining calls to the
&lt;code&gt;assert_token_consistency&lt;/code&gt; function within the &lt;code&gt;test_markdown_tabs.py&lt;/code&gt; module.
Between the previous tab checks and the extra tabs checks, the consistency checks were
now able to properly exclude any Markdown with a tab character from the checks.&lt;/p&gt;
&lt;p&gt;For me, this was just the right way to do it.  While I needed to comment out those
function calls at that time, it always felt like I was cheating.  It was not the
test’s responsibility to know when to disable the consistency check, it was the
consistency check that needed to make that decision.  By moving the determination of
how to handle tabs into the consistency checks, I felt that I more properly
constrained the problem to the responsible object.  It did not feel like cheating
any more.  It just felt right.&lt;/p&gt;
&lt;p&gt;But now that the consistency of the line/column numbers was in a better place, how
would I verify that the whitespace that I extracted was the correct whitespace?
If I wanted people to write solid linting rules, I want to give them solid data to
base those rules on.&lt;/p&gt;
&lt;h2 id="this-all-leads-up-to-this"&gt;This All Leads Up to This&lt;a class="headerlink" href="#this-all-leads-up-to-this" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given my stated desires to check the consistency of the tokens, I could only see
one way to be sure of the content of the tokens.  While in previous weeks it was a
small voice, that small voice was now starting to speak with its outdoor voice.  To
check the content, I would need to write a Markdown transformer.&lt;/p&gt;
&lt;p&gt;I had been thinking about working on this for a while, and even added an item to the
issues list to keep track of it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;## &lt;span class="nv"&gt;Features&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;Correctness&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;can&lt;/span&gt; &lt;span class="nv"&gt;we&lt;/span&gt; &lt;span class="nv"&gt;generate&lt;/span&gt; &lt;span class="nv"&gt;Markdown&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;tokens&lt;/span&gt;? &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="nv"&gt;we&lt;/span&gt; &lt;span class="nv"&gt;have&lt;/span&gt; &lt;span class="nv"&gt;enough&lt;/span&gt; &lt;span class="nv"&gt;info&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To me, it felt like I was trying to avoid going down this route, afraid that writing
a Markdown transformer would result in me going down another rabbit hole.  Given my
recent experience, I believe it was an acceptable concern that I needed to address
if I decided to write the Markdown transformer.&lt;/p&gt;
&lt;p&gt;But from a quality point of view, I felt that writing the transformer was inevitable.
Outside of manual validation,
the only way that I could validate that that tokens were accurately representing the
Markdown document was to regenerate the original document from the tokens.  As much
as I tried to convince myself otherwise, I just could not see another path that would
provide me with the same level of quality and confidence I that I believe the project
deserves.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the actual work that was documented in this article varied from the work
documented in the last article, the goals driving both were the same:
quality and confidence.&lt;/p&gt;
&lt;p&gt;For me, it is always important to make sure that
project responsibilities are defined and adhered to.  Some of those responsibilities
are people or role focused, and some of those responsibilities are assigned to
objects within the project.  In both cases, having those clear boundaries helps
to figure out where things go and what should be taking care of any issues.&lt;/p&gt;
&lt;p&gt;Having completed this block of work, I felt good.  For me, commenting out or disabling
a test or a part of a test without a good reason just feels wrong.  Like “nails down
a chalkboard” wrong.  By properly assigning the responsibility for disabling the
consistency check to the consistency check itself, I was restoring the control of
that decision to the object that was responsible for it.  I had restored balance
to one small corner of the universe!&lt;/p&gt;
&lt;p&gt;But it was hard for me not to think about doing a consistency check for the token
content.  But, like before, it boiled down to a cost-benefit analysis.  Did I
think that cost of a deep check like that would justify the benefit?  The more I
thought about it, the more it &lt;em&gt;just made sense&lt;/em&gt;.  Once again, this was not a logical
decision, but an emotional one.  And as such, I did feel that the benefit justified
the cost.  I could not give a solid reason why, just a solid feeling that it would.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once I acknowledged to myself the need for proper verification of the token’s content,
the only true viable path was to write a Markdown transformer.  While I knew that I had
a good foundation for checking the line/column numbers of the tokens, I could not see
any other alternative that would verify the tokens at a level that was acceptable to me.
But how could I start work on that massive task, and not lose myself like I did with
adding tab support?&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:norOthers"&gt;
&lt;p&gt;In all fairness to Python, most popular software languages do not natively support immutable complex objects without some sort of trick, pattern, or additional plugins. &lt;a class="footnote-backref" href="#fnref:norOthers" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:caveat"&gt;
&lt;p&gt;As with everything, there are caveats.  If you understand the system that Python uses to mangle the names as part of making a variable private, you can &lt;em&gt;technically&lt;/em&gt; get around this.  However, that effort is considered out of scope for this article.  Since all the member variables are base types, any consideration of modifying complex types exposed in this way by such an object are also considered out of scope. &lt;a class="footnote-backref" href="#fnref:caveat" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Weeding the Project's Issue List</title><link href="https://jackdewinter.github.io/2020/07/06/markdown-linter-weeding-the-projects-issue-list/" rel="alternate"></link><published>2020-07-06T00:00:00-07:00</published><updated>2020-07-06T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-07-06:/2020/07/06/markdown-linter-weeding-the-projects-issue-list/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/29/markdown-linter-rabbit-hole-3-trying-to-dig-myself-out/"&gt;last article&lt;/a&gt;,
I talked about how I was pulling myself out of the rabbit hole that I dug myself into,
by finding a small task, and completing it with panache.&lt;sup id="fnref:panache"&gt;&lt;a class="footnote-ref" href="#fn:panache"&gt;1&lt;/a&gt;&lt;/sup&gt;  In this article, I
talk about how I continued to get my confidence back by resolving …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/29/markdown-linter-rabbit-hole-3-trying-to-dig-myself-out/"&gt;last article&lt;/a&gt;,
I talked about how I was pulling myself out of the rabbit hole that I dug myself into,
by finding a small task, and completing it with panache.&lt;sup id="fnref:panache"&gt;&lt;a class="footnote-ref" href="#fn:panache"&gt;1&lt;/a&gt;&lt;/sup&gt;  In this article, I
talk about how I continued to get my confidence back by resolving items on the issues
list while increasing the quality of the project.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the
&lt;a href="https://jackdewinter.github.io/2020/06/29/markdown-linter-rabbit-hole-3-trying-to-dig-myself-out/#what-was-my-experience-so-far"&gt;end of the last article&lt;/a&gt;,
I talked about how I was starting to get out of the negative headspace that I found
myself in, making progress with the project at the same time.  The project’s
progress was a good thing, but it was my emotions towards the project that I was more
concerned with.  I have seen people stop working on their passion projects for
varied reasons, and I just did not want a momentary lapse of
confidence on my part to be the reason that I stopped working on this project.&lt;/p&gt;
&lt;p&gt;When I was pulling myself up out of my rabbit hole, I came to the realization that part
of the reason that my confidence took a bit of a hit, were the contents of the issues
list. While I am pretty sure that not every item on the list is an actual issue, until I
debug and verify each one, each item on that list is a potential bug.  And each
one of those potential bugs represented a bit of uncertainty that lowered my confidence.
Given that realization, taking some time to go through and “weed” the project’s issue
list seemed like a good idea!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fdd7349a3473bda8a5644bead48396542919ec09"&gt;16 Jun 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4312898343a31e382e9f5fe105374cbbde5ebbff"&gt;26 Jun 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-out-easy"&gt;Starting Out Easy&lt;a class="headerlink" href="#starting-out-easy" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first three tasks on my list were simple things to resolve, little things that
I kept on meaning to do when I had some time. Completing them to get me warmed up
for the issues list was a good, solid plan.&lt;/p&gt;
&lt;p&gt;The first item on
my list was some simple refactoring of the &lt;code&gt;assert_token_consistency&lt;/code&gt; function in the
&lt;code&gt;utils.py&lt;/code&gt; module.  I had added some decent functionality to it in the last couple of
weeks, and it was time to make sure that the module was returned to its normal, properly
organized state.  The needed changes were simple. Start with a bit of extracting code
into functions, then add some function and variable renaming, and finally test the
changes to make sure I did not break anything.  While nothing changed in the source
code for the project, it felt good knowing that the test code was just &lt;em&gt;that&lt;/em&gt; much
cleaner.&lt;/p&gt;
&lt;p&gt;The next item was also a simple task: add reporting of leading whitespace to the next
list item token (&lt;code&gt;li&lt;/code&gt;).  When I was adding the code to handle leading whitespace for the
list start tokens, somehow, I forgot the new list item token in that work.  I noticed
this when I went to verify the next list item tokens in the consistency checks, and
there was no indication of the leading whitespace, other than the &lt;code&gt;indent_level&lt;/code&gt;
variable. For the sake of those consistency checks, this needed to be addressed.&lt;/p&gt;
&lt;p&gt;Adding this support into the consistency checks with the new list item tokens
modifications in place was almost trivial.
The &lt;em&gt;do not do new list item token until fixed&lt;/em&gt; check was removed and replaced with a
simple calculation of the &lt;code&gt;init_ws&lt;/code&gt; variable, in keeping with the handling of the list
start tokens.  To complete those changes, I also added some code in the
&lt;code&gt;__maintain_block_stack&lt;/code&gt; function to guarantee that new list item tokens were 
properly added and removed from the stack.&lt;/p&gt;
&lt;p&gt;Finally, I decided to use PyCharm and its enhanced code analysis tools to take a look
at the project, fixing things where possible.  I have
&lt;a href="https://jackdewinter.github.io/2020/04/20/markdown-linter-adding-image-links-and-simple-cleanup/#simple-cleanup-3-pycharm-static-code-analysis"&gt;talked before&lt;/a&gt;
about how PyCharm, while not a good development environment for me, is a product I
definitely like to use as a tool on a current project.  For me, the most useful of these
tools is a comprehensive look at what arguments and variables are used, and whether
they are needed.  In addition, PyCharm has a project dictionary that allows
me to search for typos in comments and variable names while maintaining a custom
dictionary that allows me to remove often used terms and abbreviations.
Combined, I feel that using PyCharm as a tool just adds an extra level of quality
and cleanliness to the project.&lt;/p&gt;
&lt;p&gt;While none of these tasks were big issues to tackle, they were small tasks that were
easily resolved and crossed off my mental “when I get time” list. And one less item
on that list is one less thing to worry about!&lt;/p&gt;
&lt;h2 id="verifying-issues"&gt;Verifying Issues&lt;a class="headerlink" href="#verifying-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="scenario-86a-indented-code-blocks"&gt;Scenario 86a: Indented Code Blocks&lt;a class="headerlink" href="#scenario-86a-indented-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are times when I look at an issue and I know exactly why I put that issue onto the
issues list.  This was not one of those times.  The notes I have for this one clearly
state that scenario 86a is a modification of
&lt;a href="https://github.github.com/gfm/#example-86"&gt;scenario 86&lt;/a&gt;
, but with 9 leading spaces
before the indented code block.  Those same notes are even clear that the reason I
added this new scenario was because I was concerned that scenario 86 only tested a case
where the length of the extracted whitespace equaled the length of the remaining
whitespace.  What I did not know was why I thought this was an issue.&lt;/p&gt;
&lt;p&gt;I did some due diligence here and found nothing.  I temporarily added some extra debug
code around the indented code block code but did not find anything useful.  After
making a mental note to myself to write better notes on why I added items to the issues
list, I removed it from the issues list and moved on.&lt;/p&gt;
&lt;h3 id="scenario-87-more-fun-with-indented-code-blocks"&gt;Scenario 87: More Fun with Indented Code Blocks&lt;a class="headerlink" href="#scenario-87-more-fun-with-indented-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I was doing the initial work to add the line/column number to the tokens back in
May, I wrote an issue to myself as a question:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;087 - shouldn’t it be inside of the indented code block?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unlike the issue with scenario 86a, it was easy to see why I wrote that question.  If
you look at the example by itself, the blank line before the reported start of the
indented code block is also indented by 4 space characters.  However, when I looked at
the example within the context of the GFM specification for
&lt;a href="https://github.github.com/gfm/#example-87"&gt;example 87&lt;/a&gt;,
the line before the example reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blank lines preceding or following an indented code block are not included in it:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;An honest question, an honest and researched answer, and an issue that was quickly
resolved.  Next!&lt;/p&gt;
&lt;h3 id="scenarios-235-236-252-and-255-indented-code-blocks-and-lists"&gt;Scenarios 235, 236, 252, and 255: Indented Code Blocks and Lists&lt;a class="headerlink" href="#scenarios-235-236-252-and-255-indented-code-blocks-and-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In each of these four cases, every scenario had to do with something
that may look like an indented code block being started from within a list. Like
scenario 87 in the last section, I could see how these scenario tests raised
questions.  For each one of these examples, from a quick glance it is hard to tell if
the number of spaces is correct from the example.&lt;/p&gt;
&lt;p&gt;In the case of
&lt;a href="https://github.github.com/gfm/#example-235"&gt;scenario 235&lt;/a&gt;
, my first inclination was that I had coded something wrong.
The &lt;code&gt;-&lt;/code&gt; character is followed by 4 spaces, so &lt;code&gt;one&lt;/code&gt; should be in an indented code block.
Right?  Almost.  The actual start sequence for the list is not &lt;code&gt;-&lt;/code&gt;, but &lt;code&gt;-{space}&lt;/code&gt;. As
such, the list starts with the &lt;code&gt;-&lt;/code&gt; character at column number 2, the space character at
column number 3, followed by 3 space characters for a total indent to column number 6.
The blank line
then ends the list on line number 2, and line 3 with 5 leading spaces is picked up as
an indented code block.  The scenario test was correct. Yes!&lt;/p&gt;
&lt;p&gt;The general math for
&lt;a href="https://github.github.com/gfm/#example-236"&gt;scenario 236&lt;/a&gt;
is the same, but because the text &lt;code&gt;two&lt;/code&gt; is indented 6 spaces
instead of scenario 237’s 5 spaces, it counts as a continuation of the original list.
&lt;a href="https://github.github.com/gfm/#example-252"&gt;Scenario 252&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-255"&gt;scenario 255&lt;/a&gt;
are just variations of this, with and without the indented code blocks confusing the
issue.  In each case, the scenario tests were correct.  But I felt good that I had
questioned whether they were correct, and it was solidly answered in the positive.&lt;/p&gt;
&lt;p&gt;However, even though I did not find an immediate issue, I did find a future issue.  In
each of these cases, the &lt;code&gt;indent_level&lt;/code&gt; associated with the list is assumed to be
comprised of
space characters.  This assumption is fine for now, as the current consistency
checks explicitly ignore checking tests that contain tabs.  But when the tab character
support is enabled in the consistency checks, extra calculations will need to be added
to ensure the column numbers remain accurate.  This was not something I needed to
deal with now, but it would be an issue later.&lt;/p&gt;
&lt;h3 id="blank-lines-and-html-blocks"&gt;Blank Lines and HTML Blocks&lt;a class="headerlink" href="#blank-lines-and-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I initially thought that this one was an open-and-shut case; the issue being noted down
as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;blanks lines, if starts with 2 ws, is it (x,1) or (x,3)?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The obvious answer is that it is always 1, as I indicated in the commit message for
removing the issue:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answered question: blank lines always start at 1, as do HTML blocks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To verify this, I did a a quick scan of the test code for the text &lt;code&gt;html-block&lt;/code&gt; and
the text &lt;code&gt;BLANK&lt;/code&gt;, looking for the string values of their respective tokens in the
scenario test output.  As expected, each of those tokens contained a column number
of 1.  Until they didn’t.  &lt;/p&gt;
&lt;p&gt;The HTML block token and the blank line token always start at the start of the line, and
hence have a column number of 1.  But when those leaf block tokens are created within a
container block, the start of the line is where the
container block says it is.  Therefore, for blank lines created within a list block,
their column number becomes the indent level for the container block.&lt;/p&gt;
&lt;p&gt;The good news here is that I had an issue with the commit message, not the source
code.  If I could go back and correct the commit message&lt;sup id="fnref:doNotRebase"&gt;&lt;a class="footnote-ref" href="#fn:doNotRebase"&gt;2&lt;/a&gt;&lt;/sup&gt; to make it more
correct, I would have changed it to:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answered question: blank lines always start at 1, as do HTML blocks, except when enclosed by a container block.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;After a bit of double checking, those scenarios and their tokens were also verified.
Another quick issue to resolve and get off the list!&lt;/p&gt;
&lt;h3 id="scenarios-197-257-and-262-blank-lines-and-lists"&gt;Scenarios 197, 257, and 262: Blank Lines and Lists&lt;a class="headerlink" href="#scenarios-197-257-and-262-blank-lines-and-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This issue was logged in order to explore whether or not there were issues with lists
that started with a blank line, as in
&lt;a href="https://github.github.com/gfm/#example-257"&gt;scenario 257&lt;/a&gt;
and
&lt;a href="https://github.github.com/gfm/#example-262"&gt;scenario 262&lt;/a&gt;.
To start with a baseline for blank lines, the example for
&lt;a href="https://github.github.com/gfm/#example-197"&gt;scenario 197&lt;/a&gt;
is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;aaa&lt;/span&gt;

&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;strong&gt;Aside:&lt;/strong&gt; Due to previous issues with me missing spaces in the examples, I had
previously replaced the spaces in this example with the character sequence &lt;code&gt;\a&lt;/code&gt;, making
the space character more visible.  Then, before passing this string to the test code,
the string is processed this string by invoking &lt;code&gt;.replace("\a", " ")&lt;/code&gt; on the resultant
string, transforming it into an accurate representation of the example.  This greatly
reduced the number of times that I missed trailing whitespace to zero!)&lt;/p&gt;
&lt;p&gt;In the scenario test for scenario 197, the tokens for the 1st, 4th, and 8th lines,
includes the leading whitespace while maintaining a column number of 1.  For example,
the token for the blank line on line 4 is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[BLANK(4,1):  ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Therefore, I compared that behavior to the blank line’s behavior inside of a
simple list block, such as with this Markdown for scenario 257:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the differences were clear:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[BLANK(1,5):]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are two differences between this token and the uncontained token above.  The
first is
that unlike scenario 197, the leading whitespace that was removed is not stored in the
token.  The second is that the column number is 5, when it should be 2.  Based on my
experience with blank lines in the last section, it was easy to see that the column
number should be 2, given the unordered list start character &lt;code&gt;-&lt;/code&gt; and the mandatory
space that followed it.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.github.com/gfm/#example-262"&gt;Scenario 262&lt;/a&gt;
was a far easier issue to deal with.  Its Markdown is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Simple.  An unordered list start token, by itself in a document.  Thanks to the work
I did on scenario 257, this one was easily verified.  If scenario 257 should produce a
blank line token that contains 3 leading space characters, then scenario 262 should
contain a blank line token with no leading space characters.&lt;/p&gt;
&lt;p&gt;As this was just researching the issue, I resolved the existing issue and added more
specific issues to be properly addressed later. One issue to do with recording
whitespace for blank lines in a container, and the other issue for correcting the
column number of that same blank line in a container.&lt;/p&gt;
&lt;h3 id="scenarios-extra001-and-extra002-checking-for-correctness"&gt;Scenarios Extra001 and Extra002: Checking for Correctness&lt;a class="headerlink" href="#scenarios-extra001-and-extra002-checking-for-correctness" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Looking at how
&lt;a href="https://github.github.com/gfm/#blank-lines"&gt;blank lines&lt;/a&gt;
are defined in the GFM specification, from a purely transform-to-HTML point of view,
it is obvious that a document that only contains whitespace will produce an
empty HTML document.  This is mainly due to the stipulations:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blank lines between block-level elements are ignored&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blank lines at the beginning and end of the document are also ignored.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But for those blank lines to be ignored, it stands to reason that from a tokenization
point of view, there must be a blank line token to ignore.  And as the linter operates
on tokens, the scenario tests &lt;code&gt;test_extra_001&lt;/code&gt; and &lt;code&gt;test_extra_002&lt;/code&gt; were added to
make sure the right blank tokens are produced.&lt;/p&gt;
&lt;p&gt;After the previous work in the above sections with blank lines, verifying these
scenario tests was quick and painless.  In reverse order, the text for scenario test
&lt;code&gt;test_extra_002&lt;/code&gt; was a simple document with 3 spaces, hence it needed to produce a
single blank line token with 3 spaces.  With that test solidly in place, it logically
follows that remove those 3 spaces for scenario test &lt;code&gt;test_extra_001&lt;/code&gt; would produce a
blank line token with no spaces, which is what the test expects.&lt;/p&gt;
&lt;p&gt;While this may have seemed like a trivial test, it is often the trivial cases and
&lt;a href="https://en.wikipedia.org/wiki/Edge_case#Software_engineering"&gt;edge cases&lt;/a&gt; that trip
up projects.  With everyone on the project worried how a big complex example will be
resolved, sometimes it is those little examples that slip through the crack out into
the wild.&lt;/p&gt;
&lt;p&gt;Honestly, even though they are trivial, I just felt better knowing that these trivial
cases were double-checked and covered.&lt;/p&gt;
&lt;h3 id="scenarios-559-and-560-link-reference-definitions"&gt;Scenarios 559 and 560: Link Reference Definitions?&lt;a class="headerlink" href="#scenarios-559-and-560-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I almost felt embarrassed when I read this one, as the answer was right in the
scenarios themselves.  The function comments for 559 (and with one small modification,
560) are as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_reference_links_559&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 559:  (part 1) A link label must contain at least one non-whitespace character:&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using scenario 559 as a benchmark, its Markdown is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;

&lt;span class="p"&gt;[]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the Markdown for scenario 560 is almost the same, except for added whitespace:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
 &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;
 &lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As it is hard to argue with the GFM specification’s definition of a
&lt;a href="https://github.github.com/gfm/#link-label"&gt;link label&lt;/a&gt;,
I resolved this and moved on.  In both cases, there just was not any whitespace
in the link label.&lt;/p&gt;
&lt;p&gt;But I still did due diligence: verified the example, checked the tokens, and after
a slight &lt;a href="https://en.wikipedia.org/wiki/Facepalm"&gt;face-palm&lt;/a&gt;, I resolved the issue
and moved on.&lt;/p&gt;
&lt;h3 id="changing-the-markdowntokens-constructor"&gt;Changing the MarkdownToken’s Constructor?&lt;a class="headerlink" href="#changing-the-markdowntokens-constructor" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting to ramp down on the project work, I hoped that this was a simple issue to
look at and resolve.  I had logged a simple question in the issue list:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for all of the tokens that used position_marker, do we need =None any more?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This was an interesting question in that, except for the &lt;code&gt;MarkdownToken&lt;/code&gt; class itself,
none of the child classes have &lt;code&gt;position_marker&lt;/code&gt; as an optional argument!  From
that point of view, it would be quick to resolve it.  But I did not feel that I was
doing a complete job, so I decided to run with that idea a bit and find out where it
led me to.&lt;/p&gt;
&lt;p&gt;Doing a quick search over the &lt;code&gt;MarkdownToken&lt;/code&gt; class and its children, the breakdown
of how the &lt;code&gt;MarkdownToken&lt;/code&gt; constructor was called from the child classes were as
follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt; arguments used: 3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;position_marker&lt;/code&gt; argument used: 10&lt;/li&gt;
&lt;li&gt;none of the above arguments used: 11&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the “none of the above” case, most of those child classes were for inline tokens
that do not have line/column support yet.  But if the trend of the current statistics
continues, this change may be something to revisit in the future.  Knowing more about
this issue, I was good resolving this issue now, possibly exploring this again in the
future when line/column numbers are added to inline elements.&lt;/p&gt;
&lt;h3 id="renaming-the-setext-tokens-whitespace-variable"&gt;Renaming the SetExt Token’s Whitespace Variable&lt;a class="headerlink" href="#renaming-the-setext-tokens-whitespace-variable" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I was finally at the end of my planned issues list, and I was
glad that I was ending on another simple one.  When I was writing my first pass of the
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/#fixing-the-easy-failures"&gt;consistency checker&lt;/a&gt;,
I noted that I had to special case the SetExt heading tokens, as the member variable
that is consistently named &lt;code&gt;extracted_whitespace&lt;/code&gt; for other tokens was mysteriously
named &lt;code&gt;remaining_line&lt;/code&gt; for this token.&lt;/p&gt;
&lt;p&gt;After performing due diligence to find out where the variable &lt;code&gt;remaining_line&lt;/code&gt; was
referenced and what was depending on it, there was no reason to keep this difference
around.  It just made more sense to change the name to the more consistent
&lt;code&gt;extracted_whitespace&lt;/code&gt;.  In addition to a simple search-and-replace, this change
allowed me to reduce the complexity of the &lt;code&gt;__calc_initial_whitespace&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Another small change, but another small step to a cleaner code base!&lt;/p&gt;
&lt;h2 id="why-was-this-work-important-to-me"&gt;Why Was This Work Important to Me?&lt;a class="headerlink" href="#why-was-this-work-important-to-me" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From my personal and professional experience, the longer you let an issue sit
unexplored, the more uncertainty exists with respect to the team’s confidence in a
project.  At the time when I resolved those issues, I was at a more emotional place
than normal, where those uncertainties were weighing more heavily on my confidence.
While it took some time to work through them, it just felt right doing the proper due
diligence on each issue and resolving it.&lt;/p&gt;
&lt;p&gt;And the results of resolving these issues were very positive.  With the exception of
adding the proper encapsulation of leading whitespace for new list item tokens, no
other source code was measurably changed.&lt;sup id="fnref:defineMeasurable"&gt;&lt;a class="footnote-ref" href="#fn:defineMeasurable"&gt;3&lt;/a&gt;&lt;/sup&gt;
With respect to the test code, there were a couple of net-neutral changes for code
quality, but the other changes only added extra tests cases, not changing existing
tests.  Basically, while the work done in this time frame did not change the project’s
code base significantly, it did increase my confidence in the project by eliminating a
few of the existing questions.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As far as recoveries go, I was feeling better after this stint of work.  By going
through the issues list, resolving 9 of those issues, and doing some code cleanup, my
confidence was back on track to be where it was before.  In any project, people
encounter circumstances that force them to evaluate if they have made the right project
decisions up to that point.  Depending on how hard those circumstances hit them and how
hard they hit them, people will decide to continue with the project, abandon it, or
take a wait-and-see approach.  While I was shaken for a bit, I was now back firmly in
the continue with the project camp.&lt;/p&gt;
&lt;p&gt;According to
&lt;a href="https://www.merriam-webster.com/dictionary/confidence"&gt;Webster&lt;/a&gt;,
confidence is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a feeling or consciousness of one’s powers or of reliance on one’s circumstances&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Confidence is an emotion, not logic.  It is not a light switch and it is not something
that listens to reason.  Confidence it fickle, hence the expression:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One bad apple spoils the barrel.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I could have resolved 29 issues, but if I found just one issue that looked
like a showstopper, those circumstances could be completely different. Who knows?&lt;/p&gt;
&lt;p&gt;Whether it was something substantial or something more lightweight, I knew that I
needed to do some work to try and influence my confidence in a positive direction.  In
this case, resolving several items off of the issues list was needed, and it paid
off.  It was not a guarantee, but a gamble that paid off.&lt;/p&gt;
&lt;p&gt;Someone once told me:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Marriage is made up with a whole bunch of days.  You have good days, you have bad days, and you have so-so days.  The sign of a good marriage is that you have more good days that the other two combined.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A similar concept applies to working on passion projects, like me and my PyMarkdown
project.  It was just a matter of finding the right thing to do on the project that
would reignite my confidence, and therefore passion, for the project.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having done some decent cleanup, I decided it was time to get back to work on the
consistency checker.  While I realized it was not going to be able to be 100% complete
until I started handling tab characters, I wanted to make a good effort towards getting
it more complete.  And that started with proper accounting of whitespace.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:panache"&gt;
&lt;p&gt;Per &lt;a href="https://www.merriam-webster.com/dictionary/panache"&gt;Webster’s&lt;/a&gt; “dash or flamboyance in style and action”. &lt;a class="footnote-backref" href="#fnref:panache" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:doNotRebase"&gt;
&lt;p&gt;Yes, I know you can &lt;a href="https://docs.github.com/en/github/committing-changes-to-your-project/changing-a-commit-message"&gt;change a commit message&lt;/a&gt;, but the price is usually too high to pay for anything other than your very last commit. &lt;a class="footnote-backref" href="#fnref:doNotRebase" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:defineMeasurable"&gt;
&lt;p&gt;For the sake of this sentence, I define a measurable change as a change that changes the requirements for input or the actual output of the project, with the exception of adding or modifying log messages. &lt;a class="footnote-backref" href="#fnref:defineMeasurable" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry></feed>