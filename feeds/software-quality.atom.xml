<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jack's Digital Workbench - Software Quality</title><link href="https://jackdewinter.github.io/" rel="alternate"></link><link href="https://jackdewinter.github.io/feeds/software-quality.atom.xml" rel="self"></link><id>https://jackdewinter.github.io/</id><updated>2020-07-06T00:00:00-07:00</updated><entry><title>Markdown Linter - Weeding the Project's Issue List</title><link href="https://jackdewinter.github.io/2020/07/06/markdown-linter-weeding-the-projects-issue-list/" rel="alternate"></link><published>2020-07-06T00:00:00-07:00</published><updated>2020-07-06T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-07-06:/2020/07/06/markdown-linter-weeding-the-projects-issue-list/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/"&gt;last article&lt;/a&gt;,
I talked about how I was pulling myself out of the rabbit hole that I dug myself into,
by finding a small task, and completing it with panache.&lt;sup id="fnref:panache"&gt;&lt;a class="footnote-ref" href="#fn:panache"&gt;1&lt;/a&gt;&lt;/sup&gt;  In this article, I
talk about how I continue to get my confidence back by resolving …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/"&gt;last article&lt;/a&gt;,
I talked about how I was pulling myself out of the rabbit hole that I dug myself into,
by finding a small task, and completing it with panache.&lt;sup id="fnref:panache"&gt;&lt;a class="footnote-ref" href="#fn:panache"&gt;1&lt;/a&gt;&lt;/sup&gt;  In this article, I
talk about how I continue to get my confidence back by resolving items on the issues
list while increasing the quality of the project.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/#what-was-my-experience-so-far"&gt;end of the last article&lt;/a&gt;,
I talked about how I was starting to get out of the negative headspace that I found
myself in, making progress with the project at the same time.  The project’s
progress was a good thing, but it was my emotions towards the project that I was more
concerned with.  I have seen people stop working on their passion projects for
varied reasons, and I just did not want a momentary lapse of
confidence on my part to be the reason that I stopped working on this project.&lt;/p&gt;
&lt;p&gt;When I was pulling myself up out of my rabbit hole, I came to the realization that part
of the reason that my confidence took a bit of a hit, were the contents of the issues
list. While I am pretty sure that not every item on the list is an actual issue, until I
debug and verify each one, each item on that list is a potential bug.  And each
one of those potential bugs represented a bit of uncertainty that lowered my confidence.
Given that realization, taking some time to go through and “weed” the project’s issue
list seemed like a good idea!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fdd7349a3473bda8a5644bead48396542919ec09"&gt;16 Jun 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4312898343a31e382e9f5fe105374cbbde5ebbff"&gt;26 Jun 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-out-easy"&gt;Starting Out Easy&lt;a class="headerlink" href="#starting-out-easy" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first three tasks on my list were simple things to resolve, little things that
I kept on meaning to do when I had some time. Completing them to get me warmed up
for the issues list was a good, solid plan.&lt;/p&gt;
&lt;p&gt;The first item on
my list was some simple refactoring of the &lt;code&gt;assert_token_consistency&lt;/code&gt; function in the
&lt;code&gt;utils.py&lt;/code&gt; module.  I had added some decent functionality to it in the last couple of
weeks, and it was time to make sure that the module was returned to its normal, properly
organized state.  The needed changes were simple. Start with a bit of extracting code
into functions, then add some function and variable renaming, and finally test the
changes to make sure I did not break anything.  While nothing changed in the source
code for the project, it felt good knowing that the test code was just &lt;em&gt;that&lt;/em&gt; much
cleaner.&lt;/p&gt;
&lt;p&gt;The next item was also a simple task: add reporting of leading whitespace to the next
list item token (&lt;code&gt;li&lt;/code&gt;).  When I was adding the code to handle leading whitespace for the
list start tokens, somehow, I forgot the new list item token in that work.  I noticed
this when I went to verify the next list item tokens in the consistency checks, and
there was no indication of the leading whitespace, other than the &lt;code&gt;indent_level&lt;/code&gt;
variable. For the sake of those consistency checks, this needed to be addressed.&lt;/p&gt;
&lt;p&gt;Adding this support into the consistency checks with the new list item tokens
modifications in place was almost trivial.
The &lt;em&gt;do not do new list item token until fixed&lt;/em&gt; check was removed and replaced with a
simple calculation of the &lt;code&gt;init_ws&lt;/code&gt; variable, in keeping with the handling of the list
start tokens.  To complete those changes, I also added some code in the
&lt;code&gt;__maintain_block_stack&lt;/code&gt; function to guarantee that new list item tokens were 
properly added and removed from the stack.&lt;/p&gt;
&lt;p&gt;Finally, I decided to use PyCharm and its enhanced code analysis tools to take a look
at the project, fixing things where possible.  I have
&lt;a href="https://jackdewinter.github.io/2020/04/20/markdown-linter-adding-image-links-and-simple-cleanup/#simple-cleanup-3-pycharm-static-code-analysis"&gt;talked before&lt;/a&gt;
about how PyCharm, while not a good development environment for me, is a product I
definitely like to use as a tool on a current project.  For me, the most useful of these
tools is a comprehensive look at what arguments and variables are used, and whether
they are needed.  In addition, PyCharm has a project dictionary that allows
me to search for typos in comments and variable names while maintaining a custom
dictionary that allows me to remove often used terms and abbreviations.
Combined, I feel that using PyCharm as a tool just adds an extra level of quality
and cleanliness to the project.&lt;/p&gt;
&lt;p&gt;While none of these tasks were big issues to tackle, they were small tasks that were
easily resolved and crossed off my mental “when I get time” list. And one less item
on that list is one less thing to worry about!&lt;/p&gt;
&lt;h2 id="verifying-issues"&gt;Verifying Issues&lt;a class="headerlink" href="#verifying-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="scenario-86a-indented-code-blocks"&gt;Scenario 86a: Indented Code Blocks&lt;a class="headerlink" href="#scenario-86a-indented-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are times when I look at an issue and I know exactly why I put that issue onto the
issues list.  This was not one of those times.  The notes I have for this one clearly
state that scenario 86a is a modification of
&lt;a href="https://github.github.com/gfm/#example-86"&gt;scenario 86&lt;/a&gt;
, but with 9 leading spaces
before the indented code block.  Those same notes are even clear that the reason I
added this new scenario was because I was concerned that scenario 86 only tested a case
where the length of the extracted whitespace equaled the length of the remaining
whitespace.  What I did not know was why I thought this was an issue.&lt;/p&gt;
&lt;p&gt;I did some due diligence here and found nothing.  I temporarily added some extra debug
code around the indented code block code but did not find anything useful.  After
making a mental note to myself to write better notes on why I added items to the issues
list, I removed it from the issues list and moved on.&lt;/p&gt;
&lt;h3 id="scenario-87-more-fun-with-indented-code-blocks"&gt;Scenario 87: More Fun with Indented Code Blocks&lt;a class="headerlink" href="#scenario-87-more-fun-with-indented-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I was doing the initial work to add the line/column number to the tokens back in
May, I wrote an issue to myself as a question:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;087 - shouldn’t it be inside of the indented code block?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unlike the issue with scenario 86a, it was easy to see why I wrote that question.  If
you look at the example by itself, the blank line before the reported start of the
indented code block is also indented by 4 space characters.  However, when I looked at
the example within the context of the GFM specification for
&lt;a href="https://github.github.com/gfm/#example-87"&gt;example 87&lt;/a&gt;,
the line before the example reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blank lines preceding or following an indented code block are not included in it:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;An honest question, an honest and researched answer, and an issue that was quickly
resolved.  Next!&lt;/p&gt;
&lt;h3 id="scenarios-235-236-252-and-255-indented-code-blocks-and-lists"&gt;Scenarios 235, 236, 252, and 255: Indented Code Blocks and Lists&lt;a class="headerlink" href="#scenarios-235-236-252-and-255-indented-code-blocks-and-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In each of these four cases, every scenario had to do with something
that may look like an indented code block being started from within a list. Like
scenario 87 in the last section, I could see how these scenario tests raised
questions.  For each one of these examples, from a quick glance it is hard to tell if
the number of spaces is correct from the example.&lt;/p&gt;
&lt;p&gt;In the case of
&lt;a href="https://github.github.com/gfm/#example-235"&gt;scenario 235&lt;/a&gt;
, my first inclination was that I had coded something wrong.
The &lt;code&gt;-&lt;/code&gt; character is followed by 4 spaces, so &lt;code&gt;one&lt;/code&gt; should be in an indented code block.
Right?  Almost.  The actual start sequence for the list is not &lt;code&gt;-&lt;/code&gt;, but &lt;code&gt;-{space}&lt;/code&gt;. As
such, the list starts with the &lt;code&gt;-&lt;/code&gt; character at column number 2, the space character at
column number 3, followed by 3 space characters for a total indent to column number 6.
The blank line
then ends the list on line number 2, and line 3 with 5 leading spaces is picked up as
an indented code block.  The scenario test was correct. Yes!&lt;/p&gt;
&lt;p&gt;The general math for
&lt;a href="https://github.github.com/gfm/#example-236"&gt;scenario 236&lt;/a&gt;
is the same, but because the text &lt;code&gt;two&lt;/code&gt; is indented 6 spaces
instead of scenario 237’s 5 spaces, it counts as a continuation of the original list.
&lt;a href="https://github.github.com/gfm/#example-252"&gt;Scenario 252&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-255"&gt;scenario 255&lt;/a&gt;
are just variations of this, with and without the indented code blocks confusing the
issue.  In each case, the scenario tests were correct.  But I felt good that I had
questioned whether they were correct, and it was solidly answered in the positive.&lt;/p&gt;
&lt;p&gt;However, even though I did not find an immediate issue, I did find a future issue.  In
each of these cases, the &lt;code&gt;indent_level&lt;/code&gt; associated with the list is assumed to be
comprised of
space characters.  This assumption is fine for now, as the current consistency
checks explicitly ignore checking tests that contain tabs.  But when the tab character
support is enabled in the consistency checks, extra calculations will need to be added
to ensure the column numbers remain accurate.  This was not something I needed to
deal with now, but it would be an issue later.&lt;/p&gt;
&lt;h3 id="blank-lines-and-html-blocks"&gt;Blank Lines and HTML Blocks&lt;a class="headerlink" href="#blank-lines-and-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I initially thought that this one was an open-and-shut case; the issue being noted down
as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;blanks lines, if starts with 2 ws, is it (x,1) or (x,3)?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The obvious answer is that it is always 1, as I indicated in the commit message for
removing the issue:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answered question: blank lines always start at 1, as do HTML blocks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To verify this, I did a a quick scan of the test code for the text &lt;code&gt;html-block&lt;/code&gt; and
the text &lt;code&gt;BLANK&lt;/code&gt;, looking for the string values of their respective tokens in the
scenario test output.  As expected, each of those tokens contained a column number
of 1.  Until they didn’t.  &lt;/p&gt;
&lt;p&gt;The HTML block token and the blank line token always start at the start of the line, and
hence have a column number of 1.  But when those leaf block tokens are created within a
container block, the start of the line is where the
container block says it is.  Therefore, for blank lines created within a list block,
their column number becomes the indent level for the container block.&lt;/p&gt;
&lt;p&gt;The good news here is that I had an issue with the commit message, not the source
code.  If I could go back and correct the commit message&lt;sup id="fnref:doNotRebase"&gt;&lt;a class="footnote-ref" href="#fn:doNotRebase"&gt;2&lt;/a&gt;&lt;/sup&gt; to make it more
correct, I would have changed it to:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answered question: blank lines always start at 1, as do HTML blocks, except when enclosed by a container block.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;After a bit of double checking, those scenarios and their tokens were also verified.
Another quick issue to resolve and get off the list!&lt;/p&gt;
&lt;h3 id="scenarios-197-257-and-262-blank-lines-and-lists"&gt;Scenarios 197, 257, and 262: Blank Lines and Lists&lt;a class="headerlink" href="#scenarios-197-257-and-262-blank-lines-and-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This issue was logged in order to explore whether or not there were issues with lists
that started with a blank line, as in
&lt;a href="https://github.github.com/gfm/#example-257"&gt;scenario 257&lt;/a&gt;
and
&lt;a href="https://github.github.com/gfm/#example-262"&gt;scenario 262&lt;/a&gt;.
To start with a baseline for blank lines, the example for
&lt;a href="https://github.github.com/gfm/#example-197"&gt;scenario 197&lt;/a&gt;
is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;aaa&lt;/span&gt;

&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;strong&gt;Aside:&lt;/strong&gt; Due to previous issues with me missing spaces in the examples, I had
previously replaced the spaces in this example with the character sequence &lt;code&gt;\a&lt;/code&gt;, making
the space character more visible.  Then, before passing this string to the test code,
the string is processed this string by invoking &lt;code&gt;.replace("\a", " ")&lt;/code&gt; on the resultant
string, transforming it into an accurate representation of the example.  This greatly
reduced the number of times that I missed trailing whitespace to zero!)&lt;/p&gt;
&lt;p&gt;In the scenario test for scenario 197, the tokens for the 1st, 4th, and 8th lines,
includes the leading whitespace while maintaining a column number of 1.  For example,
the token for the blank line on line 4 is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[BLANK(4,1):  ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Therefore, I compared that behavior to the blank line’s behavior inside of a
simple list block, such as with this Markdown for scenario 257:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the differences were clear:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[BLANK(1,5):]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are two differences between this token and the uncontained token above.  The
first is
that unlike scenario 197, the leading whitespace that was removed is not stored in the
token.  The second is that the column number is 5, when it should be 2.  Based on my
experience with blank lines in the last section, it was easy to see that the column
number should be 2, given the unordered list start character &lt;code&gt;-&lt;/code&gt; and the mandatory
space that followed it.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.github.com/gfm/#example-262"&gt;Scenario 262&lt;/a&gt;
was a far easier issue to deal with.  Its Markdown is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Simple.  An unordered list start token, by itself in a document.  Thanks to the work
I did on scenario 257, this one was easily verified.  If scenario 257 should produce a
blank line token that contains 3 leading space characters, then scenario 262 should
contain a blank line token with no leading space characters.&lt;/p&gt;
&lt;p&gt;As this was just researching the issue, I resolved the existing issue and added more
specific issues to be properly addressed later. One issue to do with recording
whitespace for blank lines in a container, and the other issue for correcting the
column number of that same blank line in a container.&lt;/p&gt;
&lt;h3 id="scenarios-extra001-and-extra002-checking-for-correctness"&gt;Scenarios Extra001 and Extra002: Checking for Correctness&lt;a class="headerlink" href="#scenarios-extra001-and-extra002-checking-for-correctness" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Looking at how
&lt;a href="https://github.github.com/gfm/#blank-lines"&gt;blank lines&lt;/a&gt;
are defined in the GFM specification, from a purely transform-to-HTML point of view,
it is obvious that a document that only contains whitespace will produce an
empty HTML document.  This is mainly due to the stipulations:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blank lines between block-level elements are ignored&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blank lines at the beginning and end of the document are also ignored.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But for those blank lines to be ignored, it stands to reason that from a tokenization
point of view, there must be a blank line token to ignore.  And as the linter operates
on tokens, the scenario tests &lt;code&gt;test_extra_001&lt;/code&gt; and &lt;code&gt;test_extra_002&lt;/code&gt; were added to
make sure the right blank tokens are produced.&lt;/p&gt;
&lt;p&gt;After the previous work in the above sections with blank lines, verifying these
scenario tests was quick and painless.  In reverse order, the text for scenario test
&lt;code&gt;test_extra_002&lt;/code&gt; was a simple document with 3 spaces, hence it needed to produce a
single blank line token with 3 spaces.  With that test solidly in place, it logically
follows that remove those 3 spaces for scenario test &lt;code&gt;test_extra_001&lt;/code&gt; would produce a
blank line token with no spaces, which is what the test expects.&lt;/p&gt;
&lt;p&gt;While this may have seemed like a trivial test, it is often the trivial cases and
&lt;a href="https://en.wikipedia.org/wiki/Edge_case#Software_engineering"&gt;edge cases&lt;/a&gt; that trip
up projects.  With everyone on the project worried how a big complex example will be
resolved, sometimes it is those little examples that slip through the crack out into
the wild.&lt;/p&gt;
&lt;p&gt;Honestly, even though they are trivial, I just felt better knowing that these trivial
cases were double-checked and covered.&lt;/p&gt;
&lt;h3 id="scenarios-559-and-560-link-reference-definitions"&gt;Scenarios 559 and 560: Link Reference Definitions?&lt;a class="headerlink" href="#scenarios-559-and-560-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I almost felt embarrassed when I read this one, as the answer was right in the
scenarios themselves.  The function comments for 559 (and with one small modification,
560) are as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_reference_links_559&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 559:  (part 1) A link label must contain at least one non-whitespace character:&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using scenario 559 as a benchmark, its Markdown is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;

&lt;span class="p"&gt;[]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the Markdown for scenario 560 is almost the same, except for added whitespace:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
 &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;
 &lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As it is hard to argue with the GFM specification’s definition of a
&lt;a href="https://github.github.com/gfm/#link-label"&gt;link label&lt;/a&gt;,
I resolved this and moved on.  In both cases, there just was not any whitespace
in the link label.&lt;/p&gt;
&lt;p&gt;But I still did due diligence: verified the example, checked the tokens, and after
a slight &lt;a href="https://en.wikipedia.org/wiki/Facepalm"&gt;face-palm&lt;/a&gt;, I resolved the issue
and moved on.&lt;/p&gt;
&lt;h3 id="changing-the-markdowntokens-constructor"&gt;Changing the MarkdownToken’s Constructor?&lt;a class="headerlink" href="#changing-the-markdowntokens-constructor" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting to ramp down on the project work, I hoped that this was a simple issue to
look at and resolve.  I had logged a simple question in the issue list:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for all of the tokens that used position_marker, do we need =None any more?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This was an interesting question in that, except for the &lt;code&gt;MarkdownToken&lt;/code&gt; class itself,
none of the child classes have &lt;code&gt;position_marker&lt;/code&gt; as an optional argument!  From
that point of view, it would be quick to resolve it.  But I did not feel that I was
doing a complete job, so I decided to run with that idea a bit and find out where it
led me to.&lt;/p&gt;
&lt;p&gt;Doing a quick search over the &lt;code&gt;MarkdownToken&lt;/code&gt; class and its children, the breakdown
of how the &lt;code&gt;MarkdownToken&lt;/code&gt; constructor was called from the child classes were as
follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt; arguments used: 3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;position_marker&lt;/code&gt; argument used: 10&lt;/li&gt;
&lt;li&gt;none of the above arguments used: 11&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the “none of the above” case, most of those child classes were for inline tokens
that do not have line/column support yet.  But if the trend of the current statistics
continues, this change may be something to revisit in the future.  Knowing more about
this issue, I was good resolving this issue now, possibly exploring this again in the
future when line/column numbers are added to inline elements.&lt;/p&gt;
&lt;h3 id="renaming-the-setext-tokens-whitespace-variable"&gt;Renaming the SetExt Token’s Whitespace Variable&lt;a class="headerlink" href="#renaming-the-setext-tokens-whitespace-variable" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I was finally at the end of my planned issues list, and I was
glad that I was ending on another simple one.  When I was writing my first pass of the
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/#fixing-the-easy-failures"&gt;consistency checker&lt;/a&gt;,
I noted that I had to special case the SetExt heading tokens, as the member variable
that is consistently named &lt;code&gt;extracted_whitespace&lt;/code&gt; for other tokens was mysteriously
named &lt;code&gt;remaining_line&lt;/code&gt; for this token.&lt;/p&gt;
&lt;p&gt;After performing due diligence to find out where the variable &lt;code&gt;remaining_line&lt;/code&gt; was
referenced and what was depending on it, there was no reason to keep this difference
around.  It just made more sense to change the name to the more consistent
&lt;code&gt;extracted_whitespace&lt;/code&gt;.  In addition to a simple search-and-replace, this change
allowed me to reduce the complexity of the &lt;code&gt;__calc_initial_whitespace&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Another small change, but another small step to a cleaner code base!&lt;/p&gt;
&lt;h2 id="why-was-this-work-important-to-me"&gt;Why Was This Work Important to Me?&lt;a class="headerlink" href="#why-was-this-work-important-to-me" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From my personal and professional experience, the longer you let an issue sit
unexplored, the more uncertainty exists with respect to the team’s confidence in a
project.  At the time when I resolved those issues, I was at a more emotional place
than normal, where those uncertainties were weighing more heavily on my confidence.
While it took some time to work through them, it just felt right doing the proper due
diligence on each issue and resolving it.&lt;/p&gt;
&lt;p&gt;And the results of resolving these issues were very positive.  With the exception of
adding the proper encapsulation of leading whitespace for new list item tokens, no
other source code was measurably changed.&lt;sup id="fnref:defineMeasurable"&gt;&lt;a class="footnote-ref" href="#fn:defineMeasurable"&gt;3&lt;/a&gt;&lt;/sup&gt;
With respect to the test code, there were a couple of net-neutral changes for code
quality, but the other changes only added extra tests cases, not changing existing
tests.  Basically, while the work done in this time frame did not change the project’s
code base significantly, it did increase my confidence in the project by eliminating a
few of the existing questions.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As far as recoveries go, I was feeling better after this stint of work.  By going
through the issues list, resolving 9 of those issues, and doing some code cleanup, my
confidence was back on track to be where it was before.  In any project, people
encounter circumstances that force them to evaluate if they have made the right project
decisions up to that point.  Depending on how hard those circumstances hit them and how
hard they hit them, people will decide to continue with the project, abandon it, or
take a wait-and-see approach.  While I was shaken for a bit, I was now back firmly in
the continue with the project camp.&lt;/p&gt;
&lt;p&gt;According to
&lt;a href="https://www.merriam-webster.com/dictionary/confidence"&gt;Webster&lt;/a&gt;,
confidence is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a feeling or consciousness of one’s powers or of reliance on one’s circumstances&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Confidence is an emotion, not logic.  It is not a light switch and it is not something
that listens to reason.  Confidence it fickle, hence the expression:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One bad apple spoils the barrel.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I could have resolved 29 issues, but if I found just one issue that looked
like a showstopper, those circumstances could be completely different. Who knows?&lt;/p&gt;
&lt;p&gt;Whether it was something substantial or something more lightweight, I knew that I
needed to do some work to try and influence my confidence in a positive direction.  In
this case, resolving several items off of the issues list was needed, and it paid
off.  It was not a guarantee, but a gamble that paid off.&lt;/p&gt;
&lt;p&gt;Someone once told me:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Marriage is made up with a whole bunch of days.  You have good days, you have bad days, and you have so-so days.  The sign of a good marriage is that you have more good days that the other two combined.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A similar concept applies to working on passion projects, like me and my PyMarkdown
project.  It was just a matter of finding the right thing to do on the project that
would reignite my confidence, and therefore passion, for the project.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having done some decent cleanup, I decided it was time to get back to work on the
consistency checker.  While I realized it was not going to be able to be 100% complete
until I started handling tab characters, I wanted to make a good effort towards getting
it more complete.  And that started with proper accounting for of whitespace.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:panache"&gt;
&lt;p&gt;Per &lt;a href="https://www.merriam-webster.com/dictionary/panache"&gt;Webster’s&lt;/a&gt; “dash or flamboyance in style and action”. &lt;a class="footnote-backref" href="#fnref:panache" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:doNotRebase"&gt;
&lt;p&gt;Yes, I know you can &lt;a href="https://docs.github.com/en/github/committing-changes-to-your-project/changing-a-commit-message"&gt;change a commit message&lt;/a&gt;, but the price is usually too high to pay for anything other than your very last commit. &lt;a class="footnote-backref" href="#fnref:doNotRebase" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:defineMeasurable"&gt;
&lt;p&gt;For the sake of this sentence, I define a measurable change as a change that changes the requirements for input or the actual output of the project, with the exception of adding or modifying log messages. &lt;a class="footnote-backref" href="#fnref:defineMeasurable" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Rabbit Hole 3 - Trying To Dig Myself Out</title><link href="https://jackdewinter.github.io/2020/06/29/markdown-linter-rabbit-hole-3-trying-to-dig-myself-out/" rel="alternate"></link><published>2020-06-29T00:00:00-07:00</published><updated>2020-06-29T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-06-29:/2020/06/29/markdown-linter-rabbit-hole-3-trying-to-dig-myself-out/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/"&gt;last article&lt;/a&gt;,
I talked about how I quickly found myself descending into a rabbit hole while
addressing an issue with my PyMarkdown project.  From experience, that behavior is a
pattern that I personally must work hard at to avoid.  In this article I talk about
mentally digging …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/"&gt;last article&lt;/a&gt;,
I talked about how I quickly found myself descending into a rabbit hole while
addressing an issue with my PyMarkdown project.  From experience, that behavior is a
pattern that I personally must work hard at to avoid.  In this article I talk about
mentally digging myself out of that hole while extending the consistency checks for the
PyMarkdown linter to tokens beyond the initial token.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the
&lt;a href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/#what-was-my-experience-so-far"&gt;end of the last article&lt;/a&gt;,
I talked about how I started chasing a feature down multiple rabbit holes, noticing that
behavior a good 4-5 days after I felt that I should have noticed it.  As part of who I
am, I find certain types of puzzles very hard to put down and almost addictive in
nature.  During the development of the PyMarkdown
project, I have had my share of these puzzles, so I have had to
be very vigilant that I take a measured approach when solving each issue in an
attempt to keep that behavior in check.&lt;/p&gt;
&lt;p&gt;As this was the first time during this project that I have travelled down this route so
completely, I was slightly proud of myself.  Usually, for a project of this complexity
and duration, I would have expected to descend to those depths an extra 2-3 more times,
if not more. From experience, I find that it is during those times that I
lose my perspective on a project, and either go for perfection, give up the project
that I am working on, or both.  I am not sure, but my current belief is that by taking
a look at the bigger picture, and looking at it frequently, I have mostly mitigated my
desire for perfection by moderating it with other grounding concepts like feasibility.&lt;/p&gt;
&lt;p&gt;Having noticed that I dug myself into that hole, it was now time to try and figure
out what to do.  Stay where I was? Go forward? Go backward?  It really was my choice
on how I handled that situation.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4bb4034ec69bc0aa67552f08c986ff94632e1e82"&gt;14 Jun 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="mental-and-emotional-stuff-is-important-too"&gt;Mental and Emotional Stuff Is Important Too&lt;a class="headerlink" href="#mental-and-emotional-stuff-is-important-too" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I am not one for using excuses when something does not work out, but I am also not one
to keep on knocking someone down for failing.  Keep in mind the saying I
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#changing-the-narrative"&gt;have adopted&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Stuff happens, pick yourself up, dust yourself off, and figure out what to do next.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For me and my family, there are two parts of that statement are important to
realize: the trying part and the figure out/learning part.&lt;/p&gt;
&lt;p&gt;In all honesty, I have every reason to not write this blog or work on this project.
I could spend more time interacting with my family,
fiddling around with home automation (how this blog started), watching movies (the more
b-movie or “hard” sci-fi the better), reading books (see movies), or any number of other
things.  At the time that I am writing this article, it is just shy of 4 months that I
have been working from home, due to
&lt;a href="https://www.cdc.gov/coronavirus/2019-ncov/index.html"&gt;COVID-19&lt;/a&gt;.  There is the
stress related to thinking about the 500,000 fatalities and 10 million infected
people worldwide.  Let’s face it.  The mere thoughts of that scale of death and
disease are somewhat crippling to me on good days. Add to that the normal stress of
making sure I am being a good worker, colleague, husband, and father.  Pick any 1 or 2
of those reason, and most people would understand my reasons if I said “I started
writing a blog, but I stopped when…”&lt;/p&gt;
&lt;p&gt;But I continue writing this blog and continue developing the project.  I have good days
and I have bad days, and I also have just, well, days.  But I keep on trying.
I know I am not going to get the blog right each time, but I try, and I improve.
I know I am not going to get the PyMarkdown project right on the first try,
and I am probably at my tenth or eleventh try if I add all the small tries
together.  But I keep on trying.&lt;/p&gt;
&lt;p&gt;And that is where the second half of the saying comes into play: figure out what to do
next.  There is a great quote that may or may not be attributed to
&lt;a href="https://quoteinvestigator.com/2017/03/23/same/"&gt;Albert Einstein&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Insanity is doing the same thing over and over again and expecting different results.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Figuring out what to do next for me is learning from what just happened, trying to avoid
the same mistakes in the future.  Does it always work? Nope.  Sometimes it takes a
couple of times for me to figure things out.  Sometimes I do not figure them out and
have to ask for help on how to deal with those mistakes or how to prevent them.  And
in some rare cases, I just need to let them be.  But that is also learning: learning
what I can do, what I cannot do, and trying to understand the effort required for each.&lt;/p&gt;
&lt;h2 id="how-does-this-relate-to-my-current-situation"&gt;How Does This Relate to My Current Situation?&lt;a class="headerlink" href="#how-does-this-relate-to-my-current-situation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I went down a rabbit hole and lost 4-5 days of productive work, only to realize that
when I was completely obsessed with the solution.  While I did struggle to find some
positive spin on the situation, it was
a rough break to deal with. Mentally, it took me about a week to get over the “oh no, I
went there
again” thoughts in my head.  Emotionally, I was hard on myself because I had “let
myself” not pay attention and lost my way.  Then add the weight of the elements in
my environment that were going on around the world at that time.  It took me a bit to
work through that quagmire.&lt;/p&gt;
&lt;p&gt;But I do not believe on giving up on something without a good reason.  I have learned a
lot about Python, writing, and myself by working on the PyMarkdown project and writing
about it in this blog.  The things that I have learned are in all sorts of areas, not
just the technical areas that I expected.  And personally, I have committed to this
path: to learning and helping others learn.  Basically, I have too many good reasons
to keep going, and not many reasons to give up.&lt;/p&gt;
&lt;p&gt;And yes, it was hard to push myself forward for the first couple of
weeks, through all the emotional and mental debris in the way.  I did a lot of
falling in that time, deciding each time to pick myself up.  There were times when the
words flew out of my fingers, and times where I could not type the next line in either
the project or the blog.  But I had confidence that I would work through it, and that
I would not give up.  This was something I knew I could do, I just had to push through
some bad stuff to get there.&lt;/p&gt;
&lt;h2 id="where-to-start"&gt;Where to Start?&lt;a class="headerlink" href="#where-to-start" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I knew that I had to push forward with something positive, but what to do?  After a
bit of thinking, hoping to get myself back into the writing mood, I decided that I
would make some enhancements to the work already done.
In the last article, I described how I added code to validate the initial token in the
token stream.  This was done by only adding logic into the function for the cases where
the &lt;code&gt;last_token&lt;/code&gt; variable was &lt;code&gt;None&lt;/code&gt; for any block tokens.  The plan for this
enhancement was to keep the focus on block tokens, but to focus on the other block
tokens in the arrays. That is, focus on the cases where the the &lt;code&gt;last_token&lt;/code&gt; variable
was not &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="keeping-the-scope-small"&gt;Keeping the Scope Small&lt;a class="headerlink" href="#keeping-the-scope-small" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After being burnt by the events documented in the previous article, I wanted to be extra
careful by setting myself up for success.  If I started with a small scope and found
that I was able to get it working quickly, I could always do more work on a subsequent
enhancement.  Knowing how I work; I knew that it would be far more difficult for me to
reduce the work’s scope once I had started it.  Especially when my confidence needed
a boost, I needed a solid, yet achievable, goal that I could complete with confidence.&lt;/p&gt;
&lt;p&gt;The question was where to start?  I had a feeling that dealing with leaf blocks which
started on the same line as container blocks were going to be a headache, so I removed
them from the scope.  I knew that I had issues with tab characters from the last
enhancement, so I removed them as well.  Was there anything else I could remove?&lt;/p&gt;
&lt;p&gt;Looking over the scenario tests and their data while scribbling some notes for myself,
I quickly came to two conclusions.
The first was that verifying the consistency of list-related objects would be relatively
easy, as the token contained all the necessary data.  Because of the presence of the
&lt;code&gt;indent_level&lt;/code&gt; variable and extracted whitespace in those tokens, I was able to quickly
figure out how to check their consistency.  After a couple of mental dry runs with my
solution and the real test data, I had confidence I could complete those checks.&lt;/p&gt;
&lt;p&gt;The second conclusion was that handling the block quote tokens were going to be
a completely different issue. Those tokens did not have a concept like
an &lt;code&gt;indent_level&lt;/code&gt; that could be generally applied, nor any memory of the whitespace
that they extracted from the line.  Supporting consistency checking with block quotes
was going to take some decent changes to the block quote tokens, something that was
going to take a lot of time and planning to properly execute.&lt;/p&gt;
&lt;p&gt;With these considerations in mind, I decided that
this enhancement would not address any token arrays with block
quote tokens or tab characters.  To keep things more manageable, I would restrict
any checking to leaf block tokens on new lines.  With this in place, it was good to go!
But I needed to add one thing first: a consistency token stack.&lt;/p&gt;
&lt;h3 id="adding-the-consistency-token-stack"&gt;Adding the Consistency Token Stack&lt;a class="headerlink" href="#adding-the-consistency-token-stack" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The necessity for adding this stack to the consistency check was not a surprise to me.
To allow the parser to maintain a proper understanding of what the scope of the active
container blocks was, I added a stack to the parser explicitly for those container
blocks.  With the task of validating the consistency of the tokens and without access
to that internal stack, I knew that I needed to replicate some of the functionality
of that stack.&lt;/p&gt;
&lt;p&gt;Before any of the serious checking of the tokens took place, I needed a simple
stack that would track which container tokens were currently active.  The first pass at
this was really simple, with the
&lt;a href="https://en.wikipedia.org/wiki/Pseudocode"&gt;pseudocode&lt;/a&gt;
being as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for each token:
  if the token is a container block:
    add the token to the stack
  else if the token ends a container block:
    remove the last item from the stack

  do the rest of the processing
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This pseudocode is part of my mental algorithm repository that I lovingly refer to as
Parser 101.  Except in the case
of very simple parsers, almost every other parser I have written has had to maintain
some manner of stack to track context.  While the consistency checker is not a
full-fledged parser, it is operating on the tokens generated by a legitimate
full-fledged parser.  As such, it made sense that some of my parser experience would
assist me with this enhancement.&lt;/p&gt;
&lt;p&gt;The first pass at implementing this algorithm was a simple translation of the above
pseudocode fragment into Python code.  The &lt;em&gt;if the token is a container block&lt;/em&gt;
translation was simple, due to a previous refactoring:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CONTAINER_BLOCK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the &lt;em&gt;add the token to the stack&lt;/em&gt; part of the translation was just as simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;em&gt;if the token ends a container block&lt;/em&gt; part of the translation was a bit more
tedious to implement.  This was primarily due to end tokens not having any concept of
the token that started that block, only the name.  As such, after adding a comment and
a note to improve this, the following code was written to figure out if the container
block was ending:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;token_name_without_prefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token_name_without_prefix&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_block_quote&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_unordered_list_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_ordered_list_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_new_list_item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, the &lt;em&gt;remove the last item from the stack&lt;/em&gt; was translated into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;token_name_without_prefix&lt;/span&gt;
            &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After all that was added, I quickly ran the tests and… tests were failing all over
the place.  But why?&lt;/p&gt;
&lt;h3 id="getting-the-stack-code-working"&gt;Getting the Stack Code Working&lt;a class="headerlink" href="#getting-the-stack-code-working" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Looking at the stack code, something became obvious almost immediately. If my
observation was correct, the processing of the &lt;code&gt;EndMarkdownToken&lt;/code&gt; was never being
invoked. A couple of quick debug statements verified that observation.  Doing a bit
more digging, I found out that I had set the class of the &lt;code&gt;EndMarkdownToken&lt;/code&gt; to
&lt;code&gt;INLINE_BLOCK&lt;/code&gt;.  This meant at the start of the consistency check loop, the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INLINE_BLOCK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;would prevent the &lt;code&gt;EndMarkdownToken&lt;/code&gt; from ever getting through.  A quick fix changed
that statement to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INLINE_BLOCK&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the test all ran… er… not fine?  With echoes of “what now?” ringing through
my ears, and debugging some more, the answer took a while to find.  Using extra
debug statements, I was able to pull some additional information out of the tests.
It became apparent that the second half
of the function had many issues with those end tokens.  However, addressing that
issue was easy, by adding the following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;after the stack code and before the remaining code.  A couple of extra test runs, both
with and without debug statements and… everything was working with the new stack code.
On to the next issue!&lt;/p&gt;
&lt;h3 id="removing-block-quotes"&gt;Removing Block Quotes&lt;a class="headerlink" href="#removing-block-quotes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the stack code in place and running cleanly, I needed to add the code to
prevent checking for the consistency for block quotes.  As previously decided, block
quotes were outside the scope of the current enhancement, and as such the following
code was added to check for block quotes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;found_block_quote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_block_quote&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;found_block_quote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;found_block_quote&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;last_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this code may seem flawed, it was written this way on purpose.  I did not want
to have to validate any tokens that were contained within a block quote block, but I
did not want to remove the validation of the non-contained tokens either.  The above
block of code simply checks to see if there is a block quote on the container block
stack, skipping over any token while that condition is true.  This allows for any
block quote contained tokens to be avoided, while still validating any other tokens
present in that test sample.&lt;/p&gt;
&lt;h3 id="ignoring-tabs-for-now"&gt;Ignoring Tabs for Now&lt;a class="headerlink" href="#ignoring-tabs-for-now" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The other big thing to take care of was to ignore any tabs that occurred in the
initial whitespace for any of the block tokens.  This was accomplished by changing the
return value of &lt;code&gt;__calc_initial_whitespace&lt;/code&gt; to be a pair of values, the first being the
same &lt;code&gt;indent_level&lt;/code&gt; as before and the second was a new &lt;code&gt;had_tab&lt;/code&gt; variable.  By setting
this variable, it was then possible to change this assert:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;init_ws&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;had_tab&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;init_ws&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As I knew tabs were going to be a problem until they are properly and thoroughly
addressed, this change circumvented the assert statement when a tab was encountered.&lt;/p&gt;
&lt;h2 id="adding-the-basic-enhancement"&gt;Adding the Basic Enhancement&lt;a class="headerlink" href="#adding-the-basic-enhancement" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With those changes in place and the tests passing, it felt that it was the right time
to add the code for the planned enhancement.  The basic part of this change was
easy, adding an else statement that followed the &lt;em&gt;same line number&lt;/em&gt; check, as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CONTAINER_BLOCK&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;last_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;init_ws&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;had_tab&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__calc_initial_whitespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;had_tab&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;init_ws&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This part of the algorithm makes clear sense.  Leaf blocks always start on a new
line, except for when they are started on the same line as a container block. As such,
the token starts right after any leading whitespace.  Since this enhancement focuses
solely on leaf block tokens on a new line, and due to the previous work to ignore any
tabs in the consistency checks, this code was kept simple.&lt;/p&gt;
&lt;p&gt;Testing this code out in my head, it was all sound except for when the token was in
a container block.  While
block quote blocks were excluded, that still left list blocks.  As such, when I ran the
tests this time, I expected failures to occur with leaf blocks that are started on their
own line but are contained within a list block.  As I went through the test run
failures, it was affirming to see that each of the failures that were now showing up
were squarely within those parameters.&lt;/p&gt;
&lt;h3 id="going-through-the-failures"&gt;Going Through the Failures&lt;a class="headerlink" href="#going-through-the-failures" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I went through the failures from the last set of code changes, I scribbled down notes
about the failure patterns that I saw.  The big pattern that I observed is, what I felt,
was a very obvious one.
When a leaf block was created within a list block, the reported column number was
always one more than the &lt;code&gt;indent_level&lt;/code&gt; variable for the list token.  That pattern does
make sense, as the list block contains the new leaf block, calculated from the indent
level of the list.&lt;/p&gt;
&lt;p&gt;The first pass at modifying the check to take this into account was the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                &lt;span class="n"&gt;top_block&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_unordered_list_start&lt;/span&gt;
                    &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
                    &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_ordered_list_start&lt;/span&gt;
                    &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_new_list_item&lt;/span&gt;
                &lt;span class="p"&gt;):&lt;/span&gt;
                    &lt;span class="n"&gt;init_ws&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indent_level&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code almost worked but reported errors with the first line.  That was quickly
addressed with a simple change to the code, checking to make sure that the
&lt;code&gt;container_block_stack&lt;/code&gt; variable containing the container stack is not empty:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;container_block_stack&lt;/span&gt;
                &lt;span class="p"&gt;):&lt;/span&gt;
                    &lt;span class="n"&gt;top_block&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                        &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_unordered_list_start&lt;/span&gt;
                        &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
                        &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_ordered_list_start&lt;/span&gt;
                        &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_new_list_item&lt;/span&gt;
                    &lt;span class="p"&gt;):&lt;/span&gt;
                        &lt;span class="n"&gt;init_ws&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indent_level&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="dealing-with-consistency-and-lists"&gt;Dealing with Consistency and Lists&lt;a class="headerlink" href="#dealing-with-consistency-and-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At this point, the only tests that were failing were tests related to list blocks.
Most of those tests were either contained in the &lt;code&gt;test_markdown_list_blocks.py&lt;/code&gt; module
or the &lt;code&gt;test_markdown_lists.py&lt;/code&gt; module.  Doing a bit more digging, the reason for a lot
of the failures was visible within seconds of looking at the failing scenario tests.
To make sure that lists and their inevitable sublists can be controlled properly, the
&lt;code&gt;indent_level&lt;/code&gt; variable contains the required indentation from the beginning of the
line, not since the end of the last list block.  To
complement this, any whitespace that occurs before that list block is saved within
the list block token.  The effect of this is that both ordered and unordered list
start tokens did not require any further modification, containing all the required
information within their own token.&lt;/p&gt;
&lt;p&gt;To address this, the check for adjusting the calculation if the token is in a list
was changed to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;container_block_stack&lt;/span&gt;
                    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
                    &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_unordered_list_start&lt;/span&gt;
                    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
                    &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_ordered_list_start&lt;/span&gt;
                &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Furthermore, on additional examination, blank lines were in a similar situation.  Blank
lines contain complete information on how they were derived, so no manipulation of the
token’s column number was required.  Hence, another slight modification of the check
resulted in the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;container_block_stack&lt;/span&gt;
                    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_blank_line&lt;/span&gt;
                    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
                    &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_unordered_list_start&lt;/span&gt;
                    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
                    &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_ordered_list_start&lt;/span&gt;
                &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="almost-there"&gt;Almost There&lt;a class="headerlink" href="#almost-there" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Running the tests again, the number of failures remaining was now a much smaller set of
tests.  Once again doing my due diligence,
I discovered an interesting issue with the new list item token: I had left out an
important field out of the token.  Unlike the ordered and unordered list start tokens,
the contents of
the new list item
token only had the &lt;code&gt;indent_level&lt;/code&gt; field, with the &lt;code&gt;extracted_whitespace&lt;/code&gt; field being
added to try and solve the failures.  But without the proper values for the
&lt;code&gt;extracted_whitespace&lt;/code&gt; field, it was not a proper solution to the problem.  I even
made modifications to the container block stack to properly deal with the new list
tokens. But even with those two changes in place, it just was not enough to solve all
the issues.&lt;/p&gt;
&lt;p&gt;Once I determined that it was not enough, I knew that I had to fix this properly at a
later date and close out this enhancement.  To accomplish that, I made a small change
to the code as part of the main consistency check: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_new_list_item&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="c1"&gt;# TODO later&lt;/span&gt;
                &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I did not feel that it was a great solution, but it was a decent stop-gap until I
could address those tokens.&lt;/p&gt;
&lt;h2 id="the-inevitable-bug-fixes"&gt;The Inevitable Bug Fixes&lt;a class="headerlink" href="#the-inevitable-bug-fixes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Along the way, there were some small issues that were uncovered in the parser code,
fixed almost immediately due to their small nature.  There was a small fix made to the
&lt;code&gt;list_in_process&lt;/code&gt; function to make sure that the line was adjusted properly in some
edge cases.  There was another fix to the &lt;code&gt;__adjust_for_list_start&lt;/code&gt; function to make
sure that it returned an indication of whether it processed the list start index or not.
And finally, even though the tabs were not part of the enhancement, there was a bit
of cleanup to do in the area of the dual-purpose code used to handle list indents and
block quotes.  None of these were big bugs, but little issues that the consistency
checker was uncovering, and getting dealt with up front before they became a larger
issue.&lt;/p&gt;
&lt;p&gt;And that is where I stopped.  I knew that if I started trying to get more of the tab
code to work, it would be another rabbit hole.  Reminding myself of the big picture and
the current goals for the enhancement, I backed off.  And after a couple of minutes,
I felt good about it.  Tabs would wait for another enhancement, and then I would spend
a good amount of time working on tabs.  But for now, it could wait.&lt;/p&gt;
&lt;h2 id="importance-of-starting-small"&gt;Importance of Starting Small&lt;a class="headerlink" href="#importance-of-starting-small" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I needed this enhancement to be a win, and I think I achieved that by keeping my
goals in mind. Rather than trying to do everything and having my effort be scattered,
I kept my work focused within the boundaries of a simple goal, one that I had
confidence that I would be able to achieve.  With this progress, I felt more confident
about myself and the project, and I knew I was on my way back to building a solid and
stable foundation that I could build further on.&lt;/p&gt;
&lt;p&gt;While my previous experience guided me towards this approach as I needed a win, it is
a solid approach regardless.  One of my managers at a previous company used to say:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is better to under promise and over perform than the other way around.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I prefer another quote that was relayed to me by a friend at my current company:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Having a conversation with someone about resetting expectations is always troubling for me.  I would rather my reports take small bites of work and get better estimates on those bites of work, than take huge chunks of works and get lost and need help finding their way.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Those words have stayed with me for a long while, and I have tried to live up to the
essence of that quote.  I cannot tell anyone when the PyMarkdown linter is going to be
ready.  The scope is big enough that I cannot accurately judge that span of time.  But
I can let people know what my next 3 items on the issue list are, and approximately how
long it will take to complete them.  Those items are my small bites, something I can
solidly analyze and realistically figure out a time frame for their completion.&lt;/p&gt;
&lt;p&gt;For me, I feel that it is better to complete 10 tasks that work together than to
complete 1 task that will not work until it is completely done.  There just is no
comparison in my mind.  And having just completed one of those smaller tasks, my
confidence was returning.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After my experience with the rabbit hole called &lt;em&gt;Tabs&lt;/em&gt;, I was worried that I was
going to focus more on the negative aspects of the project, rather than making
some good progress.  Would I repeat the behavior that I documented in my last article,
or would I correct that behavior and move the project forward?  While the
enhancements I made to the consistency checking were small, I was convinced that they
were solid enhancements.  That was exactly the type of win that I needed.&lt;/p&gt;
&lt;p&gt;This enhancement was not about technical feasibility, it was about getting myself out of
a negative headspace.  I believe it is true of most people that we are own worst
enemies, as we are privy to those thoughts and emotions that we keep private.  I know
that I am my own worst enemy for those reasons.  And while I did try hard with the
last enhancement, I know I was harder on myself that others would have been.  Not for
going down the rabbit hole, but because I did not notice I had slipped down there and
needed to get out of there before getting lost.&lt;/p&gt;
&lt;p&gt;I started this enhancement trying to get rid of the “oh no, here we go again” mindset.
Based on where my confidence was at finishing this enhancement, I am proud to report a
lot of positive work has been done.  My confidence was by no means back to where it
should be, but I was on my way there.  I developed a plan, made certain limitations,
and stuck by those limitations while delivering a well thought out enhancement.&lt;/p&gt;
&lt;p&gt;This was definitely a step in the right direction.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having added a few issues to my issues log, mostly to verify certain scenarios I tested
or wrote about, I knew that I had some technical debt building up.  Along with the
new list item token issue, I felt it was a good time to build up some more confidence
by knocking some more of those issues out of the way.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Rabbit Hole 2 - Losing My Way</title><link href="https://jackdewinter.github.io/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/" rel="alternate"></link><published>2020-06-22T00:00:00-07:00</published><updated>2020-06-22T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-06-22:/2020/06/22/markdown-linter-rabbit-hole-2-losing-my-way/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/"&gt;last article&lt;/a&gt;,
I talked about starting to add consistency checks for the line/column numbers by
adding simple line number checks.  In this article, I document the work that I
performed to add column checks to the project in a similar fashion to.  While I would
like …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/"&gt;last article&lt;/a&gt;,
I talked about starting to add consistency checks for the line/column numbers by
adding simple line number checks.  In this article, I document the work that I
performed to add column checks to the project in a similar fashion to.  While I would
like to say that the required effort was simple and the work was quickly accomplished,
as the title of the article implies, there were issues along the way that I could have
handled better.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the
&lt;a href="https://jackdewinter.github.io/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/#adding-in-more-line-number-checks"&gt;end of the last article&lt;/a&gt;,
I talked about how I felt that the right move at that time was to move from the basic
consistency checking of line numbers to adding  a similar level
of checks for column
numbers.  My main argument for switching was that, from experience, it was
easier to track the line numbers when I manually verified the line/column numbers
than it was to track the column numbers.&lt;/p&gt;
&lt;p&gt;For line numbers, unless it was a list block
or a block quote block, a new block always meant a new line, which was easy to keep
track of.  For those two container blocks,
I had to check to see if a new block followed the container block, but the calculation
was still relatively simple.&lt;/p&gt;
&lt;p&gt;The calculation of column numbers was more detailed, and therefore more difficult
for me to accurately
calculate on-the-fly.  If not contained within a list block or a block quote block, I
looked at the whitespace at the start of the token and adjusted the column based
on the amount of whitespace.  If it was within a container block, I looked at the amount
of indent imparted by the container block and adjusted from there.  And while these
calculations may seem straightforward and easy, I initially double and triple checked
these values before moving on.  Even then, when I was checking the consistency of the
line numbers, I know that I got a decent handful of column numbers wrong.&lt;/p&gt;
&lt;p&gt;In the end, after getting some proper perspective, I believe that the
situation became an easy one to resolve.  I had the
easy cases for line numbers done, and that was good enough for a while.  I needed to get
the column numbers to a confidence level where I felt comfortable going back to the
line numbers and finishing off those checks.  Even though I was nervous about the
mistakes that I would find, I buckled down and started to work.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits after
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/9a2196b4dfd9948ef188e40c2619346bc4e673be"&gt;30 May 2020&lt;/a&gt; up to
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/19b4a2e6c26588370a2bab063b5cb1583d45f7d1"&gt;11 Jun 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="in-case-you-did-not-notice"&gt;In Case You Did Not Notice&lt;a class="headerlink" href="#in-case-you-did-not-notice" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking at the dates in the previous section, the duration between the start of the
column number work and the end of the column number work was 12 days.  To be clear,
this was not all the column number work, just the easy parts of the column numbers.
The batch of work documented in this article took a lot longer than my normal 5-day
to 7-day work time.&lt;/p&gt;
&lt;p&gt;It was for reasons like this situation that I named the articles in this part of the
series as “rabbit hole” articles.  Using that term at work a lot, it was amusing to
looking around for a good definition of what “rabbit hole” really means.  After some
fun research, I settled on this specific part of the article at
&lt;a href="https://www.dictionary.com/e/slang/rabbit-hole/"&gt;dictionary.com’s slang dictionary&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But as Kathryn Schulz observed for The New Yorker in 2015, rabbit hole has further evolved in the information age: “These days…when we say that we fell down the rabbit hole, we seldom mean that we wound up somewhere psychedelically strange. We mean that we got interested in something to the point of distraction—usually by accident, and usually to a degree that the subject in question might not seem to merit.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That really does capture what happened here.  But I do not want to spoil the story too
much.  Just continue reading and keep this in mind.&lt;/p&gt;
&lt;h2 id="keeping-it-simple-to-start"&gt;Keeping It Simple to Start&lt;a class="headerlink" href="#keeping-it-simple-to-start" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As with all good tales, the work started off with good intentions.  As stated above, I
simply wanted to replicate for column numbers, the extra confidence that I achieved
with line numbers.  To that extent, the first stipulation that I made was that, if
possible, I was going to leave the container blocks until later.  Container
blocks were going to easily make things more confusing, so leaving them out would free
my mind up to concentrate solely on the leaf blocks.
While I was not sure what impact that rule would make, I hoped that it would reduce
the large amount of work that I was anticipating.&lt;/p&gt;
&lt;h2 id="taking-time-to-come-up-with-a-plan"&gt;Taking Time to Come Up With A Plan&lt;a class="headerlink" href="#taking-time-to-come-up-with-a-plan" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With container block tokens (via the previous section) and inline tokens (as noted in
previous articles) excluded, I was able to concentrate all my effort on the leaf blocks.
While it was tempting to dive right into the work and to “clean everything up”, I knew
that I needed more of a plan than “clean everything up”
or “check all leaf blocks”.  I needed to take a good survey of the existing tokens and
their resultant HTML and determine what the intent of the token is and how it translates
into HTML.&lt;/p&gt;
&lt;p&gt;How did I know to do that?  When I was going through the different scenario tests while
implementing the consistency checks for
the line numbers, I noticed that there seemed to be 2 different classes of column
numbers for leaf tokens: one class where the whitespace occurs before the token and one
class where the whitespace seems to be part of the token.  It took a bit of research
and looking again at the tests, but I did verify that there were at least 2 classes of
leaf tokens.&lt;/p&gt;
&lt;p&gt;Confused?  Let me help!&lt;/p&gt;
&lt;h3 id="organizing-classes-of-blocks-by-their-intent"&gt;Organizing Classes of Blocks By Their Intent&lt;a class="headerlink" href="#organizing-classes-of-blocks-by-their-intent" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Fenced code blocks are blocks where any whitespace that occurs before the token is
recorded in the token, placing it solidly in the &lt;code&gt;before&lt;/code&gt; class.  Looking at the
Markdown for
&lt;a href="https://github.github.com/gfm/#example-105"&gt;example 105&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;aaa&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the Markdown for &lt;a href="https://github.github.com/gfm/#example-106"&gt;example 106&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;aaa&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;in the GFM specification, both fenced code block Markdown fragments produce the exact
same HTML output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;aaa
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that any whitespace before the code block starts is removed and does not appear in
the output.  While I need to add that whitespace back in to validate the column numbers
properly, it makes no difference to the HTML that is output.  As all the whitespace
occurs before the token itself starts, I decided to call this class of leaf blocks
the &lt;code&gt;before&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;On the other hand,
&lt;a href="https://github.github.com/gfm/#example-86"&gt;example 86&lt;/a&gt;
shows Markdown text for an indented code block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;foo&lt;/span&gt;
    &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;that produces the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    foo
bar
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, the indented code block is more aware of the whitespace that occurs
before the block starts, putting it firmly in the &lt;code&gt;contains&lt;/code&gt; class.  Specifically,
this class of blocks is for any leaf block where the whitespace makes up even a small
part of the block itself.  This is obvious with this block as the whitespace starts
at column 1 but continues in the produced HTML within the &lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;To prove that these leaf blocks are in the correct classes, I replicated the above
examples, but deleted a single space character from the initial whitespace for each
code block.  That change did not make any difference to the fenced code block, but
that change precipitated the removal of one space character from the HTML output for
the indented code block.  Due to that simple behavior, it was simple to place every leaf
block type into one of the two classes, allowing the blocks to be mostly handled as a
group of blocks instead of as individual blocks.&lt;/p&gt;
&lt;h3 id="aside"&gt;Aside&lt;a class="headerlink" href="#aside" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To keep things above board, there technically is a third class, but it is mostly hidden.
In the case of blank lines and link reference definitions, the actual HTML output for
both elements is that they are ignored.  Therefore, technically the third class is for
&lt;em&gt;ignored&lt;/em&gt; tokens, but for the purposes of this classification, I assume they are in
neither class.&lt;/p&gt;
&lt;h3 id="classifying-the-blocks"&gt;Classifying the Blocks&lt;a class="headerlink" href="#classifying-the-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that newly acquired information in mind, I walked through similar examples and
assigned each of the leaf tokens to one of these three classes: before, contains, or
ignored.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;thematic breaks: before, see &lt;a href="https://github.github.com/gfm/#example-17"&gt;example 17&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;atx headings: before, see &lt;a href="https://github.github.com/gfm/#example-38"&gt;example 38&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;setext headings: before, see &lt;a href="https://github.github.com/gfm/#example-54"&gt;example 54&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;indented code block: contains, see &lt;a href="https://github.github.com/gfm/#example-86"&gt;example 86&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;fenced code block: before, see &lt;a href="https://github.github.com/gfm/#example-106"&gt;example 106&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;HTML block: contains, see &lt;a href="https://github.github.com/gfm/#example-120"&gt;example 120&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;link reference definition: ignored, see &lt;a href="https://github.github.com/gfm/#example-162"&gt;example 162&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;paragraphs: before, see &lt;a href="https://github.github.com/gfm/#example-192"&gt;example 192&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;blank lines: ignored, but treated as contains, see &lt;a href="https://github.github.com/gfm/#example-197"&gt;example 197&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="keeping-things-consistent"&gt;Keeping Things Consistent&lt;a class="headerlink" href="#keeping-things-consistent" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In looking at how whitespace was handled for each of the leaf block tokens, one thing
did indeed stand out: I was not storing whitespace for each of the tokens in the token
itself.  While it was being passed down to the base class, there was not an explicit
variable named &lt;code&gt;extracted_whitespace&lt;/code&gt; for each token that stored this information.
Some tokens had that variable, some did not.&lt;/p&gt;
&lt;p&gt;While I could calculate this information on a token by token basis, it seemed simpler
to add the following line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to each of the constructors that were not assigning the argument to a member variable.
Specifically, the tokens for block quotes, list starts, indented code blocks, html
blocks, and thematic breaks needed this change, and it was a very quick change to
perform.  The important thing about this change was that, going forward, each of the
non-ignored tokens contained a
variable that explicitly was there to contain any extracted whitespace.  As this
variable was now in most block tokens, I hoped that the group of tokens could now be
processed largely as one group, instead of 11 distinct block tokens.&lt;/p&gt;
&lt;h2 id="player-enter-rabbit-hole-level-1"&gt;Player, Enter Rabbit Hole Level 1&lt;a class="headerlink" href="#player-enter-rabbit-hole-level-1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I implemented the column numbers to begin with, I honestly thought there was only
one class of tokens, and therefore I treated them all as if they were in the &lt;em&gt;before&lt;/em&gt;
class.  To that extent, when I calculated each of the column numbers for the leaf
tokens, I started with the number 1 at the first position in the line and incremented
by 1 for each space character present in the data.  Effectively, I used the formula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But now that I knew there was also a &lt;em&gt;contains&lt;/em&gt; class, it meant adjusting the formula
slightly.  Additionally, based on further observations, it looked like the HTML blocks
and the indented code blocks were going to need slightly different formulas.&lt;/p&gt;
&lt;p&gt;HTML blocks were the easiest one to observe and determine the pattern for.  Based on
the Markdown from
&lt;a href="https://github.github.com/gfm/#example-120"&gt;example 120&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it was obvious to me that the Markdown produces output that is exactly what is
contained within the block, namely:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  *hello*
         &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on the transformation, an
&lt;a href="https://en.wikipedia.org/wiki/Identity_transform"&gt;identity transformation&lt;/a&gt;
to be exact, it made sense that the formula for HTML blocks is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The reasoning for this simple calculation is based on the observation of the transformed
HTML.  As any text that is part of the Markdown HTML block is part of the resultant
HTML, I interpreted that to mean that the block itself starts at the start of the line,
hence a column number of 1.&lt;/p&gt;
&lt;p&gt;Following a similar line of investigation, I looked at a good example of an indented
code block, the Markdown for
&lt;a href="https://github.github.com/gfm/#example-86"&gt;example 86&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;foo&lt;/span&gt;
    &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and its resultant HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    foo
bar
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on this transformation, after the first 4 spaces are removed from the start of
each line, those lines are inserted into the HTML output, with a &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;
around them.
As the first 4 spaces are removed from each line, they are effectively part of the
token, but in a weird way.  In the above example, the first 4 spaces are swallowed while
the remaining spaces are left intact.  Based on this behavior, I interpreted that to
mean that the block itself starts after the 4th space, even though there are more spaces
before the non-space text starts.  Given that, the formula is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;but with a special provision that any unused text is added to the start of the text
token that follows the indented code block token.&lt;/p&gt;
&lt;p&gt;Now that I had the behavior down, it was on to implementing the code for the
consistency check.&lt;/p&gt;
&lt;h2 id="congratulations-player-now-enter-rabbit-hole-level-2"&gt;Congratulations Player, Now Enter Rabbit Hole Level 2&lt;a class="headerlink" href="#congratulations-player-now-enter-rabbit-hole-level-2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having a solid idea of the behavior that I expected from each &lt;em&gt;contains&lt;/em&gt; token and the
group of &lt;em&gt;begins&lt;/em&gt; tokens, it was time to write the consistency check.
To allow for an easy computation of what the initial positioning was, I created
the &lt;code&gt;__calc_initial_whitespace&lt;/code&gt; function, starting it off with the equivalent
of:&lt;sup id="fnref:every"&gt;&lt;a class="footnote-ref" href="#fn:every"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__calc_initial_whitespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calc_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;calc_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="sb"&gt;`every token`&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;indent_level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calc_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By isolating all the various formula into one function, I was to be able to
use this simple code to implement the check itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;init_ws&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__calc_initial_whitespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;init_ws&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="fixing-the-easy-failures"&gt;Fixing the Easy Failures&lt;a class="headerlink" href="#fixing-the-easy-failures" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After running the scenario tests with this new code in place, there were a lot of
successes,
but also failures that I needed to deal with.  The first set of failures
was with
various tokens that did not have a properly implemented &lt;code&gt;extracted_whitespace&lt;/code&gt; member
variable: HTML blocks,
blank lines, and SetExt headings.&lt;/p&gt;
&lt;p&gt;The HTML blocks were the easiest to deal with, as the formula from the previous section
always returns a column number of 1.  I added code to always return an index of 0 for
the length of the initial whitespace, resulting in a column position of 1 once the
above code was applied.  From there, blank lines were equally easy. While there are
good arguments for having blank lines denote the start or the end of the line, I picked
the start of the line to keep things simple. This made the coding easy, as these tokens
ended up returning 0, the same value as for HTML blocks.&lt;/p&gt;
&lt;p&gt;That left an oddball: SetExt headings.  For some reason that is lost to me, SetExt
headings use the &lt;code&gt;remaining_line&lt;/code&gt; member variable instead of
&lt;code&gt;extracted_whitespace&lt;/code&gt;.  While it felt weird, it was easy to do a quick check for that,
returning the length of that variable when SetExt headings tokens were encountered.
I also added an issue to my list to check this out in the future, as it is an
unnecessary complication that does not add any benefit.&lt;/p&gt;
&lt;p&gt;Running that scenario tests again, most of the issues were dealt with easily, following
the above rules, and adjusting the column numbers to the newly corrected values after
additional manual verification.
It was only a small handful of
errors that showed up, mostly in the HTML block scenario tests and the indented code
block scenario tests.  As those two blocks were ones that I placed into the
&lt;em&gt;contains&lt;/em&gt; class, these failures were expected and quickly addressed, applying changes
to the scenario tests to resolve those failures in short order.&lt;/p&gt;
&lt;h3 id="paragraphs-were-a-bit-more-work"&gt;Paragraphs Were a Bit More Work&lt;a class="headerlink" href="#paragraphs-were-a-bit-more-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The next group of failures were easily grouped together as scenario tests that deal
explicitly with paragraphs.  On closer examination, it seemed that the failures occurred
only in a couple of specific cases.  After a couple of observations, it became obvious
that the failures were
restricted to multiline paragraphs.  In those multiline paragraphs, all the
whitespace stripped from the start of each line in the paragraph is added to the
token, not just the first line.  To address that, I made some quick changes to the code
for dealing with multiline paragraph tokens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;calc_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;calc_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;indent_level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;calc_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;indent_level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calc_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the paragraph tokens dealt with, the column numbers now lined up nicely between
my calculated numbers and the consistency check numbers.  Other than tabs, the only
outlying scenario tests were two tests for indented code blocks inside of list blocks.&lt;/p&gt;
&lt;h3 id="another-rabbit-hole"&gt;Another Rabbit Hole&lt;a class="headerlink" href="#another-rabbit-hole" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To be honest, during the writing of this article, getting a firm understanding of the
status of these two scenario tests took a couple of passes.  I had that understanding
when I completed the tests, then forgot it before I wrote the article.  When I started
to write article, I figured it out again, then forgot it while focusing on other
aspects of the article.  Finally, when I found the correct answer again, before I
forgot the explanation yet again, I quickly jotted down notes for this section.&lt;/p&gt;
&lt;p&gt;Yes, column numbers can be confusing.  Keep good notes.  Trust me on this.&lt;/p&gt;
&lt;p&gt;The two list block scenario tests that I had issues with were
&lt;a href="https://github.github.com/gfm/#example-235"&gt;example 235&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-252"&gt;example 252&lt;/a&gt;.  For example 235:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;    &lt;span class="n"&gt;one&lt;/span&gt;

     &lt;span class="n"&gt;two&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;due to the extra indentation, the top paragraph starts at column number 7.  However,
as the lower paragraph does not have enough spaces to match that start column, it is
instead interpreted as an indented code block.&lt;sup id="fnref:see236"&gt;&lt;a class="footnote-ref" href="#fn:see236"&gt;2&lt;/a&gt;&lt;/sup&gt;  As such, that indented code
block starts at column 5, per established rule from above, and contains text that
starts with the 1 extra space.  As the column number in the test was 6, it was adjusted
to the now correct value of 5, with manual verification and consistency check
verification in place.  From personal experience, it was easy to forget that the
indented code block starts after the 4 space indent, making the calculation look
wrong.&lt;/p&gt;
&lt;p&gt;For &lt;a href="https://github.github.com/gfm/#example-252"&gt;example 252&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;      &lt;span class="n"&gt;indented&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;

   &lt;span class="n"&gt;paragraph&lt;/span&gt;

       &lt;span class="k"&gt;more&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it was more &lt;em&gt;fun&lt;/em&gt; with lists, but this time it was an unordered list that
contained a valid indented code block, unlike the example above.  In this case, the
list start sequence does not have any whitespace before it and is a simple 1 digit
list start.  From a calculation point of view, that means start with 0, add 0 to
that total for leading whitespace for the list start, 2 to that total for characters
in the list start sequence, and then add 1 to that total for the mandatory
list-to-content whitespace separator.  That means that the earliest that any content
can start in the list is at index 3, matching the list’s &lt;code&gt;indent_level&lt;/code&gt; member
variable.  As the
next token is an indented code block, adding 4 to that total results in an index of 7
or a position/column of 8 where the content for the code block starts.
  As the column number in the test was 9, it was adjusted
to the now correct value of 8, with manual verification and consistency check
verification in place.&lt;/p&gt;
&lt;p&gt;As I mentioned in my introduction to this article, the calculation for column numbers
were more detailed.  It was not until I wrote down the formulas for the calculation,
as outlined above, that I was able to confirm that I had made the right choice.&lt;/p&gt;
&lt;p&gt;And with that, all the scenario tests were passing except for tabs.&lt;/p&gt;
&lt;p&gt;Yeah, tabs again.&lt;/p&gt;
&lt;h2 id="be-wary-player-now-enter-rabbit-hole-level-3-tabs"&gt;Be Wary Player, Now Enter Rabbit Hole Level 3: Tabs&lt;a class="headerlink" href="#be-wary-player-now-enter-rabbit-hole-level-3-tabs" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I looked at the code, dreading a lot of changes to the code to support tabs, there
was both good
news and bad news.  The first part of the good news was that
except for the tab scenarios, the rest of the code was solid.  I had found a couple of
issues so far, but otherwise column numbers looked good.  The second part of the good
news
was that anything to fix with respect to tabs at the start of a line would be
largely restricted to the indented code blocks.  Until I started testing with container
blocks, any blocks that started with any combination of tabs and spaces would always
trigger the 4 whitespace minimum required to start an indented code block.&lt;/p&gt;
&lt;p&gt;The bad news?  This was not going to be fun.   As I documented in
&lt;a href="https://jackdewinter.github.io/2020/04/27/markdown-linter-reducing-the-parsers-technical-debt/#refactor-2-more-fun-with-tabs"&gt;More Fun With Tabs&lt;/a&gt;,
Markdown uses tab characters as tab stops.  To remove the complexity of handling those
tabs at the start of every block, I did the necessary computations to translate tab
characters into the correct number of spaces, based on the current index in the Markdown
document.  From that point on, any leading whitespace was tab-free and easy to work
with and manipulate for the transformation into HTML.&lt;/p&gt;
&lt;p&gt;But then I got to validating tokens for consistency with respect to column numbers.
After clearing away all the
other failures, only 13 failures remained, and all them dealt with tabs and
specifically with tabs in indented code blocks.  How bad could it be to reverse the
change and pass the initial whitespace through?  I started working the problem.&lt;/p&gt;
&lt;p&gt;Three days later, I determined that it would be very difficult.  After 2 restarts, there
was just too much code already in place to handle that relied on all leading whitespace
being space characters.
Replacing it would require more time to just get it to a good starting point, not even
to the point of having the tests passing.  Resetting for a third time, I decided to
just focus on the initial case of having a tab in the starting whitespace that caused
an indented code block.  Instead of working to reset the tab in all the code,
I focused on reconstructing the leading whitespace to determine what the proper handling
of the tab should be.&lt;/p&gt;
&lt;p&gt;Another three days later, and the code was complete.  When the initial whitespace is
encountered, a check is made against the initial line to be parsed to see if that line
contains a tab.  If so, further progressing is done to extract the original whitespace
that directly corresponds to the initial whitespace that caused the indented code block
to be started.  Once the original whitespace fragment was recovered, the extracted
whitespace in the indented code block token was adjusted, placing the proper portions
of the leading whitespace in the code block token and the following text block token.
And it also provisionally supported lists and block quotes.&lt;/p&gt;
&lt;h3 id="why-did-i-need-to-do-this"&gt;Why Did I Need to Do This?&lt;a class="headerlink" href="#why-did-i-need-to-do-this" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Basically, before this work, the whitespace that
was in the leaf block tokens did not have to be correct as it was largely ignored. As
such, only the extracted whitespace stored in the enclosed text block had to be
correct, as that whitespace is directly exposed when rendering the token into HTML.  To
make this more evident, consider the Markdown text for
&lt;a href="https://github.github.com/gfm/#example-7"&gt;example 7&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;tab&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;tab&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt; is a tab character.  As the specification explains, there is a bit of
calculation trickery in this area.  The list start character &lt;code&gt;-&lt;/code&gt; must be followed by
a space, so when the first tab character is encountered, 2 spaces must be emitted to
replace the tab stop.  When the next tab character is encountered, we are already at
a tab stop, so that tab is replaced with 4 characters, for a total initial whitespace
of 6 characters.&lt;/p&gt;
&lt;p&gt;Why was this important?  Because I had to make sure the right whitespace was being
placed in the right token, otherwise either the HTML validation would fail, or the
new consistency checks would fail.  Before this consistency check, if I
placed the needed 2 characters in the HTML text, the test passed.  Due to the check,
I now had to also properly calculate the whitespace to put in the indented code block
tokens itself.&lt;/p&gt;
&lt;p&gt;As I finished up work on the changes, I looked at the calendar… and noticed that
instead of my usual one week of work, it was 12 days later.  What I had budgeted 5
days for had taken 12 days.&lt;/p&gt;
&lt;h2 id="what-went-wrong"&gt;What went wrong?&lt;a class="headerlink" href="#what-went-wrong" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking back, I simply messed up. To me, there is nothing wrong with messing
up with something like this, if I learn something and grow.  So, it is just a
matter of taking a good look at what happened, and being honest with myself.&lt;/p&gt;
&lt;p&gt;The big thing that happened is that I believe that when I saw that it was going to
be a lot of additional work to support tabs, I should have stopped to re-evaluate
what needed to be done.  Instead, I kept on pressing forward instead of evaluating
whether tabs were worth it at that time.  As I personally do not use tabs, and many
of the documents that I surveyed do not have tabs in them, I could have sidelined tabs
for another day.&lt;/p&gt;
&lt;p&gt;In addition, once I started to work on implementing the proper tab support for the
tokens, I ignored additional warning signs.  Thinking back, I believe that I
kept on thinking “just around the next corner” and “one more line”, instead of being
honest about the work.  Essentially, I let my pride get in the way.  Instead of
being okay with leaving a partially implemented solution or resetting the work, I
was convinced that it was just another 5 minutes away… even after 5 days.&lt;/p&gt;
&lt;p&gt;On top of that, I mostly ignored my rule about leaving container blocks out of the
current block of work.  To get to this point with the tabs, I had to write extra
code that is specifically in place to deal with indented code blocks within container
blocks that contain tabs in the leading whitespace.  That is doubling down on dealing
with container blocks, not leaving them for later.&lt;/p&gt;
&lt;p&gt;I need to think about things.  How did I feel about all this?&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I have
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#changing-the-narrative"&gt;mentioned before&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Stuff happens, pick yourself up, dust yourself off, and figure out what to do next.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yeah, I messed up.  Stuff happened.  Instead of doing what I normally do, I went down
the rabbit hole
and got lost in trying to get the column numbers right, not just “good enough”. Even
after I started implementing the tab support, I did not pay attention to my own
warning signs that were telling me to reset and regroup.&lt;/p&gt;
&lt;p&gt;As for the dusting myself off, I realized that there was some good news out of all
this work.  Good news from all this? Really?&lt;/p&gt;
&lt;p&gt;The biggest part of the good news is this is the first time that this kind of thing
has happened on this project.  Yeah, I was
&lt;a href="https://en.wikipedia.org/wiki/Hyperfocus"&gt;hyperfocused&lt;/a&gt;
on getting the
work done, and did not pay attention to anything else.  But unlike other projects where
this happened multiple times throughout the same project, this was the first time for
this project.  One instance of this for a project that has lasted 8 months… not bad!
This is not just me making
&lt;a href="https://www.idiomeanings.com/make-lemonade-out-of-lemons/"&gt;lemons out of lemonade&lt;/a&gt;,
I was genuinely happy.  Granted, it took me a bit of self-reflection to get there,
but I got there.&lt;/p&gt;
&lt;p&gt;And on the way there, I did notice things.  One thing that I am confident about is that
even though having to take this route
with the tab characters is painful, it would have been more painful to have to deal
with those tabs in multiple places.  The current implementation for leading whitespace
removes the tabs, only adding them back in for the few cases where they are needed.
Another thing is that although I needed to address a couple of issues with 2 classes
of leaf blocks, the calculations for the column numbers were mostly spot on.  I still
want to make sure remain consistent by having consistency checks, but I am more
confident that I calculated the column numbers correctly.&lt;/p&gt;
&lt;p&gt;Sure, I got distracted.  It happens to everyone, especially with projects that we are
all passionate about.  I sincerely wanted to do the right thing, and that is not bad,
just counterproductive at this time.  Right now, I need “good enough”, not “perfect”.
While this was indeed a setback, it was a relatively small setback, one that I can
easily recover from.&lt;/p&gt;
&lt;p&gt;Overall, I was a bit bruised from following tabs down the rabbit hole, but I was
okay with it.  Not proud of it, but also not blaming myself and flogging myself for
it either.  Just okay with it.  And while I did go overboard, I did get the initial
scope of work done.  In the end, all is good.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After focusing a lot of time on went wrong, it took a bit for me to realize that the
consistency checks were working as planned.  But on further examination, with possible
influence from my issues with hyperfocusing, I decided that I was not yet at the
point where I could switch back to line numbers.  As such, my next article will talk
about how I continued this work verifying column numbers.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:every"&gt;
&lt;p&gt;The text &lt;code&gt;every token&lt;/code&gt; is not meant to be taken literally.  Instead of listing each of the 11 tokens, I just felt it was more compact to use a figurative value. &lt;a class="footnote-backref" href="#fnref:every" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:see236"&gt;
&lt;p&gt;The case where the second paragraph’s column matches the indent of the list item is tested in &lt;a href="https://github.github.com/gfm/#example-236"&gt;example 236&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:see236" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Rabbit Hole 1 - Adding Consistency Checks</title><link href="https://jackdewinter.github.io/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/" rel="alternate"></link><published>2020-06-15T00:00:00-07:00</published><updated>2020-06-15T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-06-15:/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the end of my
&lt;a href="https://jackdewinter.github.io/2020/06/08/markdown-linter-adding-line-and-column-support/"&gt;last article&lt;/a&gt;,
I talked about how I felt a lack of confidence in the work that I had just completed,
primarily due to the large number of scenario tokens that I added line/column numbers
to. This article documents the work to increase my …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the end of my
&lt;a href="https://jackdewinter.github.io/2020/06/08/markdown-linter-adding-line-and-column-support/"&gt;last article&lt;/a&gt;,
I talked about how I felt a lack of confidence in the work that I had just completed,
primarily due to the large number of scenario tokens that I added line/column numbers
to. This article documents the work to increase my confidence in those line/column
numbers
by starting to add consistency checks to all the scenario tests.  Additionally, I talk
about the bad line/column numbers that were found by the new consistency checks and how
I addressed those issues.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Why am I referring to this work as a
&lt;a href="https://www.merriam-webster.com/dictionary/rabbit%20hole"&gt;rabbit hole&lt;/a&gt;?
It is because this kind of verification can be easy, but if things are not done right,
the verification itself can be very messy and seemingly endless.  As with many things
in this project, whether or not to do this is a balancing act between the risk of doing
(or not doing) it, the
cost of doing it, and the impact if the risk comes to pass. The risk of not doing this
type of verification is that I may have miscalculated one of the line number/column
number pairs for one of the tokens in the 700+ examples that make up the scenario
tests. The cost of doing this is a small amount of code for the verification part of
the code, but it could also add tons of code to the actual parser to track additional
elements.  The impact is even more difficult to pin down.&lt;/p&gt;
&lt;p&gt;While part of the impact is measurable, namely the number of line number and column
number errors found, the other part of the impact is not measurable: confidence.
There is my confidence that I have those numbers right and there is the confidence of
any users that I have those numbers right.  And if I do not reach the minimum confidence
level for any users of the project, I am certain that I will lose those users.  It will
be a balancing act that I will need to be aware of, and to monitor going forward, even
after this work is finished.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits after
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/9a2196b4dfd9948ef188e40c2619346bc4e673be"&gt;30 May 2020&lt;/a&gt; up to
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4bb4034ec69bc0aa67552f08c986ff94632e1e82"&gt;14 Jun 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="a-quick-aside"&gt;A Quick Aside&lt;a class="headerlink" href="#a-quick-aside" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Yes, one of these again!  I have been trying to figure out a good way to talk about
the line number and column numbers as a pair, trying out various combinations over
the last article and during the writing of this article.  The most descriptive and most
compact wording that I believe captures the information is: line/column number.  It
both indicates that they are a pair and that the pair has two distinct parts.  From
this point forward, I am going to strive to consistently use this format.&lt;/p&gt;
&lt;h2 id="starting-with-some-refactoring"&gt;Starting with Some Refactoring&lt;a class="headerlink" href="#starting-with-some-refactoring" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I am always looking for ways to make the project better, and this was no exception.
During the addition of the &lt;code&gt;position_marker&lt;/code&gt; variables throughout the parsing code,
I noticed there were four variables that were usually getting passed around together:
&lt;code&gt;token_stack&lt;/code&gt;, &lt;code&gt;token_document&lt;/code&gt;, &lt;code&gt;close_open_blocks_fn&lt;/code&gt; and &lt;code&gt;handle_blank_line_fn&lt;/code&gt;.
While these variables might have slightly different names in the functions that used
them, their usage pattern was very consistent.  In each case, they were defined once in
the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class, and passed without change down throughout the rest of the
parser.  If Python had a good concept of a read-only variable, I would have used that
concept to decorate these variables.  Another alternative was to make these variables
static variables, but it did not feel right to me to make them into 4 different
static variables.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ParserState&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Class to provide for an encapsulation of the high level state of the parser.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;token_document&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;close_open_blocks_fn&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;handle_blank_line_fn&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;token_stack&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_document&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;token_document&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close_open_blocks_fn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;close_open_blocks_fn&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle_blank_line_fn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;handle_blank_line_fn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As I did want to reduce the overhead of passing these around, I created a new class
&lt;code&gt;ParserState&lt;/code&gt;, initialized an instance of it in the &lt;code&gt;__parse_blocks_pass&lt;/code&gt; function of
the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class, and added those four variables to that class as member
variables.  Then I worked my way through the parser, passing that object down further
and further into the parser.  Along the way, where possible, I removed PyLint
&lt;code&gt;too-many-arguments&lt;/code&gt; warnings and a couple of &lt;code&gt;too-many-locals&lt;/code&gt; warnings as well.  To
me, it just left things a bit cleaner, and ready for the next
step: starting to add the consistency checks.&lt;/p&gt;
&lt;h3 id="why-not-static-variables"&gt;Why not static variables?&lt;a class="headerlink" href="#why-not-static-variables" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Perhaps it is my object-oriented background or perhaps it is
my test automation background, but both of those backgrounds note that static variables
are bad.  From the object-oriented point of view, static variables cause issues because
you must be very aware of what is changing and observing those variables at every
moment.  From the test automation point of view, static variables are just hard to
test.  Because
everything in the project that uses that static variable has access to it, it can be
the result of a direct or indirect change from almost anywhere in that project.  If it
is only accessible from a static method, then there are problems with clearing out the
value of that variable so it can be properly tested under all circumstances.  Basically,
most of my experience tells me to stay away from static variables if possible.&lt;/p&gt;
&lt;h2 id="starting-with-the-plumbing"&gt;Starting with the Plumbing&lt;a class="headerlink" href="#starting-with-the-plumbing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With any sort of verification code, it is always a good idea to start with something
simple, slowly building on top of that work.  As this was just normal verification code,
the first thing I did was to add this function to the &lt;code&gt;utils.py&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assert_token_consistency&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Just a simple function that could be called from each of the scenario tests, starting
out with a skeleton function that does nothing.  With that in place, I started the
laborious task of going to each of the &lt;code&gt;test_markdown_*.py&lt;/code&gt; files and changing the
tests at the end of each scenario test from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_strings_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_gfm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_gfm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_strings_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_gfm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_gfm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;assert_token_consistency&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This was a simple task, but by making sure it was completed, I was able to go ahead
and add in any consistency checks between the Markdown and the tokens without wondering
if I had missed any of the tests.  And yes, I was paranoid and double checked all
the scenario tests at least one more time to make sure I did not miss any of the tests.&lt;/p&gt;
&lt;p&gt;Why did I take such a small step?  While other people’s mileage may vary, I find that
adding multiple consistency checks in a single step compounds the errors that
can occur if you get that check wrong.  Unless I can avoid it, I choose small changes
to the verification that I can easily validate manually, getting those changes addressed
solidly before moving on.  The base calculus that I am betting on is that the time
taken to complete multiple steps independently is less than the time taken to combine
them together.  Based on my experience, including implementing, testing, debugging, and
maintenance as factors into that equation usually favors the independent steps.&lt;/p&gt;
&lt;h2 id="verifying-the-line-numbers-start-at-1"&gt;Verifying the Line Numbers Start At 1&lt;a class="headerlink" href="#verifying-the-line-numbers-start-at-1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I was sure that verifying column numbers was going to be messy, but I was confident
that verifying line numbers would be more simplistic.  When it comes down to it, the
base part of verifying line numbers is making sure that each block token starts on
its own new line, except for a block that is within a container block.  In those cases,
and only those cases, can the line number be the same.&lt;/p&gt;
&lt;p&gt;But even before I started down that path, the first verification that I wanted to do
was to make sure that each array of tokens started with a block token on line 1.  It
was the simplest verification that I could think of, and from previously discovered
issues, I knew there were at least a couple of reported issues in this area.  If I
coded it properly, not only would I validate that the verification was working, but
I could also detect and fix an issue or two at the same time.&lt;/p&gt;
&lt;h3 id="classifying-the-tokens"&gt;Classifying the Tokens&lt;a class="headerlink" href="#classifying-the-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Up to this point in the project, I had little need to classify any of the Markdown
tokens as anything other than Markdown tokens.  When I addressed a block of tokens,
those tokens were always as a single token or as a small group of 2-3 tokens.  But,
to verify the line numbers properly, I was going to need to group the tokens on a
larger scale.  To accomplish that, I was going to have to add classification to the
tokens.&lt;/p&gt;
&lt;p&gt;In re-reading the verification steps outlined at the start of the previous section, I
realized at the minimum I was going to need to add the concept of each token belonging
to a specific class of token.
In this context, I was defining the class of the token as the grouping assigned to the
Markdown element in the GFM specification.  Using that as a template, along with some
previous work with Python enumerations, I was able to quickly set up this enumeration:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Enumeration to provide guidance on what class of token the token is.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="n"&gt;CONTAINER_BLOCK&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;LEAF_BLOCK&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;INLINE_BLOCK&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While Python supports four types of enumerations, I was confident that the simple
type of enumeration was the right fit to solve this issue.  I did not need the
enumeration to do anything fancy, just provide a simple property value for each token
that specifies what the class of that token is: container block, leaf block, or inline.
With the enumeration in place, it was a simple task to go through all the tokens in the
&lt;code&gt;markdown_token.py&lt;/code&gt; module and associate each token with its respective class. Using
the GFM specification as a guide, each token was matched up to its owning element and
assigned the proper class instance for that element.&lt;/p&gt;
&lt;h3 id="adding-the-first-verification"&gt;Adding the First Verification&lt;a class="headerlink" href="#adding-the-first-verification" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With each token classified, the first part of the token verification was to only focus
on the blocks, as inline line/column numbers were not yet implemented.  Using the new
classification variable &lt;code&gt;token_class&lt;/code&gt; this was easily accomplished by adding a simple
loop over all the non-inline tokens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INLINE_BLOCK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, this was expanded to remember the last token, as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;last_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INLINE_BLOCK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;pass&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

        &lt;span class="n"&gt;last_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While these were not big changes, it was a good start.  It made sure that the first
token in the document was always positioned on line number 1, which it should always
be.  If not,
the verification code asserts on the failure.  Simple.  And while I could have added
more
checks, I decided that was complex enough for now, and stopped there.  As I mentioned
above, taking small steps with the verification is a far safer bet.  And as I would
soon discover, it was already bearing fruit!&lt;/p&gt;
&lt;h3 id="looking-for-issues-link-reference-definitions"&gt;Looking for Issues - Link Reference Definitions&lt;a class="headerlink" href="#looking-for-issues-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When implementing the line/column numbers for each block tokens, as documented in the
&lt;a href="https://jackdewinter.github.io/2020/06/08/markdown-linter-adding-line-and-column-support/#lather-rinse-repeat"&gt;last article&lt;/a&gt;,
I noted down scenario
tests that looked dodgy for later examination.  At that time, I tagged the scenario
tests for examples 166 and 168 as being incorrect as they started off with an
extra blank line that started on line 2.  With this new verification code in place, when
those scenario tests were executed again, those new verification tests failed right
away.&lt;/p&gt;
&lt;p&gt;The output of the test was not an issue, as the HTML output for a blank line token in
the current output formatter is to output nothing.  However, when I added in the
line/column number check, it failed as it was the first block token in the output, and
it reported that it started on line 2.  The blank line was indeed on line 2, but the
token was being output at the start of the token array, and then again in the middle of
the &lt;code&gt;actual_tokens&lt;/code&gt; array.&lt;/p&gt;
&lt;p&gt;After some digging, I was able to find the error. During the processing of the blank
line, the parser checks to see whether there is an active link reference definition,
and if so, stops the definition.  However, regardless of whether a definition
was found, that blank line token is appended to the &lt;code&gt;token_document&lt;/code&gt; array.  With any
other token, this would be the correct thing to do.  However, as the processing of
the link reference definition
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#hitting-implementation-issues"&gt;requires rewinding on failures&lt;/a&gt;,
the blank line was output, the parsing was rewound for the failed link reference
definition, and then the blank line was output again.  Once I figured out what the
problem was, it was easily remedied by seeing if a rewind was in progress by checking
the &lt;code&gt;force_ignore_first_as_lrd&lt;/code&gt; variable, and only emitting the token if it was not set.&lt;/p&gt;
&lt;p&gt;After some double checking, the scenario tests for example 166 and 168 were executed
again, verifying that they were indeed fixed.  I then ran the tests again to see what
other tests were failing, and it was a mass of SetExt heading failures that caught
my eye right away.&lt;/p&gt;
&lt;h3 id="looking-for-issues-setext-headings"&gt;Looking For Issues - SetExt Headings&lt;a class="headerlink" href="#looking-for-issues-setext-headings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It was very evident that more than half of the SetExt heading tests were failing
from the scenario test summary line.  Performing a quick count of the failing tests,
there were 13 SetExt heading tests failures out of a total 25 scenario tests.  As I
have put significant time into making sure that both the SetExt and Atx headings are
working properly, I was surprised to see that there were any verification failures, let
alone 13 of them.&lt;/p&gt;
&lt;p&gt;Within seconds of looking at the first of those tests, it was easy to see why the
verification was failing.  In the scenario test for example 50, the first part of
the Markdown text is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="o"&gt;=========&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;but the tokens being output by that block of Markdown text was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "[setext(2,1):=:]",
        "[text:Foo :]",
        "[emphasis:1]",
        "[text:bar:]",
        "[end-emphasis::1]",
        "[end-setext::]",
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From an HTML point of view, the tokens were correct, as the HTML output for that text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Foo &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was correct.  But it was also obvious that the line/column number for the first token
was wrong.  As the first token, it should start on line 1, not line 2.  Even more
interesting is that if you visually look at the Markdown, it is obvious that it indeed
is the first Markdown element in the document.&lt;/p&gt;
&lt;p&gt;Starting to debug this scenario test, the answer was quick to come.  In the processing
of a SetExt heading, as
&lt;a href="https://jackdewinter.github.io/2020/06/01/markdown-linter-taking-time-to-evaluate/#adjusting-the-parsing-of-whitespace-in-setext-tokens"&gt;talked about previously&lt;/a&gt;,
the Markdown for a SetExt heading occurs after a paragraph has completed, transforming
that paragraph into a SetExt heading.  At the time that the SetExt heading token is
added to the markdown token array, the position that is associated with the token is
the start of the SetExt Markdown indicator.  As such, that is the position that is used
for the token.  And it does make sense that for every token, the position should
indicate where that token occurs.&lt;/p&gt;
&lt;h3 id="adapting-the-token-to-properly-represent-its-data"&gt;Adapting the Token to Properly Represent Its Data&lt;a class="headerlink" href="#adapting-the-token-to-properly-represent-its-data" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Despite the token position being technically correct, from a line/column number
verification point of view it did not make sense, and line/column numbers were what
was being verified.  As I thought about this, I vacillated between
representing the token with the position of the SetExt Markdown element and
the position of the block of text contained within the SetExt heading.  To me, there
just was not a good answer.  They both had a valid use and a valid reason to be the
one position that represented the token.&lt;/p&gt;
&lt;p&gt;Battling back and forth, I finally came to the realization that I needed to break out
of my current thinking that a token must have only one position.  While it is
not a feature I want to use frequently, this was an honest case where the token
should contain two positions: the primary position to contain the location of the
SetExt element itself and the secondary position to contain the location of the block
of text contained within the SetExt heading.&lt;/p&gt;
&lt;p&gt;To accomplish this, I added two new variables to the &lt;code&gt;SetExtHeadingMarkdownToken&lt;/code&gt; class:
&lt;code&gt;original_line_number&lt;/code&gt; and &lt;code&gt;original_column_number&lt;/code&gt;.  These two variables would be used
independently of the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt; variables to track the position
of the block of text contained within the SetExt heading.  I wired up the necessary
code to pass in the correct values for the two new variables, included adjusting the
&lt;code&gt;__str__&lt;/code&gt; function to present them as part of the token.&lt;/p&gt;
&lt;p&gt;When I reran the scenario test for example 50, I was pleasantly greeted with the
following new set of tokens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "[setext(2,1):=::(1,1)]",
        "[text:Foo :]",
        "[emphasis:1]",
        "[text:bar:]",
        "[end-emphasis::1]",
        "[end-setext::]",
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="changing-the-scenario-tests"&gt;Changing the Scenario Tests&lt;a class="headerlink" href="#changing-the-scenario-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now that the SetExt heading token contained a good set of information, I needed to
change the scenario tests to understand the new information.  Without any change, those
tests would still only know about the primary position.  To address this issue, I added
the following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__calc_adjusted_position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;markdown_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_setext_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;original_line_number&lt;/span&gt;
        &lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;original_column_number&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
        &lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;PositionMarker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;index_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it may seem like overkill to some people, the purpose of this function is to
keep the addition of this new logic contained within a single function.  This
encapsulation came in useful when I added it in to the consistency function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;last_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;current_position&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__calc_adjusted_position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INLINE_BLOCK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;last_position&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__calc_adjusted_position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

        &lt;span class="n"&gt;last_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Used for both the &lt;code&gt;current_token&lt;/code&gt; and the &lt;code&gt;last_token&lt;/code&gt;, the new function easily provides
the right position for both tokens, with only a small change to the target function. In
addition, the adding of the &lt;code&gt;last_position&lt;/code&gt; variable gave me a bit of a reminder of the
direction that I needed to go in with the consistency checks.  More on that in a minute.&lt;/p&gt;
&lt;p&gt;Refocusing myself on the work directly ahead of me, running all the scenario tests
yielded 20 test failures, the original 13 tests plus another 7 tests that contained
SetExt heading tokens, just not at the start of the array.  For each of those 20 tests,
I manually checked the new tokens against the Markdown sample, and once I was satisfied
that they were accurate, I adjusted the expected tokens for that test to match the new
tokens.&lt;/p&gt;
&lt;p&gt;And this time, when I ran all the scenario tests, I was greeted with a clean slate
of no test failures.&lt;/p&gt;
&lt;h3 id="before-going-on"&gt;Before Going On&lt;a class="headerlink" href="#before-going-on" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Up to this point, when adding the consistency checks, I was mostly invoking the
tests with the following line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -m gfm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the new consistency checks were only concerned with the scenario tests, this was
the fastest method to run all those tests.  However, before continuing, I wanted
to make sure those changes did not have any adverse side effects, so I ran the all
the tests in the project using:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While running all the tests may not have been necessary, I wanted to run them to
be confident that I did not introduce any bad side effects.  As the complete group of
tests can be executed in less than half a minute, the cost of the little bit of extra
confidence was easy for me to justify.&lt;/p&gt;
&lt;h2 id="adding-more-consistency-checks"&gt;Adding More Consistency Checks&lt;a class="headerlink" href="#adding-more-consistency-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the SetExt heading tokens addressed and all the scenario tests passing again,
it was time to add more consistency checking.  As alluded to in the last section,
now that the line numbers are being verified for the first token, it was time to
add verification of container blocks and leaf blocks on the same line.&lt;/p&gt;
&lt;p&gt;In this case, the smallest step I could take was to check for two blocks that had the
same line number.  When this condition is true, the previous block must be a container
block, otherwise some error has just occurred.  In addition, without worrying about
column number accuracy yet, I can also state that that the current position must be to
the right of the enclosing block.  Adding those changes into the consistency checking
was therefore just as easy as its description:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;last_position&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__calc_adjusted_position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_class&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownTokenClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CONTAINER_BLOCK&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;last_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;current_position&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this was not checking everything yet, it was a good step forward.  While I was
certain that I did not mess anything up with the container tokens, it was
good to have the validation that I did not miss anything.  It was to my surprise
that when ran the scenario tests again, two failures were reported.&lt;/p&gt;
&lt;h3 id="duplicated-tokens"&gt;Duplicated Tokens&lt;a class="headerlink" href="#duplicated-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After I got over my surprise at there being two possible container block failures, I
started to investigate those two tests.  It was with relief that I noticed that both
tests, 218 and 219, were noted as being suspicious during the work from my last
article. From a quick glance at the test output, it was easy to spot that the check
was not failing due to container block issues, but due to almost duplicate blank line
tokens present in the
&lt;code&gt;actual_tokens&lt;/code&gt; array.  Because the line number was the same in both tokens,
it looked like a case of a leaf block within a leaf block instead of a duplicated
token.&lt;/p&gt;
&lt;p&gt;Debugging through this, it took me a while to figure this issue out.  After a lot
of head scratching, I finally had added enough debug information that I noticed that
in the code for the &lt;code&gt;parse_line_for_container_blocks&lt;/code&gt; function, once the calling of the
&lt;code&gt;handle_block_quote_block&lt;/code&gt; function was completed, the blank line had already been
handled, but the processing continued.  After verifying this a couple of times, I tried
removing the first call to process the blank line, but some of the other cases where
I handled blank lines stopped working.  While it did seem a bit of a kludge&lt;sup id="fnref:kludge"&gt;&lt;a class="footnote-ref" href="#fn:kludge"&gt;1&lt;/a&gt;&lt;/sup&gt;,
on the return from the &lt;code&gt;handle_block_quote_block&lt;/code&gt; function, I simply verified that the
blank line process was handled already.  If that, then the tokens were added to the
markdown token array, and the function was returned from.&lt;/p&gt;
&lt;p&gt;As the scenario test for example 261 was also flagged in the same line as 218 and 219,
I took a similar look at the output, of that, but did not notice any issues.  I even
tried some variations on the data to see if there was an error that was previously
exposed, and now fixed, and I was not able to reproduce it.  Confident that 218 and 219
were fixed and that I could not reproduce 261, I removed those issues from my
issues list.&lt;/p&gt;
&lt;p&gt;Once again, I re-ran the scenario tests, and all the test passed.  Executing the
entire batch of tests for the project, I was also greeted with a clean set of tests,
each one of them passing.  Now to figure out what to do next.&lt;/p&gt;
&lt;h2 id="adding-in-more-line-number-checks"&gt;Adding in More Line Number Checks?&lt;a class="headerlink" href="#adding-in-more-line-number-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a good look at adding more line number verification, I had a hard choice to
make.  Either I could try and add more line number verification, or I could start
working on column number verification.  There were good reasons for both paths, but
I had to make a choice.&lt;/p&gt;
&lt;p&gt;I went back and forth on this decision before taking another look at the existing
scenario tests, trying to figure out what I was most concerned about.  I decided that
while
it would be nice to get the line numbers completed, I was more concerned about the
column numbers.  In the token array for each scenario tests, I was able to track
the lines and line numbers more easily that I was able to track the column numbers.
In the end, that one observation is what affected my decision: I needed to start
verifying the column numbers next.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For any consistency checking being implemented, it is often useful to have a handful
of issues that you know should fail, and then see the new consistency logic
failing.  The new checks passed that part of the test.  In addition, the
consistency checks add so far pointed out an issue with how I assigned line/column
numbers to the SetExt heading token.  Having caught and
reported failures on those issues, I was confident that adding consistency checking
for the line/column numbers was a good thing to do.  Seeing as the cost was still
very low, it seemed that the cost:benefit ratio was still heavily in favor of
continuing, so that is what I decided to do.&lt;/p&gt;
&lt;p&gt;Going back to my main issue regarding my confidence with line/column numbers and
their accuracy, if anything, I think I believed that I had lost ground.  With each
check finding something, it was both an affirmation that I was right to question
my manual verification abilities and a challenge to find more issues with more
consistency checking.  Basically, it was both “good job” and “what else ya got?” in
the same sentence.&lt;/p&gt;
&lt;p&gt;If I am honest, I felt it was a bit of a setback.  I had hoped it was going to lift
my confidence a bit, instead of a give-and-take that balanced each other out.  I
knew I needed to do something to boost my confidence, and I just hoped that adding
column number consistency checks would be the key to that.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having reached a good point in my verification for line numbers, it was time to proceed
further down the
&lt;a href="https://www.merriam-webster.com/dictionary/rabbit%20hole"&gt;rabbit hole&lt;/a&gt;
that is consistency checking by starting to verify the column numbers.  And what a
rabbit hole it would end up being!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:kludge"&gt;
&lt;p&gt;According to Merriam-Webster: “a haphazard or makeshift solution to a problem and especially to a computer or programming problem” &lt;a class="footnote-backref" href="#fnref:kludge" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Line and Column Support</title><link href="https://jackdewinter.github.io/2020/06/08/markdown-linter-adding-line-and-column-support/" rel="alternate"></link><published>2020-06-08T00:00:00-07:00</published><updated>2020-06-08T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-06-08:/2020/06/08/markdown-linter-adding-line-and-column-support/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I documented at the
&lt;a href="https://jackdewinter.github.io/2020/06/01/markdown-linter-taking-time-to-evaluate/#what-is-next"&gt;end of the previous article&lt;/a&gt;,
having arrived at the decision to improve the linter’s foundation,
it was time to tackle the largest issue on the stack: missing support for line numbers
and column numbers.
While at the time I thought of it as …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I documented at the
&lt;a href="https://jackdewinter.github.io/2020/06/01/markdown-linter-taking-time-to-evaluate/#what-is-next"&gt;end of the previous article&lt;/a&gt;,
having arrived at the decision to improve the linter’s foundation,
it was time to tackle the largest issue on the stack: missing support for line numbers
and column numbers.
While at the time I thought of it as a glaring omission (see
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#line-numbers-and-column-numbers"&gt;this article for more&lt;/a&gt;
), the passage of time since that discovery has helped me see that omission in a
better light.  On its own, the process of getting the tokenization correct was a large
enough task but adding the determination of each token’s line number and column
number to that task would have made that task unbearably larger.
Knowing myself as I do, even if I had discovered that requirement during the design
phase, there is a really good chance that I would have relegated the determination of
each token’s original position into its own task.  Regardless of what happened in the
past, it was obvious that I needed to start working on that task now.&lt;/p&gt;
&lt;p&gt;Starting to think about this issue, I had no doubt it was going to be a tough task to
complete, and I knew that I needed to find a way to break things down even further.
As I figured that
adding line numbers and column numbers to every token was going to be too much, I
reduced the scope even further by deciding to limit the scope to only block tokens.  As
every inline element is rooted in
a block element, I had
confidence that this would ensure that the line number and column numbers would be solid
in each block elements before adding the inline elements into the mix.  It was also a
solid dividing line for the task that just made sense to me.&lt;/p&gt;
&lt;p&gt;With those decisions on scope dealt with, it was time to delve into the depths of
line numbers and column numbers.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/628d6848029c3a2b02c755611455301fdf0fced4"&gt;26 May 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/1eb3677506dcefe7562f72082bed5374761f21cc"&gt;16 May 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="why-was-reducing-the-scope-good"&gt;Why Was Reducing the Scope Good?&lt;a class="headerlink" href="#why-was-reducing-the-scope-good" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Each of the implemented and enabled parser test functions includes the list variable
&lt;code&gt;expected_tokens&lt;/code&gt; and the string variable &lt;code&gt;expected_gfm&lt;/code&gt;.  The &lt;code&gt;expected_tokens&lt;/code&gt;
variable
is used to ensure that the tokens that are expected from the Markdown document are
emitted by the parser.  The &lt;code&gt;expected_gfm&lt;/code&gt; variable is used to ensure that those tokens
can use a simple algorithm&lt;sup id="fnref:simpleAlg"&gt;&lt;a class="footnote-ref" href="#fn:simpleAlg"&gt;1&lt;/a&gt;&lt;/sup&gt; to transform themselves into the HTML required by
the specification.  Prior to this work, their focus was simple: enable that forward
translation from Markdown into HTML.&lt;/p&gt;
&lt;p&gt;Adding in support for line numbers and column numbers was going to be a lot of work,
but it was working in a different direction: backwards towards the original Markdown
document.  There was no denying that this was a difficult task to complete, but
due to circumstances, the reduction in scope would leave me with a far simpler problem
to solve.  In addition, to protect the work already done in the forward direction, the
existing battery of tests remained in place, diligently guarding that work.&lt;/p&gt;
&lt;p&gt;With protection for the already completed work in place, and a clear definition of the
work to be done in mind, it was time for me to figure out how to start the process off.&lt;/p&gt;
&lt;h2 id="where-to-start"&gt;Where to start?&lt;a class="headerlink" href="#where-to-start" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To help me keep track of things,
I added each of the block element names to the
&lt;code&gt;readme.md&lt;/code&gt; document where I track my issues.  As I needed to represent
every Markdown block, I moved the question in the issue document regarding the adding
of a Link Reference Definition token to the start of this new section and transformed
it into a statement.  As each block element in the
Markdown document needed to be tagged with its position, it was a necessity that
Link Reference Definition tokens be added, even if they did not result in any HTML
output.&lt;/p&gt;
&lt;p&gt;Having all the blocks elements listed in that document, I then needed to somehow
pick a good place to start. I was aware that wherever I decided to start, that token
was going to have a lot more work
associated with it as I tested out and implemented the foundation used to add line
numbers and column numbers to the other tokens.  Whatever process and code I used
for that first block element; the plan was to repeat it in some closely related form
for each of the other 10 block elements in the list.  But which one to pick?&lt;/p&gt;
&lt;p&gt;In the end, I decided to start with Atx headings.  Unfortunately, I did not keep any
notes as to why I picked this block element to start. My best guess is that after
having a lot of exposure to heading code while implementing the last group of rules, I
figured headings would be a good place to
start.  Following that line of thought, I believe that I also would have guessed that
SetExt headings were going to be the more difficult token to change, leaving Atx
headings as the best place to start.  Either that, or I decided to go alphabetic and
‘a’ is the first letter of the alphabet.  Either way, Atx headings were first, and it
was going to be a &lt;em&gt;fun&lt;/em&gt; ride.&lt;/p&gt;
&lt;h2 id="adding-in-position-markers"&gt;Adding in Position Markers&lt;a class="headerlink" href="#adding-in-position-markers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a good look at the Atx headings and the information that was being passed around,
the first thing that caught my eye was a good opportunity to refactor.  As I was letting
parts of the parser grow organically, many functions included the argument
&lt;code&gt;line_to_parse&lt;/code&gt; along with an argument that was usually named &lt;code&gt;start_index&lt;/code&gt;.  This
organic pairing made sense in a lot of places, allowing for the easy manipulation of
the current index, and occasionally the &lt;code&gt;line_to_parse&lt;/code&gt;.  However, when adding in
support for line numbers, I was going to have to pass in a third variable, meaning it
was time to refactor this.  As I have said
&lt;a href="https://jackdewinter.github.io/2020/05/04/markdown-linter-core-pre-rule-improvements/#source-providers"&gt;previously&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Write it once, write it neat.  Write it twice, think about extracting it.  Write it three times, extract it without a second thought.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that is where I started to work on replacing the &lt;code&gt;line_to_parse&lt;/code&gt; variable and the
&lt;code&gt;start_index&lt;/code&gt; like variables with the &lt;code&gt;position_marker&lt;/code&gt; variable and the
&lt;code&gt;PositionMarker&lt;/code&gt; class.  This class was, and remains, very simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PositionMarker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Class to provide an encapsulation of the location within the Markdown document.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;index_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text_to_parse&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_number&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;index_number&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_to_parse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;text_to_parse&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_indent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;line_to_parse&lt;/code&gt; variable was replaced by the &lt;code&gt;text_to_parse&lt;/code&gt; member variable, the
index-type variable was replaced with the &lt;code&gt;index_number&lt;/code&gt; member variable, with the
&lt;code&gt;line_number&lt;/code&gt; member variable being introduced.  As I knew I would have to support
“indented” text, such as text after a block quote character or a list start sequence,
I added &lt;code&gt;index_indent&lt;/code&gt; at the same time.&lt;/p&gt;
&lt;p&gt;And with that, the easy stuff was ended.  It was time to move on to the tougher stuff.&lt;/p&gt;
&lt;h3 id="creating-the-marker"&gt;Creating the marker&lt;a class="headerlink" href="#creating-the-marker" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Wanting to start at the beginning, I made some modifications to the
&lt;code&gt;__parse_blocks_pass&lt;/code&gt; function in the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class to track the line
number.  As I did not have to deal with Link Reference Definition tokens yet
(spoilers!), this was a straight forward change, with the local &lt;code&gt;line_number&lt;/code&gt; variable
being initialized
before the main loop and that same variable being incremented at the end of the loop.
To encapsulate this information, I created a new position marker as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;position_marker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PositionMarker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;token_to_use&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of passing &lt;code&gt;token_to_use&lt;/code&gt; to the &lt;code&gt;parse_line_for_container_blocks&lt;/code&gt; function, I
instead passed in the expression &lt;code&gt;position_marker.text_to_parse&lt;/code&gt;.  While I wanted to
pass in &lt;code&gt;position_marker&lt;/code&gt; by itself, I knew I had some important work to do before
getting that would be possible.&lt;/p&gt;
&lt;h3 id="stage-1-integrating-the-marker-locally"&gt;Stage 1 - Integrating the Marker Locally&lt;a class="headerlink" href="#stage-1-integrating-the-marker-locally" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Using my knowledge of the project, I knew that the path between the
&lt;code&gt;__parse_blocks_pass&lt;/code&gt; function in the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class and the
&lt;code&gt;parse_atx_headings&lt;/code&gt; function in the &lt;code&gt;LeafBlockProcessor&lt;/code&gt; class was going to go through
a number of functions in the &lt;code&gt;ContainerBlockProcessor&lt;/code&gt; class.  Instead of
using a lot of guesswork to determine what that path was, I decided to start at the
&lt;code&gt;parse_atx_headings&lt;/code&gt; function itself and work my way backwards to the
&lt;code&gt;parse_line_for_container_blocks&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;In the place of adapting the entire function in one pass, I decided to start with
focusing
on the passing of the position marker into the function.  To facilitate this decision,
in the &lt;code&gt;parse_atx_headings&lt;/code&gt; function, I wrote some simple
&lt;a href="https://en.wikipedia.org/wiki/Glue_code"&gt;glue code&lt;/a&gt; to interface between the old style
code and the new style code. Before the change, the code looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse_atx_headings&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;close_open_blocks_fn&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Handle the parsing of an atx heading.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="n"&gt;new_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After the change, the code looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse_atx_headings&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;close_open_blocks_fn&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Handle the parsing of an atx heading.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="n"&gt;line_to_parse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_to_parse&lt;/span&gt;
        &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt;
        &lt;span class="n"&gt;new_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the &lt;code&gt;__parse_line_for_leaf_blocks&lt;/code&gt; function where the &lt;code&gt;parse_atx_headings&lt;/code&gt; function
was called from, I created a new &lt;code&gt;PositionMarker&lt;/code&gt; instance named &lt;code&gt;temp_marker&lt;/code&gt;, with
the information from the local function.  That new &lt;code&gt;temp_marker&lt;/code&gt; variable was then
passed into the &lt;code&gt;parse_atx_headings&lt;/code&gt; function instead of the previously used
&lt;code&gt;line_to_parse&lt;/code&gt; and &lt;code&gt;start_index&lt;/code&gt; arguments.&lt;/p&gt;
&lt;p&gt;I knew from the start that this approach was going to be more work.  However, by
isolating the change
to the function’s signature, I knew I could keep the parser stable and usable at any
point.  By keeping the parser in that good state, I knew I could depend on the
large bank of tests used by the project to verify any change was a successful change
with no unintended side effects.  The process was indeed slower than some other
methods, but it was a process that I had absolute confidence that I could rely on.&lt;/p&gt;
&lt;h3 id="stage-2-integrating-the-marker-up-the-stack"&gt;Stage 2 - Integrating the Marker Up the Stack&lt;a class="headerlink" href="#stage-2-integrating-the-marker-up-the-stack" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In this stage, the process that was applied to the &lt;code&gt;parse_atx_headings&lt;/code&gt; function was
applied again and again until the &lt;code&gt;__parse_blocks_pass&lt;/code&gt; function was
reached.  With every step going back towards that function, I repeated the same actions
that I performed in stage 1, but with the calling function: add glue code, change
function arguments, create a temporary position marker, and pass that position marker
into the newly changed function.&lt;/p&gt;
&lt;p&gt;The almost continuous execution of tests at this point was essential.  As with any
parser, even slight changes in the content or interpretations of the content can cause
small ripples in the output that may escape detection if not quickly located and
addressed.  While I was doing my best to try and ensure that all changes were kept as
isolated as possible, it was only the rapid battery of tests that kept my confidence
high that I was going in the right direction with no ripples.&lt;/p&gt;
&lt;p&gt;Another thing that helped me immensely was using Git’s staging ability.  To facilitate
clean commits, Git has a nice feature called a
&lt;a href="https://git-scm.com/about/staging-area"&gt;staging area&lt;/a&gt;,
with the moving changes into this area being commonly referred to as staging.  The nice
part about Git staging is that,
&lt;a href="https://www.freecodecamp.org/forum/t/how-to-discard-unstaged-changes-in-git/13214"&gt;as this article describes&lt;/a&gt;,
it is very easy to discard any changes made to your local files in favor of the state of
that file with any committed changes and staged changes applied.  As such, each time I
applied this process to another function, I ensured that once the tests were all
passing that I staged those changes in the repository.  In the cases where I made
mistakes, which did happen frequently, I had the knowledge that I was able to revert
the relevant files back to their pre-change states, and resume work from there.  When
it was time to commit those changes, they were already isolated in the staging area,
ready to be committed.&lt;/p&gt;
&lt;h3 id="stage-3-cleaning-up-going-back-down"&gt;Stage 3 - Cleaning up Going back down&lt;a class="headerlink" href="#stage-3-cleaning-up-going-back-down" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Once I reached the &lt;code&gt;__parse_blocks_pass&lt;/code&gt; function, I was able to connect
with the real &lt;code&gt;position_marker&lt;/code&gt; variable, using that variable instead of creating a
new &lt;code&gt;temp_marker&lt;/code&gt; variable.  I then started working back towards the
&lt;code&gt;parse_atx_headings&lt;/code&gt; function, replacing &lt;code&gt;temp_marker&lt;/code&gt; with &lt;code&gt;position_marker&lt;/code&gt; as
I went.&lt;/p&gt;
&lt;p&gt;When I got to the
&lt;code&gt;parse_atx_headings&lt;/code&gt; function, I then proceeded to replace instances of &lt;code&gt;line_to_parse&lt;/code&gt;
within that function with &lt;code&gt;position_marker.text_to_parse&lt;/code&gt; and instances of &lt;code&gt;start_index&lt;/code&gt;
with &lt;code&gt;position_marker.index_number&lt;/code&gt;.  As these changes were localized, they were
easy to make, but I still ran frequent test passes just to make sure I was making
the right changes.  I do acknowledge that some of those test passes were executed out
of paranoia, but in my mind, if running the
tests an extra time allowed me to step forward with no reservations, it was worth it.&lt;/p&gt;
&lt;p&gt;Finally, at the end of all this process, I removed the &lt;code&gt;line_to_parse&lt;/code&gt; variable and
the &lt;code&gt;start_index&lt;/code&gt; variable from the function, as they were no longer being used.
There was no benefit to keeping those two variables around, so I just removed them.
I now had a solid function to parse for Atx headings, referencing the line number and
index number in a nice compact object.  In addition, I was able to easily trace this
compact object from the main processing line of the parser directly to the function
itself. The only thing left to complete the change was to wire up the token.&lt;/p&gt;
&lt;h3 id="stage-4-wiring-up-the-token"&gt;Stage 4 - Wiring up the Token&lt;a class="headerlink" href="#stage-4-wiring-up-the-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now that I had the &lt;code&gt;position_marker&lt;/code&gt; object being passed properly into the
&lt;code&gt;parse_atx_headings&lt;/code&gt; function, I needed to pass that object into the token’s
constructor.&lt;/p&gt;
&lt;p&gt;The first change I made was to the base &lt;code&gt;MarkdownToken&lt;/code&gt; object, changing its constructor
to allow the passing in of a &lt;code&gt;line_number&lt;/code&gt; argument and a &lt;code&gt;column_number&lt;/code&gt; argument to be
stored in the instance.  To complement this change, I made some
modifications to the &lt;code&gt;__str__&lt;/code&gt; method to add the line number and column number to
the returned string, but only if at least one of those two numbers was not 0.  The
benefit of this slight change was that the line number/column number pair would only
show up in the function’s output if that information were provided.  As that information
was only provided once I added support for that type of token, I only
had to worry about the token output changing for the tokens I had already changed.&lt;/p&gt;
&lt;p&gt;The second change was to modify the constructor for the &lt;code&gt;AtxHeadingMarkdownToken&lt;/code&gt;
class to accept a &lt;code&gt;position_marker&lt;/code&gt; argument.  That code was implemented as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
        &lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_indent&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, if the &lt;code&gt;position_marker&lt;/code&gt; variable was not present, the default value of 0
was used for the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt; variables.
If the &lt;code&gt;position_marker&lt;/code&gt; variable was present, the &lt;code&gt;line_number&lt;/code&gt; was be moved over
from its &lt;code&gt;position_marker&lt;/code&gt; object into the function’s &lt;code&gt;line_number&lt;/code&gt; variable.  For
the &lt;code&gt;column_number&lt;/code&gt; variable was assigned the sum of the &lt;code&gt;index_number&lt;/code&gt; member variable,
the &lt;code&gt;index_indent&lt;/code&gt; variable (at this point, always 0), and &lt;code&gt;1&lt;/code&gt;.  As index values are
always 0 based and column numbers are always 1 based, the addition of &lt;code&gt;1&lt;/code&gt; to the index
number ensured it was based properly.&lt;/p&gt;
&lt;p&gt;Finally, these newly calculated values for the &lt;code&gt;line_number&lt;/code&gt; and the &lt;code&gt;column_number&lt;/code&gt;
were passed into the newly retooled &lt;code&gt;MarkdownToken&lt;/code&gt; object constructor.  This was the
point that I was preparing for, where everything came together.  It was now time
to see how close I got to the actual test results.  If memory serves, I believe I
actually closed my eyes after saving my changes and started the execution of
the tests.&lt;/p&gt;
&lt;h3 id="stage-5-addressing-test-results"&gt;Stage 5 - Addressing Test Results&lt;a class="headerlink" href="#stage-5-addressing-test-results" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Prior to the very end of the previous step, the most frequent test command line that I
used was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -m gfm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This executed only the parser’s scenario tests, reducing the test area to only those
tests that were tagged as being part of the &lt;code&gt;gfm&lt;/code&gt; group.  As I was running the tests
with each change, it was important to keep the scope, and therefore execution time,
of the tests to a minimum.  And up to this point, it worked well, and the tests were
solid, passing every time.&lt;/p&gt;
&lt;p&gt;But as I made the connection between the &lt;code&gt;AtxHeadingMarkdownToken&lt;/code&gt; token’s constructor
calling the &lt;code&gt;MarkdownToken&lt;/code&gt; token’s constructor, I knew that everything that I had
just changed was just a good guess.  I hoped that I had wired things up correctly, but
at that point, I only knew 2 things for sure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;due to the tests, I had not disrupted any of the parsed tokens for the test cases, including their order and content&lt;/li&gt;
&lt;li&gt;I was passing some transformation of the base &lt;code&gt;position_marker&lt;/code&gt; into the token’s constructor&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With everything wired up, I used the above command line multiple times, each time
picking off one of the failed tests to validate.  With each test, I first calculated
what I thought the line/column pair should be, noting it down in the function’s
comments section.  I then validated it against the test results, trying my hardest
to not peek at the test results before I did my calculations. Once
I had all those tests cleaned up, I did an extra pass through the changed tokens,
manually recalculating the line/column pair and checking to make sure they were right.
Only after all that was addressed did I change the module in the above command
line from &lt;code&gt;gfm&lt;/code&gt; to &lt;code&gt;rules&lt;/code&gt;, cleaning up any test failures caused by line/column pairs
that were now being displayed as part of the output.&lt;/p&gt;
&lt;h3 id="the-importance-of-good-tests"&gt;The Importance of Good Tests&lt;a class="headerlink" href="#the-importance-of-good-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I can talk at length about good practices with respect to tests, I hope I can
convey the
sincere importance that I associate with having good tests and good test coverage
on a project.  It is true that I can often “eyeball” a simple change to a project,
figuring out whether that change is correct.  But in my mind, anything beyond a
simple change requires solid, repeatable testing.  Without that testing in place, you
are betting against the risk of something going wrong with your project.&lt;/p&gt;
&lt;p&gt;Testing is not about finding bugs as much as it is about risk management.  If you have
a small project that rolls various forms of dice for a Dungeons and Dragons campaign,
the impact of that risk failing is very light.  Any person I know that would
use such a project would also have some backup dice for “just in case”.  For the
PyMarkdown project, the end goal is to have a tool that website owners can trust to keep
their website’s Markdown documents in a proscribed format and style.  The impact of
too many failures is a loss of trust in the project, with a certain level of loss in
trust being associated with those website owners dropping their use of the project.  By
having good testing of various forms embedded within the project, I can hopefully
mitigate some amount of the loss of trust that any failure brings with it.&lt;/p&gt;
&lt;p&gt;Since I have worked so hard to get the project to this state, I did not want to take
any unnecessary risk to the project’s stability.  The tests are a solid tool that
I use frequently to keep any such risk to a minimum, and especially during refactoring,
where I rely on them heavily.  And as I rely on them heavily, I am also continuously
looking for better ways to test the projects that those tests are in.&lt;/p&gt;
&lt;h2 id="lather-rinse-repeat"&gt;Lather-Rinse-Repeat&lt;a class="headerlink" href="#lather-rinse-repeat" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I honestly tried to find another heading for this section.  Try as I might, no other
section heading seemed to convey the repetition that I went through other than the
phrase:
&lt;a href="https://en.wikipedia.org/wiki/Lather,_rinse,_repeat"&gt;Lather, Rinse, and Repeat&lt;/a&gt;
.  For each of the 10 remaining tokens, the 5 steps outlined above for Atx heading
were repeated, with only a few changes to the process.  Those changes are outlined
in the following sections.  Please note that the following sections are ordered with
respect to the amount of work needed to resolve them, rather than my usual
chronological ordering.&lt;/p&gt;
&lt;p&gt;When I encountered questions with respect to whether something with respect to that
token was done properly or not, those questions were added as action items to the
&lt;code&gt;readme.md&lt;/code&gt; file to be examined later.  I knew this was going to be a
&lt;a href="https://www.merriam-webster.com/dictionary/slog"&gt;slog&lt;/a&gt;, and a hard slog at that.
It just seemed more efficient to me to note them and move on, circling back to deal
with them later.&lt;/p&gt;
&lt;h3 id="html-blocks-setext-heading-blocks-and-code-blocks"&gt;HTML Blocks, SetExt Heading Blocks and Code Blocks&lt;a class="headerlink" href="#html-blocks-setext-heading-blocks-and-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There were no changes introduced to the process for these elements.&lt;/p&gt;
&lt;h3 id="thematic-breaks"&gt;Thematic Breaks&lt;a class="headerlink" href="#thematic-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There was only one small change to the process for this element.  That change was
the delaying of the cleanup stage until a later time, as I wanted to get more breadth
of tokens implemented to ensure I had the right foundation for the change.&lt;/p&gt;
&lt;p&gt;The other change that I made was to the &lt;code&gt;MarkdownToken&lt;/code&gt; class, thereby affecting all
the other tokens.  For this change, I moved the code to calculate the &lt;code&gt;line_number&lt;/code&gt;
variable and
the &lt;code&gt;column_number&lt;/code&gt; variable from the &lt;code&gt;AtxHeadingMarkdownToken&lt;/code&gt; class to the base
&lt;code&gt;MarkdownToken&lt;/code&gt; class.  Once this code was proven, it just made more sense to keep
it in the base class than repeating it for each token.&lt;/p&gt;
&lt;h3 id="blank-line-token"&gt;Blank Line Token&lt;a class="headerlink" href="#blank-line-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The change required to process the blank line token was not with the token itself, but
with the processing of block quote blocks.  The &lt;code&gt;__handle_blank_line&lt;/code&gt; function was
changed in the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class to accommodate the &lt;code&gt;position_marker&lt;/code&gt; argument,
starting the change for all calls to this function requiring that argument.  Other than
that change, everything else was normal.&lt;/p&gt;
&lt;h3 id="block-quote-blocks-and-list-blocks"&gt;Block Quote Blocks and List Blocks&lt;a class="headerlink" href="#block-quote-blocks-and-list-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Strangely enough, I thought these two types of blocks would take the most amount of
work to address, but due to the way they were implemented, only a couple of small
changes were required.  In both cases, the block start algorithms have to deal with
with the possibility of a tab character (often denoted as &lt;code&gt;\t&lt;/code&gt;) being used as the
whitespace between the block start sequence and the rest of the block’s data.&lt;/p&gt;
&lt;p&gt;Having already dealt with tab stops versus tab characters and
&lt;a href="https://jackdewinter.github.io/2020/04/27/markdown-linter-reducing-the-parsers-technical-debt/#refactor-2-more-fun-with-tabs"&gt;fixing that issue&lt;/a&gt; once,
I really did not want to fix it again.  I just needed to ensure that the current fix
and the previous fix were compatible with each other.  To ensure that happened
correctly, the modified line text and index numbers were passed to a newly created
&lt;code&gt;PositionMarker&lt;/code&gt; instance, created after the processing of the Block Quote block and
the List blocks.  This ensured that any line text modified by the processing of
either container block would be retained, while adding the now normal processing
using the &lt;code&gt;PositionMarker&lt;/code&gt; class.&lt;/p&gt;
&lt;h3 id="paragraph-blocks"&gt;Paragraph Blocks&lt;a class="headerlink" href="#paragraph-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As the catch-all element for Markdown documents, I had a feeling that these blocks
would end up near the top of the “most effort” list, although I will admit that I
guessed the reason
wrong.  I thought that it would have something to do with lists and block quotes,
while the actual reason is due to Link Reference Definitions.  More precisely, the
reason is due to failed or partially failed Link Reference Definitions.&lt;/p&gt;
&lt;p&gt;Due to its composition, it is impossible to properly determine if a Link Reference
Definition is valid without reading the next line.  As documented in the article
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/"&gt;Adding Link Reference Definitions&lt;/a&gt;, its multiline
nature and use of various forms of quoted sections mean that unless the parser
encounters the end of the closing section or a blank line, it does not know if it
had reached the end of the Link Reference Definition.  If it reaches the end and
for any reason that Link Reference Definition is not valid, the logic in the parser
starts adding lines back on to a list of lines that need to be reparsed without
them being misinterpreted as a Link Reference Definition.&lt;/p&gt;
&lt;p&gt;It is precisely that requeuing logic that I needed to alter to work properly with the
new &lt;code&gt;PositionMarker&lt;/code&gt; class.  While the &lt;code&gt;index_number&lt;/code&gt; remained untouched, I had to
make sure that the &lt;code&gt;line_number&lt;/code&gt; variable was properly reset to account for the
length of the &lt;code&gt;lines_to_requeue&lt;/code&gt; variable when any requeuing occurred.  I had a
bit of a problem with the initial implementation of this code, so I wanted to take
extra time and really boost my confidence that I was handling the change for this
token properly.&lt;/p&gt;
&lt;h3 id="link-reference-definitions"&gt;Link Reference Definitions&lt;a class="headerlink" href="#link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This one should be very obvious… I needed to add the token itself!  When designing
the parser, I did not see any need for a token that literally has no impact on
the output, so I did not add a token for it.  While a link element that refers to a
link reference definition will show up as a link in the HTML output, the link reference
definition itself is not added to the HTML in any form.  However, now that I was
adding support for all markdown block elements, I found myself in the position of
adding the token in to the parser.&lt;/p&gt;
&lt;p&gt;Adding the token itself was not too difficult. That was accomplished by the usual
process of finding the right method, the &lt;code&gt;__stop_lrd_continuation&lt;/code&gt; method in this case,
creating a new instance of the new &lt;code&gt;LinkReferenceDefinitionMarkdownToken&lt;/code&gt; class in
that function, and properly populating it.  Then the process of adding the support for
the &lt;code&gt;PositionMarker&lt;/code&gt; class kicked in, and quickly I had a case of a wired-up
token with the proper data.&lt;/p&gt;
&lt;p&gt;And then I went to test it… and I noticed that the tests failed in the transformation
of the tokens into HTML.  Looking, I quickly determined that I needed to make
some additional changes to the &lt;code&gt;TransformToGfm&lt;/code&gt; module.  This was a simple change, as
by definition, Link Reference Definitions have no effect on the output.  To accommodate
the new token, a simple handler was registered for that token that simply returns the
same string that was given to the handler.&lt;/p&gt;
&lt;p&gt;And then I went to test it… and the line number and column numbers were incorrect.
In about half of the tests, the pair of numbers seemed to be widely different than I had
manually calculated.  Double checking my numbers, I then noticed a pattern.  The
numbers being reported were for the last line of the Link Reference Definition.
Because of its multiline nature, the values associated with the &lt;code&gt;position_marker&lt;/code&gt;
variable were the ones used when that Link Reference Definition was considered both
valid and complete.  Avoiding the passing of a single use variable around, I added
the starting position to the &lt;code&gt;LinkDefinitionStackToken&lt;/code&gt; instance at the top of the
stack, and things looked better.&lt;/p&gt;
&lt;p&gt;As I looked at the token and its &lt;code&gt;__str__&lt;/code&gt; function output, it looked very lean.  Based
on other tokens, I expected a lot more information to be stored in that token, to be
analyzed later.  Slowly going through the information gathered during the processing
of the token, I ended up figuring out how to properly represent the token.  Between the
various whitespace
sequences between parts of the definition, the various parts of the definition
themselves, and both uninterpreted and interpreted parts, the data called for a
class with 11 member variables.&lt;/p&gt;
&lt;p&gt;Slowly but surely, I started working through each of the Link Reference Definition
scenario tests, starting with the easier  ones and working my way to the more difficult
ones.  It took me a while to work through each scenario and validate it, but I breathed
a sigh of relief when I finished going through
all the tests. In the end, it had taken 2 days to complete, along with countless
executions of the scenario tests.&lt;/p&gt;
&lt;p&gt;It was not until I looked at my notes that I remembered something: I had delayed some
of the cleanup.&lt;/p&gt;
&lt;h2 id="cleaning-up"&gt;Cleaning Up&lt;a class="headerlink" href="#cleaning-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before calling this round of changes done, there was a decent amount of delayed cleanup
to be performed.  As part of Stage 3 of the process, there were quite a few times where
that cleanup was delayed for one reason or another.  As I was about to move on to
another issue, I wanted to make sure that cleanup was performed.&lt;/p&gt;
&lt;p&gt;That cleanup itself was easy, as I had repeated the “change-test-check” process
so many times that I believe I could perform it while sleeping.  Following a variation
of that same process, the code was cleaned up in short order.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I finished the cleanup, I was happy to have the work of adding in the line numbers
and column numbers behind me.  After 10 days of work, it was now a large task
that I knew was not on my task list anymore.  But while I was
happy, I was also concerned about the 20 new issues that I had added to my issues list.
I was aware that at least a few of those items would be checked out and determined to
be false alarms, but that probably left somewhere between 16 to 18 issues to research
and triage.&lt;/p&gt;
&lt;p&gt;On top of that, there was also the fact that each line number/column number
pair for the tokens was determined manually by me.  While I have faith that I can
count accurately for small sets of numbers, I do know that I make mistakes.  Some
of those mistakes I had already caught while going over the test cases before committing
the changes for each of the elements.  But it was entirely possible, and indeed
probable, that I had missed at least 1 or 2 mistakes.  This was not due to lack of
confidence, but due to a sense of reality.  I know that the project has great coverage
and great scenarios, but I also know that I do not have every scenario represented,
just the really important ones.&lt;/p&gt;
&lt;p&gt;That got me thinking.  If I found that many errors, was there a way to remove the need
for me to manually count those values?  Could I automate it?  Would it be worth it?
Would I find anything?&lt;/p&gt;
&lt;p&gt;The more I thought about those questions, the more I realized that I needed to explore
this area.  If nothing else, I wanted to make sure I had not missed anything.  But after
thinking about it for a while, I realized that I did not want to risk that I had missed
anything important.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;And here ladies and gentlemen is where I begin to go down the
&lt;a href="https://www.merriam-webster.com/dictionary/rabbit%20hole"&gt;rabbit hole&lt;/a&gt;
.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:simpleAlg"&gt;
&lt;p&gt;At the current moment, the &lt;code&gt;transform_to_gfm.py&lt;/code&gt; module is approximately 900 lines long.  About 30% of that module is processing overhead, with about 18% dedicated to handling the &lt;em&gt;somewhat complex&lt;/em&gt; issue of list looseness. The remaining 52% is consumed with the simple &lt;code&gt;handle_*&lt;/code&gt; methods used to translate each token’s start and end tokens into HTML.  While the calculation of list looseness does add some complexity to the translation, the algorithm and implementation are both relatively simple. &lt;a class="footnote-backref" href="#fnref:simpleAlg" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Taking Time To Evaluate</title><link href="https://jackdewinter.github.io/2020/06/01/markdown-linter-taking-time-to-evaluate/" rel="alternate"></link><published>2020-06-01T00:00:00-07:00</published><updated>2020-06-01T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-06-01:/2020/06/01/markdown-linter-taking-time-to-evaluate/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have been busy at work on the PyMarkdown project since December 2019, November 2019
if you include project pre-planning.  During that time, I have established a very
consistent schedule for planning the next weeks’ worth of work. Normally I start
planning the next article a couple of days …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have been busy at work on the PyMarkdown project since December 2019, November 2019
if you include project pre-planning.  During that time, I have established a very
consistent schedule for planning the next weeks’ worth of work. Normally I start
planning the next article a couple of days before I write the rough outline for the
current article, ensuring continuity between the two articles.  This occurs
concurrently with the last couple of days of development work for the week, so I usually
have a very healthy picture of where the project is and where the project is going.&lt;/p&gt;
&lt;p&gt;This week was very different.  For the first time since I started the project, I was
unsure of the right direction to take.  As I stated at the
&lt;a href="https://jackdewinter.github.io/2020/05/25/markdown-linter-rules-headings-part-2/#what-is-next"&gt;end of the previous article&lt;/a&gt;,
I needed to answer one important question: should I write more rules or should I fix
more issues?&lt;/p&gt;
&lt;p&gt;While I did arrive at a final answer, it would eventually take me almost 2 weeks
before I was able to properly answer that question.  In addition to spending some time
to take a good look at the project, I decided to use that time to knock some of the low
priority issues off the technical debt list, hoping to gain some useful insight on
how to answer the question along the way.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/2517d271dc7b79b76683ff5cce7bb573f22fab7a"&gt;15 May 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/1fbcfcb8185fcb8d7dcb6b70adb7309b0225f8da"&gt;08 May 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="how-did-i-get-here"&gt;How Did I Get Here?&lt;a class="headerlink" href="#how-did-i-get-here" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I believe that questions such as features versus issues are important questions
for any project maintainers to ask of themselves and their project team.  Even more
important to me is the policy that any such questions and answers regarding a project
must occur with full transparency to team members and other people interested in the
project.  I know I am not the first person to get stuck on an issue like this in their
project, and I will not be the last. Because of that desire for transparency and
openness, I wanted to document how I arrived at an answer, with explanations along the
way to help others with their decisions regarding similar questions. Basically, I
consider everyone reading this article to be an honorary team member.&lt;/p&gt;
&lt;p&gt;As I alluded to in the introduction, most of my articles start off as ideas that I
get while I am working on the project.  When I am trying to figure out the direction
that
I want to go with on the project, I consider both my ability to code and test any
changes along with how I am going to document those changes in an article.  By the
time the end of the “project week” starts to roll around, I have usually started to
transition from having an idea of where I want the project to go, into a plan of what
to do for the project in the next week, and how I will write the article about the
execution of the plan the week after.&lt;/p&gt;
&lt;p&gt;When I get to the last day of the week, three things happen one after the other.
First, I perform a small project retrospective to figure out what parts
of the last week went well, and where I can improve, being as honest with myself as
I can.  Secondly, I scan over my commits and notes from that week and come up with a
good unifying theme for that week’s outline and sketch out a very rough outline for
the future article.  If things went well, that theme matches
the project direction from a week before.  If not, I just adjust as I go.  Finally,
I use both of those pieces of information to compose a plan on what needs to be done
in the next week with respect to the project.&lt;/p&gt;
&lt;p&gt;I have found this process very healthy as it asks three very important questions for
the project. How did you do? What did you do? What do you plan to do?  More
specifically, by asking the questions in that order, my plan for the next week can
be an informed plan, incorporating any “where can I improve” action items into the
next weeks work, while they are still fresh from the retrospective.&lt;/p&gt;
&lt;h2 id="where-did-this-process-fall-apart"&gt;Where Did This Process Fall Apart?&lt;a class="headerlink" href="#where-did-this-process-fall-apart" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The current issue that I had with this process started when I asked myself the rules
versus issues
question because of one of those retrospectives.  I remember sitting down at my
desk, starting to type out a couple of notes to myself as part of my retrospective.
There were two main
themes that were a part of that retrospective.  What went well was the writing of the
rules and my belief that I had developed the right framework.  What needed improving
was that my confidence in the framework was at a high level, but was it was high enough
for me to continue developing rules?  I did not feel comfortable moving forward
on the project without answering that question. But after a long period of time, I
had not made any progress on answering it.  I silently hoped that moving on to my next
task would help.&lt;/p&gt;
&lt;p&gt;Despite my hope, skipping to creating a rough outline of that week’s work did not help
me to answer that question either.  The prior few weeks had all been about proving that
I had done
enough work on the project that linting rules were both possible and easy to write.  I
sincerely believed that I have succeeded with that goal with room to spare.  Mission
achieved!
But with that important question solidly answered in the positive, it did not help
me move forward on answering the question on whether the project would benefit
more from more rules or less issues.&lt;/p&gt;
&lt;p&gt;I then tried to force the issue by coming up with a plan for the next week, hoping it
would
jar something in my head that would “magically” resolve the issues I had with the
retrospective and outline.  It did not work. I just sat there and paused for a long time
while staring at the screen.  I tried bouncing between the retrospective, the outline,
and the planning, but the results did not change.  I was at a bit of an impasse.
As far as I could figure, the scales seemed equally balanced.  If the questions had to
do with some manner of data-driven metric, it would have been easy for me to come up
with a
&lt;a href="https://en.wikipedia.org/wiki/Go/no_go"&gt;go-no-go&lt;/a&gt;
threshold that I could rely on.  This decision was not going to be data-driven, but
emotion-driven.  That would make the go-no-go decision a lot more difficult to pin
down to an answer that I felt good with.&lt;/p&gt;
&lt;p&gt;After making a good-faith effort to arrive at an answer, I decided to choose neither
answer.
Instead, I decided to do two things.  The first thing was to take a good look at the
code over a few days, hoping to get extra insight as to where I felt the project
was and how to better answer that question.  The second thing was to fix some low-level
issues that I had noticed and wanted to address.  Nothing too earth-shattering, just
some small cleanup issues that never seemed to get picked up in one of the
other refactoring efforts.  I hoped that this two-pronged approach would help me to pick
up some other information that would tip the scales one way or the other.&lt;/p&gt;
&lt;p&gt;In my mind, while it was not much of a plan, it was moving forward.  It was taking a
step forward in the hope of getting more information.  At the very least, the project
would benefit by a few issues being removed from the technical debt list.  That
was level of success criteria for the week that was lower that I was used to, but I
was fine with it.  That is, if I figured out how to properly answer that question!&lt;/p&gt;
&lt;h2 id="taking-time-is-not-taking-it-easy"&gt;Taking Time Is Not Taking It Easy&lt;a class="headerlink" href="#taking-time-is-not-taking-it-easy" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While it is true that I have written every line of code in the project
so far, I rarely have time to take a step back and see how things all fit together.  To
quote a professor of mine from university:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sometimes you cannot see the forest because the trees get in the way.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As I was looking through the code, I was taking notes, mostly questions for myself.
In all honesty, a couple of them were “does this really work?” which I resolved to
answer for myself by the end of the week.  Most of them though were simply me
wondering out loud if there was a better way to do something or whether I could
change something in a function to make it more readable or maintainable.&lt;/p&gt;
&lt;p&gt;In the end, as would befit my university professor, I think I was better able to see
both the forest and the trees after those couple of days.  But while I had hoped that
it would nudge me one way or the other in answering my main question, I remained
at an impasse.  I was able to answer all the questions I had asked myself as I was
looking
through the code, but none of those answers signified that I had done something wrong.
They only suggested small improvements on how I wrote the code.  By no means were any
of those answers better enough to tip the scales.&lt;/p&gt;
&lt;h2 id="fixing-issues"&gt;Fixing Issues&lt;a class="headerlink" href="#fixing-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With one of my two paths not providing any information to sway the answer either way,
it was time to switch to the second path: fixing issues.&lt;/p&gt;
&lt;h3 id="better-logging-command-line-support"&gt;Better Logging Command Line Support&lt;a class="headerlink" href="#better-logging-command-line-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One of the first things on my “never got around to it”&lt;sup id="fnref:roundTuit"&gt;&lt;a class="footnote-ref" href="#fn:roundTuit"&gt;1&lt;/a&gt;&lt;/sup&gt; list was to make sure
that PyMarkdown has proper command line logging support.  This level of logging
support was already available through the test framework but adding that same support
to the command line support seemed to always get pushed off.  It was time to change
that.&lt;/p&gt;
&lt;p&gt;Adding that support was extremely simple, especially since I have added support like
this to many command line programs.  From experience, the two parts to adding this
feature are adding the ability to control the default log level and adding the ability
to redirect any logs that are produced to a file.&lt;/p&gt;
&lt;p&gt;The actual core code to implement this feature was just 7 lines long, with the
interpretation of the command line arguments being the bulk of this change.  The
existing interpretation code, to handle command line argument parsing through the
&lt;code&gt;argparse&lt;/code&gt; library, was changed to include support for the
&lt;code&gt;--log-level&lt;/code&gt; and &lt;code&gt;--log-file&lt;/code&gt; options, including a default setting of &lt;code&gt;CRITICAL&lt;/code&gt; for
the log level.  To round out these changes, the &lt;code&gt;log_level_type&lt;/code&gt; function was added to
verify that any specified log level is a valid log level.&lt;/p&gt;
&lt;p&gt;Those 7 core lines to add the logging itself may change from language to language, but
they almost always are simple modifications of a common pattern.  The first part of
that pattern is dealing with
writing to the console.  As many logging frameworks will do this by default, the
customization here is to ensure that the desired logging level is applied to the
console log handler.  The second
part of that pattern is to add support for logging to a log file, usually requiring 2
to 3 discrete actions to customize the file logging to the proper settings for the
application.  As these are the two most frequently used logging modes
for command line programs, most languages include good solid templates on how to add
this for that specific language.&lt;/p&gt;
&lt;p&gt;The fun part for me is always in making sure that a change like this is tested properly,
and this was not an exception.  As this is a new set of command line options, existing
tests that listed existing command line options were updated.  Additional tests were
added to &lt;code&gt;test_main.py&lt;/code&gt; to specifically test the new options, including tests
specifically around specifying invalid options.&lt;/p&gt;
&lt;p&gt;I am not sure if it felt good to have this issue taken care of as much as I felt like
I should have got to this one before that moment.  Being such of a core fixture
in other command line applications I have written, I just felt like this should have
been addressed a lot sooner.  Still, it was good to get it out of the way.&lt;/p&gt;
&lt;h3 id="better-logging-support"&gt;Better Logging Support&lt;a class="headerlink" href="#better-logging-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This change was a small-ish change, but it was one that I was overdue to explore.  Back
at the start of May, in my article on
&lt;a href="https://jackdewinter.github.io/2020/05/04/markdown-linter-core-pre-rule-improvements/#side-note"&gt;pre-rule improvements&lt;/a&gt;
I noted that while I might be able to get away with a single static logger variable
at the top of my modules, I had not seen any good documentation on the “right” way
to do it.  When I looked at various examples, such as
&lt;a href="https://pythonspot.com/logging/"&gt;this example&lt;/a&gt;
at Python Spot, the examples seemed to always show logging within a single module
application, and not within a multiple module application like PyMarkdown. As such,
I decided to add localized &lt;code&gt;logger&lt;/code&gt; variables until I could do some
research and figure out the proper way to add logging to each module.&lt;/p&gt;
&lt;p&gt;It was not until I got the time to do more thorough research that I was able to find a
good example of how to log with multiple modules.  While the
&lt;a href="https://docs.python.org/3/howto/logging.html"&gt;Python logging docs&lt;/a&gt;
has a good section on “Logging from multiple modules”, it was actually the section
titled
&lt;a href="https://docs.python.org/3/howto/logging.html#advanced-logging-tutorial"&gt;Advanced Logging Tutorial&lt;/a&gt;
that gave me the information I was looking for.  While not an example, the guidance that
is given near the top of this section is quite clear:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A good convention to use when naming loggers is to use a module-level logger, in each module which uses logging, named as follows:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Python
logger = logging.getLogger(__name__)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This means that logger names track the package/module hierarchy, and it’s intuitively obvious where events are logged just from the logger name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yes!  After searching for some clear guidance for weeks on this, I finally found
something that was both authoritative and definitive.  Even more, the last sentence
contained a good, solid explanation of why this process should be followed.&lt;/p&gt;
&lt;p&gt;In the grand scheme of things, this change took very little time.  Instead of having a
logger instance declared as &lt;code&gt;logger&lt;/code&gt; within various classes and static methods, a new
instance &lt;code&gt;LOGGER&lt;/code&gt; was created at the top of each file per the instructions quoted above.
The change from &lt;code&gt;logger&lt;/code&gt; to &lt;code&gt;LOGGER&lt;/code&gt; was a simple search-and-replace tasks for each
file, quickly accomplished.  The hard part here was removing any &lt;code&gt;logger&lt;/code&gt; arguments
that were being passed into functions in favor of the &lt;code&gt;LOGGER&lt;/code&gt; instance declared at the
top of the file. Testing was also simple, as all I had to do was execute all of the
tests again, and make sure I did not miss anything.&lt;/p&gt;
&lt;p&gt;It felt good to get this one off the issues list and committed to the repository.
If I had to guess, I think this one never made it into any of my refactoring lists
because things were
working okay, with no loss functionality in PyMarkdown because of it.  At the
same time, there was this persistent nagging when looking at the issues list that I
really need to figure out the “right” way to do this… and now I know what that is.&lt;/p&gt;
&lt;p&gt;But did this help me figure out the answer to my question? Nope.  Taking some time
to go back and look at my half-written notes, I was still at that same impasse.
Nothing had changed.  Hopefully, that would soon change.&lt;/p&gt;
&lt;h3 id="adjusting-the-parsing-of-whitespace-in-setext-tokens"&gt;Adjusting the Parsing of Whitespace in SetExt Tokens&lt;a class="headerlink" href="#adjusting-the-parsing-of-whitespace-in-setext-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like the other issues that I addressed at this time, the effort to address
this issue was small. Found during the development of
&lt;a href="rule-3.md#rule-md023-headings-must-start-at-the-beginning-of-the-line"&gt;rule MD023&lt;/a&gt;,
this was a rare case where I felt that code added to a rule could
have been positioned better in the core framework.  While the added code in the rule was
only a small amount of code, it was a case where I knew a better way of handling this
whitespace was possible, as it was already being done for the related Paragraph token.&lt;/p&gt;
&lt;p&gt;The two tokens that the SetExt heading token is related to are the Atx heading token
and the Paragraph token.  The SetExt heading token is related to the Atx heading token
in that they are both heading tokens.  The SetExt heading token is related to the
Paragraph token as a SetExt
token is created by changing an eligible Paragraph token with SetExt markings after it
into a SetExt token.  As such, when I wrote the code for rule MD023, I was surprised
that the logic for detecting whitespace at the start of a Paragraph token was trivial
but the similar logic for a SetExt token was more involved.&lt;/p&gt;
&lt;p&gt;Digging into why those tokens were handled differently, I quickly determined that it
was only a couple of small changes that separated the handling of those two tokens.
Addressing these differences required a few simple changes during the coalesce
phase and the
inline processing phase, both ensuring that the processing afforded to Paragraph tokens
was also being applied to its kindred SetExt tokens.  That was immediately followed up
by adding a
couple of tests to make sure this change stuck, and then by a change to rule MD023 to
make use of a more trivial calculation of leading whitespace.&lt;/p&gt;
&lt;p&gt;Looking back at my notes while I am writing this article, I believe this was the start
of me mentally tipping the scales towards spending time working on the issues.  While
this was not a big change, I believe that it represented a larger set of smaller things
that I wanted to get right before moving on.  I believe the change that was occurring
was a subtle change in how I was weighing the various categories of issues.&lt;/p&gt;
&lt;p&gt;That weighing was starting to put more emphasis on fixing issues, specifically issues
with the parser.  The previous two issues that were addressed, both dealing with
logging, did not seem to affect my decision at all.  This issue, dealing with the
parser, moved the weighing enough that I noticed it.  While it was only barely
noticeable at this point, that feeling was going to get stronger as I addressed
the next issue.&lt;/p&gt;
&lt;h3 id="properly-grouping-hard-line-break-whitespace"&gt;Properly Grouping Hard Line Break Whitespace&lt;a class="headerlink" href="#properly-grouping-hard-line-break-whitespace" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One of the things that I noticed when fixing the previous issue was that where
hard line breaks were concerned, they did not have any leading whitespace embedded
within them.  It was not a big issue. If I was not looking at the test cases
for the previous issue, I would not have seen this issue.  It was just silently
waiting to be discovered.&lt;/p&gt;
&lt;p&gt;It may seem like a small thing, but I have a “rule” that any whitespace before any
non-text token goes with the token that follows it.  Just before I started
writing rules, I noticed that many of the tokens were following this rule, so
I decided to apply this pattern as a blanket rule over  all the tokens.  The benefit
to this approach is that I have a consistent expectation of where the leading
whitespace will be placed after it is extracted.  That benefit allows me to write
better, more consistent rules where I always know where to look for that whitespace.&lt;/p&gt;
&lt;p&gt;The fix for this issue was almost trivial.  For the most part, it was adding another
parameter to the &lt;code&gt;HeadBreakMarkdownToken&lt;/code&gt; constructor, passing it either the
line continuation character &lt;code&gt;\&lt;/code&gt; or the leading whitespace that caused the hard line
break to occur.  A bit of cleaning up with the resultant variables, and it was done.
But as with the previous issue, I could feel the weighing of my priorities changing.
This was another small thing, so small that it went undetected until I chanced upon
it.  But the thing was, it started me thinking: If I was able to find this issue, what
other issues were lurking in the parser, waiting to be discovered?&lt;/p&gt;
&lt;h3 id="consistently-using-the-word-heading"&gt;Consistently Using the Word “Heading”&lt;a class="headerlink" href="#consistently-using-the-word-heading" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I was very aware that this was a non-code related task, I felt that it was a good
time to get it out of the way.  During my documentation of
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#a-quick-aside"&gt;the first three rules&lt;/a&gt;,
I decided to choose “heading” of “header” for the reasons outlined in
that article.  However, even though I had made that change in my articles&lt;sup id="fnref:notThat"&gt;&lt;a class="footnote-ref" href="#fn:notThat"&gt;2&lt;/a&gt;&lt;/sup&gt;,
I had not
made the accompanying changes in the PyMarkdown source.&lt;/p&gt;
&lt;p&gt;This was a quick search-and-replace, followed by running of tests to make sure things
were good.  Experiencing no bumps and no typos, everything went fine.  While purely
cosmetic, it felt good to make sure that the blog and the source code were in sync
with each other.  Making sure they were in sync just felt good.&lt;/p&gt;
&lt;h3 id="removing-setextheadingendmarkdowntoken"&gt;Removing &lt;code&gt;SetExtHeadingEndMarkdownToken&lt;/code&gt;&lt;a class="headerlink" href="#removing-setextheadingendmarkdowntoken" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I have long since got rid of the notes I used during the early days of writing the
parser for PyMarkdown, so any attempt at figuring out why I added this class near the
start of the project on 29 January 2020 is probably going to fail.  My best guess, based
on what I can see in the GitHub repository, is that perhaps I believed that having a
specific end token for each start token type was the way to go.  Regardless, since that
time I have adopted an approach with a single &lt;code&gt;EndMarkdownToken&lt;/code&gt; that refers to its
starting &lt;code&gt;MarkdownToken&lt;/code&gt; by name.  This approach has proven to be quite practical as
most of the operations that rely on &lt;code&gt;EndMarkdownToken&lt;/code&gt; instances do not need any
contextual information except for the starting tokens’s name.  As such, the
practicality of having a specific
&lt;code&gt;EndMarkdownToken&lt;/code&gt; instance that matches each start Markdown token feels overpowered to
me, with little benefits to show for the added complexity.&lt;/p&gt;
&lt;p&gt;Removing this token was easy.  The class was removed from the &lt;code&gt;markdown_token.py&lt;/code&gt; module
and the &lt;code&gt;leaf_block_processor.py&lt;/code&gt; module was changed to add an &lt;code&gt;EndMarkdownToken&lt;/code&gt;
instance for the related SetExt heading.  The rest of the changes in the commit for this
change were holdovers from the previous changes, where I had forgot to do a
clean build and record the changes.&lt;/p&gt;
&lt;p&gt;This change was cosmetic, but like other issues detailed in this article, it changed
the weighing of the issues even more.  Once again, the change was not a dramatic one,
but it was enough that at this point, it was noticeable.&lt;/p&gt;
&lt;h2 id="what-was-my-choice"&gt;What Was My Choice?&lt;a class="headerlink" href="#what-was-my-choice" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having addressed a good handful of small issues that did not make the big lists for
refactorings, the balance between the two scales had shifted enough that I knew that
I had a good solid answer: fix more issues.  I did not feel that I would be wrong in
adding more rules, just that I wanted to focus on ensuring that a number of the smaller
issues were given some focus to ensure they were resolved properly.  It also did not
feel like I had lost any confidence in writing rules, that was still at a healthy level.&lt;/p&gt;
&lt;p&gt;In the end, I believe it came down to a solid understanding that if I was going to
write more rules with this framework, I wanted to make sure that any obvious issues
were dealt with.  The largest of those issues that needed to be addressed was adding
the proper line number and column number support to the tokens.  But it also meant
working through the issues that I found during the first 12 rules and either verifying
they are issues and addressing them or explaining why they were okay.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I strongly believe that the process of taking my time and working through those low
priority issues gave me some valuable insight into the project that I had missed
before.  While the primary catalyst for being able to properly answer the question
were the parser issues that I resolved, I do not discount the insights provided by
looking at the source code at a higher level than usual.  I believe that by allowing
myself time to absorb the project code at a higher level, it opened some doors in my
mind that allowed me to be better influenced by the issues I fixed.  I cannot prove
that of course, but as with all feelings, it just is.&lt;/p&gt;
&lt;p&gt;And while it was initially irritating that I could not answer the features versus
issues question, I now believe it was inevitable.  Especially since I am the only
one working on this project, I do not have anyone to remind me to stop looking at
the trees and focus on the forest.  That change in perspective really helped me to
get a clearer picture, and for that reminder, I am grateful.&lt;/p&gt;
&lt;p&gt;One thing that I did not expect was that the answering of this question taking almost
2 weeks.  I started the planning for this block of work on 02 May and it was 16 May
before I had the planning in place for the next block of work.  The thing is, at no
time during the process did I want to
&lt;a href="https://en.wikipedia.org/wiki/Timeboxing"&gt;timebox&lt;/a&gt;
this process.  It took 2 weeks because that is what I needed to properly answer this
question.  And I was fine with that.&lt;/p&gt;
&lt;p&gt;For the large part, I am also okay with spending some time making sure I get the
parser right before moving on to authoring more rules.  Sure, it means I am extending
the development cycle out by at least a couple of weeks, but I think that the time
will be well spent.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having answered the question of rules vs foundation, it was time to tackle one of the
big issues that I had listed: line numbers and column numbers.  I knew this was not
going to be an easy change, but that just told me I should make sure I do it right the
first time!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:roundTuit"&gt;
&lt;p&gt;Not &lt;a href="https://www.bing.com/search?q=round+tuit"&gt;one of these&lt;/a&gt; which was actually given to me by my family one time. &lt;a class="footnote-backref" href="#fnref:roundTuit" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:notThat"&gt;
&lt;p&gt;I rarely go back and change anything in previous articles, except for bad grammar.  Since I wrote that article, I have endeavored to be consistent in my use of “heading” over “header”. &lt;a class="footnote-backref" href="#fnref:notThat" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Rules - Headings - Part 2</title><link href="https://jackdewinter.github.io/2020/05/25/markdown-linter-rules-headings-part-2/" rel="alternate"></link><published>2020-05-25T00:00:00-07:00</published><updated>2020-05-25T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-05-25:/2020/05/25/markdown-linter-rules-headings-part-2/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For any readers that have been waiting with bated breath since last week when I posted
my article titled “Markdown Linter - Rules - Headings - Part 1”, I will now break the
suspense.  This week’s article is titled… drum roll please…&lt;/p&gt;
&lt;p&gt;“Markdown Linter - Rules - Headings - Part 2”.&lt;/p&gt;
&lt;p&gt;Yeah, I know …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For any readers that have been waiting with bated breath since last week when I posted
my article titled “Markdown Linter - Rules - Headings - Part 1”, I will now break the
suspense.  This week’s article is titled… drum roll please…&lt;/p&gt;
&lt;p&gt;“Markdown Linter - Rules - Headings - Part 2”.&lt;/p&gt;
&lt;p&gt;Yeah, I know, the title is terribly unoriginal, but like the previous article, there is
nothing special about this article except that it details the second group of
heading rules that I am creating.&lt;/p&gt;
&lt;p&gt;With this group of rules completed, except for the two rules mentioned in
&lt;a href="https://jackdewinter.github.io/2020/05/18/markdown-linter-rules-headings-part-1/#what-about-those-two-rules-that-were-left-out"&gt;the previous article&lt;/a&gt;,
every rule in the initial heading rules group will be completed.  Even though I know
these rules will not be the last group of rules that I write, the writing of these
rules serves an important purpose.  The process of writing these rules will help to
paint a reliable picture of the stability of the project at this point.  This picture
will then allow me to determine whether writing more rules or fixing some issues is the
best course of action for the project.&lt;/p&gt;
&lt;p&gt;To be clear, I am not pro-rules nor am I pro-issues, I am pro-project.  If the
picture that emerges gives me a level of confidence with which to write more rules, so
be it.  If that level of confidence is not achieved, then I will address any issues
that I feel are getting in the way of me being able to add more rules with confidence.
Basically, the tests and the issues provide me data, and I will interpret that data to
determine the proper next step.  Simple.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/006eed187e212bb2c425ebebe1202193be327708"&gt;28 April 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/816a1fb5fcf07c765ee3858e5d9292129800478c"&gt;02 May 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="dealing-with-an-omission"&gt;Dealing with An Omission&lt;a class="headerlink" href="#dealing-with-an-omission" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I started to write this article, I went over the 15 different rules that I know
contain headings: 3 in the
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/"&gt;“First Three” article&lt;/a&gt;,
5 in
&lt;a href="https://jackdewinter.github.io/2020/05/18/markdown-linter-rules-headings-part-1/"&gt;the last article&lt;/a&gt;,
2 rules
&lt;a href="https://jackdewinter.github.io/2020/05/18/markdown-linter-rules-headings-part-1/#what-about-those-two-rules-that-were-left-out"&gt;to skip&lt;/a&gt;,
and 4 rules in this article.  Huh?  I double checked my numbers, and as far as my math
is concerned, 3 + 5 + 2 + 4 = 14.  Where did the missing rule go?&lt;/p&gt;
&lt;p&gt;At the end of implementing the last rule group, I determined that the development of
&lt;a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#md025---multiple-top-level-headings-in-the-same-document"&gt;rule MD025&lt;/a&gt;
needed to be put on hold, for the same reasons as
&lt;a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#md041---first-line-in-file-should-be-a-top-level-heading"&gt;rule MD041&lt;/a&gt;:
YAML front matter.  Rule MD025 exists to make sure that there is one and only one
top-level heading present in each document. The description for rule MD041 allows that
top-level heading to be specified in the metadata for the file, and the plan for rule
MD025 is to follow that same pattern.  As rule MD041 was put on hold until that
metadata support is added, it only makes sense that rule MD025 is also put on hold
pending the addition of that same metadata support.&lt;/p&gt;
&lt;h2 id="and-now-more-rules"&gt;And Now, More Rules&lt;a class="headerlink" href="#and-now-more-rules" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With this group of 4 rules, the total number of implemented heading rules will
be 12.  I believe that is a good sampling of rules with which to decide whether to
fix more issues or create new rules.  To that extent, let’s go!&lt;/p&gt;
&lt;h2 id="rule-md023-headings-must-start-at-the-beginning-of-the-line"&gt;Rule MD023 - Headings must start at the beginning of the line&lt;a class="headerlink" href="#rule-md023-headings-must-start-at-the-beginning-of-the-line" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_023.py"&gt;Rule MD023&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For this rule, the first answer that popped into my mind was the usual answer:
consistency. According to the GFM specification, there is no syntactic difference
between:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;Heading&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;Heading&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As they are equivalent, just like with previous rules, it makes sense to use the simpler
form of the heading to keep things consistent.&lt;/p&gt;
&lt;p&gt;However, on a more thorough examination, a better purpose for this rule is
compatibility.  While I recognize that the initial parser features and tests are based
on the
&lt;a href="https://github.github.com/gfm/"&gt;GFM specification&lt;/a&gt;,
knowing where other parsers diverge from that specification allows me to start thinking
about future “tunings” for the project.  I do not know how possible it is, but I am
wondering if I can tune PyMarkdown’s output based on a profile set up for a given
Markdown parser being used.  While this is still in the “far-future thinking” stage,
one of the pieces of data I need to understand for that endeavor is how far from my
chosen base specification are the specifications for those other parsers.&lt;/p&gt;
&lt;p&gt;To get an idea of how compatible a normal Atx heading is across parsers, I submitted
the text &lt;code&gt;# Heading 1&lt;/code&gt; to
&lt;a href="https://johnmacfarlane.net/babelmark2/?text=%23+Heading+1%0A%0A"&gt;Babelmark&lt;/a&gt;&lt;sup id="fnref:Babelmark"&gt;&lt;a class="footnote-ref" href="#fn:Babelmark"&gt;1&lt;/a&gt;&lt;/sup&gt;.
Except for the presence of an &lt;code&gt;id&lt;/code&gt; attribute in the &lt;code&gt;h1&lt;/code&gt; tag (and that
attribute’s value varying only slightly), the results were the same across all the
parsers,
indicating wide compatibility. When I added 2 spaces at the start of the text and
submitted that text to
&lt;a href="https://johnmacfarlane.net/babelmark2/?text=++%23+Heading+1%0A%0A"&gt;Babelmark&lt;/a&gt;,
only 12 out of the 31 available parsers interpreted the line as an Atx heading.  With
only 39% of the parsers at Babelmark recognizing the changed text as an Atx heading,
it was far from being widely compatible.&lt;/p&gt;
&lt;p&gt;Based on those results, for the sake of compatibility, it made sense to create a rule
to recommend the removal of
any whitespace at the start of an Atx heading line.  While a standard GFM
Markdown parser will treat it properly, with less than half of the sampled parsers
handling it properly, it just made sense to avoid that extra
whitespace.  If PyMarkdown tuning is a feature that I add in the future, I can always
revisit this rule and make it aware of the added tuning.  As that feature is currently
only a maybe, a current, solid rule for headings means no spaces at the start of
heading lines.&lt;/p&gt;
&lt;h3 id="adding-the-rule"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Adding the code to implement this rule was trivial.  The rule simply looks at the
&lt;code&gt;extracted_whitespace&lt;/code&gt; field of the Atx heading token where the captured whitespace
from before the start of the Atx heading is stored.  If the value of
&lt;code&gt;extracted_whitespace&lt;/code&gt; is not empty, whitespace is present, and the rule fails.&lt;/p&gt;
&lt;p&gt;Using the process from the previous section to test Markdown samples with multiple
parsers, I then tested variations of SetExt headings like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;heading&lt;/span&gt;
&lt;span class="c1"&gt;----------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where there was extra spacing at the start of the first line, the second line, or both
lines.  In each of those cases, the results showed that there was at least one parser
that did not recognize it as a proper SetExt heading.  If I want a linter that can
be useful for a wide variety of parsers, the failure of one parser to recognize
the above text as a SetExt heading is still somewhat of a failure.&lt;/p&gt;
&lt;p&gt;To deal with whitespace before SetExt headings, only a small amount of extra parsing
was required above what was added for the Atx headings.  When the SetExt token is
observed, that token is stored in the
&lt;code&gt;setext_start_token&lt;/code&gt; variable, with the storing of the presence of any leading
whitespace in the &lt;code&gt;any_leading_whitespace_detected&lt;/code&gt; variable.  As Text tokens are
observed, if the
&lt;code&gt;any_leading_whitespace_detected&lt;/code&gt; variable has not already been set, a simple
decomposition of the text is performed to look for leading whitespace on each line, the
&lt;code&gt;any_leading_whitespace_detected&lt;/code&gt; variable being set to &lt;code&gt;True&lt;/code&gt; if any whitespace is
found.  Finally, when the SetExt’s end token is observed, one final check is made
against the end token for whitespace.  When that is complete, if any whitespace was
detected in any of these three phases, the rule fails with the value stored in the
&lt;code&gt;setext_start_token&lt;/code&gt; variable being used as the failure token.&lt;/p&gt;
&lt;p&gt;The code for implementing this rule, the tests, and test data were all trivial.  Once I
understood the constraints that I needed for the rule, it was easy to
translate those constraints into test data and source code.  Perhaps I am a bit jaded
in my viewpoint, but after implementing 8 other rules for headings, adding this rule
was just easy.&lt;/p&gt;
&lt;p&gt;The real interesting part about implementing this rule was using Babelmark and looking
at the output from the various parsers.  Seeing the different HTML variations that
arose from the different interpretations of a single Markdown element made it clearer to
me why the GFM specification was written.  If there is not a single, clear picture of
how parsers translate Markdown into HTML, the authors start to get confused, tailoring
their use of Markdown to a specific parser and its output. Seeing that Babelmark output
just really drove that point home for me.&lt;/p&gt;
&lt;h2 id="rule-md024-multiple-headings-with-the-same-content"&gt;Rule MD024 - Multiple headings with the same content&lt;a class="headerlink" href="#rule-md024-multiple-headings-with-the-same-content" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_024.py"&gt;Rule MD024&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense_1"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If the parser is following the GFM specification exactly or is a bare bones parser,
this rule does not make any sense.  When presented with Markdown such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;## &lt;span class="k"&gt;Next&lt;/span&gt; &lt;span class="nv"&gt;Heading&lt;/span&gt;

&lt;span class="nv"&gt;some&lt;/span&gt; &lt;span class="nv"&gt;text&lt;/span&gt;

## &lt;span class="k"&gt;Next&lt;/span&gt; &lt;span class="nv"&gt;Heading&lt;/span&gt;

&lt;span class="nv"&gt;some&lt;/span&gt; &lt;span class="nv"&gt;text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the parser will generate HTML that is close to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Next Heading&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;some text&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Next Heading&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;some text&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, either through its own configuration or through a plugin, most Markdown
parsers allow for a
mode in which some transformation of the heading text is added to the &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; tag,
usually in an &lt;code&gt;id&lt;/code&gt; attribute.  Some parsers go
further than that, providing an anchor point allowing the reader to navigate directly
to the heading by using a full URL with the contents of the &lt;code&gt;href&lt;/code&gt; attribute after the
normal part of the URL.&lt;/p&gt;
&lt;p&gt;Once such example is this HTML, which was rendered by one of the parsers for the
first heading in the previous sample:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt; &lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"h2-next-heading"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"user-content-next-heading"&lt;/span&gt; &lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"anchor"&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"#next-heading"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
Next Heading
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This kind of generated HTML output is popular for two main reasons.  First, various
combinations
of the heading tag’s &lt;code&gt;id&lt;/code&gt; attribute, the anchor tag’s class, and the anchor tag’s &lt;code&gt;id&lt;/code&gt;
attribute allow for stylesheets to be applied to the generated page in a clean and
unambiguous manner.
Secondly,
assuming that the normal URL to the page is &lt;code&gt;https://www.website.com/that-page.html&lt;/code&gt;,
since the &lt;code&gt;href&lt;/code&gt; attribute for the anchor tag is specified as &lt;code&gt;#next-heading&lt;/code&gt;, the
reader can go directly to that section on the page by using the URL
&lt;code&gt;https://www.website.com/that-page.html#next-heading&lt;/code&gt;.  This concept is so useful that
multiple “Table of Contents” plugins that I looked at required another plugin to
already be enabled that provides this information that is the repurposed by the Table
of Contents plugin.&lt;/p&gt;
&lt;p&gt;Specifically related to this rule, the part that I want to focus on is the generation
of the &lt;code&gt;id&lt;/code&gt; attributes and the
&lt;code&gt;href&lt;/code&gt; attribute.  If a naïve generator implementation is used, the heading text
&lt;code&gt;Next Heading&lt;/code&gt; will always be reduced to some form of the text &lt;code&gt;next-heading&lt;/code&gt;, without
any regard for duplicates.  When a more advanced implementation is used, the plugin
remembers that it has already generated the text &lt;code&gt;next-heading&lt;/code&gt; for the current
document.  To avoid any duplication, when the parser goes to generate another instance
of a heading &lt;code&gt;id&lt;/code&gt; based on the text &lt;code&gt;Next Heading&lt;/code&gt;, it generates it as normal but also
appends a suffix to the generated text, usually something like &lt;code&gt;-1&lt;/code&gt; to keep the
generated ids unique.&lt;/p&gt;
&lt;p&gt;Because Markdown parsers are not guaranteed to perform the proper, advanced generator
implementation, this rule plays it safe by failing when it detects heading text that is
duplicated.  However, to provide further configuration for more compliant parsers,
this rule
can also be set to only fail the rule in cases where sibling heading elements have
the same name.  While it is not stated, my guess is that some parsers include extra
information in their generated ids that only causes duplication issues when sibling
headings have the same text.&lt;/p&gt;
&lt;h3 id="adding-the-rule_1"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Using the default configuration, the evaluation for this rule is
very simple.  When an Atx heading token or a SetExt heading token is observed, the
rule starts collecting the text until it encounters the appropriate end token.  At
that point, one of two things happen.  If this is the first time that text has been
seen, it is saved in a dictionary that is cleared at the start of each document.  If it
is not the first time that the text has been seen, the rule fails.  Simple and clear
cut.&lt;/p&gt;
&lt;p&gt;If this rule’s configuration is changed to only search for duplicates in siblings,
a small amount of a change is required in the algorithm, but not much.  The first
change is that each of the 6 levels of headings must have its own dictionary. Instead
of looking up the collected text in a single dictionary, the text is looked for in the
dictionary assigned to its heading level.  Basically, if a heading is a level
2 heading, then it needs to verify against the level 2 heading dictionary, and so on.
As the heading level that determines which dictionary to use is an integer, it made
sense to create an
array that contains 6 dictionaries, one for each heading level and initialized to an
empty dictionary for each new document.&lt;/p&gt;
&lt;p&gt;With those changes in place, a bit of working through multiple scenarios provided the
rest of the answers. For the increasing heading level case, consider the general case
of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;##&lt;/span&gt; &lt;span class="k"&gt;Level&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;###&lt;/span&gt; &lt;span class="k"&gt;Level&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it is appropriate to only increase the heading level by 1, hence the creation of
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#rule-md001-incrementing-heading-levels"&gt;rule MD001&lt;/a&gt;,
the general case for this rule applies to any increase in heading levels.  When
going to the new heading level, the level’s dictionary must be cleared to ensure that
any previous headings do not pollute the rule’s sense of duplication.  If multiple
levels are involved, it makes logical  sense to clear all the dictionaries up to and
including the new heading level.&lt;/p&gt;
&lt;p&gt;The other case to consider is where the heading levels decrease, such as with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;###&lt;/span&gt; &lt;span class="k"&gt;Level&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="o"&gt;##&lt;/span&gt; &lt;span class="k"&gt;Level&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, the general case for this applies to any decrease in heading levels.  As
the new &lt;code&gt;Level 2&lt;/code&gt; heading is separated from any previous level 2 headings by the
&lt;code&gt;### Level 3&lt;/code&gt; heading, those headings are no longer considered siblings.  As such,
when moving to the lower levels, the dictionaries must be cleared down to and including
the new heading level.&lt;/p&gt;
&lt;p&gt;Other than figuring out the logic for this rule, and taking a while to do it, the rest
of the coding for this rule went smoothly.  While the new algorithm based on that logic
took longer to figure out than I hoped it would, it was useful to be able to have the
test data and test cases on hand from VSCode’s output.  Taking the information from
the &lt;code&gt;Problems&lt;/code&gt; window of that editor saved a lot of time when coded into my tests for
this rule.  I did have a couple of false starts but knowing that the algorithm passed
the tests using the VSCode derived test data really increased my confidence that I got
the algorithm right.&lt;/p&gt;
&lt;h2 id="rule-md026-trailing-punctuation-in-heading"&gt;Rule MD026 - Trailing punctuation in heading&lt;a class="headerlink" href="#rule-md026-trailing-punctuation-in-heading" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_026.py"&gt;Rule MD026&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense_2"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This rule seems to be largely derived from Ciro Santilli’s
&lt;a href="https://cirosantilli.com/markdown-style-guide#punctuation-at-the-end-of-headers"&gt;Markdown Style Guide&lt;/a&gt;.
In this document, Ciro claims that headings are not complete sentences, and as such,
should not
end with punctuation.  Specifically, his examples show very good cases for
not ending a heading with the &lt;code&gt;:&lt;/code&gt; character or the &lt;code&gt;.&lt;/code&gt; character.  My best guess is
that David Anson, when creating his rule based on that document, wanted to allow his
linter’s users to be able to extend this concept to include any headings that end
with a set of common punctuation characters. As such, the default for David’s rule is
to fail the rule if any heading ends with any of the &lt;code&gt;.,;:!?。，；：！？&lt;/code&gt; characters,
and that set of characters can be easily changed with configuration.&lt;/p&gt;
&lt;p&gt;While I do not completely agree with this rule, I do agree with the premise
behind the rule: headings should never be considered complete sentences.  To properly
describe that statement and how it applies to various headings, I needed to
brush up on my English grammar rules.  Even though it has been a few years since I
was in high school, I was quickly able to find a good solid definition:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a complete sentence starts with a capital letter, ends with a punctuation character, and expresses a complete thought.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Using that definition as a rubric, I feel it is useful to demonstrate how that rule
applies to the headings in my own documents.  For this comparison, I used the layout
of the current section of this article as a good example of how to conceptually apply
this rule.&lt;/p&gt;
&lt;p&gt;For each rule in this section, the level 2 heading is always the id of the
rule followed by the description.  In the case of this rule, that heading is
&lt;code&gt;Rule MD026 - Trailing punctuation in heading&lt;/code&gt;.  That heading is not a valid
sentence because it is not a complete thought and does not end with punctuation.
The level 3 heading following this section is &lt;code&gt;Adding the Rule&lt;/code&gt;.  There is a bit more
nuance involved with that heading, as I can easily argue that it can be interpreted as
a complete sentence, just a very weak one.  The saving grace for that heading is that
it does not end with punctuation, so it is not advertising itself as a complete
sentence.&lt;/p&gt;
&lt;p&gt;That leaves the heading for this section which is &lt;code&gt;Why Does This Rule Make Sense?&lt;/code&gt;. When
I first looked at my grammar references for this, it seemed to fail at every point.
It starts with a capital letter, ends with punctuation, and looks like a complete
sentence.  Yes, I said “looks”… and it took me a bit to get there as well.  Remember
above when I said that a complete sentence expresses a complete thought?  That is where
context comes in.  Without the context imposed by this document, the obvious question
to ask is “What rule?”.  Because I tied the context of the heading to document’s
structure, it is not a complete thought unless it remains in the document. As it is not
a complete thought on its own, it narrowly fails the complete sentence test.&lt;/p&gt;
&lt;h4 id="aside-so-why-keep-it-like-that"&gt;Aside: So, Why Keep It Like That?&lt;a class="headerlink" href="#aside-so-why-keep-it-like-that" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;I know that using partial questions as headings is not a popular choice, and I know it
narrowly fails the complete sentence test.  So why keep it?&lt;/p&gt;
&lt;p&gt;For me, it all boils down to using my own voice in my writing, and the authenticity of
my writing in that voice.  For each of these rules, if I were reading someone else’s
document, I would ask two questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Why is it good to do this?&lt;/li&gt;
&lt;li&gt;What did it take to do this?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Wording the second question as a statement is relatively easy.  Instead of “What did it
take to do this?” I used the heading “Adding the Rule”.  It is not glamourous, but it
concisely and accurately conveys the image that I want to convey for that section.&lt;/p&gt;
&lt;p&gt;For the first question, I struggled for a long while trying to rephrase that question
as anything other than a question, and it just did not seem correct.  It either was
missing something, or it just felt like something that I would not say unless I was
prompted to.  So instead of
settling for something that I was not confident about, I opted for using a question that
did capture the essence that I wanted in a heading for that section.&lt;/p&gt;
&lt;p&gt;And yes, I purposefully worded the heading of this section to emphasize that point.
That, and it is the kind of question I would ask myself if I was reading someone else’s
article.&lt;/p&gt;
&lt;h3 id="adding-the-rule_2"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At this point in the development of heading rules, I believe the term “ditto” is
appropriate.  Like a fair number of the rules before this one, any text that
is seen between either the Atx heading token or the SetExt heading token is collected
for later examination.  As that process of collecting the heading text has been
well documented in the other rules, I will avoid documenting it from here on out,
assuming that avid readers already know it fairly well, instead focusing on the
unique bits and differences in the algorithms.&lt;/p&gt;
&lt;p&gt;Once the heading text is collected and the heading’s end token is encountered, 
the rule’s comparison logic is then activated.  Quite simply, when the end token is
encountered, the
last text character of the collected text is checked against the configured set of
punctuation characters.  If there is a match, the rule fails.  If configuration is
provided to change the set of punctuation characters to check against, the check
is simply performed against that list of characters instead of the default list.&lt;/p&gt;
&lt;p&gt;At first, I was a bit let down that I saw this as being a simple rule, as the both
the code and testing for this rule were very trivial.  While I was initially
disappointed, after a while I was able to see it as a good thing. One benefit that I
started to see is that if these rules are performing a consistent action, it reduces
the chance that I am going to get the logic wrong.  Perhaps more obvious to me is the
benefit that if the logic is indeed very similar, it may be encapsulated into a base
class or helper class in a future refactoring, thereby reducing the maintenance costs.&lt;/p&gt;
&lt;p&gt;When I realized what those benefits were, I became okay with this rule being a mundane
rule to write.  Mundane equals refactorable equals lower maintenance.&lt;/p&gt;
&lt;h2 id="rule-md036-emphasis-used-instead-of-a-heading"&gt;Rule MD036 - Emphasis used instead of a heading&lt;a class="headerlink" href="#rule-md036-emphasis-used-instead-of-a-heading" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_036.py"&gt;Rule MD036&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense_3"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This rule is another rule that was largely derived from Ciro Santilli’s
&lt;a href="https://cirosantilli.com/markdown-style-guide#emphasis-vs-headers"&gt;Markdown Style Guide&lt;/a&gt;.
If I had to guess, it seems that Ciro had seen cases where people were using
emphasis as headings in Markdown documents, something that is confusing.  Doing a bit
of easy research, most Markdown tutorial sites, such as
&lt;a href="https://www.markdowntutorial.com/"&gt;Markdown Tutorial&lt;/a&gt;,
address headings in their first 3 lessons.   For people who may ignore tutorials and
go straight to cheat sheets, both
&lt;a href="https://www.markdownguide.org/cheat-sheet"&gt;Markdown Guide’s Cheat Sheet&lt;/a&gt; and
&lt;a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet"&gt;Adam Pritchard’s Cheatsheet&lt;/a&gt; deal with headings on their first page where they are immediately
visible. From this research alone, it is hard to figure out why someone would use
emphasis over headings.  However, I started wondering if perhaps there were historical
reasons for this rule?&lt;/p&gt;
&lt;p&gt;If you start looking at the tutorials and cheat sheets from a different angle,
perhaps the historical angle to justify this rule does make sense.  Perhaps these
distinct sources put
headings near the start of their documents because people were not using headings
properly at the time that those documents were written.
Thinking as an author, by putting headings near the start of the tutorial or cheat
sheet, I would expect that placement to strongly hint that they are important and
should be looked at before going with the rest of the document.&lt;/p&gt;
&lt;p&gt;To explore that concept further, I assumed that I did not know about headings, forcing
me to theorize on how to make a heading-like element would work.  Trying to forget
about this rule, I started working on a list of the elements that I could use.
With headings out of the picture, and every one of the other blocks having a very
distinct purpose, that left only inline elements.  Line breaks are not immediately
visible, and links are really meant for navigation, so they were removed from the
possibilities list early on.  That left backslashes, character references, code spans,
and emphasis. Out of those 4, only the emphasis made sense to use to draw attention to
some text.&lt;/p&gt;
&lt;p&gt;Based on those restrictions, the best heading-like element that I came up with was this
example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="k"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;So&lt;/span&gt; &lt;span class="n"&gt;Heading&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="k"&gt;More&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What a surprise! That is exactly what this rule is looking for.  In particular:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the paragraph is a single line, surrounded by emphasis&lt;/li&gt;
&lt;li&gt;the contents of the paragraph are only simple text, no inline Markdown except for the surrounding emphasis&lt;/li&gt;
&lt;li&gt;for the same reasons as
&lt;a href="https://jackdewinter.github.io/2020/05/25/markdown-linter-rules-headings-part-2/#rule-md026-trailing-punctuation-in-heading"&gt;rule MD026&lt;/a&gt;,
the text does not end with a punctuation character&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Basically, if the only action I do is to remove the emphasis around the text, instead
prefixing the line with the text &lt;code&gt;#&lt;/code&gt;, it should become a valid heading.&lt;/p&gt;
&lt;p&gt;As I now had a working theory on why this rule may have been created and what a good
justification was for it, it was time to start writing the rule.&lt;/p&gt;
&lt;h3 id="adding-the-rule_3"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While the logic for the rules has been somewhat simple before the point, even a simple
glance at this rule led me to believe that the logic for this rule was going to need
some heft to it.  As it often is with many complex parsing scenarios, it was
time to use a Finite State Machine.  While there are many good articles on Finite
State Machines, such as this decently complete one at
&lt;a href="https://en.wikipedia.org/wiki/Finite-state_machine"&gt;Wikipedia&lt;/a&gt;, these complex
machines boil down to this simple statement:  the machine has a finitely small number
of states and for each state there are 0 or more transitions from that state to other
states.&lt;/p&gt;
&lt;p&gt;From my experience, there is a certain level in parsing or pattern recognition where a
simple comparison is not enough, and a formal Finite State Machine is required.  The
inverse of this is also true, where the formality and setup required for a proper
Finite State Machine may get in the way of a small, efficient algorithm. Consider the
algorithm and code for
&lt;a href="https://jackdewinter.github.io/2020/05/25/markdown-linter-rules-headings-part-2/#rule-md026-trailing-punctuation-in-heading"&gt;rule MD026&lt;/a&gt;
in the previous section.  A simple &lt;code&gt;if&lt;/code&gt; statement was used to look for 3 types of
tokens: a start heading token, any contained text tokens, and an end heading token.
While not called out as such, this algorithm was a small state machine with
clear states and clear transitions between states.  Once the contents of the heading
were collected, then rule MD026 did an analysis on it, and determined whether
to fail the rule based on that analysis.&lt;/p&gt;
&lt;p&gt;Breaking that logic out into a full-fledged Finite State Machine had little benefit,
as the simple logic was able to complete the task without less than 5 states and
without any complicated transition logic.  On the other hand, the logic for this
rule as defined in the last section reveals that this rule’s algorithm requires 5
distinct states:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;look for a paragraph start token&lt;/li&gt;
&lt;li&gt;look for an emphasis start token&lt;/li&gt;
&lt;li&gt;look for a text token&lt;/li&gt;
&lt;li&gt;look for an emphasis end token&lt;/li&gt;
&lt;li&gt;look for a paragraph end token&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If at any point the next token that we encounter is not the type of token required to
go to the next state, the machine resets back to state 1 and the machine starts to look
for a new paragraph.  While the transition logic remained simple, I felt that
the “large” number of different states made using a Finite State Machine the best
alternative.&lt;/p&gt;
&lt;p&gt;Once I had the states and transitions figured out, the writing of the rule was
trivial.  The states were represented by a simple set of &lt;code&gt;if&lt;/code&gt; statements, each one
clearly looking for the correct condition to move the state machine to the next state.
If that condition is not found,
the current state is reset to state 1, causing it to look for the initial condition
again.  If the Finite State Machine gets past the final state, the rule fails and the
current state is again reset back to state 1, looking for another candidate paragraph
to evaluate.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From the viewpoint of adding new rules, this was a good experience.  My feelings,
as expressed in
&lt;a href="https://jackdewinter.github.io/2020/05/18/markdown-linter-rules-headings-part-1/##what-was-my-experience-so-far"&gt;the last article&lt;/a&gt;,
were easily extended to cover this set of rules as well.  While I still want to jump
ahead sometimes, my confidence in the process of writing rules and the framework in
which I write those rules is getting deeper with the authoring of each rule. A good
part of that confidence boost is that when I create new rules, the bulk of the time used
to author those rules is focused on the rules themselves, and not on how to wring the
required data from the framework.  It is only the rare exception where I need to figure
out how to get some data from the framework.&lt;/p&gt;
&lt;p&gt;But it is those exceptions that caused me to pause and think when trying to answer the
question that I posed at the start of the article: write more rules or fix more issues?
This answer is a difficult one for me to arrive at, as there is good data to support
both sides.  Writing more rules would round out the framework some more, while focusing
on the framework will fix known issues with the framework, allowing future rules to
be written with less friction.&lt;/p&gt;
&lt;p&gt;This choice was also complicated by the arrival of new ideas for the project as I am
implementing the rules.  A good example of this is the Markdown parser “tunings” that
I briefly talked about back in the documentation for
&lt;a href="http://localhost:8000/2020/05/25/markdown-linter-rules-headings-part-2/#rule-md023-headings-must-start-at-the-beginning-of-the-line"&gt;rule MD023&lt;/a&gt;.
While it is nice to think about these concepts and how they could make the project
better, doing anything more than thinking about them at this stage would be
distracting.  Even worse, it could derail the project by having me follow that
concept down the
&lt;a href="https://www.merriam-webster.com/dictionary/rabbit%20hole"&gt;rabbit hole&lt;/a&gt;.  If I want
to be able to explore concepts such as “tunings”, which of the two options would
allow me to get there faster while maintaining my require level of quality?&lt;/p&gt;
&lt;p&gt;In the end, I determined that I wanted some more time to think about this.  There
are a few issues in my backlog, and fixing those issues will give me some more
time to determine the best course of action.  Sometimes, the best decision is not to
decide, but to collect more information.  I firmly believe that this is one of those
cases.  And if I am wrong?  It just means the foundation for the project will be
that much cleaner and stronger than it was before.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the previous section, I feel that the best course of action is to do
some refactoring.  While it is not a glorious task, it will give me some time
to determine if whether to choose line/column support in the parser or adding more
rules.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:Babelmark"&gt;
&lt;p&gt;Babelmark is a useful online tool that converts a given piece of Markdown text into HTML using a wide variety of Markdown parsers.  I find tools like this very useful in exploring possibilities for how to solve issues that I have. &lt;a class="footnote-backref" href="#fnref:Babelmark" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter rules"></category></entry><entry><title>Markdown Linter - Rules - Headings - Part 1</title><link href="https://jackdewinter.github.io/2020/05/18/markdown-linter-rules-headings-part-1/" rel="alternate"></link><published>2020-05-18T00:00:00-07:00</published><updated>2020-05-18T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-05-18:/2020/05/18/markdown-linter-rules-headings-part-1/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After setting up a good, easy process for
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#adding-the-rule"&gt;writing new rules&lt;/a&gt;,
it was now time to make some headway on the task of writing those new rules.  While the
title “Headings - Part 1” is not glamorous, it is a very apt description for the way
that I planned out …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After setting up a good, easy process for
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#adding-the-rule"&gt;writing new rules&lt;/a&gt;,
it was now time to make some headway on the task of writing those new rules.  While the
title “Headings - Part 1” is not glamorous, it is a very apt description for the way
that I planned out the development of this group of rules dealing with Markdown
headings. In
&lt;a href="https://github.com/DavidAnson/markdownlint"&gt;David Anson’s MarkDownLint&lt;/a&gt;,
there are a total of 15 linter rules that specifically deal with headings.
The first 3 of those rules were used as examples in the previous article, leaving
12 rules to implement.  For reasons I will follow up on, I decided to leave the
implementation of rules MD041 and MD043 for later, reducing the number of rules to
a nice manageable 10.&lt;/p&gt;
&lt;p&gt;Without any unnecessary embellishment, the article’s title simply denotes that I am
going to talk about the implementation of the first half of those rules.  Sure, I could
come up with a name like “The 5 Most Important Rules for Headings!” or “5 Rules
for Headings That You Cannot Live Without!”, but the truth is that they were simply the
next group of rules.  Nothing fancy, nothing misleading, just the plain truth.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c07dd31cf85db9905693191fb022705b4d641305"&gt;24 April 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/1c4a87c88f45417ddc70c537a3c598a4349ed7ad"&gt;26 April 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="what-about-those-two-rules-that-were-left-out"&gt;What About Those Two Rules That Were Left Out?&lt;a class="headerlink" href="#what-about-those-two-rules-that-were-left-out" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Just to get this out of the way: because it was expedient.&lt;/p&gt;
&lt;p&gt;I started to look at rule MD041 when I was implementing rule MD002, as documented in
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#rule-md002-deprecated-first-heading-should-be-top-level"&gt;the last article&lt;/a&gt;.
At that time, I looked at rule MD041 to determine if I could just include the work for
MD041 with the work to write rule MD002.  While the only difference between the two
rules is the inclusion of “YAML front matter” into the rule, I felt that the
difference was a large one at that stage of the project.  I knew that I needed to
added metadata support to the parser as a requirement for my use of the linter.  But
the overriding question I had to answer was: Was this the right time to add this
new feature to the parser?&lt;/p&gt;
&lt;p&gt;After a decent amount of back and forth on the subject, I decided against adding it at
that moment. From my point of view, at that time it was better to focus on additional
linter rules for the project rather than focus on additional features for the parser.
While it would be fun to add more functionality to the parser to allow for MD041 to be
implemented, I made a judgement call that it could wait a bit.&lt;/p&gt;
&lt;p&gt;For rule MD043, my decision was based on a combination of the
complexity of the feature and the usefulness of the feature to me.  Without a deep dive
into the rule, it looks like there will be a fair number of edge cases that I will have
to consider for rule MD043, easily increasing its complexity.  From the usefulness
point of view, while I can
see how it may be useful, this is not a feature that I see myself using a lot.  While I
took a different path to the judgement call, the result was the same: Rule MD043 could
wait for later.&lt;/p&gt;
&lt;h2 id="why-is-this-group-of-rules-important"&gt;Why Is This Group of Rules Important?&lt;a class="headerlink" href="#why-is-this-group-of-rules-important" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I didn’t think about it at the time, I needed this group of rules to prove
two important things to myself: that I had chosen the right base framework to write
linter rules with, and that I had chosen a good development process with which to
write and test those rules.  It was only after the development was completed and
I was writing this article that I was able to recognize their importance in proving
or disproving those two things to myself.&lt;/p&gt;
&lt;h2 id="rule-md018-no-space-after-hash-on-atx-style-heading"&gt;Rule MD018 - No space after hash on atx style heading&lt;a class="headerlink" href="#rule-md018-no-space-after-hash-on-atx-style-heading" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_018.py"&gt;Rule MD018&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This rule is all about catching a
&lt;a href="https://www.merriam-webster.com/dictionary/typo"&gt;typo&lt;/a&gt;.
This rule surmises that when someone types:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="n"&gt;Heading&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;they probably forgot to add a space and really meant to type this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;Heading&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it is possible that the author intended to start a new line with the text
&lt;code&gt;#Heading&lt;/code&gt;, I believe that it is far more likely that a typo occurred.&lt;/p&gt;
&lt;h3 id="adding-the-rule"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The two important parts of adding this rule were recognizing that it can take place
in a normal paragraph and that it can occur at the start of any line in that paragraph.&lt;/p&gt;
&lt;p&gt;While I did consider the possibility of text like &lt;code&gt;#Heading&lt;/code&gt; being
captured as part of another block element, my experimentation with the CommonMark
parser did not reveal any case that causes another block element to stop
capturing on a line like &lt;code&gt;# Heading&lt;/code&gt;.  As such, by default the text ends up being
captured within a paragraph block using a text token. As is shown in
&lt;a href="https://github.github.com/gfm/#example-47"&gt;example 47&lt;/a&gt;,
an Atx heading can interrupt other blocks, but more importantly, it can interrupt a
paragraph block.  With these two constraints understood, I was ready to start
coding the rule.&lt;/p&gt;
&lt;p&gt;Leveraging the first constraint allowed me to add code to the &lt;code&gt;next_token&lt;/code&gt;
function to consider any text token within a paragraph block eligible for further
examination.  From there, I applied the second constraint by enhancing the
rule to look for an Atx heading-like pattern at the start of each line within those
eligible text tokens.
This was accomplished by breaking down each text token into separate lines and checking
them against a
&lt;a href="https://docs.python.org/3/howto/regex.html"&gt;Python regular expression&lt;/a&gt;.
By carefully reading the GFM specification’s section on
&lt;a href="https://github.github.com/gfm/#atx-headings"&gt;Atx headings&lt;/a&gt;,
I was able to construct the regular expression &lt;code&gt;^\s{0,3}#{1,6}\S&lt;/code&gt;, which breaks down
into the following components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; - start matching at the start of the line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s{0,3}&lt;/code&gt; - look for between 0 and 3 whitespace characters&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#{1,6}&lt;/code&gt; - look for between 1 and 6 &lt;code&gt;#&lt;/code&gt; characters&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\S&lt;/code&gt; - look for one non-whitespace character&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I needed the regular expression to be a form of the regular expression to recognize the
proper GRM specification form but modified to look for the specific case that I wanted
to look for.  In this instance, I was looking for heading-like text that is missing
at least one space after the starting &lt;code&gt;#&lt;/code&gt; characters.  To satisfy this constraint I
used the &lt;code&gt;\S&lt;/code&gt; sequence,
matching any single non-whitespace character, at the end of the regular expression
specifically looking for no whitespace characters at the end of the expression. Using my
favorite online &lt;a href="https://pythex.org/"&gt;Python regular expression tester&lt;/a&gt;, I was able to
verify that I had the correct regular expression right away.&lt;/p&gt;
&lt;p&gt;The rigorous testing for this rule involved more testing of cases where the rule should
not fail than cases where it should fail.  But when I boiled all those tests down into
what was relevant, there were a couple of patterns that I just needed to test.  In
testing, this is referred to as equivalence class testing.&lt;/p&gt;
&lt;p&gt;While sites like
&lt;a href="https://www.professionalqa.com/equivalence-class-testing"&gt;this one&lt;/a&gt;
go on and on about what it is, it breaks down into one statement.  Unless there
is something special (usually around boundary conditions), entire groups of tests can
be considered equivalent and be represented by a single test, if their relevant
behavior is consistent across that entire group.  Consider a simple calculator
application that allows for the addition of 2 integers together.  The testing of that
application does not need to test every single integer added to every single integer.
Just thinking about the work required for that is exhausting!  Instead, the testing can
be broken down into representative
groups such as “any integer added to 0 equals that integer”, drastically reducing the
number of tests required to cover a specific component.&lt;/p&gt;
&lt;p&gt;Applying this concept to the test cases for this rule, I was able to reduce over 20
tests down to a more reasonable 8 tests.  Some of these groups were making sure
the rule does not fail if eligible text is in any of the text-containing leaf blocks
except for the paragraph block, in which it should fail.  The rest of the groups were
simple cases based on variations of the regular expression above, that regular
expression a reflection of the specification.&lt;/p&gt;
&lt;p&gt;Confident that I had covered all the conditions for this rule, it was time to move
on to the next one!&lt;/p&gt;
&lt;h2 id="rule-md019-multiple-spaces-after-hash-on-atx-style-heading"&gt;Rule MD019 - Multiple spaces after hash on atx style heading&lt;a class="headerlink" href="#rule-md019-multiple-spaces-after-hash-on-atx-style-heading" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_019.py"&gt;Rule MD019&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense_1"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like a fair number of the other rules that are defined, this rule is about
consistency.  While the opening paragraph for the GFM specification for
&lt;a href="https://github.github.com/gfm/#atx-headings"&gt;Atx headings&lt;/a&gt;
does allow for more than one space after the initial set of &lt;code&gt;#&lt;/code&gt; characters, it also
specifies that those leading spaces are stripped before the rest of the line is
parsed as inline content.  Essentially:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;Heading&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;                                            &lt;span class="n"&gt;Heading&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;are syntactically equivalent.  As they are equivalent, it makes sense to use the simpler
form of the heading to keep things consistent.&lt;/p&gt;
&lt;h3 id="adding-the-rule_1"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The code to evaluate this rule was very simple.  When the content of the Atx heading is
parsed into a text token, any spaces that are stripped from that token are kept as part
of the text token in a separate part specifically reserved for stripped whitespace.  To
check for multiple spaces, I simply added code that checked to see if a
text token existed within an Atx heading, and if so checked to see if that token
contained more than one space in that stripped whitespace area of the token.&lt;/p&gt;
&lt;p&gt;As the code was simple, the tests themselves were simple.  The examples from the
&lt;a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#md019---multiple-spaces-after-hash-on-atx-style-heading"&gt;MD019 rule description page&lt;/a&gt;
were used verbatim as the only cases needed as that is how simple this rule is.  At
least it was that simple until I looked more closely at the next two rules.&lt;/p&gt;
&lt;h2 id="rules-md020-and-md021"&gt;Rules MD020 and MD021&lt;a class="headerlink" href="#rules-md020-and-md021" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_020.py"&gt;Rule MD020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_021.py"&gt;Rule MD021&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="these-rules-look-very-familiar"&gt;These Rules Look Very Familiar&lt;a class="headerlink" href="#these-rules-look-very-familiar" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While preparing for the work detailed in
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/"&gt;the last article&lt;/a&gt;,
I quickly read through the list of rules before starting that work.  I believe that
because I was focusing on those first 3 rules, I missed an interesting
piece of information on rules MD020 and MD021.  The piece of information is that
rules MD020 and MD021 are variations of the rules for MD018 and MD019 that apply
specifically to Atx headings with the
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#atx-headings-vs-atx_closed-headings"&gt;Atx_Closed style&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That information was both good news and bad news.  The good news part was that since I
had the code and tests already written for the previous two rules, I could repurpose a
lot of that code for these new rules.  The bad news part was that I was going to have
to rewrite parts of those two previous rules to exclude cases where the latter two rules
will fail.  However, I believe that the good news here definitely outweighs the bad
news, so on to the coding!&lt;/p&gt;
&lt;h3 id="adjusting-the-old-rules"&gt;Adjusting the Old Rules&lt;a class="headerlink" href="#adjusting-the-old-rules" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first part of adding these new rules was modifying the old rules to not fail if an
Atx_Closed style of Atx heading is found.  Rule Md019 was the easiest one to adjust,
requiring only a small change. As part of the normal Atx heading parsing, the number of
trailing &lt;code&gt;#&lt;/code&gt; characters in the heading is collected in the Atx heading’s
&lt;code&gt;remove_trailing_count&lt;/code&gt; variable.  The small change I made was to only fail rule MD019
if that variable was zero, an easy change in anyone’s viewpoint.
The change for rule MD018 was only slightly more difficult, adding an additional check
for the regular expression &lt;code&gt;#\s*$&lt;/code&gt;&lt;sup id="fnref:closeAtx"&gt;&lt;a class="footnote-ref" href="#fn:closeAtx"&gt;1&lt;/a&gt;&lt;/sup&gt; to the existing condition.  In both
cases, simple test cases were added to expressly test the rule to make sure they did
not fail if presented with an Atx_Closed style heading.&lt;/p&gt;
&lt;p&gt;Simple changes, and simple tests to verify those changes.&lt;/p&gt;
&lt;h3 id="adding-the-new-rules"&gt;Adding the New Rules&lt;a class="headerlink" href="#adding-the-new-rules" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Adjusting rule MD019 to fit the parameters of rule MD021 was interesting, but not too
difficult.  The original check for spaces was modified to set the variable
&lt;code&gt;is_left_in_error&lt;/code&gt; instead of failing immediately.  When the end token for the Atx
heading token is seen, it checks to see if that &lt;code&gt;is_left_in_error&lt;/code&gt; was set or if the
closing &lt;code&gt;#&lt;/code&gt;
count is greater than 1, failing if either part is true.  Checking the end token was
required as the parser’s pattern is that any leading spaces are applied to the token
that follows those spaces, meaning that those spaces before the closing &lt;code&gt;#&lt;/code&gt; characters
is stored with the Atx heading’s end token.&lt;/p&gt;
&lt;p&gt;Making similar changes to rule MD020 proved to be a bit more difficult.  The
constraints from rule MD018 were still present, but rule MD020 added the constraint of
looking for bad spacing before the closing set of &lt;code&gt;#&lt;/code&gt; characters.  Starting with the
previous regular expression for finding normal Atx headings in paragraphs
(&lt;code&gt;^\s{0,3}#{1,6}\S&lt;/code&gt;) and merging it together with the the regular expression
for excluding Atx_Closed line failures from rule MD019 (&lt;code&gt;#\s*$&lt;/code&gt;), I ended up with the
expression &lt;code&gt;^\s{0,3}#{1,6}.*#+\s*$&lt;/code&gt;.  To merge the two expression together, I made two
small changes.  The &lt;code&gt;\S&lt;/code&gt; expression used to indicate the matching of any character that
is not whitespace was replaced with the &lt;code&gt;.*&lt;/code&gt; expression to match zero or
more instances of any character.  The &lt;code&gt;#&lt;/code&gt; character used to indicate a single &lt;code&gt;#&lt;/code&gt;
character was then replaced with the &lt;code&gt;#+&lt;/code&gt; expression to match 1 or more &lt;code&gt;#&lt;/code&gt; characters,
allowing for any number of closing &lt;code&gt;#&lt;/code&gt; characters in the Atx heading.  &lt;/p&gt;
&lt;p&gt;Before adding any extra test cases, I used my favorite
&lt;a href="https://pythex.org/"&gt;Python regular expression tester&lt;/a&gt; to do some extensive testing
on the regular expression.  I am happy to report that except for a simple
typo, I got the regular expression right on the first try!&lt;/p&gt;
&lt;p&gt;With the regular expression
verification concluding successfully, I moved to add the test cases for both rules.
For both rules, I started by adding copies of the test cases from the original rules
but modified each one to represent missing spaces at the start of the Atx_Closed style
headings instead of normal Atx style headings.  From there, I added test cases where
spaces were
missing from both the start and the end of the Atx heading as well as where spaces
were only missing from the end of the Atx_Closed style headings.  It was there that I
ran into an interesting case.&lt;/p&gt;
&lt;h3 id="is-this-really-a-failure"&gt;Is This Really A Failure?&lt;a class="headerlink" href="#is-this-really-a-failure" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While the original rules do not specifically identify this as a distinct case, consider
the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;Heading&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this obviously qualifies as an Atx heading, I can credibly argue that it should
be included in MD020’s definition of a typo in an Atx_Closed styled heading.  While I
could have left it out, I felt strongly that this was most likely a typo and the rule
should fail on this input as well.  &lt;/p&gt;
&lt;p&gt;Adding this into the rule for MD020 was easy.  If the last token is a text token and the
rule is currently looking at an end Atx heading token, the rule checks to see if that
previous text token ends with a &lt;code&gt;#&lt;/code&gt; character.  If the &lt;code&gt;#&lt;/code&gt; character is found, it fails
the rule.&lt;/p&gt;
&lt;p&gt;After adding the code for this newly discovered case, I spent some time exploring
different possible combinations, making sure that I had the right equivalence classes
for all 4 new rules.  When I was satisfied that I had not missed anything, I move on
to the next rule.&lt;/p&gt;
&lt;h2 id="rule-md022-headings-should-be-surrounded-by-blank-lines"&gt;Rule MD022 - Headings should be surrounded by blank lines&lt;a class="headerlink" href="#rule-md022-headings-should-be-surrounded-by-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_022.py"&gt;Rule MD022&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense_2"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I could stay with the consistency answer I used for MD019, a better answer for
this rule is  compatibility and readability.  Speaking to compatibility,
there are some Markdown parsers that will not recognize Atx headings unless they are
preceded by a blank line or followed by a blank line.  To keep things simple, having
at least one blank line on either side of the Atx heading keeps the options for parser
choices open.&lt;/p&gt;
&lt;p&gt;From a readability point of view, hopefully it is obvious that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;Lorem&lt;/span&gt; &lt;span class="nv"&gt;ipsum&lt;/span&gt; &lt;span class="nv"&gt;dolor&lt;/span&gt; &lt;span class="nv"&gt;sit&lt;/span&gt; &lt;span class="nv"&gt;amet&lt;/span&gt;, &lt;span class="nv"&gt;consectetur&lt;/span&gt; &lt;span class="nv"&gt;adipiscing&lt;/span&gt;.

## &lt;span class="k"&gt;Next&lt;/span&gt; &lt;span class="nv"&gt;Section&lt;/span&gt;

&lt;span class="nv"&gt;Morbi&lt;/span&gt; &lt;span class="nv"&gt;dictum&lt;/span&gt; &lt;span class="nv"&gt;tortor&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;diam&lt;/span&gt; &lt;span class="nv"&gt;volutpat&lt;/span&gt;, &lt;span class="nv"&gt;ut&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is a lot easier to read than:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;Lorem&lt;/span&gt; &lt;span class="nv"&gt;ipsum&lt;/span&gt; &lt;span class="nv"&gt;dolor&lt;/span&gt; &lt;span class="nv"&gt;sit&lt;/span&gt; &lt;span class="nv"&gt;amet&lt;/span&gt;, &lt;span class="nv"&gt;consectetur&lt;/span&gt; &lt;span class="nv"&gt;adipiscing&lt;/span&gt;.
## &lt;span class="k"&gt;Next&lt;/span&gt; &lt;span class="nv"&gt;Section&lt;/span&gt;
&lt;span class="nv"&gt;Morbi&lt;/span&gt; &lt;span class="nv"&gt;dictum&lt;/span&gt; &lt;span class="nv"&gt;tortor&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;diam&lt;/span&gt; &lt;span class="nv"&gt;volutpat&lt;/span&gt;, &lt;span class="nv"&gt;ut&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Between the coloring of the Atx heading in my editor and the spacing around the Atx
heading, it is easy to find the different sections.  Without that spacing, I know it
takes me a lot more effort to find headings, especially in a large document.&lt;/p&gt;
&lt;p&gt;In addition to these reasons, I believe that different people have varying requirements
on what is acceptable or proper amounts of spacing before and after a heading.  I
personally know of a few people with visual impairments that find it easier to
acknowledge the change in sections if accompanied by extra spacing.  To support varying
requirements like these, rule MD022 has the &lt;code&gt;lines_above&lt;/code&gt; and &lt;code&gt;lines_below&lt;/code&gt;
configuration values that allows the user to alter the required number of blank lines
before and after each heading element.  From my point of view, the benefit provided
by allowing the user to configure this rule easily outweighs the work that was
required to add it.&lt;/p&gt;
&lt;h3 id="adding-the-rule_2"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In documenting the previous 4 rules, I noticed that I almost always talk about
testing as a final step, which is far from my practice.  As such, I thought it would
be useful to use this rule’s development as an example of my normal development
process.&lt;/p&gt;
&lt;h4 id="testing-done-right"&gt;Testing Done Right&lt;a class="headerlink" href="#testing-done-right" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;As I documented in &lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/"&gt;my last post&lt;/a&gt;,
my usual process for developing a new rule is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creating a New Rule&lt;/li&gt;
&lt;li&gt;Creating the Initial Tests&lt;/li&gt;
&lt;li&gt;Implementing the Rule&lt;/li&gt;
&lt;li&gt;Thorough Rule Validation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I usually talk about running the tests after I talk about creating a rule, because it
is in the “Thorough Rule Validation” phase that most of the interesting things happen.
In this case, it was the “Creating the Initial Tests” phase that was interesting.&lt;/p&gt;
&lt;p&gt;Creating a new rule is a task that I can now perform while sleeping, as I have done it
enough times that adding a new rule to the project only requires a little bit of my
attention to accomplish correctly.  I was then wakened out of slumber when I proceeded
to the next step and started going through the initial combinations of test data for
this rule.  Honestly, keeping all that data in my head caused me to get confused
somewhat quickly.  There were simply too many
combinations to keep in my head with any degree of confidence.  As such, I started
creating the initial test cases for rule MD022, adding
one test case per file just like normal.  Working through each set of combinations,
I was surprised that at the end of that exercise, I had 22 test files ready to go for
testing.  Reviewing the variations of text block types, SetExt/Atx headings,
valid/invalid spacing, and alternate spacing configurations, it did seem justified that
22 test files were required to properly test the rule. And that number was kept low as
I cheated a little bit, leaving any combinations with container blocks (block quotes
and list blocks) out of the
equation until I could do a bit more research and thinking on them.&lt;/p&gt;
&lt;h4 id="writing-the-rule"&gt;Writing the Rule&lt;a class="headerlink" href="#writing-the-rule" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Having so many test cases, I was concerned that the logic was going to be incredibly
complex, but I was able to boil it down to two simple metrics: the number of blank lines
before a heading and the number of blank lines after a heading.  The count
of lines before any heading is equal to the number of blank lines after a leaf block
completes and the heading block starts.  The count of lines after any heading is equal
to the number of blank lines after the end of the heading until the next leaf block
starts.  This is where excluding the container blocks paid off, as adding those blocks
in to this rule with their containing conditions and ending conditions would have
complicated those calculations by a fair amount.&lt;/p&gt;
&lt;p&gt;Given the calculations as specified in the last paragraph, the code to determine these
values was simple, but required some thinking.  The &lt;code&gt;blank_line_count&lt;/code&gt; variable is
incremented if it is not
&lt;code&gt;None&lt;/code&gt; and is greater than zero.  At the start of the document, the &lt;code&gt;blank_line_count&lt;/code&gt;
variable is set to &lt;code&gt;-1&lt;/code&gt; to make sure it does not fail for a heading at the very start of
the document.  Whenever the end of a leaf block is encountered, the &lt;code&gt;blank_line_count&lt;/code&gt;
variable is set to &lt;code&gt;0&lt;/code&gt; to allow the counting of blank lines to commence.  The end token
for anything other than leaf blocks is not important to this rule, so in that case, the
&lt;code&gt;blank_line_count&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt; to stop counting until the next qualifying end token
starts it again.&lt;/p&gt;
&lt;p&gt;Once I had the calculation of &lt;code&gt;blank_line_count&lt;/code&gt; worked out properly, the rest was a
matter of perspective.  The before count is simply the value of &lt;code&gt;blank_line_count&lt;/code&gt; at
the time that the Atx heading is encountered.  Likewise, the after count is the value
of &lt;code&gt;blank_line_count&lt;/code&gt; at the time that the next leaf block is encountered.  But what
if there is no next leaf block?  What if the heading block is the last block in the
document?  That is where the &lt;code&gt;completed_file&lt;/code&gt; function comes in handy. Added
to the plugin manager for cases like this, this function is called after all the
line and token processing for the Markdown has completed.  When the
&lt;code&gt;completed_file&lt;/code&gt; function is called for this rule, it performs the usual check for
closing conditions, failing the rule if the conditions are right.&lt;/p&gt;
&lt;p&gt;With the 22 test cases identified at the start of the development for this rule,
the testing was simple, with almost no errors in the implementation of the rule
itself, just the normal semantic and typo stuff.  I do feel that I must acknowledge
that I believe part of the reason this went off so cleanly was because the container
blocks are not yet implemented.  I do think those 2 blocks alone will easily
&lt;a href="https://idioms.thefreedictionary.com/throw+a+wrench+in+the+works"&gt;throw a monkey wrench&lt;/a&gt;
into the works.  But for now, it is a good place to stop with development of this rule.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After the stress of adding the first three rules, as documented in
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/"&gt;the previous article&lt;/a&gt;,
adding these rules to PyMarkdown was comparatively easy.  While I still had to contend
with the line numbers and column numbers not being reported&lt;sup id="fnref:yes"&gt;&lt;a class="footnote-ref" href="#fn:yes"&gt;2&lt;/a&gt;&lt;/sup&gt;, everything else in
my “rule development process” was working fine.  There are times that I want to skip
the tests and get to the development of the rule and have fun, as I am only human.
But if there is anything that
my experience as a developer has taught me, it is that having a clear picture of what
you want to do before your write the code is essential to shaping the code.  If you
start with a poor picture for what your code will do, you get poor results.  I find it
almost always pays off to take the time to draw that good picture, getting together
solid test cases and manually calculating their anticipated results once executed
against the project.&lt;/p&gt;
&lt;p&gt;While the ease of rule development is nice, it is the solid nature and usefulness of the
core rule engine that is making me happy.  In implementing this batch of 5 rules, I
did not have to make any changes to the core rule engine.  At the same time, the
development of the rules was easy, my focus centering on the particulars of the rule
itself, and not the infrastructure required to support the rule.  While I am not sure
if it is happiness or pride, it is a good
feeling that the work to get the project to this point is paying off.  And while I
do know refactoring is needed in some areas, I also have a growing collection of
proof that my approach to this project is solid and should be continued.&lt;/p&gt;
&lt;p&gt;Based on those observations, I believe that any earlier questions about whether I
had chosen the right framework and the right development process were answered
positively.  As an added benefit, I also sincerely believe that my early choices to do
things “this way” are paying off for the project.  While not 100% frictionless,
the minimal effort that I require to write new rules is challenging but not difficult,
increasing the “fun quotient” for the project.&lt;/p&gt;
&lt;p&gt;I honestly couldn’t wait to keep the progress going with the next set of rules.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Without much fanfare, since this first group of 5 heading rules was accomplished
with ease, next on the list if the second group of 5 rules.  I do hope that I
will have a similar result with those rules!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:closeAtx"&gt;
&lt;p&gt;Look for any &lt;code&gt;#&lt;/code&gt; character followed by any number of whitespace characters, anchored to the end of the line. &lt;a class="footnote-backref" href="#fnref:closeAtx" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:yes"&gt;
&lt;p&gt;Yes, I am still kicking myself over that, just not as much. &lt;a class="footnote-backref" href="#fnref:yes" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter rules"></category></entry><entry><title>Markdown Linter - Rules - The First Three</title><link href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/" rel="alternate"></link><published>2020-05-11T00:00:00-07:00</published><updated>2020-05-11T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-05-11:/2020/05/11/markdown-linter-rules-the-first-three/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With some solid refactoring work completed, it was time for me to write the first set
of rules based on all that hard work.  To start things off, I planned to work on 2-3
rules that would verify that I had created an acceptable framework for writing and
evaluating …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With some solid refactoring work completed, it was time for me to write the first set
of rules based on all that hard work.  To start things off, I planned to work on 2-3
rules that would verify that I had created an acceptable framework for writing and
evaluating Markdown linting rules.  As
&lt;a href="https://github.com/DavidAnson/markdownlint"&gt;David Anson’s MarkDownLint&lt;/a&gt;
plugin for VSCode already has a number of rules defined, it made sense to pick a
handful of rules from there as a starting point.  This choice was also fitting, as
David’s NPM-based project was the inspiration for my Python-based project.&lt;/p&gt;
&lt;p&gt;But how to pick the rules to start with?  One of my criteria was that whatever
set of rules that I picked, I wanted to be able to extend the set  of rules naturally
once I finished proving the first few rules were able to be clearly written.  The other
criteria that I wanted was for those initial rules to be a good cross-section of what to
expect in the other rules.&lt;/p&gt;
&lt;p&gt;Based on those criteria and some quick thinking on my part, it took me less than 2
minutes to realized that the first three rules in David’s check list would do just fine!&lt;/p&gt;
&lt;h2 id="why-is-this-article-so-long"&gt;Why Is This Article So Long?&lt;a class="headerlink" href="#why-is-this-article-so-long" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To be honest, this article got away from me.  Without breaking down this article into
3 articles, each one focusing on its own rule, I couldn’t see any intermediate
solutions for breaking up the article.  These are the first three rules I wrote for the
project, and as such, they laid the foundation for all the other rules.  It just
did not seem right to artificially break up the article.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c9e487dcf47b9fce0bdf4ccf6e5af26507a06c65"&gt;17 April 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/2425a81be8b95ed891cb210e8bdfa4d7de126f6a"&gt;23 April 2020&lt;/a&gt;, except for the commit from
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/562600457654234aa7cabefa8e2a6b56665d936c"&gt;18 April 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="why-the-first-three-rules"&gt;Why the First Three Rules?&lt;a class="headerlink" href="#why-the-first-three-rules" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given that David Anson’s work was the inspiration for this project, it made sense to
start with those rules,
&lt;a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#rules"&gt;outlined here&lt;/a&gt;.
The first three of those rules easily meet the first criteria, as all three rules deal
with examining the headings in a Markdown document.  Doing a quick count of all the
rules that dealt with headings, I counted 15 such rules.  Definitely qualifies as
extensible.&lt;/p&gt;
&lt;p&gt;As for the second criteria, the first rule is a standard rule, the second rule is a
disabled rule, and the third rule has configuration that affects how the rule is
measured.  Between the three of them, I had a lot of confidence that together they
would represent a good cross-section of all rules, and therefore satisfy the
second criteria nicely.&lt;/p&gt;
&lt;p&gt;With the three rules selected and a confirmation that these three rules satisfied my
criteria, it was time to move forward with implementation.&lt;/p&gt;
&lt;h2 id="a-quick-aside"&gt;A Quick Aside&lt;a class="headerlink" href="#a-quick-aside" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Are they &lt;code&gt;headings&lt;/code&gt; or &lt;code&gt;headers&lt;/code&gt;?  While some of my cheat sheet resources like the
&lt;a href="https://www.markdownguide.org/cheat-sheet"&gt;Markdown Guide’s Cheat Sheet&lt;/a&gt;
refer to them as &lt;code&gt;headings&lt;/code&gt;, other resources like
&lt;a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet"&gt;Adam Pritchard’s Cheatsheet&lt;/a&gt;
refer to them as &lt;code&gt;headers&lt;/code&gt;.  Even the
&lt;a href="https://spec.commonmark.org/0.29/#atx-headings"&gt;CommonMark specification&lt;/a&gt;
refers to them as &lt;code&gt;headings&lt;/code&gt;, but then include a couple of times where the term
&lt;code&gt;header&lt;/code&gt; is used instead of &lt;code&gt;heading&lt;/code&gt;.  So which one is right?&lt;sup id="fnref:cheatSheet"&gt;&lt;a class="footnote-ref" href="#fn:cheatSheet"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;To keep things simple, I am going to use the term &lt;code&gt;heading&lt;/code&gt; in this article and my
other articles that deal with headings going forward.  That term seems to be the one
that is most dominant in the specification, and I believe that the authors of the
specification had a good reason for specifically using the term &lt;code&gt;heading&lt;/code&gt;.  Even if
that reason is not documented.&lt;/p&gt;
&lt;h2 id="rule-md001-incrementing-heading-levels"&gt;Rule MD001 - Incrementing Heading Levels&lt;a class="headerlink" href="#rule-md001-incrementing-heading-levels" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_001.py"&gt;Rule MD001&lt;/a&gt;.  Feel free to examine the code at your convenience.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This rule is simple: when using headings, the heading level should at most
increase by one.  Based largely on the
&lt;a href="https://www.w3.org/WAI/tutorials/page-structure/headings/"&gt;W3C’s Accessibility Guidelines&lt;/a&gt;,
this rule just makes sense even without those accessibility guidelines.  If you have a
heading, and you want subsections under that heading, you use a heading level that is
one below the current one.  Consider this example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# &lt;span class="nv"&gt;What&lt;/span&gt; &lt;span class="nv"&gt;I&lt;/span&gt; &lt;span class="nv"&gt;Did&lt;/span&gt; &lt;span class="nv"&gt;On&lt;/span&gt; &lt;span class="nv"&gt;My&lt;/span&gt; &lt;span class="nv"&gt;Summer&lt;/span&gt; &lt;span class="nv"&gt;Vacation&lt;/span&gt;

&lt;span class="nv"&gt;I&lt;/span&gt; &lt;span class="nv"&gt;did&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;lot&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;things&lt;/span&gt;.

## &lt;span class="nv"&gt;July&lt;/span&gt;

&lt;span class="nv"&gt;July&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;when&lt;/span&gt; &lt;span class="nv"&gt;it&lt;/span&gt; &lt;span class="nv"&gt;started&lt;/span&gt;.

### &lt;span class="nv"&gt;The&lt;/span&gt; &lt;span class="nv"&gt;Pool&lt;/span&gt;

&lt;span class="nv"&gt;I&lt;/span&gt; &lt;span class="nv"&gt;went&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;pool&lt;/span&gt; &lt;span class="nv"&gt;every&lt;/span&gt; &lt;span class="nv"&gt;day&lt;/span&gt;.

#### &lt;span class="nv"&gt;Swim&lt;/span&gt; &lt;span class="nv"&gt;Classes&lt;/span&gt;

&lt;span class="nv"&gt;Mom&lt;/span&gt; &lt;span class="nv"&gt;made&lt;/span&gt; &lt;span class="nv"&gt;me&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;, &lt;span class="nv"&gt;again&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;

## &lt;span class="nv"&gt;August&lt;/span&gt;

&lt;span class="nv"&gt;This&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;when&lt;/span&gt; &lt;span class="nv"&gt;everything&lt;/span&gt; &lt;span class="nv"&gt;seemed&lt;/span&gt; &lt;span class="nv"&gt;repetitive&lt;/span&gt;.

### &lt;span class="nv"&gt;The&lt;/span&gt; &lt;span class="nv"&gt;Pool&lt;/span&gt;

&lt;span class="nv"&gt;I&lt;/span&gt; &lt;span class="nv"&gt;got&lt;/span&gt; &lt;span class="nv"&gt;really&lt;/span&gt; &lt;span class="nv"&gt;sick&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;pool&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it does accurately detail most of my summer vacations as a kid, I believe that it
is also a decent example of a report with the various highlights of each section
organized under their own headings.  It makes sense to
begin the document with the level 1 heading describing what the document is all about.
From there, it logically follows that to break the document up, there should be level 2
headings with the month names, each heading containing text specific to that month.
As going to the local pool was the major part of each summer, it therefore follows that
each of the months has its own level 3 heading under which I talk about what I did at
the pool during that month.  Finally, swim classes were deemed mandatory by my mother,
so me and my siblings took at least one session of swim classes each summer.  Detailing
those classes in the month they happened, under a level 4 heading, just seems to be the
right thing to do.  As a matter of fact, this example reminds me a lot of the
“returning to school” report that my mother made us right just before school started,
just to ensure that our waterlogged brains still remembered how to write properly.
Thanks Mom!&lt;/p&gt;
&lt;p&gt;Putting my reminiscing about summers as a kid aside, take another look at the headings
and the text, observing the natural progression for heading levels, as detailed in the
last paragraph.  For me, the headings and their levels just feel right, their flow is
natural and not jarring.  When I need to get more specific with information in each
section, I used a new heading one level down from the current heading and added that
more specific information under the new heading.  From my point of view, it just worked,
and I really did not need to think about why it worked… it just did.&lt;/p&gt;
&lt;p&gt;Specifically looking at the heading levels themselves, while there is a case where the
heading levels decrease by more than 1, there are no cases where the heading level
does not increase by 1.  As an author, it just made sense to author the report like
that, adding more detail with a lower heading and a lower subsection, and then popping
back up to the right level to continue.   While there may have been a scenario in which
the &lt;code&gt;Swim Classes&lt;/code&gt; section was followed by a level 3 heading and more text, it was not
required.  In fact, I believe that my freedom to not follow up that section with a
“garbage” level 3 heading and section text are what makes the flow of the headings
work as they do.&lt;/p&gt;
&lt;p&gt;While I might have taken the long way around in describing my theory behind this rule,
to me it simply just makes sense both as an author and as a reader.&lt;/p&gt;
&lt;h3 id="adding-the-rule"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This was my first rule using the built-in parser, so I wanted to make sure to lay down
some good patterns for myself to repeat going forward.&lt;/p&gt;
&lt;h4 id="pattern-test-format"&gt;Pattern: Test Format&lt;a class="headerlink" href="#pattern-test-format" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The first pattern I wanted to set in stone is the pattern to specify how to execute
tests for a given rule. After experimenting with different formats and combinations,
it was the proven test format that I chose
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/04222e24fdfb4c0f2d5c0e768516590a0140bb63#diff-0f4bc6824d3dcdb712fd4a5305ff4e4f"&gt;back in November&lt;/a&gt;
that won out.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_md0047_good_description&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test to make sure...&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;scanner&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MarkdownScanner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;suppplied_arguments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"test/resources/rules/md047/some_test_file.md"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;expected_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;expected_output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
    &lt;span class="n"&gt;expected_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;execute_results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scanner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invoke_main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;suppplied_arguments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;execute_results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assert_results&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;expected_output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_error&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_return_code&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This format keeps things simple: a descriptive function name, a decent function
description, and simple boiler-plate code for the function that can be applied to most
tests.  Even in cases where I had to add some extra code, such as adding a
configuration file for the linter
to read in and use, those changes were always applied on top of this template code,
not instead of it.
And except for those additions, only the variables &lt;code&gt;supplied_arguments&lt;/code&gt;,
&lt;code&gt;expected_return_code&lt;/code&gt;, &lt;code&gt;expected_output&lt;/code&gt;, and
&lt;code&gt;expected_error&lt;/code&gt; were ever changed for any of the tests, even to this day.&lt;/p&gt;
&lt;p&gt;Basically, my plan was to create the template once, put it through a trial of fire to
test it, and then reuse it endlessly once proven.  Keep it effective by keeping it
simple.  As Isaac Newton said:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Truth is ever to be found in the simplicity, and not in the multiplicity and confusion of things.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="pattern-creating-a-new-rule"&gt;Pattern: Creating a New Rule&lt;a class="headerlink" href="#pattern-creating-a-new-rule" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Translating the logic described under the section
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#why-does-this-rule-make-sense"&gt;Why Does This Rule Make Sense?&lt;/a&gt;
into Python code was easy.  First, I created the tests cases described above, and
examined the debug information output for those cases, specifically looking at what the
final sequence of tokens was.  As all the information for the rules was contained
within the instances of the &lt;code&gt;AtxHeaderMarkdownToken&lt;/code&gt; or
the &lt;code&gt;SetextHeaderMarkdownToken&lt;/code&gt;&lt;sup id="fnref:here"&gt;&lt;a class="footnote-ref" href="#fn:here"&gt;2&lt;/a&gt;&lt;/sup&gt;, those were the only two tokens I had to worry
about.&lt;/p&gt;
&lt;p&gt;With that knowledge in hand, it was time to move to the second pattern that I wanted to
repeat: creating a new
rule.  While the content of each rule changes, this process is always consistent.
First, I pick a test to clone from and copy its contents into a new file.  In this
initial case, I copied the file &lt;code&gt;rule_md_047.py&lt;/code&gt; into the file
&lt;code&gt;rule_md_001.py&lt;/code&gt;.  Any initialization for each rule is performed in the
&lt;code&gt;starting_new_file&lt;/code&gt; function, so that function is cleaned out except for the comment.
Finally, the &lt;code&gt;next_token&lt;/code&gt; is cleaned out in the same way, to provide for a clean slate
to start writing the rule with.  For this rule, &lt;code&gt;rule_md_047.py&lt;/code&gt; used the &lt;code&gt;next_line&lt;/code&gt;
function, so that needed to be changed to override the &lt;code&gt;next_token&lt;/code&gt; function instead,
as this rule is specifically token based.  Except for this one special case, this
pattern has now been replicated for each rule in the project.&lt;/p&gt;
&lt;h4 id="pattern-creating-the-initial-tests"&gt;Pattern: Creating the Initial Tests&lt;a class="headerlink" href="#pattern-creating-the-initial-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The third pattern that I wanted to get in place was specifying a good set of initial
test cases for the rule, prior to writing the rule itself.  A strong proponent of
test-driven development, I believe that before writing the source code, at least a
rough outline of the test code and test data should be written.&lt;/p&gt;
&lt;p&gt;A common misconception of test-driven development is that before you write any code,
you write all the tests.  The process is an iterative process, one
that grows over time.  While this entire process is the pattern that I want to
enshrine in this project, the important part that I want to tackle at this point is
coming up with a good set of tests and test data to start with.&lt;/p&gt;
&lt;p&gt;For this project, this initial set of tests and test data are made easy by the
existing MarkdownLint rules
&lt;a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#rules"&gt;outlined here&lt;/a&gt;.
While the rules outlined there do not always have a comprehensive set of Markdown
documents to test that rule, they always document at least one good
Markdown document and one bad Markdown document.  If there was something obvious that
is missing, I also try and add it at this point, just to save iterations later. But
just in case I miss something, I have another pattern,
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#pattern-thorough-rule-validation"&gt;Thorough Rule Validation&lt;/a&gt;,
that I will talk about later to try and catch those missed cases.&lt;/p&gt;
&lt;h4 id="implementing-the-rule"&gt;Implementing the Rule&lt;a class="headerlink" href="#implementing-the-rule" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Once things were setup, it was time to add the logic.  A false failure is not desired
when a new document is started, so I added a reset of the &lt;code&gt;last_header_count&lt;/code&gt; class
variable in the &lt;code&gt;starting_new_file&lt;/code&gt; function.  In the &lt;code&gt;next_token&lt;/code&gt; function, I then
added some simple code to test whether the token was one of the two heading tokens, and
if so, set the &lt;code&gt;hash_count&lt;/code&gt; variable to a non-None value.  At this point, I added some
debug to the function and ran each of the test cases against the rule, checking to see
whether what I expected to happen, did happen.&lt;/p&gt;
&lt;p&gt;As this rule implements simple logic, the initial logic was validated on my first try.
Removing the debug statements, I added some logic to filter out any cases where
&lt;code&gt;last_header_count&lt;/code&gt; was not set (initial case) or where &lt;code&gt;header_count&lt;/code&gt; was not greater
than &lt;code&gt;last_header_count&lt;/code&gt; (not increasing).  With those cases filtered out, it was
simple to
check for an increase of 1 and to fail if the increase was more than 1.  A quick
call to &lt;code&gt;report_next_token_error&lt;/code&gt; to report the failure, and the basic case was
completed.&lt;/p&gt;
&lt;p&gt;From there, I circled back to the test data, and looked to see if there were any
obvious cases that I was missing.  It was then that I noticed that the text’s
description specified headings, but had no test data for SetExt headings, just
Atx headings.  I quickly crafted some data that mixed a SetExt heading followed by
a valid and invalid Atx heading and iterated through the process again.  It was
only after I was sure that I had not missed anything obvious that I proceeded
to the next pattern: Thorough Rule Validation.&lt;/p&gt;
&lt;h4 id="pattern-thorough-rule-validation"&gt;Pattern: Thorough Rule Validation&lt;a class="headerlink" href="#pattern-thorough-rule-validation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The final pattern that I wanted to put into place was to be thorough in my rule
validation, using both internal data sources and external data sources.&lt;/p&gt;
&lt;p&gt;The validation against the internal data sources was easy, as I had just finished the
source code
and the tests code for that rule.  However, I put that aside and instead ignored the
source code in favor of the the definition of the rule’s scenario along with the
test data.  Based on those two factors alone, I predicted what the outcome of the test
should be, then executed the test to verify that prediction.&lt;/p&gt;
&lt;p&gt;If I encountered an error, the first step I took was to recheck the expected output
more rigorously against the rule’s scenario and the test data.  Whenever doing this, I
rechecked the output multiple times just to make sure I had the right answer.  From
my experience, unless I try very hard, it is unlikely that I will make the same mistake
twice.  If there was an error in the output, I corrected the error and executed the
tests again, as if from the beginning of this section.  If there was an error in the
rule itself, I would add some debug to the rule and run further tests to check what
refinements I needed to make, before restarting all the tests in this section.&lt;/p&gt;
&lt;p&gt;For this initial rule, I had errors in the test data and the rule, and this attention
to detail helped me spot them quickly.  After a few iterations, I was confident
that the validation against internal data sources was completed, and I needed to move
on to an external data source.  As the MarkDownLint implementation of the rules was
done as a VSCode plugin, it made sense to use VSCode + MarkDownLint as the external
validation source.&lt;/p&gt;
&lt;p&gt;It was with great confidence that I I loaded up the sample files into VSCode to check
against MarkDownLint.  It was when I looked at VSCode’s Problems tab that I got a big
surprise.  I had forgotten something important: line numbers and column numbers.&lt;/p&gt;
&lt;h4 id="line-numbers-and-column-numbers"&gt;Line Numbers and Column Numbers&lt;a class="headerlink" href="#line-numbers-and-column-numbers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;To say this hit me like a ton of bricks would not do it justice.  I was floored.
I was so focused on getting the parsing of the tokens done accurately, I completely
forgot to design and implement a way to place the location of the element in the
Markdown document into their tokens.  It was hard to miss the issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MD001/heading-increment/header-increment:
  Heading levels should only increment by one level at a time
  [Expected: h3; Actual: h4] markdownlint(MD001) [4,1]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Honestly, I took me a bit to get over this.  It was so obvious to me that I should
have seen this ahead of time.  When you are reporting any type of linting failure, you
need to specify the location of that failure so that the user can fix it.  Without
that information, the rule is somewhat useless.&lt;/p&gt;
&lt;p&gt;In the present as I am writing this article, I can better understand what happened
and how I missed those number.  However, at the time I struggled to find an interim
solution until I could start to tackle this properly.  I needed to focus on the
first cohort of rules, so I tried to put this mishap out of my mind.  It was after
some a couple of frustrating hours that I added two fields to track the line number and
column number of the tokens, setting both to 0.&lt;/p&gt;
&lt;p&gt;After some additional “yelling” at my monitor, I decided to close out that first rule,
and moved one to the second rule, confident that I (mostly) had set up some solid
patterns to focus on for the future rules.&lt;/p&gt;
&lt;h2 id="rule-md002-deprecated-first-heading-should-be-top-level"&gt;Rule MD002 - (Deprecated) First Heading Should Be Top Level&lt;a class="headerlink" href="#rule-md002-deprecated-first-heading-should-be-top-level" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_002.py"&gt;Rule MD002&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-not-make-sense"&gt;Why Does This Rule (Not) Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-not-make-sense" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Note the slightly different wording of the heading.  As documented on the
&lt;a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#md002---first-heading-should-be-a-top-level-heading"&gt;MarkdownLint site&lt;/a&gt;,
this rule has been replaced by
&lt;a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#md041---first-line-in-file-should-be-a-top-level-heading"&gt;rule MD041&lt;/a&gt;.
The important difference between the two rules is that MD002 looks at Atx headings
and SetExt headings, while rule MD041 also looks at the metadata at the start of the
document, often referred to as YAML front matter.  Because there is an improved rule,
this rule is disabled by default in favor of that rule.&lt;/p&gt;
&lt;p&gt;Whether in rule MD002 or rule MD047, the reasoning for both rules is consistent: each
document should contain a clean title.  For both rules, this is achieved by looking at
the first Atx heading or SetExt heading in the document and verifying that the first
heading is a level 1 heading.  For rule MD047, the only difference from rule MD002 is
that it additionally looks for a specific metadata field that can take the place of an
explicit level 1 heading.&lt;/p&gt;
&lt;p&gt;A good example of rule MD002 is the standard &lt;code&gt;readme.md&lt;/code&gt; file that I usually add at
the base of a GitHub project.  Typically, I start with a file that looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;ReadMe&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;describes&lt;/span&gt; &lt;span class="n"&gt;what&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;who&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;contact&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the title is simplistic, it does present a clear indication of what the title and
purpose of the document is.  If, on the other hand, you see a Markdown document like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Lorem&lt;/span&gt; &lt;span class="n"&gt;ipsum&lt;/span&gt; &lt;span class="n"&gt;dolor&lt;/span&gt; &lt;span class="n"&gt;sit&lt;/span&gt; &lt;span class="n"&gt;amet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;consectetur&lt;/span&gt; &lt;span class="n"&gt;adipiscing&lt;/span&gt; &lt;span class="n"&gt;elit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Phasellus&lt;/span&gt; &lt;span class="n"&gt;felis&lt;/span&gt; &lt;span class="n"&gt;lacus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finibus&lt;/span&gt;
&lt;span class="n"&gt;eget&lt;/span&gt; &lt;span class="n"&gt;gravida&lt;/span&gt; &lt;span class="n"&gt;eget&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dapibus&lt;/span&gt; &lt;span class="n"&gt;vel&lt;/span&gt; &lt;span class="n"&gt;lacus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Phasellus&lt;/span&gt; &lt;span class="n"&gt;placerat&lt;/span&gt; &lt;span class="n"&gt;nisi&lt;/span&gt; &lt;span class="n"&gt;enim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;eu&lt;/span&gt; &lt;span class="n"&gt;maximus&lt;/span&gt; &lt;span class="n"&gt;ipsum&lt;/span&gt;
&lt;span class="n"&gt;congue&lt;/span&gt; &lt;span class="n"&gt;nec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="nb"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;sollicitudin&lt;/span&gt; &lt;span class="n"&gt;metus&lt;/span&gt; &lt;span class="n"&gt;urna&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;quis&lt;/span&gt; &lt;span class="n"&gt;iaculis&lt;/span&gt; &lt;span class="n"&gt;ligula&lt;/span&gt; &lt;span class="n"&gt;condimentum&lt;/span&gt; &lt;span class="n"&gt;eu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it is hard to figure out what this document is for.  Simply by adding a title heading,
this can be cleared up.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# &lt;span class="k"&gt;Random&lt;/span&gt; &lt;span class="nv"&gt;Test&lt;/span&gt; &lt;span class="nv"&gt;Paragraphs&lt;/span&gt;

&lt;span class="nv"&gt;Lorem&lt;/span&gt; &lt;span class="nv"&gt;ipsum&lt;/span&gt; &lt;span class="nv"&gt;dolor&lt;/span&gt; &lt;span class="nv"&gt;sit&lt;/span&gt; &lt;span class="nv"&gt;amet&lt;/span&gt;, &lt;span class="nv"&gt;consectetur&lt;/span&gt; &lt;span class="nv"&gt;adipiscing&lt;/span&gt; &lt;span class="nv"&gt;elit&lt;/span&gt;. &lt;span class="nv"&gt;Phasellus&lt;/span&gt; &lt;span class="nv"&gt;felis&lt;/span&gt; &lt;span class="nv"&gt;lacus&lt;/span&gt;, &lt;span class="nv"&gt;finibus&lt;/span&gt;
&lt;span class="nv"&gt;eget&lt;/span&gt; &lt;span class="nv"&gt;gravida&lt;/span&gt; &lt;span class="nv"&gt;eget&lt;/span&gt;, &lt;span class="nv"&gt;dapibus&lt;/span&gt; &lt;span class="nv"&gt;vel&lt;/span&gt; &lt;span class="nv"&gt;lacus&lt;/span&gt;. &lt;span class="nv"&gt;Phasellus&lt;/span&gt; &lt;span class="nv"&gt;placerat&lt;/span&gt; &lt;span class="nv"&gt;nisi&lt;/span&gt; &lt;span class="nv"&gt;enim&lt;/span&gt;, &lt;span class="nv"&gt;eu&lt;/span&gt; &lt;span class="nv"&gt;maximus&lt;/span&gt; &lt;span class="nv"&gt;ipsum&lt;/span&gt;
&lt;span class="nv"&gt;congue&lt;/span&gt; &lt;span class="nv"&gt;nec&lt;/span&gt;. &lt;span class="nv"&gt;Integer&lt;/span&gt; &lt;span class="nv"&gt;sollicitudin&lt;/span&gt; &lt;span class="nv"&gt;metus&lt;/span&gt; &lt;span class="nv"&gt;urna&lt;/span&gt;, &lt;span class="nv"&gt;quis&lt;/span&gt; &lt;span class="nv"&gt;iaculis&lt;/span&gt; &lt;span class="nv"&gt;ligula&lt;/span&gt; &lt;span class="nv"&gt;condimentum&lt;/span&gt; &lt;span class="nv"&gt;eu&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="adding-the-rule_1"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having previously explained my process for
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#adding-the-rule"&gt;adding new rules&lt;/a&gt;,
I’ll leave that content out from here on, and just concentrate on what has changed.&lt;/p&gt;
&lt;p&gt;The logic for this rule is almost exactly the same as for the previously implemented
rule
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#rule-md001-incrementing-heading-levels"&gt;MD001&lt;/a&gt;,
except that instead of checking for an increase in the heading level,
it simply looks to see if the first heading it encounters has a heading level of 1.
The implementation of this rule introduced two new concepts: rule configuration and
disabling a rule by default.  While the next rule,
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#rule-md003-heading-style"&gt;MD003&lt;/a&gt;,
will properly deal with the configuration aspect, the main focus of this rule is the
ability to add a rule that is disabled by default.&lt;/p&gt;
&lt;p&gt;To provide options to the user, adding a rule that is disabled has merit.  In this
case, a new rule was added that is more comprehensive than this rule. However, rather
than removing this rule and possibly breaking the configuration of some users, the
original rule was preserved for users that are not comfortable updating their linting
to use the more comprehensive rule.  In addition, there is also a good
argument to be made for new rules to be added in a disabled state, allowing people who
are upgrading to a new version of the project to control which new features they want.
As both examples illustrate, having a rule be disabled by default is a useful feature
to have.&lt;/p&gt;
&lt;p&gt;The code to allow for a rule to be disabled by default was added back in November when
I was testing out the plugin manager concept.  While there was a good test of the
disable feature at that time, it was now time to really test its functionality with
this rule.  This testing was achieved by looking back at the test data for MD001 and
noticing that the first heading in the file &lt;code&gt;improper_setext_header_incrementing.md&lt;/code&gt; is
a level 2 heading.  That means that if rule MD002 is enabled and executed for that
Markdown file, I would expect a failure to occur.  Therefore, when I executed the
MD001 tests again, with rule MD002 in its default disabled state, I expected that no
additional failures would be reported.  I executed that tests, and this behavior is
exactly what I saw in the results.  For me, that was enough proof that the rule was
disabled by default.  &lt;/p&gt;
&lt;p&gt;To properly test this disabled rule, only a slight change to my normal process of
testing rules was required.  In addition to the normal information supplied by
the test in the &lt;code&gt;supplied_arguments&lt;/code&gt; variable of the test, the start of that array
was modified to include the elements &lt;code&gt;-e&lt;/code&gt; and &lt;code&gt;MD002&lt;/code&gt;.  As PyMarkdown allows for rules
to be enabled and disabled on the command line, those two additions simply told the
command line to enable (&lt;code&gt;-e&lt;/code&gt;) rule MD002 (&lt;code&gt;MD002&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;With those changes made to the tests, the rest of the testing went by without incident.&lt;/p&gt;
&lt;h2 id="rule-md003-heading-style"&gt;Rule MD003 - Heading Style&lt;a class="headerlink" href="#rule-md003-heading-style" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This section describes the initial implementation of PyMarkdown’s
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/master/pymarkdown/plugins/rule_md_003.py"&gt;Rule MD003&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-does-this-rule-make-sense_1"&gt;Why Does This Rule Make Sense?&lt;a class="headerlink" href="#why-does-this-rule-make-sense_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In a single word: consistency.  I am sure I would not want to read a Markdown document
that had multiple heading styles, such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;ATX&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;

&lt;span class="o"&gt;##&lt;/span&gt; &lt;span class="n"&gt;Closed&lt;/span&gt; &lt;span class="n"&gt;ATX&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt; &lt;span class="o"&gt;##&lt;/span&gt;

&lt;span class="n"&gt;Setext&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;
&lt;span class="o"&gt;===============&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It would be a confusing mess!  If I were reviewing that document for someone, I would
tell them to
keep it simple, pick a heading style, and stick to it.  By picking a single, simple
style, it would help any readers know what to expect.&lt;/p&gt;
&lt;p&gt;In terms of styles, there are 6 styles to choose from.  The obvious style, the default
&lt;code&gt;consistent&lt;/code&gt; style, simply looks at the first header and assumes that the style
of that heading will be used for the entire document, &lt;code&gt;atx&lt;/code&gt;, &lt;code&gt;atx_closed&lt;/code&gt; or &lt;code&gt;setext&lt;/code&gt;.
If the user wants to be more
specific about the style, there are two variations on Atx headings styles, and three
variations on SetExt headings styles to choose from.  They take a bit of getting used
to, so let me walk through them.&lt;/p&gt;
&lt;h4 id="atx-headings-vs-atx_closed-headings"&gt;Atx Headings vs Atx_Closed Headings&lt;a class="headerlink" href="#atx-headings-vs-atx_closed-headings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;For Atx headings, the two variations that are available are &lt;code&gt;atx&lt;/code&gt; and &lt;code&gt;atx_closed&lt;/code&gt;,
demonstrated in the follow example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;##&lt;/span&gt; &lt;span class="n"&gt;Atx&lt;/span&gt;

&lt;span class="o"&gt;##&lt;/span&gt; &lt;span class="n"&gt;Atx&lt;/span&gt; &lt;span class="n"&gt;Closed&lt;/span&gt; &lt;span class="o"&gt;##&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only difference between these two variations are that &lt;code&gt;atx_closed&lt;/code&gt; style includes
&lt;code&gt;#&lt;/code&gt; characters at the end of the heading as well as at the beginning.  While the
&lt;a href="https://github.github.com/gfm/"&gt;GFM specification&lt;/a&gt;
has strict requirements that there can only be 1 to 6 &lt;code&gt;#&lt;/code&gt; characters at the start of the
Atx heading, the only requirement for the closing &lt;code&gt;#&lt;/code&gt; characters is that there is at
least one valid &lt;code&gt;#&lt;/code&gt; character.  For any stricter requirements on the closing &lt;code&gt;#&lt;/code&gt;
characters, a new rule would have to be written to add more stringent requirements for
any Markdown documents with the &lt;code&gt;atx_closed&lt;/code&gt; style.&lt;/p&gt;
&lt;h4 id="setext-headings-vs-setext_with_42-headings"&gt;SetExt Headings vs SetExt_With_* Headings&lt;a class="headerlink" href="#setext-headings-vs-setext_with_42-headings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;For documents that use the SetExt headings, the obvious issue is what to do if the
document requires a level 3 heading, as SetExt headings only support a level 1 and a
level 2 heading.  To handle this case, the &lt;code&gt;setext_with_atx&lt;/code&gt; style is used to specify
that level 1 and level 2 headings remain SetExt, while level 2 to 6 headings are to
use Atx headings, as in the following example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;Setext style H1&lt;/span&gt;
&lt;span class="gh"&gt;===============&lt;/span&gt;

&lt;span class="gh"&gt;Setext style H2&lt;/span&gt;
&lt;span class="gh"&gt;---------------&lt;/span&gt;

### ATX style H3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without specifying a heading style of &lt;code&gt;setext_with_atx&lt;/code&gt; and relying on an implicitly
or defaulted setting of &lt;code&gt;setext&lt;/code&gt;, the rule would fail on the heading labeled
&lt;code&gt;ATX style H3&lt;/code&gt;.  To round things out, there is also a style variation
&lt;code&gt;setext_with_atx_closed&lt;/code&gt; which has the same behavior as the above example, except using
the &lt;code&gt;atx_closed&lt;/code&gt; style instead of the &lt;code&gt;atx&lt;/code&gt; style.&lt;/p&gt;
&lt;h3 id="adding-the-rule_2"&gt;Adding the Rule&lt;a class="headerlink" href="#adding-the-rule_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Back in the description for
&lt;a href="https://jackdewinter.github.io/2020/05/11/markdown-linter-rules-the-first-three/#adding-the-rule_1"&gt;rule MD002&lt;/a&gt;,
I mentioned that I would cover the configuration aspect later, focusing at that
time on the disabling of rules by default.  Having completed the discussion about that
rule, it is now time to talk configuration.  For any readers following along with the
commits in the project’s repository, note that the work for rule configuration was
performed in changes introduced in the commits for both rules MD002 and MD003.&lt;/p&gt;
&lt;h4 id="configuration"&gt;Configuration&lt;a class="headerlink" href="#configuration" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Configuration was the last component of the rules that I needed to have implemented and
tested thoroughly before implementing more rules.  It was important to me to get
configuration right, as just over half of the initial rules contains some element
of configuration.&lt;/p&gt;
&lt;p&gt;The main part of accepting configuration was to change the &lt;code&gt;main.py&lt;/code&gt; command line
interface to accept a configuration file in the JSON format, verifying that it
was a proper JSON file by parsing it into a simple Python &lt;code&gt;dict&lt;/code&gt; object before
continuing.  Just before the files were scanned, a call was introduced to the new
&lt;code&gt;__load_configuration_and_apply_to_plugins&lt;/code&gt; function, that function performing the
required work to call the &lt;code&gt;initialize_from_config&lt;/code&gt; function in each plugin.  At that
point, if the plugin requires any configuration, it calls the plugin’s
&lt;code&gt;get_configuration_value&lt;/code&gt; function to see if a value of the requested type is present in
the map.&lt;/p&gt;
&lt;p&gt;That might seem like a lot of work, but that work done can be summarized
as: load the configuration, let the plugins know about it, and then let the plugin
retrieve the configuration if required.  Almost everything else surrounding those
actions were either making sure errors were handled properly or making sure that the
correct information was passed properly to the plugin manager.&lt;/p&gt;
&lt;p&gt;Before checking the configuration code in for MD002, and then again for MD003, I
changed various parts of the plugins to request different information from the
configuration store.  It was this extra testing that allowed me to simplify rule MD003.
The initial code for the rule raised an exception if the configuration value did not
match one of the required values.  Based on that testing, I changed it to use the
default value in that case instead.  It just seemed like the right thing to do in
that case.&lt;/p&gt;
&lt;h4 id="the-rule-and-the-tests"&gt;The Rule and The Tests&lt;a class="headerlink" href="#the-rule-and-the-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Once the configuration was in place, the rest of the development went smoothly.  A
slight change to the Atx heading token was required to report the number of trailing
&lt;code&gt;#&lt;/code&gt; characters, but other than that, the core rules engine was stabilizing with no
other changes.&lt;/p&gt;
&lt;p&gt;The rule itself was somewhat simple but reducing the complexity of the check was a
daunting task.  At first, I wrote the rule with everything in the &lt;code&gt;next_token&lt;/code&gt;
function, which worked decently well.  The first part of that function was a block
of code that figured out two important attributes: the type of heading (&lt;code&gt;atx&lt;/code&gt;,
&lt;code&gt;atx_closed&lt;/code&gt;, or &lt;code&gt;setext&lt;/code&gt;) if the token was a heading token and whether that token
contained a level 1 or level 2 heading token.&lt;/p&gt;
&lt;p&gt;Based on that information, the rest of the code worked out cleanly.  If it was not a
heading token, exit quickly.  If the style was &lt;code&gt;consistent&lt;/code&gt; and this was the first
heading token to be seen, set the style to the heading type of the current token.
With all that out of the way, the actual checking of the styles started.  If the
style was one of the 3 basic styles, a simple comparison determined if the rule
failed or not.  In the &lt;code&gt;*with*&lt;/code&gt; variations for SetExt, the logic was a little more
complicated, mostly dealing with checking the level of the heading. A certain amount
of playing around with the code was required to get all the rules validating
the Markdown in a clean and simple manner.&lt;/p&gt;
&lt;p&gt;The tests themselves were simple as well.  Before starting on the rule, I had
created one test input file
with a positive example for each of the style types.  By changing the configured
style type to apply to the rule, I was able to cover all combinations very quickly.
What were negative cases for some tests became positive tests for other cases, and
vice versa.  The reusability of the data for testing this rule ended up being a big
win.  Instead of 3-5 test documents for each style, the tests only use a total of
5 documents, not including the &lt;code&gt;empty.md&lt;/code&gt; file.  Pretty efficient!&lt;/p&gt;
&lt;p&gt;It was with that battery of tests in place that I worked to reduce the complexity of
the rule.  I won’t try and say I got everything right on the first try. I didn’t.
But having those tests in place helped me figure out where I went wrong and helped
me determine the next changes to make.  Having a good set of tests is pivotal in
being able to refactor any algorithm, and that includes one the project’s rules.&lt;/p&gt;
&lt;h4 id="resolving-conflicts-between-rule-test-data"&gt;Resolving Conflicts Between Rule Test Data&lt;a class="headerlink" href="#resolving-conflicts-between-rule-test-data" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The one thing that I had to start watching out with this rule was the test data for one
rule raising an error on a previously written rule.  In each of the tests that I wrote,
I specifically wanted to narrow down the testing to that specific rule,
to keep the test more relevant to the rule.  With rules MD001 and MD002 being in the
same area, it was only luck that they did not cause any interference with each other.
For rule &lt;code&gt;MD003&lt;/code&gt;, it caused interference with the test data for the previous 2 rules,
where a consistent style for the input data was not a priority.&lt;/p&gt;
&lt;p&gt;To remove the interference, the PyMarkdown’s disable rule feature was used, the
opposite to the enable rule used in the testing of rule MD002.  Instead of adding the
&lt;code&gt;-e&lt;/code&gt; and &lt;code&gt;MD002&lt;/code&gt;
values to the &lt;code&gt;supplied_arguments&lt;/code&gt; variable, the values &lt;code&gt;--disable-rules&lt;/code&gt; and &lt;code&gt;MD003&lt;/code&gt;
were added.  In the tests for rule MD002, rule MD002 was enabled from the
command line at the same time that rule MD003 was disabled from the command line.&lt;/p&gt;
&lt;p&gt;By applying &lt;code&gt;--disable-rules&lt;/code&gt; and &lt;code&gt;MD003&lt;/code&gt; to the tests for MD001 and MD002, I was
able to resolve the interference from rule MD003 cleanly, getting nice consistent
test results.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first part of my experience that I want to talk about is change and how I handle it.
Specifically, I want to talk about the line and column numbers.  While it was painfully
obvious after comparing the output in VS Code with my output, it really hadn’t crossed
my mind before then.  I was more concerned with the ability to write a solid rule, and
not concerned with the content that would be displayed when that rule detected a
violation.  Sure, I felt like I should have caught that in the design process, and I
gave myself somewhere between 5 minutes and 5 hours to deal with that.&lt;/p&gt;
&lt;p&gt;After that, I noted it in my “to do” document as technical debut, and I just put it
behind me.  That was not an easy thing to do, and my failure to account for that in
my design haunted me for a bit.  In the end, what helped me get over it was looking at
what I did accomplish.  I know it sounds cliché, but in this case, it helped me get
a better perspective on the issue.  What I forgot to do was add support for line numbers
and column numbers. What I did not forget was to build a strong parser that has over
800 test cases that it is passing without fail.  That parser also has a simple
translation layer that can be plugged in to the parser to generate GFM specification
compliant HTML code.  Accomplishing those two feats was not easy.&lt;/p&gt;
&lt;p&gt;On top of accomplishing those two feats was another, more obvious one.  I started in
2019 November with an idea of writing a Markdown linter in Python.  With the three
initial rules that I had just created, I proved to myself that I had made the right
choice in selecting to build a parser for Markdown.  The successful rules just proved
that.  The third feat was writing a parser-based linter for Markdown in Python.&lt;/p&gt;
&lt;p&gt;Yeah, I still feel a bit like a fool for missing something that was obvious, but with
those things in my head, it became easier to let it go.  Instead of focusing on the 1%
that was that design flaw, I made sure to refocus myself on the 99% of the project that
was not a design flaw… and moved forward.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed the first set of rules, I decided that it was more important for me
to keep my momentum in creating new rules than to add line numbers and column numbers
to the parser.  Truth be told, I thought that getting some distance from that problem
would help me so it more clearly.  With both reasons in place, I started work on
the next group of heading based rules.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:cheatSheet"&gt;
&lt;p&gt;To avoid the same issue with “cheat sheet” versus “cheatsheet”, &lt;a href="https://www.dictionary.com/browse/cheat-sheet?s=t"&gt;dictionary.com&lt;/a&gt; says the correct answer is “cheat sheet”. &lt;a class="footnote-backref" href="#fnref:cheatSheet" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:here"&gt;
&lt;p&gt;It was not until the writing of this article that I formally decided to go with heading over header.  There is now an item in my backlog to make this change throughout the source code. &lt;a class="footnote-backref" href="#fnref:here" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter rules"></category></entry><entry><title>Markdown Linter - Core - Pre-Rule Improvements</title><link href="https://jackdewinter.github.io/2020/05/04/markdown-linter-core-pre-rule-improvements/" rel="alternate"></link><published>2020-05-04T00:00:00-07:00</published><updated>2020-05-04T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-05-04:/2020/05/04/markdown-linter-core-pre-rule-improvements/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Way back in 2019 November, I started this project with a bare-bones framework using a
simple dynamic plugin loader.  It was a simple proof of concept to determine whether I
could create the basis for an extensible linter framework in Python.  Once I verified
that I could write that …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Way back in 2019 November, I started this project with a bare-bones framework using a
simple dynamic plugin loader.  It was a simple proof of concept to determine whether I
could create the basis for an extensible linter framework in Python.  Once I verified
that I could write that framework, I implemented a very simple case to test against:
checking to make sure the provided Markdown text ends with an empty line.  While that
rule was easy to implement, it was when I looked for another rule to implement that
I determined that to properly lint Markdown text, I needed a Markdown tokenizing
parser.  From my viewpoint, unless I had a parser that
emitted tokens that were a good representation of the Markdown to lint, the linting
rules that I wanted to write would require too much guess work for my own liking.  If I
wanted to write good, solid rules, I needed to have the right information
available for those rules to act upon.  I needed a Markdown parser that emits Markdown
tokens that I had confidence would be the required, correct information for the rules.&lt;/p&gt;
&lt;p&gt;Having now written such a parser against the
&lt;a href="https://github.github.com/gfm/"&gt;Github Flavored Markdown specification&lt;/a&gt;,
it was time to move on to the next part of the project: writing rules.  However, since
almost 5 months had passed since the project started, there were a few changes
that were required in the linter’s core before I could continue.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/51bb1cf945ad5171bd1c41829a48beceb95a3ab0"&gt;12 April 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c8ee25446a425cabf9886b65ad1d4922949bbf44"&gt;16 April 2020&lt;/a&gt;, and the commit from
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/562600457654234aa7cabefa8e2a6b56665d936c"&gt;18 April 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="source-providers"&gt;Source Providers&lt;a class="headerlink" href="#source-providers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my experience, following the
&lt;a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)"&gt;threefold rule for refactoring&lt;/a&gt;
is usually a good idea, as its wisdom has borne out true in my projects many times.
While not a
literal copy of the threefold rule, I choose to remember the rule as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Write it once, write it neat.  Write it twice, think about extracting it.  Write it three times, extract it without a second thought.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The original text of “three strikes and you refactor” always seemed a little too harsh
for me with its negative connotation. In addition, I feel that it does not provide good
enough guidance on what to do in the first two cases, just the third one.  My
version of the rule still adheres to the spirit of the original rule, while
fixing the specific issues that I perceive with it.&lt;/p&gt;
&lt;p&gt;Source providers for the parser are a concept that fits that refactoring pattern very
well.  When the
original framework for the parser was written, it was designed to parse a line at a
time to conserve memory.  In the parser tests, this information is provided to the
&lt;code&gt;TokenizedMarkdown&lt;/code&gt; class as a single string, with the internal functions of the
&lt;code&gt;TokenizedMarkdown&lt;/code&gt; class breaking down that data
into individual lines for further processing. With the exception of a single
feature’s error case&lt;sup id="fnref:linkReferenceDefinitionError"&gt;&lt;a class="footnote-ref" href="#fn:linkReferenceDefinitionError"&gt;1&lt;/a&gt;&lt;/sup&gt;, this design has proven to be very
useful in reducing the complexity of the parser.
It made sense to me to refactor this section of code when considering how to
add support for the second source of Markdown data: Markdown files.&lt;/p&gt;
&lt;h3 id="starting-with-the-inmemorysourceprovider"&gt;Starting with the InMemorySourceProvider&lt;a class="headerlink" href="#starting-with-the-inmemorysourceprovider" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now that the project was moving into the rule-development phase, it was necessary to
ensure that it was just as easy to feed the parser information from a string as it was
to feed it information from a file.  As the initial development
kept things neat, it was relatively simple to take the logic for grabbing the next line
and encapsulate it within the &lt;code&gt;InMemorySourceProvider&lt;/code&gt; class as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InMemorySourceProvider&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Class to provide for a source provider that is totally within memory.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;source_text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_next_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Get the next line from the source provider.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="n"&gt;token_to_use&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;token_to_use&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;
                &lt;span class="n"&gt;token_to_use&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;token_to_use&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This class contains very simple logic.  When the instance of the class is initialized,
it starts by breaking down the input text into a tuple.  The first element of the
resultant tuple contains the next line to be parsed and the second element of that same
tuple contains the input text to be parsed in the immediate future.  Once that
calculation has been performed, the rest of the processing is relatively simple.
If &lt;code&gt;get_next_line&lt;/code&gt; is called and the tuple contains 2 elements, the first element is
returned as the next line, and the &lt;code&gt;next_token&lt;/code&gt; variable (for next time) is
recalculated using the same expression as was used in the &lt;code&gt;__init__&lt;/code&gt; function.
When the &lt;code&gt;get_next_line&lt;/code&gt; is called at the end of the file, the tuple contains only 1
element.  At that point, that singular element is returned as the next line to be
parsed, and
the &lt;code&gt;next_token&lt;/code&gt; variable is set to &lt;code&gt;None&lt;/code&gt; to make sure we end the processing
properly.  Finally, when &lt;code&gt;get_next_line&lt;/code&gt; is called and the tuple is set to &lt;code&gt;None&lt;/code&gt;,
there is nothing left to parse and &lt;code&gt;None&lt;/code&gt; is returned, signaling that the provider has
reached the end of its available text.&lt;/p&gt;
&lt;p&gt;To be clear, this is the exact code that was in place for the duration of the parser
testing, just repackaged to be in a more reusable form.  Its interface is plain and
simple: it either returns the next line as a string, or it
returns a &lt;code&gt;None&lt;/code&gt; object if there are no more lines.  Nothing fancy as a class either,
just a simple interface: one function to create the instance and get it setup, and one
function to read the next line.&lt;/p&gt;
&lt;h3 id="continuing-with-the-filesourceprovider"&gt;Continuing with the FileSourceProvider&lt;a class="headerlink" href="#continuing-with-the-filesourceprovider" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;By keeping things simple, creating the class &lt;code&gt;FileSourceProvider&lt;/code&gt; was almost as simple
as the refactoring to create the &lt;code&gt;InMemorySourceProvider&lt;/code&gt; class.  While I want to keep
options open for future performance experimentation, I just needed something simple
for reading a file from the file system.  Based on those qualifications, I came up with
this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FileSourceProvider&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Class to provide for a source provider that is on media as a file.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file_to_open&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file_to_open&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"utf-8"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;file_to_parse&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;file_as_lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;file_to_parse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readlines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;did_line_end_in_newline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;next_line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;file_as_lines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;did_line_end_in_newline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;did_line_end_in_newline&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;next_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_lines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;did_line_end_in_newline&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_lines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, open the file, read in the lines, and process the lines into the format
that we expect.  The only tricky bit with the class’s &lt;code&gt;__init__&lt;/code&gt; function was handling
line terminators properly.  In fact, that is the only
purpose for the &lt;code&gt;did_line_end_in_newline&lt;/code&gt; variable, remembering if the current line
ended with a newline character before it is removed.  Based on independent unit testing
of the class, I had problems with the characters at the end of the file, which adding
that variable and the final &lt;code&gt;if&lt;/code&gt; statement resolved cleanly.  I am not sure if I feel
that the &lt;code&gt;did_line_end_in_newline&lt;/code&gt; variable is a kludge or not, but I do feel that it
was the right thing to do in order to maintain the fidelity of the data being read in
from the file.&lt;/p&gt;
&lt;p&gt;Because care was taken in the provider’s &lt;code&gt;__init__&lt;/code&gt; function to do all the necessary
processing, the &lt;code&gt;get_next_line&lt;/code&gt; function is very basic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_next_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Get the next line from the source provider.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="n"&gt;token_to_use&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_lines&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;token_to_use&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_lines&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;token_to_use&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this function could be more complicated (or simplified depending on your
viewpoint), I feel that this is a good example of keeping things basic.  The provider
reads the information into an array of strings during the &lt;code&gt;__init__&lt;/code&gt; function, and this
function simply uses an index to iterate through and return each element of that
array.  Nothing fancy for now, just some code that
is very functional.  Fancy code can always be added later.&lt;/p&gt;
&lt;h3 id="testing-the-source-providers"&gt;Testing the Source Providers&lt;a class="headerlink" href="#testing-the-source-providers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To make sure both providers are adhering to the interface in the same way, I
added a decent number of tests in the &lt;code&gt;test_source_providers.py&lt;/code&gt; file.  In all the
tests, the big thing that is being tested is if the source providers return the correct
lines given the correct input.  If there are 2 line terminators in the input, each
provider must return 3 lines, even if the last one is empty.  Every test is a variation
on that, thoroughly exercising each provider to ensure that both adhere to the
interface flawlessly.  After all, if the parser gets bad input to tokenize, it cannot
help but to produce bad output, even if is only off by a line terminator.&lt;/p&gt;
&lt;h2 id="replacing-print-with-log"&gt;Replacing Print with Log&lt;a class="headerlink" href="#replacing-print-with-log" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This improvement was a long time coming: replacing all of the &lt;code&gt;print&lt;/code&gt; statements in the
parser with &lt;code&gt;log.debug&lt;/code&gt; statements.  When I was developing the parser, adding a simple
Python &lt;code&gt;print&lt;/code&gt; statement was the easiest way to add extra debug to the output of the
tests.  This information was pivotal in my ability to debug the parser and quickly
add new features to the parser with confidence.  And in the cases where there were
problems with those features, those same &lt;code&gt;print&lt;/code&gt; statements were also pivotal in
helping me ensure the flow of each function was as I had designed it.&lt;/p&gt;
&lt;p&gt;Why did I avoid using &lt;code&gt;log.debug&lt;/code&gt; statements from the beginning of development, and
instead use &lt;code&gt;print&lt;/code&gt; statements?  I am honestly not sure.  I do recall an early
experiment in which I used both types of statements, to see which one worked better for
me.  I remember the experiment, I remember choosing &lt;code&gt;print&lt;/code&gt; statements, but I cannot
remember why I chose them, knowing I would have to replace them later. I even checked
my notes from back then, and nothing about logging vs print.  Interesting.&lt;/p&gt;
&lt;p&gt;Regardless of why I did it, the time to fix it was now.  It was a mostly painless
transition and didn’t take that long to accomplish.  To the start of most files, I
added the following import:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and at the start of many blocks of processing, I added the following line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;logger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getLogger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, for each time I called the print function, like this example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Line:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I replaced it with the exact same arguments, just changing the name of the called
function from &lt;code&gt;print&lt;/code&gt; to &lt;code&gt;logger.debug&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Line:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After the initial changes to replace &lt;code&gt;print&lt;/code&gt; with &lt;code&gt;log.debug&lt;/code&gt;, everything looked okay
until I ran the normal &lt;code&gt;clean&lt;/code&gt; script that I use with the project.  This script is a
simple script to execute the
&lt;a href="https://pypi.org/project/black/"&gt;black&lt;/a&gt;
code formatter, the
&lt;a href="https://pypi.org/project/flake8/"&gt;Flake8&lt;/a&gt;
and
&lt;a href="https://www.pylint.org/"&gt;PyLint&lt;/a&gt;
linters, and the full set of tests for the project.  When the script got to PyLint,
it seemed to go crazy and was emitting lots or warning lines, each line essentially
being the same.&lt;/p&gt;
&lt;p&gt;Reading the warnings carefully and looking at the source code, PyLint seemed to be
complaining about each logging function call that
involved concatenation.  In each case where I was concatenating strings to arrive at
what I wanted to log, PyLint raised a warning that I wasn’t doing it right.  According
to PyLint, the proper way to log a message for the above example is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Line:&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;:"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Doing a bit more research, the reason for the warning is because the logging library
was purposefully created to be lazy.  If the log level for a given call is not high
enough to cause the string to be logged, doing any kind of formatting or concatenation
on that string is wasted effort.  Following that logic, the logger follows the same
conventions that are used with the percent character (&lt;code&gt;%&lt;/code&gt;) as the
&lt;a href="https://docs.python.org/3/library/stdtypes.html?highlight=interpolation#printf-style-string-formatting"&gt;string interpolation operator&lt;/a&gt;,
delaying the evaluation of the actual string until the logger determines
whether the specified string is actually going to be logged.  Once a positive
determination has been made, the format and the arguments are applied to each other,
a resolved string is produced, and that string that is then logged.&lt;/p&gt;
&lt;p&gt;It took a while to go through each of those messages. I had to examine each
concatenation sequence, break it down into its component parts, and verify my changes.
Each string that was concatenated needed to be represented in either the format string
or the arguments passed to the logger.  It was slow and pedantic work, but in the end,
I was happy to have a logging solution that was more performant than before.&lt;/p&gt;
&lt;h3 id="side-note"&gt;Side Note&lt;a class="headerlink" href="#side-note" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Note that as a Python logging newbie, I am not 100% sure if I created more work for
myself by
frequently creating logging instances inside of the project’s static functions.  It is
possible that I can get away with a static logger variable created in the module’s
namespace at the top of the file, and not worry about creating any other loggers within
the same file.
However, in all the examples I have seen to date, the logger is
either declared at the top of a simple file or within the &lt;code&gt;__init__&lt;/code&gt; method of a
class.  As a lot of the helper classes are a collection of functions that are labelled
with the &lt;code&gt;@staticmethod&lt;/code&gt; annotation, I am not sure if one instance at the top of the
file is the correct way to go.  While
it might be more effort than I really need, I am confident that I am covering all
the logging situations properly.  If I learn something differently about logging, I
will come back and revisit it.&lt;/p&gt;
&lt;h2 id="better-error-reporting"&gt;Better Error Reporting&lt;a class="headerlink" href="#better-error-reporting" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I initially proofed out the plugin architecture for the linter, I added a
&lt;code&gt;BadPluginError&lt;/code&gt; class to help identify plugin issues and report them back to the
command line.  Using this same pattern to integrate error handling for the parser to
the linter, I added the &lt;code&gt;BadParsingError&lt;/code&gt; class, raising this error when there were
exceptions raised during the parser’s tokenization of the Markdown text.  A bit more
typing and a short while later, I had the &lt;code&gt;__handle_error&lt;/code&gt; function with refactored
content.  This newly minted function reused the error handling meant for the
&lt;code&gt;BadPluginError&lt;/code&gt; class to handle both the &lt;code&gt;BadPluginError&lt;/code&gt; class and the
&lt;code&gt;BadParsingError&lt;/code&gt; class in the same manner.&lt;/p&gt;
&lt;p&gt;With that tweak done, I had confidence that the error reporting was done, and I wouldn’t
need anything more serious until far later in the project. That is what I foolishly
thought until about 2 days later. After doing some work on implementing the first two
rules, I realized that some things needed to be fixed with error reporting.&lt;/p&gt;
&lt;p&gt;The first change I made was to change the name of the error class from &lt;code&gt;BadParsingError&lt;/code&gt;
to &lt;code&gt;BadTokenizationError&lt;/code&gt; to reflect the problem area more accurately.  While it is
more of a mouthful to say, it accurately describes that it is a problem with the
tokenization of the document, not a generic “parsing” issue. A good example of this is
when the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class is created.  Upon creation, one of the things
that it does is load the &lt;code&gt;entities.json&lt;/code&gt; file from the resources directory, as detailed
in
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/#character-references"&gt;this article&lt;/a&gt;.
If that resource file is not
loaded properly, that code was changed to raise a &lt;code&gt;BadTokenizationError&lt;/code&gt; instead of
what it was previously doing.  Without this file, parsing the Markdown text would still
be possible without any issues.  But to properly tokenize the Markdown text, the parser
needs to know if the named character entities that are provided in the Markdown
document refer to valid named entities.  It may
appear to be a semantic difference to some, but in my experience, it is the attention
to detail on little things like that which help improve the project’s maintainability.&lt;/p&gt;
&lt;p&gt;In addressing the above case, I stumbled into the second issue: too many exit
points.
While it does not show it in the commit for the &lt;code&gt;BadTokenizationError&lt;/code&gt; fix documented
in the paragraph above, the first pass at addressing that issue was messy. It caught
any raised error, did some bare bones reporting, and then performed a &lt;code&gt;sys.exit(1)&lt;/code&gt; to
stop the program with an error code of 1.  Doing a quick search through the code, I
stopped counting once I hit the third instance of a &lt;code&gt;sys.exit(1)&lt;/code&gt; call in the code.
It was time for a refactor.&lt;/p&gt;
&lt;p&gt;Beginning with the initial case that started the search, I took a quick look at the
various search results and came up with a good rubric to follow.  If possible,
I would try and more correctly classify the error using one of the two existing error
classes, &lt;code&gt;BadTokenizationError&lt;/code&gt; or &lt;code&gt;BadPluginError&lt;/code&gt;, which were already handled at the
top level by the &lt;code&gt;__handle_error&lt;/code&gt; function.  If the error occurred in the
&lt;code&gt;main.py&lt;/code&gt; file and didn’t fall into either of those categories, I would call the
&lt;code&gt;__handle_error&lt;/code&gt; function directly, striving to give a clean and concise message on
what that error was and why it occurred.  If I encountered any errors outside of those
parameters, I would save them for last and re-evaluate my rules.&lt;/p&gt;
&lt;p&gt;Based on what I found in the project, the first two rules were enough, as I did
not find an error that could not neatly fit into one of those two categories.
Instead of a few different ways of exiting the linter with an error condition,
&lt;code&gt;__handle_error&lt;/code&gt; was now the sole conduit for exiting with an error.  I went over the
tests in the &lt;code&gt;test_main.py&lt;/code&gt;,
&lt;code&gt;test_plugin_manager.py&lt;/code&gt; and &lt;code&gt;test_markdown_entity_and_numeric_character_references.py&lt;/code&gt;
files to make sure everything looked consistent, and things were good!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I have mentioned in previous articles, I like refactoring, and this stretch of
refactoring was no
exception.  Each of these tasks were little tasks, but I felt better knowing that they
were addressed before I shifted my focus to writing the rules for the linter.  The
change to using source providers would be pivotal in dealing with test sources (strings)
and live sources (files) as sibling concepts. Replacing &lt;code&gt;print&lt;/code&gt; with &lt;code&gt;log.debug&lt;/code&gt; was
also pivotal to using live sources, keeping the ability to debug what was going
on for experienced users, but not flooding a casual user with all of that information.
Finally, getting
all of the error reporting to go through one conduit just seems cleaner and more
concise to me.  Getting these taken care of just felt like the right refactoring to
do at the right time.&lt;/p&gt;
&lt;p&gt;I also realized that I enjoy the cadence I have established with refactoring.  While
there are
short bursts where it is just adding new features, for the most part I have tried to
switch off between refactoring and adding new features.  I feel that for my development
style, I have found a good balance between fixing things and adding things, even if it
needs tweaking every so often.  Perhaps it is because of that sense of balance that I
have been able to focus on this project for so long without losing energy on it.
For me, I believe it boils down to a feeling that this project is not about adding
features as much as it is about continual improvement of the project towards its goal,
taking my time to do things right as I go.&lt;/p&gt;
&lt;p&gt;Looking forward, I am sure I am not done adding features, refactoring code,
or learning something new and interesting.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a bit of a jump back in time a couple of days from where I am leaving off,
in the next article I am going to start talking about the rules that I am developing,
and how their development proceeded.  Please stay tuned!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:linkReferenceDefinitionError"&gt;
&lt;p&gt;Due to link reference definitions being a multiline element, some of the error cases required the parser to be rewritten to handle lines that need to be “rewound”, as documented in &lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#hitting-implementation-issues"&gt;this previous article&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:linkReferenceDefinitionError" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Splitting Up The Articles</title><link href="https://jackdewinter.github.io/2020/05/03/markdown-linter-splitting-up-the-articles/" rel="alternate"></link><published>2020-05-03T00:00:00-07:00</published><updated>2020-05-03T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-05-03:/2020/05/03/markdown-linter-splitting-up-the-articles/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Wow!  Getting to this point in the parser took a good amount of time, but in my head,
I didn’t expect it to create 17 articles!  Looking back at what I wanted to achieve by
writing about the linter as I develop it, it makes sense to me …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Wow!  Getting to this point in the parser took a good amount of time, but in my head,
I didn’t expect it to create 17 articles!  Looking back at what I wanted to achieve by
writing about the linter as I develop it, it makes sense to me, and I am not sorry that
I wrote any of the articles.&lt;/p&gt;
&lt;p&gt;However, that does leave me with a bit of a problem.  This is article 18 in a series on
writing a linter, and I have not really done any serious work on the linter yet.&lt;/p&gt;
&lt;h2 id="splitting-up-the-articles"&gt;Splitting Up the Articles&lt;a class="headerlink" href="#splitting-up-the-articles" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While going back and changing the names of the articles to “Markdown Tokenizer…” was
attractive, thinking about it made me feel like I would be lying to any readers.&lt;/p&gt;
&lt;p&gt;In the end, the best option that emerged was to use this article as a jumping off point
for the other aspects of the project.  Basically, a jump page.  While not glamorous,
it is honest, and follows
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#changing-the-narrative"&gt;one of the things&lt;/a&gt;
that I am trying to inspire: “Stuff happens, pick yourself up, dust yourself off, and
figure out what to do next.”&lt;/p&gt;
&lt;h2 id="jump-links-for-the-linter-project"&gt;Jump Links For the Linter Project&lt;a class="headerlink" href="#jump-links-for-the-linter-project" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here are the various directions that I have gone in documenting the further development
on the project.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://jackdewinter.github.io/tags#markdown-linter-ref"&gt;Chronological&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jackdewinter.github.io/tags#core-linter-ref"&gt;Core Linter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jackdewinter.github.io/tags#linter-tokenizer-ref"&gt;Linter Tokenizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jackdewinter.github.io/tags#linter-rules-ref"&gt;Linter Rules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="pymarkdown"></category></entry><entry><title>Markdown Linter - Reducing the Parser's Technical Debt</title><link href="https://jackdewinter.github.io/2020/04/27/markdown-linter-reducing-the-parsers-technical-debt/" rel="alternate"></link><published>2020-04-27T00:00:00-07:00</published><updated>2020-04-27T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-04-27:/2020/04/27/markdown-linter-reducing-the-parsers-technical-debt/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First off, despite what I said at the end of the
&lt;a href="https://jackdewinter.github.io/2020/04/27/markdown-linter-reducing-the-parsers-technical-debt/#what-is-next"&gt;last article&lt;/a&gt;,
no, I am not going to call this “Refactoring: The Sequel”… even if that would be a
cool name.  From my point of view, refactoring is anything involving getting rid of
technical debt, usually increasing the …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First off, despite what I said at the end of the
&lt;a href="https://jackdewinter.github.io/2020/04/27/markdown-linter-reducing-the-parsers-technical-debt/#what-is-next"&gt;last article&lt;/a&gt;,
no, I am not going to call this “Refactoring: The Sequel”… even if that would be a
cool name.  From my point of view, refactoring is anything involving getting rid of
technical debt, usually increasing the correctness, readability, or maintainability of
a project.  This can be as simple as writing clear and concise documentation, or a
more difficult task involving the rewriting of project code.  If a task moves
the project in a positive direction while not adding a new feature to the project, I
believe that that task falls under the category of refactoring.  It is a simple
definition, but it has served me well.&lt;/p&gt;
&lt;p&gt;Since this project has been ongoing since 22 Nov 2019, there have been a decent number
of issues that have been added to the parser’s debt list, and a decent number
of issues removed from that same list due to informal “refactor weeks” that I had.
Most of the issues that I added to that list had a very specific reason that I decided
to put them on the list instead of handling that issue right there. But as I am
only human, there were probably a few times where it was just easier to deal with it
later.  Regardless of how each issue was added to the list of debt, I wanted
to try and make a decent size dent to the pile of parser’s debt before
closing out the main development effort on it.  As my goal is to give better
perspective on what I am doing and why, I thought an article just focusing on these
items would be informative to anyone that has been following the project
so far.&lt;/p&gt;
&lt;p&gt;Just to keep everything above board, I am not going to talk about every individual
commit between the two commit points noted in the next section, just the interesting
ones.  In that uninteresting category are some changes to get ready for future
features, some changes to fix cut-and-paste issues from past changes, and some changes
to correct something that I forgot to do.  While they are necessary, they are not
interesting.  They just prove I am human and make mistakes just like everyone else.&lt;/p&gt;
&lt;p&gt;And like everyone else, I sometimes put things off until later.  But at some point,
the bill is due.  For me, it was now that I wanted to pay some of that bill off.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/e638e0bd6bc069ad17f9d22b3473e639c8caaa01"&gt;05 April 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/3b2025a01c436a810d1b084ab6bf38fd83a627d1"&gt;11 April 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="refactor-1-matching-commonmark-character-encoding"&gt;Refactor 1: Matching CommonMark Character Encoding&lt;a class="headerlink" href="#refactor-1-matching-commonmark-character-encoding" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The issue that was the parent of this one was an interesting issue to find, and this
issue was generated to perform the cleanup for that issue.  The HTML output for the
examples in the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
are generated by processing the Markdown text examples through
&lt;a href="https://commonmark.org/"&gt;CommonMark&lt;/a&gt;,
mainly because CommonMark is considered the reference implementation for the
specification.  In each of the following scenario tests, the parser’s output for the
&lt;code&gt;href&lt;/code&gt; attribute in each link was arguably correct, but the output did not match the
output in the examples.  To resolve this issue and ensure that the scenario tests
passed, I needed to fix the link functionality in the parser so that it encodes the
right characters according to CommonMark’s “right way” to ensure the parser passed
the tests.&lt;/p&gt;
&lt;p&gt;It would have been easy if the encoding misses were all the same thing, but they
were not.  In the &lt;code&gt;href&lt;/code&gt; attribute for
&lt;a href="https://github.github.com/gfm/#example-603"&gt;example 603&lt;/a&gt;,
the ampersand character &lt;code&gt;&amp;amp;&lt;/code&gt; is replaced with the string &lt;code&gt;&amp;amp;amp;&lt;/code&gt;.  In
&lt;a href="https://github.github.com/gfm/#example-510"&gt;example 510&lt;/a&gt;, the &lt;code&gt;\&lt;/code&gt; is replaced by the
string &lt;code&gt;%5C&lt;/code&gt;.  However, in
&lt;a href="https://github.github.com/gfm/#example-509"&gt;example 509&lt;/a&gt;,
the &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;#&lt;/code&gt; characters are both left alone, and not specially encoded.  Just
small differences in how the characters were represented, and each one a bit different.&lt;/p&gt;
&lt;p&gt;To be clear, the main goal of resolving the original issue with those tests was not to
figure out what the “actual right way” of encoding the &lt;code&gt;href&lt;/code&gt; attribute was, but to
match what CommonMark was doing.  Specifically, I wanted to make sure I have a solid
starting point for matching my parser against others, and CommonMark seemed a better
candidate than others.  After all, they published a specification on what they expect
from the CommonMark parser in the GFM specification.  But as the above cases only
caught a small number of issues in 3 tests, I determined that I needed to figure out
what the proper set of ASCII character encodings are for CommonMark.&lt;/p&gt;
&lt;p&gt;To properly figure out what CommonMark encodes and does not encode, I added in the tests
in the &lt;code&gt;test_markdown_extra.py&lt;/code&gt; file that specifies, in sequence, each of the possible
characters after the &lt;code&gt;space&lt;/code&gt; character and before the &lt;code&gt;del&lt;/code&gt; character in the ASCII
table.  While I could have done something clever using the
&lt;a href="https://docs.python.org/3.7/library/string.html"&gt;Python string constants&lt;/a&gt;,
I wanted the test to be explicit about what it was testing.  After submitting the
newly generated Markdown sample to
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;Babelmark&lt;/a&gt;,
I copied Babelmark’s response for CommonMark back into the test as the response.
From there, I just kept on adjusting the encoding code until the HTML output matched
Babelmark’s output for CommonMark exactly.&lt;/p&gt;
&lt;p&gt;Did I have to do this? Not really.  Technically, I was already meeting the minimum
requirements by passing the scenario tests.  However, I just felt that it was better to
do the thorough job than to leave it to chance.&lt;/p&gt;
&lt;h2 id="refactor-2-more-fun-with-tabs"&gt;Refactor 2:  More Fun with Tabs&lt;a class="headerlink" href="#refactor-2-more-fun-with-tabs" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When people start developing code in any programming language, one of the first things
that they learn is that the tab character in most languages is a bad
idea.  After that, the religious conversations start about whether to replace a tab
character with 2 spaces or 4 spaces, but that is not something I want to go into.
Those kinds of conversations usually just devolve into
&lt;a href="https://en.wiktionary.org/wiki/bikeshedding"&gt;bike-shedding&lt;/a&gt;
within minutes.&lt;/p&gt;
&lt;p&gt;In the GPF specification, they avoid this conversation nicely by making it clear:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tabs in lines are not expanded to spaces. However, in contexts where whitespace helps to define block structure, tabs behave as if they were replaced by spaces with a tab stop of 4 characters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Good!  So tab characters have a width of 4 characters.&lt;sup id="fnref:holdIt"&gt;&lt;a class="footnote-ref" href="#fn:holdIt"&gt;1&lt;/a&gt;&lt;/sup&gt;  That sounds right.  I
then changed my &lt;code&gt;calculate_length&lt;/code&gt; function to count every tab character as 4
characters and every non-tab character as 1 character.  No problem. Then I went
back to fix
&lt;a href="https://github.github.com/gfm/#example-6"&gt;example 6&lt;/a&gt;
which was marked as skipped and
&lt;a href="https://github.github.com/gfm/#example-7"&gt;example 7&lt;/a&gt;
which was added incorrectly as a test.  Reading the preface for those tests:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Normally the &amp;gt; that begins a block quote may be followed optionally by a space, which is not considered part of the content. In the following case &amp;gt; is followed by a tab, which is treated as if it were expanded into three spaces. Since one of these spaces is considered part of the delimiter, foo is considered to be indented six spaces inside the block quote context, so we get an indented code block starting with two spaces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That statement did not sound right to me.  The math was wrong.  The block quote start
character is followed by 2 tab characters for a total count of 8 whitespace
characters.  Subtract
1 from that for the whitespace character following the block quote character and you
have 7, not 6.  I read the entire section on tabs about 4 or 5 times, being either
persistent or stubborn, depending on your point of view.  Then finally I keyed in on
the phrase “expanded into three spaces”.&lt;/p&gt;
&lt;p&gt;Something was wrong.  I rechecked my math using 3 spaces instead of 4 spaces for
that example, and it worked.  But it said at the top that tabs were the equivalent of 4
spaces, didn’t it?  Rereading the preface for Markdown tab characters, for what seemed
like the 10th time, it was then that I noticed it.  Not a tab width of 4 characters,
but a tab stop of 4 characters.
While it may seem like a simple difference, it is not.&lt;/p&gt;
&lt;p&gt;A tab stop of 4 means that if a tab character is encountered, the parser should consider
there to be spaces until reaching a column index that is a multiple of 4. In the above
example, the tab character was encountered after the block quote start character,
effectively at an index of 1 on that line.  That meant when the parser encountered the
tab character, it should be considered the same as 3 space characters, as it would take
adding 3 space character to get from the current position of 1 to the next tab stop at
index 4.&lt;/p&gt;
&lt;p&gt;While somewhat interesting, the impact of those changes was more interesting
to me.  The first impact was that I needed to rewrite the &lt;code&gt;calculate_length&lt;/code&gt; function to
expand tabs based on a possibly non-zero index starting point.  This wasn’t a really
big deal as it was a small function, but as the complexity increased enough to where
I was worried about properly calculating the length, I added the &lt;code&gt;test_calculate_length&lt;/code&gt;
module to properly test all of its cases.&lt;/p&gt;
&lt;p&gt;The second impact was on the block quote blocks and list blocks, both of which are
container blocks.  Before this change, the start position of an enclosed block inside
of a container block was not an issue.  With this change, to properly account for tabs
and tab stops, the parser needs to know the exact position on the line where the
current string started in case it contained tabs.  This proved to be complicated
enough that I spread it over 2 commits.&lt;/p&gt;
&lt;p&gt;In between, the third impact was discovered, the tokens for indented code blocks.  As
a bit of a shortcut, instead of grabbing the required whitespace from the
string being parsed, I simply used a string containing 4 space characters as the leading
whitespace for the code block.  I needed to change that to grabbing the correct
whitespace as the length of the tab character was now variable.&lt;/p&gt;
&lt;p&gt;In the end, 3 small examples, 1 tab character, 3 impacted areas, and a lot of grumbling
on my behalf.  But it got fixed… it just took a while.&lt;/p&gt;
&lt;h2 id="refactor-3-fenced-code-blocks"&gt;Refactor 3: Fenced Code Blocks&lt;a class="headerlink" href="#refactor-3-fenced-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In getting rid of some of the technical debt, there were a couple of issues with the
fenced code blocks that I really wanted to address: fenced code blocks inside of
block quotes and fenced code blocks with starting whitespace.&lt;/p&gt;
&lt;p&gt;The examination of the first issue, fenced code blocks inside of block quotes, started
off easy enough.  In
&lt;a href="https://github.github.com/gfm/#example-98"&gt;example 98&lt;/a&gt;,
which is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;aaa&lt;/span&gt;

&lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a fenced code block is started within the block quote.  As such, when the block quote
ends, the fenced code block is closed.  That part was already working fine.  However,
when the first and only line in the code block was extracted, it was extracted with 2
extra characters of whitespace in front of it, providing for a token representation of
&lt;code&gt;[text:aaa:  ]&lt;/code&gt; instead of &lt;code&gt;[text:aaa:]&lt;/code&gt;.  This in turn added the string &lt;code&gt;aaa&lt;/code&gt; to
the HTML document instead of &lt;code&gt;aaa&lt;/code&gt;, causing the scenario test to fail.&lt;/p&gt;
&lt;p&gt;This issue was easy to fix, making sure that the indent count was considered when
returning the remaining string in the fenced code block.  Along the way,
just to make sure things were parsing properly, I added 2 extra variants of example
98, one with an extra &lt;code&gt;&amp;gt;&lt;/code&gt; character at the start of the second line and one without any
&lt;code&gt;&amp;gt;&lt;/code&gt; at the start of the second line, just to make sure they were properly parsed.
Seeing as there was already one issue found in that area, I figured the extra tests
would not hurt.&lt;/p&gt;
&lt;p&gt;Following that quick find-and-fix, I moved on to
&lt;a href="https://github.github.com/gfm/#example-101"&gt;example 101&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-103"&gt;example 103&lt;/a&gt;
which also dealt with inconsistent spacing with fenced code blocks.  However, in the
case of these examples, it was an issue with properly handling the leading spaces before
the fenced code block start, code block content, and fenced code block end.&lt;/p&gt;
&lt;p&gt;In the case of example 101:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="o"&gt;```&lt;/span&gt;
 &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the fenced code block start sequence is preceded by a single space character, as is the
first line of the code block content.  The specification clearly states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the leading code fence is indented N spaces, then up to N spaces of indentation are removed from each line of the content (if present).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Looking at the source code, it was obvious to me that any indentation for the fenced
code block start was extracted and then immediately thrown out.  A quick change to
how the fenced code block was storing the information to include the indent count of
the fenced code block start, some other code to remove up to that many whitespace
characters from the start of any content lines, and it was done.  This was the same
for example 103, just with more of an additional indent, and the added concern of
having one of the lines have fewer indent characters than the fenced code block
start line.&lt;/p&gt;
&lt;p&gt;These two small issues only took a matter of hours before they were fixed,
but they were good fixes.  I am not sure why, but I felt that these issues were going
to be larger than they were and seeing them in my “to fix” list was causing
me a bit of stress.  Regardless of the effort required, it was good to get them
taking care of.  Sometimes you move the project in a positive direction in big steps,
and sometimes they are baby steps.  The important thing to remember is that they
are both moving the project in the right direction.&lt;/p&gt;
&lt;h2 id="refactor-4-html-blocks-inside-of-lists"&gt;Refactor 4: HTML Blocks inside of Lists&lt;a class="headerlink" href="#refactor-4-html-blocks-inside-of-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes I look at some code, and I get a feeling that it isn’t quite right. I often
cannot immediately point to something specific, but I just have a feeling that usually
turns
out to be accurate indicator of bad code. That was the case with
&lt;a href="https://github.github.com/gfm/#example-144"&gt;example 144&lt;/a&gt;.
Ignoring any previous statements that I have made about the use of HTML in Markdown,
I wanted to make sure that this example was being parsed properly.  In this example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;what should be created is a list with an item containing a single &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; HTML item and
another list item with the text &lt;code&gt;foo&lt;/code&gt;.  To be honest, I had to check the HTML and list
specifications a couple of times to find out which of them overruled the other.  As I
should have gathered, the list (a container block) has higher precedence than the
HTML block (a leaf block), so when the next list item within the list block starts, the
HTML block from the first item is automatically closed.&lt;/p&gt;
&lt;p&gt;It is probably because of my uncertainty with the specification regarding which block
had the higher precedence that I decided to add an extra test, &lt;code&gt;test_html_blocks_144a&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;

&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I realize it might seem like the extra paragraph is unwarranted, but I wanted to
make extra sure that everything was being unwound properly, including the list.  Whether
or not the extra test really adds anything, I’ll double check it later.  Even though
there was nothing wrong with this test, I still trust my previous experience with code.
I would rather double check some code and find nothing rather than not check and miss
something important.  But at the same time, it had me looking at the list block code,
which is how I started looking at the issues for the next section.&lt;/p&gt;
&lt;h2 id="refactor-5-more-fun-with-lists"&gt;Refactor 5: More Fun with Lists&lt;a class="headerlink" href="#refactor-5-more-fun-with-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned previously, I often get a feeling that a given set of code is not 100%
correct, and this time it was about lists, specifically sublists. While each of the
required scenario tests for sublists were passing, there was just this little voice in
my head saying that something did not feel right.  There was just something there that
inspired me to add an issue to my notes to check them out further, but not enough for
me to give anything more than a vague feeling.&lt;/p&gt;
&lt;p&gt;Unlike how things turned out in the previous section with HTML blocks, after I did
some digging in the code, I found that my feeling was correct!  Due to my digging,
I found several problems with sublists, specifically with indenting and switching
between sublists and other lists.  To debug these problems and to make sure they
stayed fixed, I introduced a total of 16 variations on existing, passing scenario
tests to properly address these issues.  I am still trying to figure out if these
issues are due to how I implemented the parser or if they are legitimate edge cases
for the specification.  Stay tuned for that!&lt;/p&gt;
&lt;p&gt;These issues fall into 2 categories: indenting and
switching list start sequences.  My examples will mostly deal with unordered lists, but
I added the same types of tests for both ordered and unordered lists.&lt;/p&gt;
&lt;p&gt;As a good example of what I looked for, consider
&lt;a href="https://github.github.com/gfm/#example-281"&gt;example 281&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looking at this Markdown, it should be obvious that it is a pair of unordered lists,
the first having two elements and the second having a single element. Playing around
with the structure a bit, I decided to keep all the list start characters the same but
changed the indent of the second list item to make it into a sublist.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And… boom!  The parser returned an unordered list that contained another list with
2 items in that sublist.  Thinking it was a fluke, I changed the last list start
character to the &lt;code&gt;+&lt;/code&gt; character:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And boom… again! The results were not as expected.  Working my way through many of
the examples of lists in the GFM specification, I found 16 variations of
simple changes to existing scenario tests that created sublists that were parsed
incorrectly.  If I worked them out on paper or by using Babelmark, the paper and
Babelmark results backed each other up, but the parser’s results were off.  I was
missing something important somewhere.  But where?&lt;/p&gt;
&lt;p&gt;Taking a bit of time to cool down, when I started looking at those examples and various
patterns of indentation, start character, and sublists emerged.  Adding some debug
code to aid in the diagnosis, I ran each of the newly added tests again.  After some
screaming at my monitor in frustration&lt;sup id="fnref:rubberDucking"&gt;&lt;a class="footnote-ref" href="#fn:rubberDucking"&gt;2&lt;/a&gt;&lt;/sup&gt;, I was rewarded with a common
thread that went across all of the tests: starting conditions.&lt;/p&gt;
&lt;p&gt;When I start a list in the parser, the most relevant information about the list start
is the starting index of the list and the start character.  For single level lists and
lists that are neat (that is all the sublists are indented the same amount), there
are no issues with this approach as everything lines up.  But when I started moving the
starting locations of the list items and the starting locations of the text within the
list items, that is when things fell apart.  The big issue was not with the parser
going down into the sublists, but in how it recovered when exiting from those
sublists, understanding which lists to take off the list stack on the way back out.&lt;/p&gt;
&lt;p&gt;With a large amount of grumbling on my part, I worked through each of the new scenario
tests and added code that not only remembered where the list item character was, but
where the text for that item started.  This allowed me to properly figure out where the
list itself started, allowing me to create better comparisons on whether or not a list
should be removed on the way out.  It wasn’t an easy experience, but one by one the
failing tests became passing tests as I worked through the various combinations
required to get it working properly.&lt;/p&gt;
&lt;p&gt;Sure, I grumbled a lot on this one.  But I was glad that I followed a feeling and did
some exploratory testing to put that feeling to rest, rather than dismiss it!  In
my experience, there are many times where you can look at code and instantly
know it is wrong and why it is wrong.  (And no, I am not talking about tabs, or line
spacing, or curly bracket positioning, or…)  However, the really interesting times
are when you have to trust your gut feeling and explore some scenarios, either to find
an issue or to be able to increase your confidence to where you do not have that
feeling anymore.&lt;/p&gt;
&lt;p&gt;Whether it is a “I can see that is wrong” bug or a “I feel like there is something
wrong there” feeling, both have a valid place in your arsenal for improving the
quality of the project.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The purpose of this dedicated session of refactoring was not to eliminate all
the parser’s technical debt, just make a good dent in it.  Based on that metric,
I feel good that I have reduced this debt a decent amount.  Furthermore,
I took some steps to reorganize the remaining items into more organized lists,
for further study.  After making some forward progress with other components of
the linter, I will inevitably come back to the list in a few weeks and try and deal
with a couple more of those items.&lt;/p&gt;
&lt;p&gt;Other than the logistics, I feel good about the parser.  There are a decent number of
issues documented in the list, 40 items in all, but a lot of them are either suggestions
for more complete testing or questions about whether something is possible or
desired.  Doing a quick scan of those items as I write this article, there are not any
open items that I am very worried about, just concerns and ideas that I want explored.
Basically, I have things that I want to deal with, but it is okay if they wait a bit.&lt;/p&gt;
&lt;p&gt;It is with mixed feelings that I move from writing the parser to writing the
rules that will take advantage of the parser.  I know that I am moving from having
conquered one challenge to starting another challenge, and I am okay with that.  On
one hand, that transition means that the hard work I have put into the parser will
pay off.  On the other hand, it means that I will be subjecting that same work to
more stringent tests as I go forward with the rules and the rest of the linter.&lt;/p&gt;
&lt;p&gt;In the end, I guess it boils down to two things.  I have confidence in the work I
have done to date with the parser, and if anything is missing or needs fixing, I
know I will be able to handle it.  I also know that the best way to show my confidence
in the project is to move ahead and write rules that rely on that parser.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I know the parser is not perfect, and it may never be, I know it is good enough
to base the rules on top of it.  As such, my next set of tasks involves making some
changes to how the parser interacts with the rest of the project code, to ensure
that it can handle a wide variety of requirements that I may throw at it!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:holdIt"&gt;
&lt;p&gt;Yes, I know. That does not sound right to me now either.  But at the time, I honestly thought it said a tab width of 4 characters.  Keep on reading. &lt;a class="footnote-backref" href="#fnref:holdIt" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:rubberDucking"&gt;
&lt;p&gt;While I don’t frequently use screaming at my monitor as a form of &lt;a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging"&gt;rubber duck debugging&lt;/a&gt;, it does have it’s benefits sometimes. &lt;a class="footnote-backref" href="#fnref:rubberDucking" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Adding Image Links and Simple Cleanup</title><link href="https://jackdewinter.github.io/2020/04/20/markdown-linter-adding-image-links-and-simple-cleanup/" rel="alternate"></link><published>2020-04-20T00:00:00-07:00</published><updated>2020-04-20T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-04-20:/2020/04/20/markdown-linter-adding-image-links-and-simple-cleanup/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While it just happened to be the feature that was last on the list, I feel that it was
kind of fitting that image links were the last feature to be added.  Whether or not an
author creates Markdown content for a blog, documentation, or some other purpose,
a …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While it just happened to be the feature that was last on the list, I feel that it was
kind of fitting that image links were the last feature to be added.  Whether or not an
author creates Markdown content for a blog, documentation, or some other purpose,
a simple image can often improve the readability of each of those forms of documents.
Imagine going to your favorite game blog or art blog and seeing very good descriptions
of the topic being blogged about, but no pictures.  It just makes sense to add images to
documents, where needed, to enhance that document’s ability to convey the message that
the author is delivering.&lt;/p&gt;
&lt;p&gt;From there, there are just a small number of cleanups that I want to do before going
on, so let’s go!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/517a0ecf5720016756670779a0bd058394797174"&gt;27 March 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/2b0baa443437b2fe538b4445b19244ae4e42b7b3"&gt;04 April 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="what-are-image-links"&gt;What Are Image Links?&lt;a class="headerlink" href="#what-are-image-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I have covered in previous articles, a simple inline link is constructed as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the corresponding reference link (and matching link reference definition) is
constructed as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;boo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;boo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;both producing the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In both examples, by changing the opening character sequence &lt;code&gt;[&lt;/code&gt; to the opening
character sequence &lt;code&gt;![&lt;/code&gt;, we transform the destination HTML into the following image
link:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Besides the different starting characters, the first difference is that instead of the
&lt;code&gt;a&lt;/code&gt; or anchor tag being produced, the &lt;code&gt;img&lt;/code&gt; or image tag is produced.  Due to that
change, the &lt;code&gt;href&lt;/code&gt; attribute is replaced with the &lt;code&gt;src&lt;/code&gt; attribute, the &lt;code&gt;title&lt;/code&gt;
attribute is left alone, and the inline text contained with the normal anchor link is
replaced with the &lt;code&gt;alt&lt;/code&gt; attribute text.&lt;/p&gt;
&lt;p&gt;The second difference is in the text that is assigned to the &lt;code&gt;alt&lt;/code&gt; attribute.  For
normal links, the link text or link label is interpreted as inline text and placed
between the &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;/a&amp;gt;&lt;/code&gt; tags.  As this text has been moved to the image tag’s
&lt;code&gt;alt&lt;/code&gt; attribute, a transformation must occur to ensure that only valid text is assigned
to the attribute.  While not strictly specified as a “MUST” in the specification, the
&lt;a href="https://github.github.com/gfm/#images"&gt;images section&lt;/a&gt; of the specification mentions:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Though this spec is concerned with parsing, not rendering, it is recommended that in rendering to HTML, only the plain string content of the image description be used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This transformation is on display with
&lt;a href="https://github.github.com/gfm/#example-581"&gt;example 581&lt;/a&gt; as the Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;train&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jpg&lt;/span&gt; &lt;span class="ss"&gt;"train &amp;amp; tracks"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is transformed into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"train.jpg"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"foo bar"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"train &amp;amp;amp; tracks"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the above example, the &lt;code&gt;*&lt;/code&gt; character indicating emphasis is removed from the string
&lt;code&gt;foo *bar*&lt;/code&gt;, leaving the attribute value &lt;code&gt;foo bar&lt;/code&gt; to be assigned to the &lt;code&gt;alt&lt;/code&gt;
attribute.  For other inline processing sequence, similar transformations are made to
ensure that the vital information is kept with the token.&lt;/p&gt;
&lt;p&gt;The final difference is a small change to the rule that links may not contain other
links.  This rule is changed so that links may not other links unless those links are
image links.  Consider &lt;a href="https://github.github.com/gfm/#example-525"&gt;example 525&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;![moon&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;moon&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jpg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is transformed into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"moon.jpg"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"moon"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this may not look useful, consider the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;![moon&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;thenounproject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2852&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;200.&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;search&lt;/span&gt;&lt;span class="vm"&gt;?&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;moon&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once transformed, that Markdown becomes the following image:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bing.com/search?q=the+moon"&gt;&lt;img alt="moon" src="https://static.thenounproject.com/png/2852-200.png"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That Markdown snippet produced an image tag within an anchor tag.  This presents the
reader with an image of a moon that may be clicked on.  When that image is clicked on,
the link that surrounds the image link is acted upon, navigating to the link supplied
in the outer link.  In this case, click on the image of the moon takes the reader to
the Bing search page, already primed with the search text for &lt;code&gt;the moon&lt;/code&gt;.  This
feature used often to present styled buttons to a user instead of simple text for them
to click on.  Personally, I think the right image to click on makes more of an
impact and having that ability available to Markdown authors is a plus.&lt;/p&gt;
&lt;h2 id="simple-cleanups"&gt;Simple Cleanups&lt;a class="headerlink" href="#simple-cleanups" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With image links done, what remained were the various cleanups that I wanted to do
before declaring the parser “done”.  While each of these cleanups required code to be
rewritten, my stated goal with these cleanups was not to fix bugs, but to get the
code base in a more maintainable shape before fixing those bugs.  It was my hope
that by doing things in this order, it would make any bug fixing that would occur in
the future easier to perform and easier to validate.  We will see how that worked out in
the next article!  For now, on to the cleanups!&lt;/p&gt;
&lt;h3 id="simple-cleanup-1-splitting-up-the-tokenizedmarkdown-class"&gt;Simple Cleanup 1: Splitting Up the TokenizedMarkdown Class&lt;a class="headerlink" href="#simple-cleanup-1-splitting-up-the-tokenizedmarkdown-class" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first cleanup on my list was to split up the
&lt;code&gt;TokenizedMarkdown&lt;/code&gt; class into more clearly defined classes.  While I could have done
this at an earlier stage of the
project, I wanted to take a different approach with this project.  While the
&lt;code&gt;ParserHelper&lt;/code&gt; and &lt;code&gt;HtmlHelper&lt;/code&gt; classes were required for the early stages of the
project, there were other possible groupings I
wondered about.  Basically, I wondered if I would make the same grouping decisions at
the end of the parser phase as I would have at the start of that same parser phase.
In short, I wanted to experiment.  More on the results of that experiment at the end
of this section!&lt;/p&gt;
&lt;p&gt;Going through the code and separating each grouping out was a chore, but a useful one.
The first
effort was to come up with the larger groupings.  Arriving at these groupings was a
simple task, as the
processing for the tokens is broken up into three sections: the functions for the
preliminary tokenization of the input were left in the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class;
the functions combining contiguous text blocks were moved into the &lt;code&gt;CoalesceProcessor&lt;/code&gt;
class; and the functions to handle inline processing were moved into the
&lt;code&gt;InlineProcessor&lt;/code&gt; class.  This was a major chore, but it reinforced the separation
between the various processors and classes in the process, so all was good!&lt;/p&gt;
&lt;p&gt;With those major regroupings undertaken, two of those three classes still contained huge
blocks of code, so it made sense to do further refinements along more
feature-based lines.  The &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class was my first target and was
broken down into the
&lt;code&gt;ContainerBlockProcessor&lt;/code&gt; class and the &lt;code&gt;LeafBlockProcessor&lt;/code&gt; class, which just seemed
like logical groups to extract from the main class.  From there, it similarly seemed
that the
&lt;code&gt;ContainerBlockProcessor&lt;/code&gt; class was still too large, so I further extracted the
&lt;code&gt;ListBlockProcessor&lt;/code&gt; class and the
&lt;code&gt;BlockQuoteProcessor&lt;/code&gt; class.  At this point, I felt more confident that the different
functions for tokenization were in solid, well-defined, well-sized groups.&lt;/p&gt;
&lt;p&gt;Similarly, the &lt;code&gt;InlineProcessor&lt;/code&gt; class was too large so I extracted functions into the
&lt;code&gt;EmphasisHelper&lt;/code&gt; class, the &lt;code&gt;LinkHelper&lt;/code&gt; class and the &lt;code&gt;InlineHelper&lt;/code&gt; class.  The main
brains of inline processing remained in &lt;code&gt;InlineProcessor&lt;/code&gt;, coordinating when to apply
inline processing to the various tokens that needed it.  To allow for special processing
to be handled properly, the coordination of the &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;![&lt;/code&gt;, and &lt;code&gt;]&lt;/code&gt; link strings, and the
&lt;code&gt;*&lt;/code&gt; and &lt;code&gt;_&lt;/code&gt; emphasis strings was also kept in the &lt;code&gt;InlineProcessor&lt;/code&gt; class, while the
actual processing of emphasis and link were moved to the &lt;code&gt;EmphasisHelper&lt;/code&gt; class and the
&lt;code&gt;LinkHelper&lt;/code&gt; class.  The remaining functions that implemented the less intensive
inline processing were added to the &lt;code&gt;InlineHelper&lt;/code&gt; class.  Like my observation
for the tokenization classes in the last paragraph, to me this just seemed to be
the right groupings for these functions.&lt;/p&gt;
&lt;p&gt;Comparing my choices against some notes I had scribbled down at the start of the
project, I found that I was decent at
projecting the larger strokes of the grouping, but really bad at my stab on the more
finer groups.  While the names are different than the ones I used, I was spot
on with the 3 high level processors: tokenizing, coalescing, and inline.  Furthermore,
when it comes to the specific classes for container blocks and leaf blocks, I had those
spot on.&lt;/p&gt;
&lt;p&gt;And it was there I stopped.  I had a couple of scribbles for emphasis being on its own
with a question mark beside it, but that was it. The rest of the scribbles were all
followed by question marks, including a guess that each leaf block and container block
should be in its own class.  If I had to guess as to why I thought that way, I would
wager that I thought I would need more code for the inline processing while using less
code than I anticipated for the block processing.
When those assumptions on code amounts changed, it caused me to look at the rest
of the code and extract more specific groups into the groups detailed above.&lt;/p&gt;
&lt;p&gt;The end results?  While I feel it was good to do a good high-level design of the
function groupings, I need to be prepared that those plans are going to need to be
revisited and redefined once I starting writing code.  But still, a useful experiment,
and the project’s code base was also more maintainable at the same time!&lt;/p&gt;
&lt;h3 id="simple-cleanup-2-reducing-complexity"&gt;Simple Cleanup 2: Reducing Complexity&lt;a class="headerlink" href="#simple-cleanup-2-reducing-complexity" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Up to this point in the development of the project, I was more intent on completing the
parser itself than to complete it with good organization and low complexity.  While
the simple reorganizations that I documented in the last section were a start, there
were three sets of complexity warnings that I disabled until later: the
&lt;code&gt;too-many-branches&lt;/code&gt; warning,
the &lt;code&gt;too-many-statements&lt;/code&gt; warning, and the &lt;code&gt;too-many-locals&lt;/code&gt; warning.  While none of
these affected the quality of the parsing, I knew that a result of disabling these
warnings was that I would have to start resolving them at the end of the main block of
parser development.  As that time had arrived, my bar tab was now due.&lt;/p&gt;
&lt;p&gt;For the most part, the resolution for all three warnings was the same: split the code
that the warning was complaining about into smaller, more focused functions.&lt;/p&gt;
&lt;p&gt;Too many branches?  From experience, I have only run into 2 or 3 cases where having a
method with more than 10 or 15 branches was the right thing to do.  Most of the time,
too many branches means you are doing too much in your function, and by splitting
up the functionality into multiple functions, you keep the number of branches down and
the comprehension on what each function does goes up.  It’s almost always a win-win.&lt;/p&gt;
&lt;p&gt;Too many statements?  Pretty much the same argument, but exchange statements for
branches.  Once again from experience, if you have a function that has more than 25-30
statements in it, it is hard for most people to truly understand what that function is
doing without a lot of comments.  Splitting the functionality across multiple
functions allows for those statements to be associated with named functions that
describes its purpose, instead of the reader trying to figure out “what does that
section do?”&lt;/p&gt;
&lt;p&gt;Too many locals?  This is a tricky one with parsers, so I left it for last.  In most
cases, what I described for branches and statements goes for locals.  Too many of them
gets in the way of a clear understanding of what a function does.  From personal
experience, when the number of locals in a function exceeds somewhere between 10 and 15
variables, I usually need good logging or a good debugger to really understand what
each of the values should be at any point in the function.  Under 10 and I am okay.&lt;/p&gt;
&lt;p&gt;But parsers? They are often the exception to the rule for a lot of things.  The amount
of state needed to properly parse something often causes a lot of locals and arguments
to be declared and passed around, many of them for temporary computations.  For
example, whenever a specification says “collect all X up to Y, except for”, it usually
means that one variable is needed for collecting, possibly one variable to report
errors, and the “except for” at the end most often means passing in some kind of state,
often from another part of the program.  Since parsers are more grammatically based
than other types of programs, their need to interface with these things called “users”
causes more variations that need to be dealt with than other types of programs.  At
least from my experience, that seems to be the case.&lt;/p&gt;
&lt;p&gt;For the most part, I managed to clean up all cases of the branch warnings and statement
warnings and tried to address the local warnings.  While I did not complete all of
them, I felt it was a solid effort to get the parser into a more maintainable shape.
And as with all the other cleanups documented here, I do believe that each one is
contributing to the health of the project.  And that is a good feeling in my books!&lt;/p&gt;
&lt;h3 id="simple-cleanup-3-pycharm-static-code-analysis"&gt;Simple Cleanup 3: PyCharm Static Code Analysis&lt;a class="headerlink" href="#simple-cleanup-3-pycharm-static-code-analysis" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I am authoring projects, I typically have a specific development environment or
editor for each language.  For my C# projects I use Visual Studio by
Microsoft, and for Java projects I use IntelliJ by JetBrains.  In both cases, these
editors are widely accepted as one of the best editors for that specific language.
While
Visual Studio can handle Python and JetBrains has a Python specific editor (PyCharm),
I find that I personally prefer a one language to one editor relationship.  As such,
I write most of my Python code in Visual Code.&lt;/p&gt;
&lt;p&gt;However, while I do not use either editor for development, I do find that PyCharm has
some usefulness in running static analysis passes on my Python projects.  From
experience, the hints that PyCharm provides make the cost of the manual use of it as a
Static Code Analysis tool worthwhile.  And as I
was finished with the bulk of the development on the parser part of the project, I
thought it was a good time to look at the project through that lens.&lt;/p&gt;
&lt;p&gt;One immediate benefit was that PyCharm has a very decent analysis engine, and it
gave me hints on how to improve the flow of my functions.  When none of
the other functions that use my function make use of the function’s &lt;code&gt;return&lt;/code&gt; value,
PyCharm told
me that it makes sense to remove the return value.  When arguments or variables were not
being used, PyCharm suggested that they should be removed. And when I got into the
bad habit of incrementing a value by using &lt;code&gt;a = a + 1&lt;/code&gt;, PyCharm pointed out that Python
also has the &lt;code&gt;+=&lt;/code&gt; operator and I should rewrite the previous snippet as &lt;code&gt;a += 1&lt;/code&gt;.
All in all, a lot of small, but useful improvements to clean up the project.&lt;/p&gt;
&lt;p&gt;While my manual usage of PyCharm does not replace the need for running Flake8 and
PyLint over the project before I commit any changes, I believe it offers me a fresh
view of the code base
and gives me hints on where it thinks I can do better. As an added bonus, with few
exceptions, the changes are minor, and the entire batch of changes can be applied
quickly.  Personally, I consider using PyCharm in this manner akin to asking a friend
to take a read over a
document that I have been working on before I submit it.  As such, it is not always
about making the changes that PyCharm suggests but thinking about those changes and
deciding if those changes are what is best for your project.&lt;/p&gt;
&lt;h3 id="simple-cleanp-4-pulling-strings-to-the-top"&gt;Simple Cleanp 4: Pulling Strings to The Top&lt;a class="headerlink" href="#simple-cleanp-4-pulling-strings-to-the-top" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I wanted to do this cleanup for a while, partially for code cleanliness reasons and
partially for performance reasons.  In writing the first iteration of the parser, I
knew that I was focusing on getting the parser complete and not always following best
practices.  One of those best practices that I use, especially for parsers, is to make
sure that strings that I know are going to be used over and over again are
pulled out of their functions/methods and defined once at the top of the class.  In the
hurry of wanting to get the parser done, I had not kept this practice up.  As such,
there were multiple instances where I had certain strings, such as the block quote
string &lt;code&gt;&amp;gt;&lt;/code&gt;, in multiple places, instead of one place.&lt;/p&gt;
&lt;p&gt;By aggregating these strings to the top of the modules where they were declared, I was
able to clean up the code and impact performance.  By moving the strings to the top
of the modules, it made it easier for me to see the strings and concepts
that were in each of the modules.  This also has a nice benefit of having a variable
name associated with the strings, allowing for easier searching through the project for
those concepts.  From a performance point of view, this also reduces the number of times
that string is declared within the module, using references to the module’s instance of
the string instead of creating a new instance every time that piece of code is executed.&lt;/p&gt;
&lt;p&gt;All in all, for both cleanliness and performance reasons, it was a good cleanup to do!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From a code completion point of view, I felt that I had done well.  Sure, there
are still 5 scenario tests that are disabled and a number of issues and bugs that I have
logged for further research. But other than that, it was finished.&lt;/p&gt;
&lt;p&gt;I am sure that some
of the issues are just clarifications that I need to prove are done right, and that
there are some real bugs that I am going to have to fix.  I am also sure that those
two lists are not going to be static and are going to interact with each other in some
way.  I am confident that while 1 of the disabled tests will require some interesting
thinking on my part (nested image links), the other 4 disabled tests will require some
serious changes to how I process lists.  But even with these in mind, I also have faith
that, due to the large number of scenario tests, that all of these issues will probably
only account for less than 2% of all of the scenarios I am ever going to run across,
and some of the more obscure scenarios to boot.  As such, I believe I can
take my time to address them when I have time, and not rush to solve them right away.&lt;/p&gt;
&lt;p&gt;From a code quality point of view, I was happy to have some time to do some clean up.
In their own way, each of the cleanups helped the health of the project.  The first
cleanup added better organization of the code, the second and third cleanups increased
the maintainability of the code, and the fourth cleanup added a bit of a performance
improvement.  Each of those cleanups moved the project to a happier place,
quality-wise, in their own way.  Big plus there for me!&lt;/p&gt;
&lt;p&gt;From a development point of view, getting to this point was indeed a milestone, but it
was with mixed feelings that I got
here.  With respect to the base parser, outside of some issues that I have previously
noted, it was complete.  Sure, I knew that I needed to fix those issues, but after 713
examples (with 5 examples skipped), it was done.  Along the way, I modified the existing
648 examples to add 70 new examples to properly test out the parser.  And sometimes it
was a hard journey to get those working.&lt;/p&gt;
&lt;p&gt;Not too complain… but I initially felt that my fun was over.  Could I write a parser
to properly parse Markdown into intermediate tokens? Yes. Would I be able to finish it
while keeping the code coverage and scenario coverage high? Yes. Would I then be able
to take those tokens and
not only use them to power rules, but to emit the specification’s HTML?  Yes.  For me,
determining whether I can complete challenges like that is fun, and having
arrived at the answer, I felt that a lot of the project’s fun was completed.&lt;/p&gt;
&lt;p&gt;But in thinking about that some more, I realized that while one part of the fun for
the project was over, it was up to me to decide whether I would still consider
the project fun.  As I largely equate challenges with fun, that means it is up to me to
find the challenges left in the project, and to overcome them.  Since this is my first
real project in Python, at the very least there should be challenges around releasing
it.  Basically, I just need to take a better look at the project to determine where the
challenges are.  It just took me thinking about what perspective I wanted to have.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I was anxious to get to writing rules, there were some things that needed to be
addressed with the parser before I could continue.  While I could have left them there
and dealt with them later, I wanted to take a good crack at the top items on the list
and deal with them now, before the rules were added.  So next article:
“Refactoring: The Sequel!”&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Adding Reference Links</title><link href="https://jackdewinter.github.io/2020/04/13/markdown-linter-adding-reference-links/" rel="alternate"></link><published>2020-04-13T00:00:00-07:00</published><updated>2020-04-13T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-04-13:/2020/04/13/markdown-linter-adding-reference-links/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The end of the main parser is in sight!  Two articles ago, the additional
of support for
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#why-inline-links"&gt;inline links&lt;/a&gt;
was documented, and the last article detailed the addition of support for
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;.
In terms of remaining work required to meet the GFM specification, only reference links
and …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The end of the main parser is in sight!  Two articles ago, the additional
of support for
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#why-inline-links"&gt;inline links&lt;/a&gt;
was documented, and the last article detailed the addition of support for
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;.
In terms of remaining work required to meet the GFM specification, only reference links
and image links are left.  As image links are just reference links with a slightly
different syntax and slightly different rules, it made sense to focus on reference
links first.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ed20bc4e38342b2c9e3fdebc691e2021c80c67b4"&gt;26 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="a-quick-aside"&gt;A Quick Aside&lt;a class="headerlink" href="#a-quick-aside" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I just wanted to take a moment to give some context on why I am providing many
examples in this article.  If it feels like I am providing a lot of “extra”
examples, that is because I initially had a few issues with the different link
types and their syntax.  For whatever reason, the different link types were just not
“clicking” inside of my head.  It was only after I started focusing equally on the rules
and the examples, that I was able to match the “abstract” text in the specification
with the “concrete” examples provided.  Together they provided the context that I
required to truly understand reference links.&lt;/p&gt;
&lt;p&gt;I hope that by providing good examples in this article, I am providing a similar amount
of clarity to help any readers who may encounter similar issues to what I encountered.&lt;/p&gt;
&lt;h2 id="what-are-shortcut-reference-links"&gt;What Are Shortcut Reference Links?&lt;a class="headerlink" href="#what-are-shortcut-reference-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the last article on
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;,
I briefly introduced a concept called a shortcut reference link.  As that article was
focusing on link reference definitions and not reference links, I introduced it only
to show what link reference definitions were capable of
doing.  A good example of this is the following Markdown where the link reference
definition is specified on the first line and the shortcut reference link that utilizes
that definition is specified on the third line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Shortcut reference links like this are the easiest of the three reference link types to
understand as everything is kept simple.  As with all types of reference links,
shortcut reference links are taken care of in the inline processing stage, long after
any link reference definitions have been collected.
To use a link reference definition, the
normalized version of the link label from the shortcut reference link must match a
link label from a previously defined link reference definition.&lt;sup id="fnref:before"&gt;&lt;a class="footnote-ref" href="#fn:before"&gt;1&lt;/a&gt;&lt;/sup&gt;  To keep
things simple for now, I am going to assign
words like “normalized” to mean a case-insensitive comparison between two strings,
with no other modifications. While this is not completely accurate, it will help keep
things simple for now, and I promise to revisit it before the end of the article.&lt;/p&gt;
&lt;p&gt;If the link’s link label matches a link reference definition, the shortcut reference
link uses the link label as the text within the anchor.  In the case of the above
example, this produces the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When this HTML was generated, the text &lt;code&gt;link&lt;/code&gt; was used from the shortcut reference link
and the rest of the anchor tag (the text between &lt;code&gt;&amp;lt;a&lt;/code&gt; and
&lt;code&gt;&amp;lt;/a&amp;gt;&lt;/code&gt; excluding the text &lt;code&gt;link&lt;/code&gt;) was composed using information from the link
reference definition.  The benefit of this approach is that the “marker” for the link
is inline with the rest of the text while the bulkier link data is located
elsewhere in the document.   This benefit allows the author to better control their own
authoring experience by controlling where the link reference definitions occur in their
document: after the paragraph containing the link, at the end of the section, or at the
end of the document.&lt;/p&gt;
&lt;p&gt;Without exploring the normalization of link labels (yet!), each link label is parsed
to render inline processing for the link label.  A good instance of this is
&lt;a href="https://github.github.com/gfm/#example-566"&gt;example 566&lt;/a&gt;
from the GFM specification which adds inline emphasis to the link label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[*foo* bar]&lt;/span&gt;

&lt;span class="na"&gt;[*foo* bar]: /url "title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is rendered as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key is that if the normalized link label of both the shortcut reference
link and the link reference definition match, everything works fine.  If the link
label does not match, the text is simply rendered as normal text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar]&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Other than that, the only other special thing is that the link label for a shortcut
reference link cannot contain another link.  This is explicitly stated in the
definition of &lt;a href="https://github.github.com/gfm/#link-text"&gt;link text&lt;/a&gt; which states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Links may not contain other links, at any level of nesting. If multiple otherwise valid link definitions appear nested inside each other, the inner-most definition is used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A good example of this is obtained when the following Markdown text is fed through a
GFM compliant parser:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[foo[foo]]&lt;/span&gt;

&lt;span class="na"&gt;[foo]: /url "title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generating the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[foo&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;]&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looking at the HTML, the inner shortcut reference link &lt;code&gt;[foo]&lt;/code&gt; was interpreted and the
outer link &lt;code&gt;[foo[foo]]&lt;/code&gt; was deemed invalid, therefore being rendered normally.&lt;/p&gt;
&lt;h3 id="multiple-references-of-a-link-reference-definition"&gt;Multiple References of a Link Reference Definition&lt;a class="headerlink" href="#multiple-references-of-a-link-reference-definition" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt; there are instructions and examples
on what to do if there are multiple link reference definitions declared with the same
normalized link label.  However, after a couple of passes through the GFM specification,
I was unable to find any guidance on what to do if there are multiple reference links
that use a given link reference definition.  The closest that the specification gets to
this is near the start of the section on
&lt;a href="https://github.github.com/gfm/#full-reference-link"&gt;full reference links&lt;/a&gt;
(covered in the next section) which states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;followed by a link label that matches a link reference definition elsewhere in the document.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Based on this information, along with testing against the CommonMark reference parser,
I can safely state that the following example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ss"&gt;"title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on this information and the quote above, I feel that this is a good feature of
Markdown.  In certain cases where a link is used repeatedly, this behavior can be used
to have a single link reference definition to provide the link itself, and multiple
reference links pointed to that one definition.  In my mind, that is where full
reference links come in.&lt;/p&gt;
&lt;h2 id="what-are-full-reference-links"&gt;What Are Full Reference Links?&lt;a class="headerlink" href="#what-are-full-reference-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In
&lt;a href="https://daringfireball.net/projects/markdown/syntax#link"&gt;John Gruber’s original specification&lt;/a&gt;,
there were no shortcut links and full reference links were referred
to as “reference-style links”.  It was only with later parsers that the more compact
shortcut reference link was introduced.  In my mind, instead of the order in which
reference links were historically introduced, I prefer to see the hierarchy of
reference links in reverse chronological order, with the shortcut reference links first
and the full reference links second.&lt;/p&gt;
&lt;p&gt;My reasoning for this is as follows.  Based purely on efficiency, I typically start
with the clearest construct that has the least amount of effort to add. With reference
links, my first instinct is to add a shortcut reference link with the
link label matching the link reference definition that I need to add to complete it.
In 95% of the cases that I come across, I need a single link reference definition and a
single reference link, so a shortcut reference link is the best option.  For the
remaining 5%, I usually have a case where I have multiple reference links referencing a
single link reference definition, and I need a reference link that I can use there to
good effect.&lt;/p&gt;
&lt;p&gt;Consider the following example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;refers&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;

&lt;span class="n"&gt;Then&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;separate&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;must&lt;/span&gt; &lt;span class="n"&gt;still&lt;/span&gt; &lt;span class="n"&gt;refer&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When coming up with this example, I needed to take care to create my example second
paragraph in a way that &lt;code&gt;[my link]&lt;/code&gt; would fit somewhat fluidly in the sentence.
It would be more useful to do the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;refers&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;

&lt;span class="n"&gt;Then&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;separate&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="n"&gt;refer&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For me, that is where the benefit of full reference links come in.&lt;/p&gt;
&lt;p&gt;As I alluded to
in the previous example, full reference links are of the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[text][link]&lt;/span&gt;

&lt;span class="na"&gt;[link]: /url "title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where the first set of square brackets encloses link text and the second set of brackets
encloses the link label.  Unlike the shortcut reference link, where the link label
serves as both the text to match and the text around which to link, a full reference
link assigns a block of text to each of those responsibilities.  This allows a single
link reference definition to be referred to by multiple reference links, each one
having tailored link text.&lt;/p&gt;
&lt;p&gt;The link text is defined in a manner very similar to link labels, including the
limitation that link text cannot include other links, demonstrated by the
&lt;a href="https://github.github.com/gfm/#example-541"&gt;example 541&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[foo *bar [baz][ref]*][ref]&lt;/span&gt;

&lt;span class="na"&gt;[ref]: /uri&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[foo &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;]&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;ref&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Similar to how the link-within-a-possible-link example was handled for shortcut
reference links, the inner reference link text &lt;code&gt;[baz][ref]&lt;/code&gt; is interpreted as a valid
link, with the rest of the possible-link’s link text being presented as plain text.
It is simply an act of serendipity that both the inner link and outer possible-link
used the link label &lt;code&gt;[ref]&lt;/code&gt;.  Because of this act of serendipity, when the inline
processor gets to the &lt;code&gt;[ref]&lt;/code&gt; text at the end of the line, it is interpreted as a
shortcut reference
link, in a separate context from the previous link.  As such, a second
link to the same URI is generated at the end of the HTML paragraph.&lt;/p&gt;
&lt;p&gt;While I found it easier to visually see the how the above example should be parsed by
working through it in my head, it was examples of this flavor that I really struggled
with before I combined looking at rule with looking at examples, as detailed above.
To be honest, to properly figure these out, I used a pencil and a sheet of paper to
visually break down the problem.  Only when I had those scribbled notes in front of me
did I really get this example.  Perhaps it is only me, but it was by literally working
through the example and showing my work that I was able to really understand what
the parser needed to do.  After that, coding the parser to do it was simple.  As
I have mentioned a few times, figure out whatever works for you, and leverage
that.&lt;/p&gt;
&lt;h2 id="collapsed-reference-links"&gt;Collapsed Reference Links&lt;a class="headerlink" href="#collapsed-reference-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the inclusion of collapsed link references into the specification may seem like
an unnecessary element, it is an alternative that offers the author leeway on how
their Markdown article is constructed.  For some authors, the full reference link of
&lt;code&gt;[label][label]&lt;/code&gt; might be preferred.  For other authors, the shortcut reference link of
&lt;code&gt;[label]&lt;/code&gt; might be preferred.  If the author is looking for something in between, the
collapsed reference link and it’s format of &lt;code&gt;[label][]&lt;/code&gt; offers a middle ground.  All
three of the examples provided in this paragraph are semantically equal and will produce
the exacts same HTML.&lt;/p&gt;
&lt;p&gt;In the end, it is just a matter of preference which of the reference link formats
that the author prefers and is comfortable with.&lt;/p&gt;
&lt;h2 id="normalizing-link-labels"&gt;Normalizing Link Labels&lt;a class="headerlink" href="#normalizing-link-labels" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Back in the section on
&lt;a href="https://jackdewinter.github.io/2020/04/13/markdown-linter-adding-reference-links/#what-are-shortcut-reference-links"&gt;What Are Shortcut Reference Links?&lt;/a&gt;,
I simplified
the term “normalized” to mean &lt;code&gt;case-insensitive comparison&lt;/code&gt;.  The full definition of
&lt;a href="https://github.github.com/gfm/#matches"&gt;normalized&lt;/a&gt;
is a bit more complicated, but not by much.  In order of operation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grab the link text in its unprocessed form&lt;/li&gt;
&lt;li&gt;remove the opening and closing brackets from the link label&lt;/li&gt;
&lt;li&gt;perform a Unicode case fold (the Unicode equivalent of reducing all letters to lower case)&lt;/li&gt;
&lt;li&gt;strip leading and trailing whitespace&lt;/li&gt;
&lt;li&gt;collapse consecutive internal whitespace to a single space&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once these steps have been applied to the link label’s text, it is that text that is
used to determine if it matches an existing link reference definition.  In cases where
the link label is &lt;code&gt;[foo]&lt;/code&gt; or &lt;code&gt;[referenced document]&lt;/code&gt;, this process may seem weird or
superfluous.  But, in the case of
&lt;a href="https://github.github.com/gfm/#example-553"&gt;example 553&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[bar][foo\!]&lt;/span&gt;

&lt;span class="na"&gt;[foo!]: /url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the parsed inline text is equivalent, but the link is not interpreted as a full
reference link.  This is because the normalized text for the reference link is &lt;code&gt;foo\!&lt;/code&gt;
while the normalized text for the link reference definition is
&lt;code&gt;foo!&lt;/code&gt;.  While both of these strings will be equivalent to &lt;code&gt;foo!&lt;/code&gt; after applying inline
parsing, their normalized values do not match, and as such, the above example is
rendered in HTML as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[bar][foo!]&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="what-implementation-problems-did-i-have"&gt;What Implementation Problems Did I Have?&lt;a class="headerlink" href="#what-implementation-problems-did-i-have" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Between the work previously done for
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#why-inline-links"&gt;inline links&lt;/a&gt;
and
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;,
most of the required foundation work was already in place when I started with
reference links.  As I required a simple implementation of shortcut reference
links to properly test link reference definitions, it was only the introduction of
link text for full reference links that required any real block of new code.&lt;/p&gt;
&lt;p&gt;Even given that solid, tested foundation, there were two issues that gave me troubles
as I implemented reference links: using the correct text to determine matching and the
order of precedence between different types of reference links.&lt;/p&gt;
&lt;p&gt;Adding the parsing for shortcut reference links as part of the work for link
reference definitions, I naturally did the bare minimum required to get it working.  For
the link label matching algorithm, it was a simple &lt;code&gt;a == b&lt;/code&gt; comparison which worked
nicely for all the link reference definition examples except two.  To get it working
with those two examples, both dealing with case insensitivity, I changed the
comparison to &lt;code&gt;a.lower() == b.lower()&lt;/code&gt; and then both examples parsed correctly.&lt;/p&gt;
&lt;p&gt;When I reached the reference link examples that dealt with link label matching,
things got a bit more tricky, but not too tricky.  Use &lt;code&gt;.casefold()&lt;/code&gt; instead of
&lt;code&gt;.lower()&lt;/code&gt;? No problem.  Stripping various forms of whitespace from the link label?
No problem.  Using the right text as a basis for those transformations?  That took a
bit of work.&lt;/p&gt;
&lt;p&gt;Given that link processing is handled in the inline processing phase, the easiest
solution was to add parallel text handling.  My thinking was that since the inline
processing is constrained to a single continuous grouping of text, I just needed
something simple that would only exist for the lifetime of that grouping.  To accomplish
this, I used the variable &lt;code&gt;current_string_unresolved&lt;/code&gt; to keep track of a raw,
unresolved version of the string that was being processed in the variable
&lt;code&gt;current_string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While that
might seem a bit of a kludge&lt;sup id="fnref:kludge"&gt;&lt;a class="footnote-ref" href="#fn:kludge"&gt;2&lt;/a&gt;&lt;/sup&gt;, for me it was a simple solution that was
contained to the area most affected by the issue.  The other option, using an
unresolved stream and then resolving it later, seemed to have too many
issues to deal with in a manner that I was sure was going to cover all the edge
cases.  I know this because I tried that first (and second and third), before sitting
back and rethinking what the best approach would be from a high level. After three
attempts with the unresolved stream and no success, the kludge solution worked on the
first try with no issues.  Guess it really was not a kludge!&lt;/p&gt;
&lt;p&gt;Having found a decent solution for using the right text to match against, the only
issue I had left to deal with was in dealing with the order of precedence of reference
links with themselves and other elements.  Detailed in the examples between
&lt;a href="https://github.github.com/gfm/#example-572"&gt;example 572&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-579"&gt;example 579&lt;/a&gt;, these examples give very
specific guidance on the precedence to use for each combination.  While the examples
provided good guidance, the implementation was not always so easy to get right.&lt;/p&gt;
&lt;p&gt;While getting the order in which to check for
the various types of reference links took a bit, it was complicated by the determination
of whether a given reference link referenced a valid link reference definition.
Out of the 4 days it took for me to complete reference links, one of those days was
spent just going over all of the combinations, making sure that the specification
detailed them (it did!), and then checking and rechecking each modification that made
another of the above examples work.  It was only then that I staged my changes and moved
on to the next example.  In the end, it was very tedious work, but it was worthwhile
because it worked.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For the most part, the implementation of the reference links was a good experience,
combining a bit of “reuse foundation” work with some “how do I get this to work
properly” challenges.  There was just one dark sport on the implementation of the
feature.&lt;/p&gt;
&lt;p&gt;I have already mentioned my issues with understanding the link specification in the
above sections, but I feel the topic is important enough topic to warrant more
discussion.  Unlike before where I was
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#what-was-my-experience-so-far"&gt;skipping parts&lt;/a&gt;
of the specification, this challenge was a genuine case of me reading the specification
and not getting a good understanding of it.  Even with the provided examples, there
were still times where I was unable to comprehend what the specification was doing.  It
was only after going “old school” and getting out a pencil and some paper did I work
through it.&lt;/p&gt;
&lt;p&gt;At one point, I remember thinking to myself:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Writing parsers for 30 years and you still need a pencil and paper?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It was not one of the brightest moments of the project, but it did happen. It
was after what I think was the 7th or 8th time of me trying to
understand the preventing the link within a link logic detailed in the section on
&lt;a href="https://jackdewinter.github.io/2020/04/13/markdown-linter-adding-reference-links/#what-are-full-reference-links"&gt;reference links&lt;/a&gt;.
Honestly, I am guessing it was the 7th or 8th time, I lost count of the number
of attempts. For whatever reason, it just was not clicking for
me.  It is times like those that I like to break a problem down to smaller components,
what I refer to the “boulders to pebbles” approach.  And for some reason, I needed to
break those pebbles down even smaller, and I was very hard on myself for it.&lt;/p&gt;
&lt;p&gt;No matter who you are, you are going to have good days, bad days, and a lot of in
between days.  The more that you take care of yourself, the better your chance of
being on the positive end of that spectrum.  I did not need a pencil and paper because
I wasn’t capable of figuring out the problem myself, I needed them as a tool to
help me figure it out myself on that day.  I now look back at the problem and my
scribbles and have the mental capacity to understand it was just a bad day.  And
even if I am being more charitable about the day than it really was.  So what?
I used the tools that I needed to in order to solve the problem I faced.  Simple as
that.&lt;/p&gt;
&lt;p&gt;I started this project with a need and a desire to learn.  I completed this feature
learning that I still have what it takes to solve the issues that I need to.  I also
learned that I need to focus a bit more on taking better care of myself and nudging
myself towards the positive end of that spectrum.  Guess what? I stumble, I learn,
and I get up and try and not do the same thing again.  Well… not too often at least.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I know there is some “optional” stuff I need to add to the parser before I
can use it on my own website, there is only one more feature that I need to complete
before the parser is complete and GFM compliant.  With a bit of a mental drum roll…
image links are next!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:before"&gt;
&lt;p&gt;As link reference definitions are parsed with the leaf blocks, and reference links are parsed later with inline processing, the term “previously defined” refers to any definition in the Markdown document that was parsed, and not “previously defined” with respect to the relative locations of the reference links and the definition within the Markdown document. &lt;a class="footnote-backref" href="#fnref:before" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:kludge"&gt;
&lt;p&gt;According to Merriam-Webster: “a haphazard or makeshift solution to a problem and especially to a computer or programming problem” &lt;a class="footnote-backref" href="#fnref:kludge" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Adding Link Reference Definitions</title><link href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/" rel="alternate"></link><published>2020-04-06T00:00:00-07:00</published><updated>2020-04-06T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-04-06:/2020/04/06/markdown-linter-adding-link-reference-definitions/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As detailed in
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#Why-Inline-Links?"&gt;the last article&lt;/a&gt;,
the remaining work left on the main parser consists of inline links,
link reference definitions, reference links, and image links.  Inline links were
covered in the last article.  While I could try and
come up with some grand reason for doing the link …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As detailed in
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#Why-Inline-Links?"&gt;the last article&lt;/a&gt;,
the remaining work left on the main parser consists of inline links,
link reference definitions, reference links, and image links.  Inline links were
covered in the last article.  While I could try and
come up with some grand reason for doing the link reference definitions next, the
truth is simple: they were next on the list.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/680e9d9fd7472e69232a191ca84ce9bc5ff4aaec"&gt;22 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="what-are-link-reference-definitions"&gt;What Are Link Reference Definitions?&lt;a class="headerlink" href="#what-are-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#what-is-an-inline-link"&gt;last article&lt;/a&gt;,
I introduced inline links and how they present the text to appear in the
link (link label), the link itself (link destination), and an optional title for that
link (link title).  Link reference definitions are a related concept in that they take
the link destination and link title parts of the link and store them in a map, to be
used at a different time.&lt;/p&gt;
&lt;p&gt;Basically, where an inline link uses the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a link definition uses the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main difference between the two elements is that a link reference definition does
not add any elements into the HTML document by itself.  To utilize the link reference
definition, a reference link must be added to the document that has a
normalized &lt;sup id="fnref:normalized"&gt;&lt;a class="footnote-ref" href="#fn:normalized"&gt;1&lt;/a&gt;&lt;/sup&gt; link label that matches the normalized &lt;sup id="fnref2:normalized"&gt;&lt;a class="footnote-ref" href="#fn:normalized"&gt;1&lt;/a&gt;&lt;/sup&gt; link
label from a link reference definition present elsewhere in the same Markdown document.
For example, using the simplest form of reference links, a
&lt;a href="https://github.github.com/gfm/#shortcut-reference-link"&gt;shortcut reference link&lt;/a&gt;,
the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;creates a link reference definition and uses it, generating the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the normalization rules&lt;sup id="fnref3:normalized"&gt;&lt;a class="footnote-ref" href="#fn:normalized"&gt;1&lt;/a&gt;&lt;/sup&gt; are somewhat complex, in most cases it just
means using the same link label in both the reference link and the link reference
definition.  Unless you happen to get into the more interesting aspects of the
normalization rules, both reference links and link reference definitions are easy to
use, by design.&lt;/p&gt;
&lt;h2 id="why-use-link-reference-definitions"&gt;Why Use Link Reference Definitions?&lt;a class="headerlink" href="#why-use-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#i-use-inline-links-almost-exclusively"&gt;last article&lt;/a&gt;,
I mentioned that I use inline links exclusively.  Now that I have introduced link
resource definitions and reference links, I can provide more context on the difference
between them. Using a simple
&lt;a href="https://lipsum.com/"&gt;lorem ipsum generator&lt;/a&gt;,
I came up with the following two examples.  This first example contains an inline link:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;turpis&lt;/span&gt; &lt;span class="n"&gt;ac&lt;/span&gt; &lt;span class="n"&gt;vestibulum&lt;/span&gt; &lt;span class="n"&gt;imperdiet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nulla&lt;/span&gt; &lt;span class="n"&gt;mi&lt;/span&gt; &lt;span class="n"&gt;mollis&lt;/span&gt; &lt;span class="n"&gt;erat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nec&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt; &lt;span class="n"&gt;nunc&lt;/span&gt;
&lt;span class="n"&gt;lorem&lt;/span&gt; &lt;span class="n"&gt;rutrum&lt;/span&gt; &lt;span class="n"&gt;metus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Vestibulum&lt;/span&gt; &lt;span class="n"&gt;dictum&lt;/span&gt; &lt;span class="n"&gt;lacinia&lt;/span&gt; &lt;span class="n"&gt;lacus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;at&lt;/span&gt; &lt;span class="n"&gt;ornare&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;consequat&lt;/span&gt; &lt;span class="n"&gt;ultrices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;leo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aliquet&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;luctus&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;lipsum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;span class="n"&gt;Donec&lt;/span&gt; &lt;span class="n"&gt;tincidunt&lt;/span&gt; &lt;span class="n"&gt;augue&lt;/span&gt; &lt;span class="n"&gt;nisi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sed&lt;/span&gt;
&lt;span class="n"&gt;pellentesque&lt;/span&gt; &lt;span class="n"&gt;nisl&lt;/span&gt; &lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;vel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and this second example contains a reference link, specifically a shortcut reference
link:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;turpis&lt;/span&gt; &lt;span class="n"&gt;ac&lt;/span&gt; &lt;span class="n"&gt;vestibulum&lt;/span&gt; &lt;span class="n"&gt;imperdiet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nulla&lt;/span&gt; &lt;span class="n"&gt;mi&lt;/span&gt; &lt;span class="n"&gt;mollis&lt;/span&gt; &lt;span class="n"&gt;erat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nec&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt; &lt;span class="n"&gt;nunc&lt;/span&gt;
&lt;span class="n"&gt;lorem&lt;/span&gt; &lt;span class="n"&gt;rutrum&lt;/span&gt; &lt;span class="n"&gt;metus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Vestibulum&lt;/span&gt; &lt;span class="n"&gt;dictum&lt;/span&gt; &lt;span class="n"&gt;lacinia&lt;/span&gt; &lt;span class="n"&gt;lacus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;at&lt;/span&gt; &lt;span class="n"&gt;ornare&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;consequat&lt;/span&gt; &lt;span class="n"&gt;ultrices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;leo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aliquet&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;luctus&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt; &lt;span class="n"&gt;Donec&lt;/span&gt; &lt;span class="n"&gt;tincidunt&lt;/span&gt; &lt;span class="n"&gt;augue&lt;/span&gt; &lt;span class="n"&gt;nisi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="n"&gt;pellentesque&lt;/span&gt; &lt;span class="n"&gt;nisl&lt;/span&gt; &lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;vel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;lipsum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From an HTML output point of view, both examples generate the exact same output.&lt;/p&gt;
&lt;p&gt;In both cases, the examples are presented as I would normally include them in my
articles, folding each line after the 90 characters that I keep my Markdown editor set
to.  Applying my own stylistics, when I add an inline link I ensure that it begins at
the start of a new line to ensure that I can clearly identify it as a link.  In
trying an equivalent example with a reference link instead of an inline link, the
style that I chose was to place the link label delimiters (&lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;) around the link
label itself with no change in formatting, with the link reference definition following
later in the document.  While link reference definitions can precede or follow
any reference links that use them, to me this seemed like the right way to do it.&lt;/p&gt;
&lt;p&gt;From my point of view, I find that the inline reference provides better readability for
me and how I read my articles when authoring them.  Perhaps it is through having
authored and proofed many articles in this format, but to me, not having the link
information right in the paragraph feels like a grammatical or spelling error. And
while I did not really think about it before, when proofing the Markdown version of
my articles, I don’t really “see” the link destination and link title until I slow down
on my final passes.  Regardless of the reasoning behind it, I just find it works better
for me to read the Markdown version of articles with inline links.&lt;/p&gt;
&lt;p&gt;Please note that this view is solely my own.  When performing a similar evaluation for
yourself or your organization, it is important to consider your own criteria when
determining which options, reference links or inline links, is best for you.&lt;/p&gt;
&lt;h2 id="hitting-implementation-issues"&gt;Hitting Implementation Issues&lt;a class="headerlink" href="#hitting-implementation-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having implemented inline links as documented in the
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#implementing-the-algorithm"&gt;last article&lt;/a&gt;,
I started working on the link reference definitions thinking they would be easy.  In
the case of the first example,
&lt;a href="https://github.github.com/gfm/#example-161"&gt;example 161&lt;/a&gt;, it was in fact pretty easy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A complete link label, followed by both a link destination and a link title.  All on
one line.  Then add a simple shortcut reference link to reference the previously added
link reference definition.  Nice. Compact.  Complete.&lt;/p&gt;
&lt;p&gt;It was when I moved on to
&lt;a href="https://github.github.com/gfm/#example-162"&gt;example 162&lt;/a&gt;
that all of the issues started:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="s1"&gt;'the title'&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first important issue to understand is that link reference definitions are
processed as leaf nodes instead of inline text.  To keep the memory footprint of the
parser low, I made an early design decision to
only get the text from the input source one line at a time.&lt;sup id="fnref:lineByLine"&gt;&lt;a class="footnote-ref" href="#fn:lineByLine"&gt;2&lt;/a&gt;&lt;/sup&gt;  While the
proper implementation of that design is still in the future, that design limits the main
parsing function of the parser to only knowing about the current line, with no
built-in capacity for look-ahead or look-behind.  Remember this issue, as I will get
back to it in just a minute.&lt;/p&gt;
&lt;p&gt;The second important issue is that unlike all previous leaf node elements, it can take
multiple lines to determine if the current link reference definition element is valid.
In example 162, as provided above, it isn’t until the end of line following the second
&lt;code&gt;'&lt;/code&gt; character on line 3 that the link reference definition is determined to be valid.
To better highlight this problem, consider
&lt;a href="https://github.github.com/gfm/#example-165"&gt;example 165&lt;/a&gt;
which provides for an exaggerated example of this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;
&lt;span class="s1"&gt;title&lt;/span&gt;
&lt;span class="s1"&gt;line1&lt;/span&gt;
&lt;span class="s1"&gt;line2&lt;/span&gt;
&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the link reference definition as stated in example 165 is valid, it isn’t until
the 5th line, where the second &lt;code&gt;'&lt;/code&gt; character followed by the end of the line
closes off the link title, that the entire link reference definition is deemed valid.
By making one small change to the previous example, removing that previously mentioned
5th line, that entire link reference definition is rendered invalid, as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;line2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After that one small change, instead of a link reference definition followed by a valid
link reference, both elements are now just interpreted as plain text.&lt;/p&gt;
&lt;p&gt;Remember a couple of paragraphs ago when I mentioned “remember this issue” when talking
about processing link reference definitions as leaf nodes?  Here is the payoff.&lt;/p&gt;
&lt;p&gt;Because of my design choice to process the Markdown document one line at a time, I
needed to add extra logic to the parser to allow me to “rewind” those lines.  In the
case of the modified example 165, the entire link reference definition is rendered
invalid, and the parser must rewind to the start of the link reference definition.
However, when it starts parsing the lines again, care must be taken to inform the
parser that it cannot consider the newly rewound lines to be eligible for a valid
link reference definition.  Painful, but not too painful.&lt;/p&gt;
&lt;p&gt;Following along from that change, if we do a similar change to example 162 by removing
the final &lt;code&gt;'&lt;/code&gt; character
from the definition, it poses a different problem.  While the removal of the 5th line of
example 165 invalidates the entire link reference definition, removing the final &lt;code&gt;'&lt;/code&gt;
character from example 162 only invalidates the link title, leaving the rest of the link
definition valid.  To deal with this, I needed to not only have logic to go backwards
towards the start of the link reference definition, but to stop that rewinding if
whatever part of the definition that was not rewound turned out to be a valid
definition.  While the rewinding was a headache and somewhat obvious&lt;sup id="fnref:parsing"&gt;&lt;a class="footnote-ref" href="#fn:parsing"&gt;3&lt;/a&gt;&lt;/sup&gt;,
aborting the rewinding if a valid link reference definition “fragment” was found was
not obvious to me at all.&lt;/p&gt;
&lt;p&gt;That code was painful.  Honestly speaking, that logic alone took about half of the 5
days required to get the multiple-line aspect of link reference definition parsing
properly.  A decent amount of that time was taken up with rewriting the logic for
extracting the link
label, link definition, and link title to handle being straddled over multiple lines.
But the real “fun” was making sure that rewinding the lines would properly rewind the
token stream and token stack in the parser.&lt;/p&gt;
&lt;p&gt;While it took a lot of work to get there, it was personally fulfilling when I got it
right.  It wasn’t an easy issue to solve and coming up with a clean solution wasn’t
easy.  As a bonus, my dog stopped looking at me with a funny expression.  It
was pointed out to me that he did that when facepalmed myself whenever I got the
parsing wrong.  Personally, I considered that a 2-in-1 benefit!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There have only been a few issues that have taxed my experience to solve them and
implementing link reference definitions was one of them.  That is both a good thing and
a bad thing.  On the good side, due to my experience and stubbornness, I was able to
modify my implementation to deal with the issue without having to change my design
decision.  On the bad side, there is only one test with a link reference definition
being within a container block, and that leaves a lot of questions about how to handle
failures within those containers.  While I noted the later down for subsequent testing,
it still leaves me feeling a bit uneasy that I had to modify the parser to handle that.&lt;/p&gt;
&lt;p&gt;Considering where I am with the parser, I am glad that I hit that issue now, and not
after I finished the parser.  While it was painful to go through, it did reinforce
a few things about the design of the parser so far.&lt;/p&gt;
&lt;p&gt;The first thing that was
reinforced was that, with only one exception, my early decision to do line-by-line
parsing is viable.  While there may be parser extensions that change that, the
number of exceptions in the link reference definition category should be low.  If
I can then combine that with some Python generator logic, hopefully I can keep the
memory profile of the parser low.&lt;/p&gt;
&lt;p&gt;The second thing that was reinforced was that the general structure of the parser was
properly designed and implemented.  While I still need to take some time and refactor
individual
groups of functions into their own modules, the actual function themselves are
durable.  Except for the link helper functions and a few core functions, I
did not have to change any other functionality to handle the failure rewind scenario.
In those few functions I changed, it was either to specifically handle that scenario
or to pass information back to the main parser function about how to handle the rewind.
Compared to past situations I have encountered; I consider it a benefit
that I only had to change the small amount of code that I did.&lt;/p&gt;
&lt;p&gt;Finally, my decision to use inline links over reference links was reinforced. In more
closely examining the difference between the
two types of links, I believe I better understand and appreciate both types of links.
While I agree that writing Markdown with reference links will more closely approximate
how the paragraphs will look when completed&lt;sup id="fnref:JohnGruberMarkdown"&gt;&lt;a class="footnote-ref" href="#fn:JohnGruberMarkdown"&gt;4&lt;/a&gt;&lt;/sup&gt;, the absence of the
link destination and link title reduce my comprehension of the paragraph as a whole.
I find myself making the same decision as before, but now I believe I can more
clearly communicate the options for both types of links and why I chose inline links
over reference links.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The list of what is left to complete in the parser is getting shorter and shorter.
With inline links and link reference definitions tested and completed, only the
full implementation of reference links and image links remain.  While a lot of
foundation work has already been set up for these features, I am wary of declaring
that it will be an easy job from here on it.  But with only 2 features left, I know
the start of the real linting work in coming soon!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:normalized"&gt;
&lt;p&gt;Long winded version: To normalize a label, strip off the opening and closing brackets, perform the Unicode case fold, strip leading and trailing whitespace and collapse consecutive internal whitespace to a single space.  Shorter version: reduce or eliminate whitespace and do a case-insensitive comparison. &lt;a class="footnote-backref" href="#fnref:normalized" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="#fnref2:normalized" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="#fnref3:normalized" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:lineByLine"&gt;
&lt;p&gt;To keep the memory footprint of a parser low, the parser design should try and only keep the information that is required for parsing in memory.  By parsing the Markdown input line by line, I do not have to worry about having to load the entire Markdown input into memory before I can begin parsing it. &lt;a class="footnote-backref" href="#fnref:lineByLine" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:parsing"&gt;
&lt;p&gt;Except for a Lisp parser that I once wrote, I cannot think of a single parser where I didn’t have to rewind at least one complex entity out of the 25+ parsers that I have written. &lt;a class="footnote-backref" href="#fnref:parsing" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:JohnGruberMarkdown"&gt;
&lt;p&gt;As per John Gruber’s original intentions.  Go to &lt;a href="https://daringfireball.net/projects/markdown/syntax#em"&gt;this part&lt;/a&gt; of his original Markdown article and go to the paragraph preceding the start of the emphasis section.  For more complete information on why John felt that reference links were better, look further up in that section for more details. &lt;a class="footnote-backref" href="#fnref:JohnGruberMarkdown" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Adding Inline Links</title><link href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/" rel="alternate"></link><published>2020-03-30T00:00:00-07:00</published><updated>2020-03-30T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-30:/2020/03/30/markdown-linter-adding-inline-links/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having just implemented the
&lt;a href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/"&gt;Inline Emphasis&lt;/a&gt; feature
as documented in my last article, I was eager to move forward with the implementation
of the links feature.  As the group of features under links were the only ones
separating me from the completion of the project’s parser, I was …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having just implemented the
&lt;a href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/"&gt;Inline Emphasis&lt;/a&gt; feature
as documented in my last article, I was eager to move forward with the implementation
of the links feature.  As the group of features under links were the only ones
separating me from the completion of the project’s parser, I was happy when I noticed
that I was starting to think “when the parser is done” instead of
“if the parser is EVER done”. I have been working on this project for a while and it
was nice to know that in my mind, I could “see the light” with respect to this
project.&lt;/p&gt;
&lt;p&gt;In implementing the algorithm outlined in the section
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;Phase 2: inline structure&lt;/a&gt;,
I chose to implement the emphasis feature first, leaving the implementation of links
until the base algorithm and emphasis feature were implemented and tested.  Seeing as
both of those were accomplished, I felt that it was the right time to apply my
success in implementing the emphasis feature to the link feature.  I knew that the
work on the delimiter stack would easily carry over, but I was eager to see if the
implementation of the next part of links would be as easy as the implementation of
emphasis.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit from
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/a0deb2e362adebd2bb65fd0095e5add160f1dfad"&gt;17 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="why-inline-links"&gt;Why Inline Links?&lt;a class="headerlink" href="#why-inline-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a quick peek ahead, I observed that the link feature in the specification is
broken down into four groups:
&lt;a href="https://github.github.com/gfm/#inline-link"&gt;inline links&lt;/a&gt;,
&lt;a href="https://github.github.com/gfm/#link-reference-definitions"&gt;link reference definitions&lt;/a&gt;,
&lt;a href="https://github.github.com/gfm/#reference-link"&gt;reference links&lt;/a&gt;, and
&lt;a href="https://github.github.com/gfm/#images"&gt;image links&lt;/a&gt;.
Based on a quick reading of each section, it was obvious to me that for reference links
to work properly, link reference definitions would be needed.  Image links are
variations on the inline link type and reference link type, the only difference being a
different start
delimiter.  As such, I did not see any benefit to implementing image links
before those other two link types are completed.  This leaves inline links. Inline
links are self-contained, allowing them to be implemented separately from the other
three groups.  Being somewhat impatient to get the parser done, I decided to go for the
sub-feature that was more immediately available: inline links.&lt;/p&gt;
&lt;h2 id="i-use-inline-links-almost-exclusively"&gt;I Use Inline Links (Almost) Exclusively&lt;a class="headerlink" href="#i-use-inline-links-almost-exclusively" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When writing my articles and documentation, I personally find it more readable to
include any
links in my documents as a complete unit.  This means that when I add a link, I will
typically add it in the form shown in the GFM specification at
&lt;a href="https://github.github.com/gfm/#example-494"&gt;example 494&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a concrete example of this, the above link to example 494 that precedes the sample
link format was created with the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt; &lt;span class="mi"&gt;494&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gfm&lt;/span&gt;&lt;span class="o"&gt;/#&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;494&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the form can be augmented as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to provide a title, I cannot remember a case where I have used that form.
While I do not have a strong reason for or against this format, I believe that I just
have not encountered a case where I believe that a title for the link was either
desired or required.  On the other hand, I have used the following form a few
times before:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as an alternative to the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While my use of the angle bracket form is rare, it was useful in a couple of cases
where I needed to provide a space character as part of an URI.  While different
Markdown-to-HTML processors will handle the space character differently, I just wanted
something that read well and was mostly universal.&lt;/p&gt;
&lt;h2 id="what-is-an-inline-link"&gt;What is an Inline Link?&lt;a class="headerlink" href="#what-is-an-inline-link" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For a well-documented answer to this question, please look at the
&lt;a href="https://github.github.com/gfm/#inline-link"&gt;inline link section&lt;/a&gt; of the GFM for
a word-for-word answer, complete with helpful examples.  My own summarization of
this section is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an inline link occurs on a single line and comprised of the link text, a left parenthesis, an optional link destination followed by an optional whitespace and an optional link title, and a right parenthesis&lt;/li&gt;
&lt;li&gt;if in doubt about any punctuation characters in the below constructs, backslash escape them&lt;/li&gt;
&lt;li&gt;the link text is any text that appears between the opening square brackets (&lt;code&gt;[&lt;/code&gt;) and the closing square brackets (&lt;code&gt;]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;the link destination is any non-space, non-control characters, with special rules for the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, and &lt;code&gt;)&lt;/code&gt; characters&lt;/li&gt;
&lt;li&gt;the link title, if included, is contained within a single-quoted string (&lt;code&gt;'&lt;/code&gt;), double-quoted string (&lt;code&gt;"&lt;/code&gt;), or a parenthesized string (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After 5 revisions to try and keep my answer “minimal”, that is it!  While I could leave
it in a more complicated state, that summary is what I believe I have it broken down
to in my head.  For me, the first two points are the pivotal ones, setting up the link
component order and exclusions needed to create valid inline links.  The last three
rules are just simplifications of what is needed to represent each of the three
components, rounding out the definition for inline links.&lt;/p&gt;
&lt;p&gt;Keeping to those rules, when I am picturing Markdown links in my head, I usually think
of these two forms:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Between the 5 rules stated above and these two examples, I believe I am keeping it
simple and minimal, ensuring my consistent use of links.  Let me dive into those
a bit more.&lt;/p&gt;
&lt;p&gt;In terms of the order of components, the link text and both outer parentheses are
required for the inline links, but both the link destination and link title are
optional.  However, due to how they are documented, if a link title is desired, a link
destination must precede it.  Basically, the component order is always: the text that
shows up inside of the link’s anchor, the link URI itself, and a title to use when the
link is traversed.  Once again, I keep it simple to make it easy to use.&lt;/p&gt;
&lt;p&gt;For remembering when to use punctuation characters and backslashes to escape them,
I once again try to keep it simple.  The second rule is the embodiment of that.  My
definition of “if in doubt”, as stated in the second rule, is that if I have to think
“is this punctuation part of the link or not?”, I have doubt.  Therefore, if I am
authoring a
link and am not sure if I should backslash escape punctuation within a link, I escape
it.&lt;/p&gt;
&lt;p&gt;Those first two rules are specifically tailored for me and to how I write my articles.
My primary
goal in coming up with those rules is to allow me to author rough drafts of
my articles as I go, links included.  During the rough draft phase, as efficiently as
possible, I need to leave
enough information in the added links to allow me to finish each link in subsequent
passes through the document. While the “as I go” element is not present in the
subsequent passes when I clean up the link, I do need
to make sure that I keep those passes as efficient as possible.  By keeping those rules
simple, I reduce the amount of friction incurred by adding links to the documents,
therefore keeping those passes efficient.&lt;/p&gt;
&lt;p&gt;An additional benefit to using those rules is the simplification of the specification’s
acceptable rules.  Specifically, the wording of my two first points helps me avoid a
lot of the weird cases included in the 41 test cases for inline links.  The two most
frequent reasons for the examples containing weird cases are the inclusion of newline
characters
and the inclusion of extra punctuation characters.  The “single line” part of the first
rule
helps me avoid any of those newline cases, and the “if in doubt” part of the second rule
helps me avoid any of the cases with extra punctuation.&lt;/p&gt;
&lt;p&gt;My conservative estimate is
that by adding those extra words to my personal rules, I was able to reduce the number
of “applicable” cases for links that I am authoring in half, if not a bit more.  While
that might sound like a weird statement to make, for me it means that I when am
authoring a document and adding a link, I can keep my focus on the what I am adding to
the document, and not focus on trying to remember all of the weird cases for links and
how to avoid them.  For me, that is a plus.&lt;/p&gt;
&lt;h2 id="implementing-the-algorithm"&gt;Implementing the Algorithm&lt;a class="headerlink" href="#implementing-the-algorithm" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having constructed and tested the delimiter stack and emphasis parts of the algorithm,
as documented in the last article on
&lt;a href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/"&gt;Inline Emphasis&lt;/a&gt;,
it was time to implement the &lt;code&gt;look for link or image&lt;/code&gt; part of that algorithm.  Once
again, in an effort to keep things simple, I added very minimal support for image links
(as detailed in the algorithm), but that support also added &lt;code&gt;assert False&lt;/code&gt; statements
to ensure
that any scenarios with images were clearly identifiable and not executable.  This
helped to prevent me
from accidentally working on testing image link features before adding the real support
for them in a subsequent feature.&lt;/p&gt;
&lt;p&gt;While the link part of algorithm does not have as many special cases as the 17 rules for
emphasis, there are a decent number of elements to keep track of when implementing the
links portion of the algorithm.  I found that by following the examples and the
algorithm as stated, I was able to quickly isolate the changes for each example.  This
isolation allowed me to to cleanly implement each small change with a clear idea of
what was needed to be accomplished.  As I am human, there were a few issues I initially
had in following various portions of the algorithm.  In all those cases, a quick
re-read of the section helped me get the proper information I needed to implement that
portion of the links.&lt;/p&gt;
&lt;p&gt;Out of the 41 total examples for inline links, only the first 6 are ones that I would
consider normal examples, the remaining 35 testing special cases and boundary
conditions.  As such,
I started with the first example,
&lt;a href="https://github.github.com/gfm/#example-493"&gt;example 493&lt;/a&gt;,
and added the code necessary to do a simple parsing of each of the components of that
example: link text, link destination, link title, link format separators and link
whitespace.  Then I simply started working my way down the list of examples,
refining each implementation with each example that I worked on.  With each example
that I cleared; the implementation visibly got closer to its final implementation.&lt;/p&gt;
&lt;p&gt;I am not too proud to admit that on my first reading of a lot of the examples, I
questioned what their worth to the feature was.  However, as I worked down the list of
examples, the questioning changed into enjoyment.  Each new example added a small layer
of complexity to the implementation, like a piece of a puzzle cleanly fitting into
place.  Even concepts that I worried about, like new lines and backslashes, were given
enough examples to clearly and properly demonstrate how they worked. There were a
couple of times where I questioned whether an example was really needed, but those
instances were few and far between.&lt;/p&gt;
&lt;h2 id="where-i-had-problems"&gt;Where I had Problems&lt;a class="headerlink" href="#where-i-had-problems" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The addition of inline links to the project went without too many issues.  The most
prominent of these were the proper encoding of special characters in the links and the
interactions between links and emphasis.&lt;/p&gt;
&lt;p&gt;In terms of the special characters, the main problem that I had was in selecting an
interpretation of the term “special characters” that was consistent with the GFM
specification, and
hence the CommonMark implementation.  The first group of characters, the ones to
replace with named HTML entity names is small, so examples such as
&lt;a href="https://github.github.com/gfm/#example-514"&gt;example 514&lt;/a&gt;
and
&lt;a href="https://github.github.com/gfm/#example-517"&gt;example 517&lt;/a&gt;
were easy to implement and get right on the first try.  From an HTML author’s point
of view, it was obvious that the following Markdown from example 517:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'title "and" title'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;should produce the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title &amp;amp;quot;and&amp;amp;quot; title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Taking that a bit further, the next groups was still simple.  Any characters that
are represented by more than 7 bits needed Unicode encoding, which I also thought was
obvious.  Once again, from an HTML author’s point of view, the following
Markdown from
&lt;a href="https://github.github.com/gfm/#example-511"&gt;example 511&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;auml&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;would obviously translate into the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"foo%20b%C3%A4"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Verifying this was correct was easy.  I had to look at the project’s
&lt;code&gt;entities.json&lt;/code&gt; file for the information on
the &lt;code&gt;&amp;amp;auml;&lt;/code&gt; symbol.  From there I quickly verified that it is represented by the
Unicode sequence
&lt;code&gt;\u00E4&lt;/code&gt;, which becomes the sequence &lt;code&gt;%C3%A4&lt;/code&gt; when encoded with &lt;code&gt;utf-8&lt;/code&gt;.  This was all
done with Python’s &lt;code&gt;urllib&lt;/code&gt; module, specifically with the &lt;code&gt;urllib.parse.quote&lt;/code&gt;
function, and it got all of these right on the first try.&lt;/p&gt;
&lt;p&gt;The issue came to the proper encoding of characters with an ordinal value below 127
(or 7F hex) that were not control characters and not alphanumeric characters. By
default, the only character that is considered safe according to the
&lt;code&gt;urllib.parse.quote&lt;/code&gt; function is the &lt;code&gt;/&lt;/code&gt; character.  When the parser
emitted the HTML for those many of those remaining characters, it replaced the actual
character with the percent-form of that character.  While both approaches are usually
syntactically equivalent, the
comparison failed because the URI was not the same as the example’s output. It
was only over the course of a couple examples that the punctuation character safe
list from above was constructed.&lt;/p&gt;
&lt;p&gt;The second group of issues came around the interaction between normal inline processing
and the processing used for links.  In cases such as
&lt;a href="https://github.github.com/gfm/#example-524"&gt;example&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="o"&gt;`#`*&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;all the inline processing occurs within the link text section and is pretty
unambiguous to what the intent is.  However, in the cases of
&lt;a href="https://github.github.com/gfm/#example-529"&gt;example 529&lt;/a&gt; to
&lt;a href="https://github.github.com/gfm/#example-534"&gt;example 534&lt;/a&gt;,
it is not as clear as to what the intent of the author was.  In the case of
&lt;a href="https://github.github.com/gfm/#example-530"&gt;example 531&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it is not clear to me at all what the author would have intended with this Markdown.
Can you figure it out?
The good news is that the GFM specification is clear on the precedence of each
of the inline processes, but even still, it took me a bit to get that precedence
properly implemented.  &lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Except for adding a metadata feature and a table of contents feature, both
which are unofficial extensions, every other feature that I normally use when writing
articles is now implemented and tested.  Having hit that personal milestone, it is a
good feeling knowing that I am THAT close to being able to run PyMarkdown against my own
articles to lint them.  The only other core feature that I sometimes use is the
image link feature, and I know that is just a couple of features away.&lt;/p&gt;
&lt;p&gt;In terms of the feature implementation and testing for this feature, the issues
I had were either caused by my misreading of the specification or caused by trying to
skip forward in the examples, and not
following the example order set out in the GFM specification.  As I have mentioned
numerous times in this section of past articles, the GFM specification is well thought
out and battle tested from many implementations.  While I do recognize that and heap
praise on them, at the same time I seem to think that I either know better than they
do or know where they are going, hence my skips forward.  I need to stop that, as it
seems to be keep getting me in trouble.&lt;/p&gt;
&lt;p&gt;Except for a couple of “didn’t I learn this already?” moments, things went fine. My
guess is that I will learn to trust this specification properly just before I finish
the last example.  Go figure.  In all seriousness, I am going to try and put more
effort into following the specification and its examples in their proper order for
the next feature, and try and get it locked in.  If I had a great specification, I
need to learn to lean into it for support, and not fight against it.&lt;/p&gt;
&lt;p&gt;At the start of this article, I expressed an interest to see if the implementation of
inline links would be as easy as the implementation for emphasis.  While there are
differences, the 17 rules around emphasis and the looking for a complete inline link
after having found the link label itself, I am very convinced that the effort
required to implement each of them was pretty similar.  As a bonus, having taken
a quick look at all of the features in the link group, I am pretty sure that the work
for inline links will be heavily leveraged to complete the link group itself.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Emphasis and link support and delimiter stack?  Done and tested.  Inline support for
links?  Done and tested.  Before going on to reference links and image links, it only
made sense to do link reference definitions next, so that is where I implemented next,
though not without a lot of difficulties.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Adding Inline Emphasis</title><link href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/" rel="alternate"></link><published>2020-03-23T00:00:00-07:00</published><updated>2020-03-23T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-23:/2020/03/23/markdown-linter-adding-inline-emphasis/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have been reading and implementing specifications for a long time.  I truly
believed that I had seen with and dealt with every situation presented in any
specification. I was therefore surprised when I started reading the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
and I noticed an entry in the table of contents …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have been reading and implementing specifications for a long time.  I truly
believed that I had seen with and dealt with every situation presented in any
specification. I was therefore surprised when I started reading the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
and I noticed an entry in the table of contents labelled
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;Phase 2: inline structure&lt;/a&gt;.
Thinking “if it is in the table of contents as a separate entry, it must be important”,
I started reading that section, waiting for some big revelation to appear.&lt;/p&gt;
&lt;p&gt;That Phase 2 section starts with an example which is an extension of the example used
in the preceding section in the document.  After a bit of comparison with the
previous example, it should be obvious that the string &lt;code&gt;\n&lt;/code&gt; was changed to &lt;code&gt;softbreak&lt;/code&gt;
and the string &lt;code&gt;"Qui *quodsi iracundia*"&lt;/code&gt; was changed to
&lt;code&gt;str "Qui " emph str "quodsi iracundia"&lt;/code&gt;.  Going back to my article on
&lt;a href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/"&gt;Autolinks, Raw HTML, and Line Breaks&lt;/a&gt;,
the translation from &lt;code&gt;\n&lt;/code&gt; to the soft line break (or soft-break) is easy to see,
the inline parser code to perform that translation having just been implemented.  And
looking at the provided example, emphasis looked like it was going to be easy.  So why
include implementation notes on it if it was so easy?&lt;/p&gt;
&lt;p&gt;On the surface, the translation of emphasis markers to emphasis would seem to be easy
to understand, if not for the start of the next section of Phase 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By far the trickiest part of inline parsing is handling emphasis, strong emphasis, links, and images. This is done using the following algorithm.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I was kind of skeptical, but I continued reading… and reading… and reading.
After a couple of thorough reads of the section in the GFM specification on
&lt;a href="https://github.github.com/gfm/#emphasis-and-strong-emphasis"&gt;Emphasis and strong emphasis&lt;/a&gt;,
I started to understand why emphasis is not as easy as it seems. At its root it is
pretty simple: use one &lt;code&gt;*&lt;/code&gt; for emphasis and &lt;code&gt;**&lt;/code&gt; for strong emphasis.  No problems
there.  If you need a subtle change in the emphasis rules, primarily around intra-word
usage and use around punctuation, use &lt;code&gt;_&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt;. Okay…why do I need so many
rules?&lt;/p&gt;
&lt;p&gt;Isn’t it &lt;em&gt;as easy&lt;/em&gt; as &lt;strong&gt;this&lt;/strong&gt;?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Isn&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;easy&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;**?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It took a bit more reading, but for me, it was some questions from the preface of
the specification that made me understand.  The big revelation finally hit me in
the form of those questions and the ambiguity that they raised.&lt;/p&gt;
&lt;p&gt;How are the following cases from the specification of strong emphasis interpreted?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;***strong emph***
***strong** in emph*
***emph* in strong**
**in strong *emph***
*in emph **strong***
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How about the following cases of nested emphasis?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*emph *with emph* in it*
**strong **with strong** in it**
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, how about intra-word emphasis?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;internal emphasis: foo*bar*baz
no emphasis: foo_bar_baz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For most of those examples, I could come up with at least 2-3 different ways that
they could be parsed.  As such, it is probably a good idea that there are 17 rules to
help with emphasis.  But before I could work on the implementation, I needed to
do some more research.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ad66340685ba128fa522a6d275ae55348951c96c"&gt;10 March 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/23e77f98d9ab4a7a8d05285cbc11293a96c9ed11"&gt;13 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="emphasis-is-hard-and-not-always-consistent"&gt;Emphasis is Hard and not always Consistent&lt;a class="headerlink" href="#emphasis-is-hard-and-not-always-consistent" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For any readers that have been following this series, it might be apparent that I have
veered away from my usual habits.  Usually I label all of my Markdown code blocks
properly to allow my
&lt;a href="https://jackdewinter.github.io/2019/08/25/static-websites-setting-up-the-pelican-static-site-generator/"&gt;static site generator&lt;/a&gt;
to take care of the proper coloring. However, for the above examples, I just marked
them as normal text blocks without any language specified.  This
was not a mistake; it was a conscious decision.&lt;/p&gt;
&lt;p&gt;When I started entering the fenced code
block for the text, everything looked normal. However, once I added the &lt;code&gt;Markdown&lt;/code&gt;
language tag at the start of the block, that all changed.  What I saw in my VSCode
editor was the following:&lt;/p&gt;
&lt;p&gt;&lt;img alt="python logo" src="https://jackdewinter.github.io/images/linter-12/vscode.png"/&gt;&lt;/p&gt;
&lt;p&gt;Publishing the page and looking there, I saw that same text rendered as:&lt;/p&gt;
&lt;p&gt;&lt;img alt="python logo" src="https://jackdewinter.github.io/images/linter-12/chrome.png"/&gt;&lt;/p&gt;
&lt;p&gt;And finally, running it through my favorite GFM test link, the following was generated:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;strong emph&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;
&lt;em&gt;&lt;strong&gt;strong&lt;/strong&gt; in emph&lt;/em&gt;&lt;br/&gt;
&lt;strong&gt;&lt;em&gt;emph&lt;/em&gt; in strong&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;in strong &lt;em&gt;emph&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;
&lt;em&gt;in emph &lt;strong&gt;strong&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Three different platforms and three different ways to interpret the emphasis.
To me, it was then that it was apparent why a consistent way to implement
emphasis was needed in order to produce consistent results.&lt;/p&gt;
&lt;h2 id="utilizing-the-wisdom-of-others"&gt;Utilizing the Wisdom of Others&lt;a class="headerlink" href="#utilizing-the-wisdom-of-others" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Instead of trying to figure everything out myself, tempting as that can be sometimes,
I decided to implement the algorithm as stated in the GFM specification with one small
change: no links for now. To accomplish this, I kept to the algorithm’s recipe as
described, but I left the implementation of the &lt;code&gt;look for link or image&lt;/code&gt; section for
later.  My plan was to focus on the emphasis itself before moving on to
links, which I still believe was a very good decision on my part.&lt;/p&gt;
&lt;p&gt;In looking at the algorithm through a bit of a sideways lens, I observed that there were
two main tasks that the algorithm accomplishes: building the delimiter stack and
resolving that same delimiter stack.  Without taking a two-phase approach to the
algorithm, I determined that I would be multitasking two separate objectives, and not
doing either of them very well.  I just felt strongly that it was better to split the
task in two and focus on each one until it’s completion.  In the end, I was going to
finish both part of the algorithm, so if both tasks were done, emphasis would
be implemented.&lt;/p&gt;
&lt;p&gt;The first task: building the delimiter stack.&lt;/p&gt;
&lt;h2 id="building-the-delimiter-stack"&gt;Building the Delimiter Stack&lt;a class="headerlink" href="#building-the-delimiter-stack" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a high-level look at the algorithm, I came up with the following two
observations. In cases where a delimiter is not used in a special way, it needs to be
represented by a simple text node.  Where it is used in a special way, it may need to
be removed and properly replaced with the tokens that the delimiters represent. The
“may” part of that last statement is there as, after looking at some of those examples,
it may be possible to have a case where the parser only uses some of the emphasis
delimiters, but not all of them.  Once such example is the string &lt;code&gt;this **is* my text&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To accomplish this, I created a new class &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; that is a child
of the &lt;code&gt;TextMarkdownToken&lt;/code&gt; class.  In cases where the delimiter is not completely
consumed, this allows the new token to be easily consumed by existing code, without
any modifications needed.  Supporting the additional parsing requirements, the new
&lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; tokens adds the &lt;code&gt;repeat_count&lt;/code&gt;, &lt;code&gt;active&lt;/code&gt;, &lt;code&gt;preceding_two&lt;/code&gt;,
and &lt;code&gt;following_two&lt;/code&gt; fields, enabling the algorithm to be implemented properly.
Finally, but most importantly, to ensure the algorithm works properly, that new token
is added to the delimiter stack.&lt;/p&gt;
&lt;p&gt;To properly test that I had produced the correct tokens and delimiter stack,
I started by enabling one of the emphasis tests and examining the resulting tokens.
I compared those tokens against the tokens that were there before, looking for
changes that I expected to be induced by the presence of the emphasis delimiters.  As I
was only building the delimiter stack at this point in the process, this was easy to
verify.&lt;/p&gt;
&lt;p&gt;A solid example of this is the emphasis test for
&lt;a href="https://github.github.com/gfm/#example-364"&gt;example 364&lt;/a&gt;,
which is the example that I selected as my initial test.  That example contains the
string &lt;code&gt;foo*bar*&lt;/code&gt; to test against and is a pretty easy example. Before the delimiter
stack was built, I verified that the string was represented by a single
&lt;code&gt;TextMarkdownToken&lt;/code&gt; token containing the string &lt;code&gt;foo*bar*&lt;/code&gt;.  After the delimiter stack
was built, that same string was represented by 4 tokens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;code&gt;TextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;TextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, the delimiter stack contained both &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt;
tokens in the order that they appear.  At this point in the process, that was the
expected token output, and I was happy to see it work so well.&lt;/p&gt;
&lt;p&gt;As one good test was not solid proof to me, I continued to make sure that I had decent
results after building the delimiter stack by repeating this examination with 5-6
other tests.  While there were a couple of small issues along the way, I was able to
quickly get to the part where I had a high degree of confidence that the delimiter
stack was correct.  Now it was on to the resolution of that stack.&lt;/p&gt;
&lt;h2 id="resolving-the-delimiter-stack"&gt;Resolving the Delimiter Stack&lt;a class="headerlink" href="#resolving-the-delimiter-stack" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Skipping past the &lt;code&gt;look for link or image&lt;/code&gt; section of the GFM specification, I sat down
with my headphones on and poured over the section on &lt;code&gt;process emphasis&lt;/code&gt; a couple of
times, taking notes as I went.  I then went back to the
&lt;a href="https://github.github.com/gfm/#emphasis-and-strong-emphasis"&gt;emphasis scetion&lt;/a&gt;
of the GFM and started pairing each of the 17 rules to each note that I made and was
happy to find a 1-to-1 mapping between the two lists.&lt;/p&gt;
&lt;p&gt;And yes, that is right… 17 rules.  It did take a while, but I validated each step
in the specification against each of the rules, making detailed notes as I went.  While
it was slow to emerge, by the time I reached the last rule I had a plan to follow.
To implement each rule, I would implement the tests in order of the rules that they
support, with a slightly irregular start order.  Basically, instead of starting with a
“1 2 3 4” order, I started with a “3 1 4 2” order.  The reason for this weird ordering
is because the algorithm starts by identifying eligible closing emphasis, then trying
to locate a matching start emphasis.  To accommodate that, I decided to start with the
close and start pair for the normal emphasis (&lt;code&gt;*&lt;/code&gt; character) following that same pattern
with the strong emphasis (&lt;code&gt;_&lt;/code&gt; character).&lt;/p&gt;
&lt;p&gt;While I was thankful for the examples in the GFM specification before implementing
emphasis, having the emphasis examples, rules, and examples-by-rule-groups made me
even more thankful.   Starting with rules 3 and 1, I was able to get solid code written
to implement what was needed to support those rules.  The next two rules, rules 4
and 2, were added using the first two rules as a building block.  For the remaining
13 rules, I just felt that each rule and the examples to support it just naturally
flowed, each one adding another small piece of the puzzle.  While it did take some
time to get all 17 rules implemented and the tests for all 130 examples passing, it
all felt like just another step.  It was a nice feeling.&lt;/p&gt;
&lt;h2 id="emphasis-the-base-cases"&gt;Emphasis - The Base Cases&lt;a class="headerlink" href="#emphasis-the-base-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I progressed with the rules, it was nice to see the natural progressing in the
sequences that I was enabling for the parser.  This progression was so natural
and straightforward, I want to take the time to show how things progressed over
the course of the 17 rules.  The truth is that when I was finished, it felt
more like 4-5 rules than 17 rules.&lt;/p&gt;
&lt;p&gt;In order of enablement, first there were
the simple sequences enabled in rules 1 to 4:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;This is *my* emphasis.
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;This is &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;my&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; emphasis.&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; emphasis.&lt;/p&gt;
&lt;p&gt;Rules 5 to 8 added strong emphasis:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;This is *my* **strong** emphasis.
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;This is &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;my&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;strong&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; emphasis.&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; &lt;strong&gt;strong&lt;/strong&gt; emphasis.&lt;/p&gt;
&lt;p&gt;Rules 9 and 10 added clarity on how to handle nested emphasis:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*foo**bar**baz*
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;foo&lt;strong&gt;bar&lt;/strong&gt;baz&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Rules 11 and 12 add clarity on escaping delimiters and how excess delimiters are
handled:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;***foo**
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;*&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;*&lt;strong&gt;foo&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="emphasis-resolving-the-ambiguity-of-complex-cases"&gt;Emphasis - Resolving the Ambiguity of Complex Cases&lt;a class="headerlink" href="#emphasis-resolving-the-ambiguity-of-complex-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Using just the prior rules, there were many representations that could be
inconsistent from parser to parser.  These rules are used to resolve that ambiguity.
As these rules resolve ambiguity, I am only showing the HTML output in a code block
instead of showing the HTML output in a code block and the actual HTML itself.&lt;/p&gt;
&lt;p&gt;Rule 13 adds the concept that one &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; is preferred to &lt;code&gt;&amp;lt;em&amp;gt;&amp;lt;em&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;******foo******
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 14 adds the concept that the &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; tags should always deeper than the &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;
tags, if used together:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;***foo***
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 15 adds the concept that in a case of overlapping emphasis spans, the emphasis
span that ends first overrides the interpretation of the second possible emphasis
span as an actual emphasis span.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*foo _bar* baz_
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo _bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; baz_&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 16 adds the concept that if two emphasis spans have the same closing delimiter,
the shorter of those two emphasis spans is interpreted as an actual emphasis span.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;**foo **bar baz**
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;**foo &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 17 adds a clarification that number of inline elements are more tightly grouped
that emphasis spans, meaning that the parsing of those inline elements takes precedence
over the parsing of the emphasis spans.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*a `*`*
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;a &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;*&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="emphasis-rule-summary"&gt;Emphasis - Rule Summary&lt;a class="headerlink" href="#emphasis-rule-summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Without implementing a Markdown parser, it might be hard to appreciate how
natural the process of building the emphasis support into the parser was.  But please
believe me, it was a thing of beauty.  The best way to describe it was that as I
was implementing each section, I jotted down notes for myself that usually started
with “what about…”.  It was usually within a rule or two that I scratched off that
note as it was no longer an issue.  By the time I got to the end of the emphasis
implementation, all the notes were scratched off.  That kind of progression when
implementing a specification are rare, and it was just wonderful to witness.&lt;/p&gt;
&lt;h2 id="what-were-the-bumps-on-the-road"&gt;What were the bumps on the road?&lt;a class="headerlink" href="#what-were-the-bumps-on-the-road" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the implementation to support inline emphasis, other than “fat man finger”
typing errors, there were only a couple of issues that impeded its addition to the
parser.  The first was because I got impatient and tried to implement one of the rules
ahead of time and the second was caused by a subtle change I made to the algorithm
and the side effects that I needed to abate. Other than those two issues, the
development just flowed easily from the rules and their examples.&lt;/p&gt;
&lt;p&gt;The impatience issue occurred when I was trying to take care of a side-effect of rule
11, but I was trying to take care of it when implementing rule 1.  It sidetracked me
for a couple of hours without any resolution.  It was not until I double checked that it
was indeed part of rule 11 that I abandoned it until later.  The “funny” thing is that
when I did get to implementing rule 11 in the proper order, it was implemented with
almost no friction in less than 5 minutes. Because of the way the rules build on
each other, in hindsight it makes perfect sense that I ran into issues trying to
implement part of rule 11 at the beginning.&lt;/p&gt;
&lt;p&gt;The change issue was caused by a subtle change that I made to the algorithm to better
deal with Python’s data structures.  To simplify the implementation in Python, the
references in the
delimiter stack were made with indices (or “indexes” for Americans) instead of pointers.
In the “if one is found” section of the algorithm there are two cases where the
algorithm calls for the removal of nodes from the delimiter stack.  Instead of removing
the elements of the delimiter stack and recomputing the indices, I just altered the
algorithm to work better with the &lt;code&gt;active&lt;/code&gt; field.  While this did cause a few
small issues that needed to be resolved, in the end I believe it still was a better
course of development to take.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having taken time to do my research and to have a solid plan emerge, it was nice to see
that the plan paying off after the code for the first couple of rules were
implemented.  Often when you plan an approach for a project, in your head you always
think things like “I’ll have to switch to plan B if I see…”.  In this case, while
I still thought that, I was able to stick with my first plan the entire way through.
That was nice and gratifying.&lt;/p&gt;
&lt;p&gt;I also cannot stress how impressed I am with the authors of the GFM specification and
the effort they took to specify the emphasis elements.  Not only did they work hard
to resolve any ambiguity with 17 rules, but they provided a solid road map for
implementers to follow with a suggested approach.  For me, the beauty of those two
parts of the specification is how they weave together, each one reinforcing the other
one.  In its simplest form, they took something that I was sure was going to be
a headache and made it very easy to implement correctly.&lt;/p&gt;
&lt;p&gt;Basically, I started this part of the parser with a feeling of dread, thinking that
I would plan an approach and switch to plan B, or even to plan F.  But
with some good planning on the behalf of the authors of the GFM specification, it
went off without any major issues.  It was cool to see that happen.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having had a very smooth time implementing emphasis, it was very tempting to just dive
in and tackle all of the link support at the same time.  However, in looking at the
different types of links in the specification, I decided that inline links would be
a good place to start.  That is where I will pick up in my next article!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Verifying Base Scenarios</title><link href="https://jackdewinter.github.io/2020/03/16/markdown-linter-verifying-base-scenarios/" rel="alternate"></link><published>2020-03-16T00:00:00-07:00</published><updated>2020-03-16T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-16:/2020/03/16/markdown-linter-verifying-base-scenarios/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the wrap up for
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#what-was-my-experience-so-far"&gt;my last article&lt;/a&gt;,
I provided extra information on my decision to write a Markdown parser as part of
the PyMarkdown project.  My belief
is that the writing of an effective Markdown linter requires a parser that emits an
intermediate set of tokens instead of …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the wrap up for
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#what-was-my-experience-so-far"&gt;my last article&lt;/a&gt;,
I provided extra information on my decision to write a Markdown parser as part of
the PyMarkdown project.  My belief
is that the writing of an effective Markdown linter requires a parser that emits an
intermediate set of tokens instead of the usual HTML output. Accordingly, from the
start of the project, all the scenario tests for the parser have dealt with those
generated tokens and not the usual HTML output.  Based on my experience to date,
both the belief in a non-HTML parser and the decision to test the tokens have proven to
be the right choices.  During the project development to date, I have not
observed a specific case where I believe that there would have been a substantial
benefit in comparing the output to HTML instead of the intermediate tokens. However,
even with that in mind, the lack of a direct comparison between the output specified in
the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
and the output of the parser started to erode my confidence, even if just fractionally.&lt;/p&gt;
&lt;p&gt;The questions that came to mind were simple ones.  Did I keep the right information
when parsing the Markdown to enable a HTML transformation of the tokens?  Did I pick
the right token to represent a Markdown element in the token stream?  Do the tokens
contain enough information in them to allow me to write linting rules off them?  For
me, these questions are relevant given the nature of the project.&lt;/p&gt;
&lt;p&gt;Looking at those three questions, I quickly realized that answering that last
question was impossible until I start writing the linting rules.  Sure, I could take
a guess, but that is all it would be.  However, I realized that I could probably
answer the first two questions and that there was significant benefit to be gained
from doing so.  If I can write a token-to-HTML translator and apply it to that
token stream, when the HTML output for all scenarios match, I have answered the first
question.  And while I cannot answer the second question completely, if the translation
to HTML is simple enough, I will have proven that I am headed in the right direction
with respect to making good choices for the representative tokens. While I cannot prove
that those choices are not perfect choices until the rules are written, I can at least
prove to myself that my token choices are in the right direction.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f9a0e31d0abb8bb22ae071250986f0925f2b7bcb"&gt;29 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/256432757e9a9b2ceca423cf228c5cb362ea61bc"&gt;06 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="finishing-up-the-scenario-tests"&gt;Finishing Up the Scenario Tests&lt;a class="headerlink" href="#finishing-up-the-scenario-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For me, this task was essentially a bookkeeping issue.  As the remaining features were
the emphasis elements and the link elements, it felt like the
right time to march through the remaining scenarios and implement them as scenario
tests.&lt;/p&gt;
&lt;p&gt;These scenario tests fell into two categories.  In the first category,
if the scenario needed to test a failure using already implemented features, I copied
over an existing test, changed the Markdown input, executed the new test, and copied
the tokens from the newly executed test output in that test, manually verifying the
tokens as I copied them.
Basically, I figured that if the scenario test is failing in a manner that will not
change even when the owning feature is implemented, then completing the test was the
best choice for the project.
In the second category, I did the same thing except I stopped before the execution step,
instead adding a &lt;code&gt;@skip&lt;/code&gt; tag to the test’s definition.  In this way, I was able
to add the bulk of the remaining tests without having tests that would obviously fail
getting in the way.&lt;/p&gt;
&lt;p&gt;While this may have seemed like busy work, it was meant to give me a realistic picture
of how close I was to finishing the parser, and it worked.  By executing
&lt;code&gt;pipenv run pytest&lt;/code&gt;, I executed every test and was able to look for entire modules
with skipped tests, getting a good indication of what features and testing was left.
From a wholistic point of view, it was good to see that out of the
875+ tests in the project so far, there were only just over 100 tests left to go before
the parser would be completed.  Being able to see how close I was to finishing the
parser was definitely worthwhile!&lt;/p&gt;
&lt;h2 id="adding-test-grouping"&gt;Adding Test Grouping&lt;a class="headerlink" href="#adding-test-grouping" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I knew from the start that this would be the monotonous part, so I tried to make sure
that I could stage the changes as I brought more scenario tests online.  The first
thing I did was to add a new marker for PyTest to the project by adding this line to
the &lt;code&gt;setup.cfg&lt;/code&gt; file for the project:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;markers=gfm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This change allowed me to use one of PyTest’s grouping features:
&lt;a href="https://docs.pytest.org/en/latest/mark.html"&gt;marking&lt;/a&gt;.  By changing
a scenario test’s definition from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@pytest.mark.gfm&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I included that test into the &lt;code&gt;gfm&lt;/code&gt; group.  While I can still execute that test by
itself by entering &lt;code&gt;pipenv run pytest -k 032&lt;/code&gt;, I could now execute all tests in
the &lt;code&gt;gfm&lt;/code&gt; group by entering &lt;code&gt;pipenv run pytest -m gfm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This command was invaluable during development of the parser.  After adding HTML
translation support to a scenario test, I ensured that it was added to this group,
thereby staging the scenario test with its owning feature. After completing the change
to make the test pass, I then executed all the tests in the &lt;code&gt;gfm&lt;/code&gt; group to ensure that
I didn’t break anything else in the process.  While it caused me some issues from time
to time, it was an extra watch over the completed work, one that I appreciated.&lt;/p&gt;
&lt;h2 id="adding-translating-into-html"&gt;Adding Translating into HTML&lt;a class="headerlink" href="#adding-translating-into-html" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Translating any stream into something requires a loop to process through each element
in the stream, with some mix of emitting data and altering state.
I created the &lt;code&gt;TransformToGfm&lt;/code&gt; class to handle that translation, with the &lt;code&gt;transform&lt;/code&gt;
entry point to facilitate the transformation.  At this point in the implementation,
this class was very simple.  As each token was seen in the loop, its data was emitted
with only minor additional processing required.&lt;/p&gt;
&lt;p&gt;Adding this support into existing tests was easy, just monotonous.  Using the
same test 32 that was used in the prior example, that test changed from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@pytest.mark.gfm&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 032:  Simple headings&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;tokenizer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""some markdown"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;actual_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@pytest.mark.gfm&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 032:  Simple headings&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;tokenizer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;transformer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TransformToGfm&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""some markdown"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;expected_gfm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""&amp;lt;p&amp;gt;some markdown&amp;lt;/p&amp;gt;"""&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;actual_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;actual_gfm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transformer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_strings_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_gfm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_gfm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order of appearance, an instance of the &lt;code&gt;TransformToGfm&lt;/code&gt; class was added, the
&lt;code&gt;expected_gfm&lt;/code&gt; variable was set to the expected HTML, the &lt;code&gt;transform&lt;/code&gt; function was
called, and then the contents of the &lt;code&gt;expected_gfm&lt;/code&gt; variable were compared against
the output from the &lt;code&gt;transform&lt;/code&gt; function.  Except for the expected changes to the
&lt;code&gt;expected_gfm&lt;/code&gt; variable for each test, this transformation was repeated for each test
as support for the feature it enabled was added.&lt;/p&gt;
&lt;h2 id="translating-the-leaf-blocks"&gt;Translating the Leaf Blocks&lt;a class="headerlink" href="#translating-the-leaf-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Translating the leaf block tokens added in
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;this article&lt;/a&gt; and
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/"&gt;this article&lt;/a&gt;
proceeded quickly, encountering only a few unexpected issues.  These issues
fell into two categories: the handling of HTML blocks and code blocks, and the handling
of newlines in the HTML output.&lt;/p&gt;
&lt;p&gt;Most of the issues that were uncovered for leaf blocks dealt with the processing of
HTML blocks and code blocks. As mentioned in previous articles,
these two leaf blocks are special in that they maintain firm control over the formatting
of their content.  To accommodate these two leaf block types, the handling of the
&lt;code&gt;TextMarkdownToken&lt;/code&gt; was changed to accommodate the stricter output requirements of
those blocks, mostly ensuring that whitespace was preserved.  Other than that, the only
other changes needed for processing was to change most of the tokens to expose
certain fields, allowing the translator to access the token’s attributes cleanly.&lt;/p&gt;
&lt;p&gt;From a rendering viewpoint, I had guessed that any newlines in the HTML output were
going to be a problem from the start and I was right.
While the GFM is purposefully vague on when to add newlines in the
translation from Markdown to HTML, it was a vagueness that I could not avoid.  As the
main push for this article’s work was to add proper comparisons of the GFM’s HTML
output for each example, I had a hard choice to make.  Either I make modifications to
each of the 673 scenarios as I copied their HTML output into the scenario tests,
or I needed to ensure that the translation replicated the HTML &lt;em&gt;exactly&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;After a lot of thinking, I decided to go with the exact HTML output path, hopefully
removing any possible errors that may have occurred during the translation of the
HTML output for each scenario test.
When I thought about both options, I just felt that I would almost instantly regret
making any changes to the HTML output, as it would no longer be synchronized to the
GFM specification. Considering that, I figured it was better
to be consistent and do a bit more work on the project than to
start changing the scenarios.&lt;/p&gt;
&lt;p&gt;My current focus was on enabling the HTML comparisons, and I knew it was going to take
more effort and time to get them right. As such, I decided to add a fair number of “if
this look like” conditions to add or not add newlines, with plans to later refactor the
code to look for better groupings down the road.  I do not like adding technical debt
just for the sake of expediency, but I just felt it was the right decision at the time.
I figured by adjusting the translator with little tweaks here and there would give
me a more complete picture on what needed done for a proper refactor later.  It was not
a perfect decision, but it was one that I felt I could live with.&lt;/p&gt;
&lt;p&gt;When all the leaf blocks were completed, I did notice a decent boost in my
confidence.  Except for some issues with getting newlines right, the translation of
leaf blocks was straightforward.  Knowing that I had made good decisions
so far gave me that boost… something that I would need sooner rather than later.&lt;/p&gt;
&lt;h2 id="translating-the-container-blocks"&gt;Translating the Container Blocks&lt;a class="headerlink" href="#translating-the-container-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the translation of the leaf blocks went smoothly, I hit a number of issues dealing
with the container blocks added in
&lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/"&gt;this article&lt;/a&gt;.
While the block quotes themselves were not
really an issue, the list blocks that caused me a lot of trouble.&lt;/p&gt;
&lt;p&gt;In implementing the list block support in the translator, I was able to quickly get
to a point where the tags themselves were being emitted properly, but the whitespace
around the tags were off, especially with the newlines.  That was frustrating, but with
some helpful observations and experimentation, I was able to get that taken care of
relatively quickly.&lt;/p&gt;
&lt;p&gt;Following that triumph, I spent a few aggravating
days trying to figure out why some list items contained &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags and why some list
items didn’t contain &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags.  I tried a couple approaches based on
the surrounding tags and tokens, but each of them failed.  It wasn’t until I was looking
at the specification again, when I took another look at the lists section and noticed
the following paragraph in the
&lt;a href="https://github.github.com/gfm/#lists"&gt;lists section&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A list is loose if any of its constituent list items are separated by blank lines, or if any of its constituent list items directly contain two block-level elements with a blank line between them. Otherwise a list is tight. (The difference in HTML output is that paragraphs in a loose list are wrapped in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags, while paragraphs in a tight list are not.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That was the information I was searching for!  While the actual implementation is a bit
more complicated than just that, that is the essence of when I needed to add the
paragraph tags.&lt;/p&gt;
&lt;p&gt;The complications in implementation arose as the examples became more complex.  For
example, based on the above description, it is easy to see that this modified
&lt;a href="https://github.github.com/gfm/#example-294"&gt;example 294&lt;/a&gt;
is a strict list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and this unmodified
&lt;a href="https://github.github.com/gfm/#example-294"&gt;example 294&lt;/a&gt; is a loose list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From the above lists section quote, since there is a blank line that separates
two of the list elements, it is a loose list.  Pretty easy and straight forward.
Implementing this aspect of looseness was decently easy but did require some
non-trivial extra code. Basically, go back to the start of the current list, then go
through each list element in the list, looking to see if the Markdown element before it
is a blank line.  If so, mark the entire list as loose and apply that throughout the
list.&lt;/p&gt;
&lt;p&gt;However, when dealing with lists and sublists, it was not so simple.  For example,
consider the Markdown from
&lt;a href="https://github.github.com/gfm/#example-299"&gt;example 299&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

    &lt;span class="k"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Understanding the Markdown list blocks can be nested and following the guidance from
the above quote, you can deduce that the outer list is tight and the sublist is loose.
To make the leap from handling the previous 2 examples to this example would mean that
I needed to find a way to add scoping to the translation. Without scoping, when the
translator processed the above example, it saw 3 items in the same list, with the
second element making the entire list loose.  Scoping was required to allow the
translator to determine that the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; items were in one list and the &lt;code&gt;b/c&lt;/code&gt; item
was in it’s own list, therefore determining the correct looseness for both lists.&lt;/p&gt;
&lt;p&gt;The code itself to handle scoping was simple, but the tradeoff was that the
translator was slowly becoming more complicated, something that I was not happy
about.  It was not in dangerous territory yet, but it was something to keep a watch out
for.  In addition, while the difference between a list being lose or strict is
obvious in hindsight, at the time it was very annoying.  It took me the better part of
4 days to do something that was obvious.  Even better than obvious was the fact
that it was plainly spelled out in the specification.  But as I had to do a number of
other times during this project, I picked myself up, dusted myself off, and continued on
with the inline translations.&lt;/p&gt;
&lt;h2 id="translating-inlines-backslash-escapes-character-references-and-code-spans"&gt;Translating Inlines - Backslash Escapes, Character References, and Code Spans&lt;a class="headerlink" href="#translating-inlines-backslash-escapes-character-references-and-code-spans" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During this translation process, first I hit a high, then I hit a low, and then I saw
the payoff of both with the translation of these inline elements into HTML.  These
elements consist of
the backslash escapes, character references, and code spans elements, and were added in
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/"&gt;this article&lt;/a&gt;. Apart from
a couple of typos and the code spans, adding support for these features flew past
quickly. The backslash escapes and character references were already being processed
along with the
text tokens, which in turn were already tested with the leaf blocks.  The only new
code needed was for code spans, but those additions were quickly made by copying the
work done for code blocks and simplifying it a bit.  Other than a couple of typos that
I also needed to correct; the entire body of this work was completed in just under 3
hours.  And to be honest, that included me grabbing some well-deserved dinner.&lt;/p&gt;
&lt;p&gt;Based on the days of trying to figure out list blocks and paragraph tags from the
last section, it was nice to get a real easy set of changes.  It wasn’t anything
challenging, just… nice.&lt;/p&gt;
&lt;h2 id="translating-inlines-raw-html-autolinks-and-line-breaks"&gt;Translating Inlines - Raw Html, Autolinks, and Line Breaks&lt;a class="headerlink" href="#translating-inlines-raw-html-autolinks-and-line-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Rounding out the series of translations were the tests for raw html, autolinks, and
line breaks.  With features just added in the
&lt;a href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/"&gt;last article&lt;/a&gt;,
the tests for these features were added with only a couple of issues, similar in
severity to the issues from the leaf blocks.&lt;/p&gt;
&lt;p&gt;The largest group of issues encountered were issues with character encodings in
the autolinks feature.  Some of those issues were due to Unicode characters being
present in the Markdown but needing to be properly encoded and escaped when present
in URIs.  Some of the issues were because the characters present in the URIs are
special characters and had to be escaped to prevent them from being encoded twice.&lt;/p&gt;
&lt;p&gt;However, the most annoying issues were differences in the language libraries that
caused the translator to URI-encode a different set of characters than in the
GFM specification.  Specifically, it looks like the Commonmark parser uses the
Javascript libraries to encode URIs, while the PyMarkdown project uses the Python
libraries.  I wasn’t too concerned with these issues at the current time, so I made
sure to add some notes to address these concerns later and kept on marching forward.&lt;/p&gt;
&lt;p&gt;The big catch with these changes was with the scenario test for the GFM specification’s
&lt;a href="https://github.github.com/gfm/#example-641"&gt;example 641&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it might seem like a small difference when looking at a web page, the
PyMarkdown parser emitted a HTML block and a tag as content instead of
emitting a simple paragraph containing text, as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="ni"&gt;&amp;amp;lt;&lt;/span&gt;a href='bar'title=title&lt;span class="ni"&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looking at the HTML output in the example, it is very clear that it should be a
paragraph containing text,
but somewhere in the copy-and-paste process I had accepted the wrongs tokens as
correct.  Digging into this issue, I quickly found out that a single omission in one of
the functions of the &lt;code&gt;HtmlHelper&lt;/code&gt; module was not checking for whitespace between the
tag’s attributes, therefore thinking that it was a valid tag when it was not.  Within 5
minutes, I had a fix implemented, and the test corrected, and the last scenario test
that was currently implemented was now complete!&lt;/p&gt;
&lt;p&gt;As a strange aside, I may not have the only parser that has made this mistake. When
I was writing this article in VSCode, as usual, I had to check the example’s Markdown
a few times.  The Markdown in the above section was generated with the following
fenced code block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;&lt;span class="n"&gt;Markdown&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Its a pretty simple example, and I typed it in as I usually do.  Create the fenced
block, add in the text from its source, verify it a couple of times, and then add in
the language specifier.  As soon as I typed in &lt;code&gt;Markdown&lt;/code&gt;, a strange thing happened.
The &lt;code&gt;a&lt;/code&gt; for the tag name turned into a deep blue, as expected.  But then both
attribute names, &lt;code&gt;href&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt;, turned light blue while the attribute values,
&lt;code&gt;`bar`&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; turned red.  I added a space before &lt;code&gt;title&lt;/code&gt; and then deleted
it, repeating
this experiment a couple of times, looking for color changes.  There were none.  For
whatever reasons, the coloring library that VSCode is using to color Markdown text
seems to believe that example 641 contains valid Markdown.  Weird!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In writing automation tests as part of my professional job, I have a clear distinction
in my responsibility to my team.  I am not there to break their code or to find flaws
in it, I am there to help them find issues before they become problems.  If
possible, I stress automated tests over manual tests, and I also stress being able to
adopt consistent processes to shine a very focused light on anything that is different.&lt;/p&gt;
&lt;p&gt;The mere fact that I found a couple small issues with the parser, even at this
late stage of the project is fine with me.  I am helping my team (me) find these issues
before the code is released and impacts other people and their processes.  While it was
a large pain to go through, I felt that I closed part of the testing the loop by
consistently adding HTML output verification to each parser scenario test.  The mere
fact that the issues were found proves its own worth.  In addition, there was a small
efficiency and confidence boost because I do not have to guess anymore as to whether or
not I chose the right tokens.  The HTML output from the examples proved that I made the
right choices.&lt;/p&gt;
&lt;p&gt;In the end, what it boils down to for me is that while adding the HTML output
verification to each test was painfully monotonous at times, it paid off.  While
only a handful of issues were uncovered, it did find at least one issue, which itself
boosted my confidence in the project.
Regardless of whether any issues were found, knowing that the tokens that
the parser was generating were being properly translated into the GFM specification’s
HTML output was worth it.  No more questioning whether the tokens would
translate into the proper HTML… I now had proof they did!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Whenever a protocol specification states something like “and here is a suggested
way of…”, it usually means that at least 2-3 groups of people implementing the
protocol specification had issues.  So, it was with a bit of dread and a bit of
confidence that I started looking at dealing with inline emphasis, the topic of the
next article.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Autolinks, Raw HTML, and Line Breaks</title><link href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/" rel="alternate"></link><published>2020-03-09T00:00:00-07:00</published><updated>2020-03-09T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-09:/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed another refactoring session, I have confidence that the PyMarkdown
project code has been returned to what I feel is a healthy amount of technical debt.
After taking a deep breath and a good look at the features left to implement, I
realized that the list is now …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed another refactoring session, I have confidence that the PyMarkdown
project code has been returned to what I feel is a healthy amount of technical debt.
After taking a deep breath and a good look at the features left to implement, I
realized that the list is now decently short: emphasis, links, autolinks, raw HTML, and
line breaks.  Rechecking the section on
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;inline structure&lt;/a&gt;
in the GitHub Flavored Markdown (GFM) specification, it is hard to miss the fact that
the emphasis and link elements have their own “here is a suggested approach to
implementation” section while the implementation for parsing the
other elements are left up to the reader.  Deciding that the authors of the GFM
were trying to tell me something, I decided to focus on autolinks, raw HTML, and line
breaks first, leaving the emphasis and links for the last chunk of features.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/6ea7929d95468e28170671dc19214bd09507f04c"&gt;22 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/dffd948cf8e4066121dbb11ae68c385370a20877"&gt;27 February 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="my-take-on-html-in-markdown"&gt;My Take on HTML in Markdown&lt;a class="headerlink" href="#my-take-on-html-in-markdown" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Back in the article
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/"&gt;Markdown Linter - Adding HTML Blocks&lt;/a&gt;,
I provided
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#my-recommendation"&gt;a recommendation&lt;/a&gt;
as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When it comes to HTML blocks, I implemented them as part of the parser because they are part of the specification. But because of the complexity in understanding HTML blocks, I whole heartedly recommend avoiding using HTML blocks if at all possible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The big problem I have with HTML blocks is that there are 7 types of HTML blocks, and
each one has a different ending condition.  As an author that heavily uses Markdown,
I want any documents that I create to be simple and easy to read.  In my opinion,
without a lot of memorization, HTML blocks are not simple at all.  &lt;/p&gt;
&lt;p&gt;Raw HTML elements are on the complete other end of the spectrum.  If I had my way
with the GFM specification, I would demote and remove HTML blocks entirely and replace
them with raw HTML.  Raw HTML is exactly as it sounds: what you type is what you get.
The good news is that if you follow a couple of easy to memorize rules, you can do this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NEVER start a line with a HTML tag&lt;/li&gt;
&lt;li&gt;Markdown is an authoring language, and should only use HTML sparingly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In support the first rule, my reading of the start conditions of each of the
&lt;a href="https://github.github.com/gfm/#html-blocks"&gt;HTML block types&lt;/a&gt;
in the GFM concludes with the observation that all start conditions begin with the text
“line begins…”.  Thus, I created the first rule to ensure that I never inadvertently
trigger a HTML block.  Any non-whitespace text and then any HTML is fine, just not
by itself at the start of the line.&lt;/p&gt;
&lt;p&gt;My second rule may seem like my own opinion, but I believe it is a solid rule.  While
it is useful to read the GFM section on
&lt;a href="https://github.github.com/gfm/#what-is-markdown-"&gt;What is Markdown?&lt;/a&gt;,
that section boils down to this one quote from that section by John Gruber:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is little question that having the ability to add a HTML tag where needed is a
good feature of Markdown.  However, I would contend that any HTML tags that are added
are contrary to Gruber’s stated goal for a document to not be marked up with tags. As
such, unless Gruber’s readability goal is dismissed, anything more than sparing use of
HTML in a Markdown document is harmful.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong, but there are good use cases for HTML, but they are rare.  In the
5-6 years that I have been authoring documents in Markdown, there are only two times
I have ever used HTML tags in Markdown documents.  The first time is in the writing of
these articles on the Markdown parser for the PyMarkdown project and the other time was
for a project that used the &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;/ul&amp;gt;&lt;/code&gt; tags to satisfy a legal documentation
requirement for text underlining.  From talking with other developers using Markdown
parsers that underling text is a popular request along with a blanket request to
disable all HTML tag support in Markdown, mostly for security reasons.&lt;/p&gt;
&lt;p&gt;So, for what it is worth, that is my take on HTML in Markdown, and my reasons for that
opinion.  Your mileage may vary.&lt;/p&gt;
&lt;h2 id="raw-html"&gt;Raw Html&lt;a class="headerlink" href="#raw-html" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unlike the rules that an author needs to memorize to properly use HTML blocks, using raw
HTML in Markdown is very simple: its either a legal HTML tag or it gets interpreted
as normal text.  No “if it’s a blah tag, then…” rules.  Just valid or invalid.  No
ending conditions as raw HTML is inline processing of text.  Simple. Easy. Clean.&lt;/p&gt;
&lt;p&gt;The reason that I can be comfortable in saying that raw HTML is simple is the following
block of Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;Start&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="k"&gt;End&lt;/span&gt; &lt;span class="nv"&gt;Tags&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;link&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;link&lt;/span&gt; &lt;span class="nv"&gt;text&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Closing&lt;/span&gt; &lt;span class="nv"&gt;Start&lt;/span&gt; &lt;span class="nv"&gt;Tag&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;br&lt;/span&gt; &lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Alternate&lt;/span&gt; &lt;span class="nv"&gt;Parameter&lt;/span&gt; &lt;span class="nv"&gt;Enclosing&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;b2&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;foo&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Simple&lt;/span&gt; &lt;span class="nv"&gt;Alternate&lt;/span&gt; &lt;span class="nv"&gt;Parameter&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;c3&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;bar&lt;/span&gt; &lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Gratuitous&lt;/span&gt; &lt;span class="nv"&gt;Parameter&lt;/span&gt; &lt;span class="nv"&gt;Example&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;d4&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;bar&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nv"&gt;bam&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;baz &amp;lt;em&amp;gt;"&amp;lt;/em&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt; &lt;span class="nv"&gt;_boolean&lt;/span&gt; &lt;span class="nv"&gt;zoop&lt;/span&gt;:&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;zoop&lt;/span&gt;:&lt;span class="mi"&gt;33&lt;/span&gt; &lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the grammar is broken down in the
&lt;a href="https://github.github.com/gfm/#raw-html"&gt;Raw HTML&lt;/a&gt; section of the GFM specification,
it follows the
&lt;a href="https://www.w3.org/TR/html52/syntax.html#writing-html-documents-elements"&gt;HTML 5&lt;/a&gt;
specification for how to construct the tag and which tag formats are valid.  From
a document author point of view, this is simple.  When adding HTML to a Markdown
document, the author either knows how to author a web page in HTML or has a person
or web page that tells the author what HTML to insert into the document.  In either
case, assuming that those tags are valid, those tags are emitted exactly as added,
with no extra baggage added during the translation.&lt;/p&gt;
&lt;p&gt;In adding these HTML samples to the above Markdown example, I am also following my own
rules: never start a line with a tag and use it sparingly.  None of the lines start
with a tag, ensuring that none of the text is parsed as a HTML block.  And while
I went a bit overboard with the HTML specifically as it is an example, I can honestly
say it is one of the less-than-5 times I have used HTML in Markdown.  I think that
qualifies as sparingly.&lt;/p&gt;
&lt;p&gt;The raw HTML inline processing was very easy to add, as the rules are very simple:
its either a valid HTML tag, or not.  Not much to add.&lt;/p&gt;
&lt;h2 id="autolinks"&gt;Autolinks&lt;a class="headerlink" href="#autolinks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Until I started reading the specification, I had no idea that Markdown was capable of
a lot of things.  In this case, I wasn’t aware that it can make a decent attempt at
creating links with very little effort.  As far as using them in my articles and
documents, I am not sure about them yet, but at the very least they are an interesting
concept for Markdown to include.&lt;/p&gt;
&lt;p&gt;The concept is simple.  An URI contained within the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; characters is
interpreted as a link to that URI, with both the link and the link text being set to
that value.  There is also a variation of autolinks that uses any email address that
matches the email address
&lt;a href="https://html.spec.whatwg.org/multipage/forms.html#e-mail-state-(type=email)"&gt;regular expression in the HTML5 specification&lt;/a&gt;.  For email address autolinks, the link is set
to a &lt;code&gt;mailto&lt;/code&gt; scheme for the link and the email address for the link text.&lt;/p&gt;
&lt;p&gt;Real simple examples of these autolinks are contained within the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;website&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;email&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;honcho&lt;/span&gt;&lt;span class="nv"&gt;@example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;My website: &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"http://example.com"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;http://example.com&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;My email: &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"mailto:head.honcho@example.com"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;head.honcho@example.com&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To make sure they are not interpreted as HTML blocks, they are prefaced with text,
according to the rules I established in the last section.  While a properly
created autolink should not be interpreted as either of the HTML elements, I prefer to
keep things simple.  “NEVER start a line with a HTML tag unless it is a validly formed
autolink” just seemed too much.  As mentioned before, your mileage may vary.&lt;/p&gt;
&lt;p&gt;The actual HTML output is simple, as denoted in the second paragraph of this section.
In looking at autolinks a couple of times for this article, my feeling about autolinks
as a document author is that there is not enough control of the output.  Unless
I am missing something, the following Markdown is equivalent to the above HTML, and
it gives me more control of the document:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;website&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;http://example.com&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;email&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;head.honcho@example.com&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;mailto&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;honcho&lt;/span&gt;&lt;span class="nv"&gt;@example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the end, while autolinks were as trivial to add as raw HTML, I think I’ll stick
with my explicit links.&lt;/p&gt;
&lt;h2 id="line-breaks"&gt;Line Breaks&lt;a class="headerlink" href="#line-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Wrapping things up for this group of features are the line breaks: hard breaks and soft
breaks. At 14 examples for
hard line breaks and 2 examples for soft line breaks, only the indented code
blocks (11), the tabs (11), and the paragraphs (8) are in the same ball park for the
low number of examples needed to adequately demonstrate that given structural element
of Markdown.  In addition, if you really look at the 14 examples for hard line breaks,
there is a good argument to be made that there is large amount of replication between
the two character sequences, reducing the “actual” number of examples down
into the same 8-11 examples range.&lt;/p&gt;
&lt;p&gt;As indicated by the number of examples, line breaks in Markdown are really simple to
use, inheriting its line break rules from HTML.  In both languages,
if the author wants to specifically break a line after some text, they must use an
element that forces a line break before its content, use an element that preserves line
breaks within its content, or specify a hard line break itself.&lt;/p&gt;
&lt;p&gt;A good example of the first case are the grouping of Markdown lines into a paragraph by
separating them with a blank line.  This is best shown in the following Markdown from
&lt;a href="https://github.github.com/gfm/#example-190"&gt;example 190&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="n"&gt;bbb&lt;/span&gt;

&lt;span class="n"&gt;ccc&lt;/span&gt;
&lt;span class="n"&gt;ddd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;aaa
bbb&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;ccc
ddd&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is displayed as the following:&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;p&gt;aaa
bbb&lt;/p&gt;
&lt;p&gt;ccc
ddd&lt;/p&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;In this example, the (soft) line break that occurs in the Markdown between &lt;code&gt;aaa&lt;/code&gt; and
&lt;code&gt;bbb&lt;/code&gt;, and then again between the &lt;code&gt;ccc&lt;/code&gt; and &lt;code&gt;ddd&lt;/code&gt;, is kept as it is translated into
HTML.  However, when the HTML is rendered, that line break is not displayed.  When
displayed, the first pair of characters are displayed, followed by a line break, and
then the second set of characters.  As a general default rule, Markdown blocks
force a hard line break before displaying their contents, to ensure that the content is
understood to be different.&lt;/p&gt;
&lt;p&gt;For the second case, a good example of it is a slightly modified version of the
Markdown from &lt;a href="https://github.github.com/gfm/#example-110"&gt;example 110&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;bam&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar
bam
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is displayed as the following:&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;p&gt;foo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bar
bam&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;baz&lt;/p&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;The first thing to notice is that, as described in the last example, when a new
Markdown block is started, the default rule for displaying HTML forces a hard line
break to be rendered, keeping its content distinct from the previous content.  As such,
in this example both the &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; tag and the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tag are displayed with a line break
before them.  While this behavior can sometimes be overridden with styles and style
sheets, it tends to make things more confusing and is mostly avoided by HTML authors.  &lt;/p&gt;
&lt;p&gt;The second thing to notice is that the line breaks within the code block are
preserved as-is.  Both code blocks and HTML blocks maintain a very tight control on
how their data is translated and displayed, being the only two block elements that
preserves any line breaks within its content.  In terms of other elements, it should
be no surprise that code spans and raw HTML are the only two inline elements that also
preserve line breaks within their content.&lt;/p&gt;
&lt;p&gt;That leaves the final use case, where a Markdown author wants to force a hard line
break outside of any of the previously mentioned constructs.  But, how does an author
do that?&lt;/p&gt;
&lt;p&gt;The often used and not-so-visible option is to end a
line with 2 or more spaces that is also not at the end of a block.  Merging examples
&lt;a href="https://github.github.com/gfm/#example-657"&gt;657&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-666"&gt;666&lt;/a&gt; together produces the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generating the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;br&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
bar
foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is displayed as the following:&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;p&gt;foo&lt;br/&gt;
bar
foo&lt;/p&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Note that for the sake of clarity with this example, the string &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; is used in
place of the actual
space character itself.  The two spaces at the end of the first line cause the HTML
hard break tag &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; to be inserted into the data, generating a line break not only
in the generated HTML, but also in the displayed HTML.  In contrast, since the two
spaces at the end of the third line closes off the paragraph block, they are simply
stripped away and not replaced with a hard break.  This was a smart move as any Markdown
following that paragraph will be in a new block, the starting of the new block will,
by default, force a hard break in the display of that block, as noted above.&lt;/p&gt;
&lt;p&gt;In contrast, the second way to force a hard line break is to end the line with the
&lt;code&gt;\&lt;/code&gt; character, as shown in the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;
     &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While there are changes in the Markdown from the previous example, the generated HTML
remains the same.  After my initial confusion between Python’s &lt;code&gt;\&lt;/code&gt; line continuation
character and the Markdown’s &lt;code&gt;\&lt;/code&gt; hard line break character (as
&lt;a href="https://jackdewinter.github.io/2020/03/02/markdown-linter-taking-time-to-refactor-post-easy-inlines/#issue-2-python-markdown-and-line-continuation-characters"&gt;documented here&lt;/a&gt; ),
the explicit hard line break character grew on me.  &lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If I am being honest with myself, I was not sure at the beginning of the project if
I would ever get to this point.  With only 2 inline elements left to process, not
including the link definitions deferred from before, the parser is getting close
to being able to handle a full and rich Markdown document.  As the GRM specification
contains over 673 scenarios, there were times that I thought I would just give up
or use a “mostly” complete parser… something that was just barely good enough.  But
getting to this point, close to having a solid parser completed feels great!&lt;/p&gt;
&lt;p&gt;Sure, there have been cases where it took me a day or two to figure out how to do
something properly, such as list blocks and block quotes.  Those were tough.  And
as I am writing this article at a 2-3 week delay from when I made the actual changes
to the project, I know that there are some more bumps in the row yet to come.
(No Spoilers!)  But
the important thing is that while those things are hard, I face them with the mentality
that I talk about in my article on
&lt;a href="https://jackdewinter.github.io/2019/08/18/embracing-something-hard/"&gt;Embracing Something Hard&lt;/a&gt;.
Maybe
its just how I am, but for me part of the challenge is to embrace something hard
and work my way through it.&lt;/p&gt;
&lt;p&gt;It was when I was thinking about some of hard stuff that I had tackled previously
and how easy this block of features was that I started wondering.  Looking back
in the project at anything written before
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/dffd948cf8e4066121dbb11ae68c385370a20877"&gt;this commit on 27 February 2020&lt;/a&gt;,
it is hard to find any test that compares the output to HTML, though all of scenario
test output from the GFM specification is written as HTML.  What’s with that?&lt;/p&gt;
&lt;p&gt;Going back to my article on
&lt;a href="linter-1.md#what-are-the-requirements"&gt;Collecting Requirements&lt;/a&gt;,
I determined that to properly write a Markdown linter, I needed to be able to take
the output from a parser as a set of tokens, not output as HTML.  The entire reason
that I have taken steps to write this Markdown parser is that there are no current
parsers that do not output interpreted Markdown as HTML.  Furthermore, the previous
section on
&lt;a href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/#autolinks"&gt;autolinks&lt;/a&gt;
is proof of that need.  Producing a simple link
to a web page, I can generate it using an autolink, a raw HTML tag, and a HTML block.
Tokenizing the output before that translation to HTML is the only way to ensure that I
am linting the Markdown properly.&lt;/p&gt;
&lt;p&gt;To get me this far, testing against the tokenized output of the parser was the right
thing to do.  The linter is going to observe and consume the tokens from the parser,
so they are the right thing to test.  But the questions of whether I was
generating the correct tokens started to bounce around my mind…&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last section, I had some concerns about whether or not the
tokenization of the Markdown was correct, so I decided to go all out for the next
section and add the remaining scenario tests from the GFM specification.  To close
the loop on the testing, I also went through all the existing tests and added
a new class that transforms the PyMarkdown tokens into HTML, comparing that output
directly against the GFM specification.  Stay tuned!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Taking Time to Refactor -- Post-Easy Inlines</title><link href="https://jackdewinter.github.io/2020/03/02/markdown-linter-taking-time-to-refactor-post-easy-inlines/" rel="alternate"></link><published>2020-03-02T00:00:00-08:00</published><updated>2020-03-02T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-02:/2020/03/02/markdown-linter-taking-time-to-refactor-post-easy-inlines/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I was working on implementing the
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/#code-spans"&gt;inline code spans&lt;/a&gt;,
as detailed in the last article,
I performed
a thorough scan of the scenario tests and their source data, noting down any issues I
found.  I knew that I had missed the mark on how to internally represent Atx …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I was working on implementing the
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/#code-spans"&gt;inline code spans&lt;/a&gt;,
as detailed in the last article,
I performed
a thorough scan of the scenario tests and their source data, noting down any issues I
found.  I knew that I had missed the mark on how to internally represent Atx Headers,
and I was curious about how many other things I had missed.  Having found a
decent handful of issues to fix,  I decided to spend some time to address those issues
before adding more of the inline processing.  In my mind, it was
better to take a week and try and keep the issue count low than to continue forward,
possibly compounding the cost of fixing those issues.  As I am in a somewhat ideal
scenario, with nobody pressuring me for features or issue fixes, I figured it was best
if I took advantage of that to the best of my abilities and “do it right”.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/5102bfd8a3b2616eb6c3147f9416e3d7b308e523"&gt;14 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/62127eb46d5b03a781ba85fbcf3a397221716eb2"&gt;20 February 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="why-refactor-now"&gt;Why Refactor Now?&lt;a class="headerlink" href="#why-refactor-now" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As the owner and sole developer on the project, my decision to stop and refactor was
any easy one to make.  It also did not escape my attention that making a decision like
that isn’t always that simple for larger projects.  If this were a work project
or a team project, the group working on the project would have to meet to figure things
out. The team itself usually plays a critical role in assessing the cost and benefit of
each task, but
in the end it is a balancing act for managers and directors to figure out which tasks
are the best ones to focus on at any given time. As it is only me on the PyMarkdown
project, I get to conveniently shortcut those conversations in favor of simple
decisions based on my own experience.&lt;/p&gt;
&lt;p&gt;From my years of experience, I find that there are usually two driving forces that make
me support a decision to refactor a project.  The first driving force is the cost of
any applicable technical
debt on product code.  As I consider tests integral to a project’s quality, my
definition of the term “product code” includes all source code and resources required
to execute the project normally and to perform testing used to certify that same
project as shippable.  With almost 700 scenario tests for
PyMarkdown’s parser, even a small change can generate large ripples through the
code base, especially the scenario tests.  As the scenarios for a feature are only added
when that feature itself is added, each feature added therefore adds a significant
amount of product code for any change to ripple through.  It also follows that each
extra test impacted by an issue means an increased cost to fix that issue before
proceeding.  Therefore, if the goal is to keep overall costs down, refactoring more
frequently during development seems logical.&lt;/p&gt;
&lt;p&gt;The second driving force is less quantifiable, but equally important to any type of
project.  That force is the flow of the team working on the project.  Based on past
projects, I know that I work more efficiently if
I focus on a group of similar things for a while, then shift to another group when done.
The larger the difference is in the skill sets between the two groups of work, the more
relaxed I feel about the work.  This sense of relaxation allows me to get into a better
flow.  As this project is being
written by me in the evenings and on the weekends, keeping a good flow for the project
keeps me focused and energized about the project.  As I am the sole developer on the
project at the time, keeping myself motivated in a necessity!&lt;/p&gt;
&lt;p&gt;While one force is more empirical and the other is more feelings based, both
forces worked together to convince me that it was yet again time to refactor the
PyMarkdown project.&lt;/p&gt;
&lt;h2 id="issue-1-setext-headers-paragraphs-and-block-quotes"&gt;Issue 1:  SetExt Headers, Paragraphs, and Block Quotes&lt;a class="headerlink" href="#issue-1-setext-headers-paragraphs-and-block-quotes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I needed one of the smaller issues to get me warmed up, so after looking over the list
of possible issues to work on, I decided on
this one.  During the review of active scenario tests, I noticed that the text &lt;code&gt;===&lt;/code&gt;
was in the paragraph tags for the specification’s example, but the tokens that the
parser were omitting had them outside of the paragraph.  It seemed simple enough but
looks were deceiving.&lt;/p&gt;
&lt;p&gt;It took me a bit of digging to find two possible reasons for the string &lt;code&gt;===&lt;/code&gt; to be kept
inside of the paragraph: laziness and non-interrupts.  Working backwards, the
concept of laziness with block quotes and list items is that you can omit any of
the leading characters if the next non-whitespace character after the omitted
characters is text that continues the paragraph.  In essence:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="n"&gt;quote&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is equivalent to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="n"&gt;quote&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That got me halfway there, but there was still the question of how the &lt;code&gt;===&lt;/code&gt; would be
kept as part of the paragraph and not as a SetExt header indicator.  I read the
section on SetExt a couple of times before the following lines clicked:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, it cannot interrupt a paragraph, so when a setext heading comes after a paragraph, a blank line is needed between them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bingo!  I wish it did not take multiple reads through that part of the specification,
but specifications are sometimes like that.  Based on those discoveries, I temporary
rewrote the scenario for scenario 63 to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The goal of this was to remove the laziness out of the equation while working on the
interrupt issue.  When I reran scenario test 63, I correctly got a single paragraph
with 3 lines in it.  Whatever the issue was, it was not just simple parsing of
paragraphs.  Taking a step forward, I added the block quotes back into the picture,
changing that scenario text to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was at this point that the scenario broke, apparently thinking that the third line
was a
SetExt header and should close off the paragraph.  Issue reproduced!  To be sure, I
applied the laziness concept to the block quote, reverting the scenario back to
its original text of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and validated that the behavior was the same.&lt;/p&gt;
&lt;p&gt;Armed with a good reproduction case for the issue, good debug output, and a general
area in the source code for the cause of the issue, the issue was identified and
fixed in quick order.  This issue was very specific, so only the one scenario test
was impacted, which was a good thing.  The problem was that during the development
of block quotes, something made me think that anything looking like a
SetExt header should close off a paragraph, hence I added code to do just that. I
checked the code a couple of times, and that was the only scenario test referencing
that code, so I just deleted it.&lt;/p&gt;
&lt;p&gt;While the research on the issue was
a bit more effort than I originally thought, fixing this issue was a great warm up
to the next couple of issues.  One issue, one scenario test impacted, and I was
refactoring.&lt;/p&gt;
&lt;h2 id="issue-2-python-markdown-and-line-continuation-characters"&gt;Issue 2: Python, Markdown, and Line Continuation Characters&lt;a class="headerlink" href="#issue-2-python-markdown-and-line-continuation-characters" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The next issue for me to work on was a subtle copy-and-paste error, one that flew
under my radar until I took a solid look at it.  This issue did not show any indications
of failure until I started my scan of the scenario tests.  The only
reason I found this one was that I went looking for any error, not something specific.&lt;/p&gt;
&lt;p&gt;In Markdown, the &lt;code&gt;\&lt;/code&gt; character at the end of the line is used to denote a hard line
break, not yet to be implemented in the PyMarkdown project.  In Python, the &lt;code&gt;\&lt;/code&gt;
character at the end of the line is used as a line continuation character, telling the
Python interpreter to treat the text before the character and the text after the
character as a single line.  Hopefully, any readers see where I am going with this.&lt;/p&gt;
&lt;p&gt;When I added the scenario test for
&lt;a href="https://github.github.com/gfm/#example-60"&gt;scenario 60&lt;/a&gt;,
I did a copy-and-paste on the Markdown input to the new scenario test, a process I
have done for 99% of the scenario tests in the project.  To accomplish this, I pasted
the following Markdown text between the &lt;code&gt;"""&lt;/code&gt; characters denoting the Markdown to use
as input:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;
&lt;span class="c1"&gt;----&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resulting in the Python code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""Foo&lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="s2"&gt;----"""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After pasting each scenario’s Markdown into the scenario test, I try to ensure that
I replace every instance of the &lt;code&gt;\&lt;/code&gt; character with the &lt;code&gt;\\&lt;/code&gt; characters to properly
represent the backslash character in a Python string.  As I am
only human, there are times that I forget to do this.  Luckily for me, if a &lt;code&gt;\&lt;/code&gt;
character is not paired up with a valid character to escape, the Python interpreter
will generate a warning like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;======================================================== warnings summary ========================================================
test\test_markdown_setext_headings.py:346
  C:\old\enlistments\pymarkdown\test\test_markdown_setext_headings.py:346: DeprecationWarning: invalid escape sequence \&amp;gt;
    expected_gfm = """&amp;lt;h2\&amp;gt;Foo\\&amp;lt;/h2&amp;gt;"""

-- Docs: https://docs.pytest.org/en/latest/warnings.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the backslash character in Markdown is used with punctuation characters and the
backslash character in Python is used with alphabetic characters, this is usually a
very solid detection scheme for finding copy-and-paste misses.  In this case, that
check failed.&lt;/p&gt;
&lt;p&gt;The good news here is two-fold: an easy fix and a very localized fix.  This fix was
easy as I just had to apply the missed substitution.  It was localized mainly because
I had not yet implemented hard line breaks.  And yes, it meant that when I did implement
hard line breaks, I triple checked my line endings to avoid this issue showing up again.&lt;/p&gt;
&lt;p&gt;Momentum was increasing, so it was time to step things up!&lt;/p&gt;
&lt;h2 id="issue-3-code-blocks-indenting-and-blank-lines"&gt;Issue 3: Code Blocks, Indenting, and Blank Lines&lt;a class="headerlink" href="#issue-3-code-blocks-indenting-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having resolved a couple of warm-up issues, I felt it was time to tackle some larger
issues.  Each issue in
this group either deals with vertical space issues or leading space issues within a code
block.  The vertical space issue was that blank lines were not being folded into the
text blocks properly, causing foreseeable issues with  parsing complete blocks of text
soon.  Given some Markdown text, such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;abc&lt;/span&gt;

&lt;span class="n"&gt;def&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I expected that the output tokens would include a fenced code block with a single text
block inside of it with three lines present.  Instead, there were three tokens present,
the first and last were text tokens with strings and the token in the middle was a blank
line token.  While the token representation was technically correct, parsing it would
be awkward.  For the specific case of blank lines within a code block, it made sense to
merge the blank line tokens into the surrounding text tokens.&lt;/p&gt;
&lt;p&gt;The leading space issue was a bit more subtle but equally simple.  To properly parse
text blocks within a code block, an appropriate amount of whitespace may need to be
removed from each line as it is combined.  As always, it is the details that
matter, and it is easy to gloss over them.  In the opening part of the indented code
block section of the specification, the following line is present:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The contents of the code block are the literal contents of the lines, including trailing line endings, minus four spaces of indentation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The similar line for fenced code blocks reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the leading code fence is indented N spaces, then up to N spaces of indentation are removed from each line of the content (if present).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, this means that the following indented code block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;fred&lt;/span&gt;
     &lt;span class="n"&gt;frank&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;should produce a code block with the text &lt;code&gt;fred&lt;/code&gt; on the first line and the text
&lt;code&gt;&amp;lt;space&amp;gt;frank&lt;/code&gt;&lt;sup id="fnref:Space"&gt;&lt;a class="footnote-ref" href="#fn:Space"&gt;1&lt;/a&gt;&lt;/sup&gt; on the second line, having had the first 4 spaces removed.  The fenced
code blocks are
a bit more nuanced, in that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;
  &lt;span class="n"&gt;fred&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is parsed as &lt;code&gt;&amp;lt;space&amp;gt;&amp;lt;space&amp;gt;fred&lt;/code&gt;&lt;sup id="fnref2:Space"&gt;&lt;a class="footnote-ref" href="#fn:Space"&gt;1&lt;/a&gt;&lt;/sup&gt; and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="o"&gt;```&lt;/span&gt;
  &lt;span class="n"&gt;fred&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is parsed as &lt;code&gt;fred&lt;/code&gt;, based on the extra indenting of the fenced code block start.
While the line containing the text &lt;code&gt;fred&lt;/code&gt; is the same in both cases, the number of
leading spaces before the fenced code block are different, resulting in the different
outputs.&lt;/p&gt;
&lt;p&gt;Prior to fixing this issue, text lines were combined in a simple manner and no
whitespace was removed from the start of any lines within code blocks.  To properly
address this issue, not only did these two rules need to be followed, but the existing
code to properly remove leading spaces for each line within a normal paragraph needed
to be preserved.  It took a bit to get it right, but with a good number of scenario
tests to keep things honest, it was easy to get it right quickly.&lt;/p&gt;
&lt;p&gt;My original estimates for the impact of this issue was 15-20 tests, and it thankfully
remained within that range.  While the initial number of scenarios covered by these
issues was 15, I expected other scenarios to use code blocks to show how their feature
worked with code blocks, adding another 3-7 scenario tests in the process.  Looking
back, I think I got off nicely with the scope of these changes.&lt;/p&gt;
&lt;h2 id="issue-4-paragraphs-and-indenting"&gt;Issue 4: Paragraphs and Indenting&lt;a class="headerlink" href="#issue-4-paragraphs-and-indenting" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Feeling energized from fixing the issues documented in the previous sections, I decided
to keep with the theme and attack the issue with leading spaces in normal paragraphs.
Similar to the prior issue, the rule for normal paragraphs is that all
leading whitespace is
removed as the text for the paragraph is pasted together.  While it is hard to point
to an exact quote from the specification for this rule&lt;sup id="fnref:Missing"&gt;&lt;a class="footnote-ref" href="#fn:Missing"&gt;2&lt;/a&gt;&lt;/sup&gt;,
&lt;a href="https://github.github.com/gfm/#example-192"&gt;example 192&lt;/a&gt; clearly shows this as the
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="n"&gt;aaa&lt;/span&gt;
 &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is translated into the HTML text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;aaa
bbb&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The fix for this was similar to the change made for the code blocks issue, but instead
of specifying a fixed number of whitespace to remove, the &lt;code&gt;combine&lt;/code&gt; function was
changed to accept a value that indicates the removal of all whitespace.  The original 9
cases were quickly tested with the fix, and things looked solid.&lt;/p&gt;
&lt;p&gt;Originally, it looked like the changes would be confined to the original 9 cases, but
I suspected that the number would at least be double that, as this fix would affect any
scenario involving a paragraph with multiple lines. While a number of the cases were
simple cases, when all was said and done, there were 59 changes to scenario
tests in the commit for this issue.  Even so, those changes were quickly made, and the
scenario tests were re-verified.&lt;/p&gt;
&lt;p&gt;While this took a lot of work to get right, it felt good to get this one resolved.  It
was hard for me to quantify this to myself, but the parsing of the paragraphs always
looked like they had too many spaces.  It was nice to finally figure out why!&lt;/p&gt;
&lt;h2 id="issue-5-trailing-spaces-in-scenarios"&gt;Issue 5: Trailing Spaces in Scenarios&lt;a class="headerlink" href="#issue-5-trailing-spaces-in-scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the early development phase of the project, I wanted to get going with the
scenarios as quickly
as possible, so I copied each scenario’s Markdown text from the GFM specification
exactly as-is.  This was not a
problem, except that in a small number of cases, there were lines in the scenarios that
ended in one or more whitespaces.  These trailing whitespaces raised the
&lt;code&gt;trailing-whitespace&lt;/code&gt; warning when I ran the PyLint program over the project’s
code base, as I do with each set of changes. Determined to deal with the issue later,
I added a few comment lines like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# pylint: disable=trailing-whitespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to disable the Pylint warnings that occurred, knowing I would have to fix
them later.  At this point in the project, it seemed like a good time to deal with this.&lt;/p&gt;
&lt;p&gt;As this issue was largely out of sight, everything was fine.   That is, everything was
fine until I hit a
couple of problems in a row that did involve these scenarios.  Instead of immediately
noticing the trailing whitespace and the comment, I started debugging each issue
without noticing either the comment or the whitespace, and was dumfounded by why the
parsing was not as was suggested
by the Markdown text that was clearly visible.
When I took a step back to really read the scenario tests, I then noticed
the comment at the top of each of the problem test functions, and then it clicked.  But
it took a lot longer than it should have.  Instead of “just dealing with it”, I decided
that refactoring was a better solution.&lt;/p&gt;
&lt;p&gt;The fix was an easy one too, something I should have thought of earlier.  The ASCII BELL
character is represented by &lt;code&gt;\a&lt;/code&gt; in Python strings, and to the best of my knowledge is
seldom used in most Python programs or Markdown text.  As it has a very low probability
of being used in any scenarios, I replaced the
terminating whitespace characters with &lt;code&gt;\a&lt;/code&gt; characters, then added &lt;code&gt;.replace("\a", " ")&lt;/code&gt;
at the end of the sample string.  It was then a simple matter of going through the
other 6 scenarios with trailing whitespaces and repeating this fix.&lt;/p&gt;
&lt;p&gt;While issues like this may seem small, having to disable a PyLint warning did not feel
right, even if it helped me maintain momentum at the time.  It just felt really good
to solve this issue properly.&lt;/p&gt;
&lt;h2 id="issue-6-getting-atx-headers-right"&gt;Issue 6: Getting Atx Headers Right&lt;a class="headerlink" href="#issue-6-getting-atx-headers-right" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the last article, I started looking for issues after wondering if a code span
could work within an Atx Header, realizing that the specification allowed it, but
my current implementation did not allow it. As stated in the preamble for
&lt;a href="https://github.github.com/gfm/#example-36"&gt;scenario 36&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The raw contents of the heading are stripped of leading and trailing spaces before being parsed as inline content.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, my decision was based on my usage patterns, not the specification.
In my experience, I have only ever done Atx Headers in the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;###&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When I read the specification, I glossed over that section, only thinking
of Atx Headers as containers for normal text.  However, based on the specification,
the following text is also allowed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;### This *is* `my` header&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a result, instead of the header text &lt;code&gt;This is my header&lt;/code&gt; being generated by the
first sample, I can use the second sample to generate the header text of
&lt;code&gt;This &amp;lt;em&amp;gt;is&amp;lt;/em&amp;gt; &amp;lt;code&amp;gt;my&amp;lt;/code&amp;gt; header&lt;/code&gt;.  Neat!&lt;/p&gt;
&lt;p&gt;The change itself was pretty simple and confined to the &lt;code&gt;parse_atx_headings&lt;/code&gt; function.
As it was a simple change, the accompanying change in each test was also pretty
simple:  take a single Atx Header token with text, replace it with an Atx Header token
without the text, a Text token with the text, and an End token for the Atx Header.&lt;/p&gt;
&lt;p&gt;While I was concerned that the fix for this issue was going to be more widespread,
it was confined to 22 scenario tests, and was easy to verify.&lt;/p&gt;
&lt;h2 id="issue-7-bringing-the-tabs-back"&gt;Issue 7:  Bringing the Tabs Back&lt;a class="headerlink" href="#issue-7-bringing-the-tabs-back" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking for something to finish the refactoring session with, I decided to tackle one
of the longstanding fixes that I had some reservations about: the bulk conversion
of tabs to spaces.  While it was a good fix at the time, I suspected that there
might be problems with the code blocks where all text is supposed to be preserved
literally, including tab characters.&lt;/p&gt;
&lt;p&gt;In a stroke of luck, all the affected scenario tests are in the
&lt;code&gt;test_markdown_tabs.py&lt;/code&gt; file
and the places where tabs are important can be grouped into 2 distinct groups.
In the Markdown specification, there is a distinction between whether there is enough
whitespace for an indented code block with 4 spaces, or not with less than 4 spaces.
To address those cases, I simply added the &lt;code&gt;is_length_greater_than_or_equal_to&lt;/code&gt; and
&lt;code&gt;is_length_less_than_or_equal_to&lt;/code&gt; functions.  While I could have simply used a &lt;code&gt;not&lt;/code&gt;
modifier to get the same effect, I thought it was more readable to simply spell it
out.  For cases where the actual length was needed, the &lt;code&gt;calculate_length&lt;/code&gt; function
determines the length of the string, allowing for the length of a tab to be 4
characters while every other character is assigned a length of 1.&lt;/p&gt;
&lt;p&gt;While this was not a very technical issue to fix, it helped me return things to a known
good state, with confidence that tabs were being treated properly.  Before this fix,
I was always concerned that the bulk translation of tab characters to spaces would
introduce a hard to diagnose issue.  With that translation removed, that concern went
away.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At various points in the development of PyMarkdown, I have wondered if my thinking
should be more realistic with a “two steps forward, one step back” feel to it.  Maybe
it is just who I am, but with a few exceptions, I see almost all of this development as
stepping forward with quality, and hence, all positive.  I like the fact that
I am implementing some new features, then doing some refactoring, and repeating.  It
gives me a solid perception that the project is on stable footing at every stage,
accumulating little technical debt along the way.&lt;/p&gt;
&lt;p&gt;Something that struck me at this point was how easily I seemed to fall into a rhythm
that works well for me and the project:  implementing a couple of features, noting down
any issues as I implement, and then fixing a couple of the more pressing issues before
repeating the pattern.  I am not sure if that kind of a pattern that everyone else
works well with, but it seems to work well for me.  To a certain extent, it also helps
me write these articles, as writing about quality software is very different than
the development of that software.  For me, I find that they complement each other
very well.&lt;/p&gt;
&lt;p&gt;In terms of energy, keeping that rhythm going and writing these articles is
helping to keep me charged up about the project.  While I have written my share of
parsers in my career, they have almost always been for work projects with a specific
goal and deadline to achieve.  Being freed from those restrictions does come with
its benefits, but not having someone looking over your shoulder means that you have
to take on that role yourself.  These articles, while initially created to talk about
my approach in creating quality software, also server the purpose of keeping me
honest and responsible to any readers.  Call it a backup plan, but it seems to be
working well!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Going back to the specification for features to implement, I decided to start at the
end and get the line breaks, autolinks, and raw html inline processing taken care of.
While I do not use them frequently myself, they are interesting aspects to the
GFM specification, and perhaps learning about them will increase my use of them in
my everyday Markdown usage.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:Space"&gt;
&lt;p&gt;The string &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; represents a space character, which by it’s very nature, is invisible. &lt;a class="footnote-backref" href="#fnref:Space" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="#fnref2:Space" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:Missing"&gt;
&lt;p&gt;The specification states “The paragraph’s raw content is formed by concatenating the lines and removing initial and final whitespace.”  This is the closest reference that I could find to removing whitespace.  Perhaps initial means per line? &lt;a class="footnote-backref" href="#fnref:Missing" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Starting Inline Processing</title><link href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/" rel="alternate"></link><published>2020-02-24T00:00:00-08:00</published><updated>2020-02-24T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-24:/2020/02/24/markdown-linter-starting-inline-processing/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Maybe it is just me, but I love the feeling of completing a good round of refactoring
where I really get to focus on making sure that the foundations of the project are
stable.  If it helps any readers, I imagine it as a spa day for your project …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Maybe it is just me, but I love the feeling of completing a good round of refactoring
where I really get to focus on making sure that the foundations of the project are
stable.  If it helps any readers, I imagine it as a spa day for your project where the
project just gets some personalized attention and cleaning up.  While the project is not
in a perfectly clean state, I know that I performed a decent amount of tidying up in
that direction, work that will help the project as it grows.&lt;/p&gt;
&lt;p&gt;With the project cleaned up, and with the new changes to make the text blocks
continuous, it was time to start on
the inline processing.  The first three inline elements to be implemented were the
first three elements in the
&lt;a href="https://github.github.com/gfm/"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;:
backslashes, character references, and code spans.  These elements allow Markdown to
escape certain characters, replace a text sequence with a single Unicode character,
or indicate that some text is literal code.  Each of these elements has its own
special use, and are used very frequently when writing Markdown documents.  And if those
reasons were not good enough, they just happen to be the first three sections in the
specification’s inline processing section.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/5c175f68fbe182d052a83d43061443921aae7bc9"&gt;08 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/235c0c63f6ee5cb41e1f8e71fa4081b36ba1beef"&gt;14 February 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="inline-processing"&gt;Inline Processing&lt;a class="headerlink" href="#inline-processing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In Markdown processing, there are two main types of processing that occur: processing
to sort the text into blocks and the processing of the contents for those blocks.
Courtesy of
&lt;a href="https://github.github.com/gfm/#blocks-and-inlines"&gt;the specification&lt;/a&gt;,
another good explanation is as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can think of a document as a sequence of blocks — structural elements like paragraphs, block quotations, lists, headings, rules, and code blocks. Some blocks (like block quotes and list items) contain other blocks; others (like headings and paragraphs) contain inline content — text, links, emphasized text, images, code spans, and so on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While it was not readily apparent on my first read of the specification, inline
processing occurs only on the content of leaf blocks that do not strictly govern their
content.  As code blocks contain the literal content for their output and HTML blocks
contain the literal HTML content for their output, inline processing is not applied to
those blocks.  Inline processing is applied to the content of the remaining blocks, the
headings blocks and the paragraph blocks, which just happen to be the most frequently
used blocks in most Markdown documents.&lt;/p&gt;
&lt;h3 id="backslash-escapes"&gt;Backslash Escapes&lt;a class="headerlink" href="#backslash-escapes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having completed most of the processing required for the leaf blocks and container
blocks, it was
time to move on to the inline processing of the content within those blocks.
The first of the inline processes to be worked on: the backslash escapes.&lt;/p&gt;
&lt;p&gt;For readers familiar with backslashes in modern programming languages, Markdown’s
usage of backslashes is similar, but with a twist.  In modern programming languages,
a backslash character is used in strings to escape the character following the
backslash, using that next character to denote a special character. For each special
character to be represented, a distinct backslash escape sequence is used to represent
it.  For example, most languages include the escape sequence &lt;code&gt;\n&lt;/code&gt; for a line feed or
end-of-line character.  This backslash escape is used so often that many programmers
use the terms “slash-en” or “backslash-en” instead of referring to the &lt;code&gt;\n&lt;/code&gt; character
sequence as the new-line character it represents.&lt;/p&gt;
&lt;p&gt;The twist that I mentioned earlier is that Markdown, unlike programming languages,
uses backslash escapes to only escape the following ASCII punctuation characters with
themselves:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;!"#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For example, the string &lt;code&gt;\!&lt;/code&gt; will emit the sequence ‘!’, but the string &lt;code&gt;\a&lt;/code&gt; will emit
the sequence &lt;code&gt;\a&lt;/code&gt;.  Coming from a programming background, this took a bit of getting
used to, but it makes sense.  As Markdown is used to create a human readable document,
authors should not be concerning themselves with control characters, but with how the
content is organized.  From that point of view, escaping the punctuation characters
used to denote organization makes a lot of sense.&lt;/p&gt;
&lt;p&gt;It then follows that each processing character is included in that string of
characters, and that the most prominent use of backslash escapes in Markdown is to
avoid block and inline processing.  Because a backslash escaped character is emitted as
part of the backslash processing in the parser, any other processing of that character
by the parser is effectively short-circuited. This simply allows the punctuation
character to be represented without the parser mistaking it for any kind of processing
instruction.&lt;/p&gt;
&lt;p&gt;For
example, to include the text &lt;code&gt;&amp;amp;amp;&lt;/code&gt; in your document the sequence &lt;code&gt;\&amp;amp;amp;&lt;/code&gt; can be
used to escape the ‘&amp;amp;‘ character.&lt;sup id="fnref:escapingAmp"&gt;&lt;a class="footnote-ref" href="#fn:escapingAmp"&gt;1&lt;/a&gt;&lt;/sup&gt;  Another example is that the
following text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will generate the text &lt;code&gt;- this is a paragraph&lt;/code&gt; as part of a paragraph, instead of
creating a list item containing the paragraph &lt;code&gt;this is a paragraph&lt;/code&gt;.  In both cases,
the backslash escapes are used to tell the parser to just treat the escaped character
as itself and not to perform any further processing.  As useful as that
is, backslashes escapes cannot be used in code blocks, which have been covered
previously, code spans, which are covered later in this article, or autolinks and raw
HTML, which are covered in a future article.&lt;/p&gt;
&lt;p&gt;Implementing support for backslash escapes was simple, as it just required a
change in how the characters were interpreted.  As the text was still contained within
a single text block, it was just a matter of making sure the right characters were
emitted.  This was relatively easy as the processing was easy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is the next character a backslash?&lt;/li&gt;
&lt;li&gt;if not, emit a backslash and resume normal processing&lt;/li&gt;
&lt;li&gt;if so, check to see what character follows&lt;ul&gt;
&lt;li&gt;if that character is not in the escape list above, emit a backslash and resume normal processing&lt;/li&gt;
&lt;li&gt;if so, consume that character and emit that character&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Basically, if there is a valid backslash sequence, emit the second character and consume
it, otherwise, emit first character (the backslash character) and continue.  The limits
on where backslashes can be used was easy to implement, as there were only a few
places where they were not allowed.&lt;/p&gt;
&lt;h3 id="character-references"&gt;Character References&lt;a class="headerlink" href="#character-references" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Character references are an important part of HTML, and as such, Markdown has solid
support for them built in.  Character references allow for the
inclusion of special characters into the document, without the need to rely on the
file editor to support Unicode characters.  In addition, the document’s writability and
readability is often enhanced by presenting the reader with the text &lt;code&gt;&amp;amp;copy;&lt;/code&gt; instead
of the symbol ‘©‘.&lt;/p&gt;
&lt;p&gt;Think about it this way. As a document author, you want to add the copyright symbol to
your document. Where do you find it on your keyboard?  If it is not there,
what is the clearest and easiest way to add it to the document that is not tied to a
specific editor?  Markdown addresses this issue by reusing the HTML5 method of
specifying character references.&lt;/p&gt;
&lt;p&gt;For each character reference, it starts with the ‘&amp;amp;‘ character
and ends with the ‘;’ character, with characters between to denote the type of
character to reference and what the actual reference is.  Named character entity
references are the easiest to
read, as they contain some form of the name of the character they represent, such as
&lt;code&gt;&amp;amp;copy;&lt;/code&gt; for the copyright symbol.  The full list of
named character references that are supported is at the
&lt;a href="https://html.spec.whatwg.org/multipage/entities.json"&gt;HTML5 entity names document&lt;/a&gt;. &lt;sup id="fnref:namedEntities"&gt;&lt;a class="footnote-ref" href="#fn:namedEntities"&gt;2&lt;/a&gt;&lt;/sup&gt;
As an alternative to the &lt;code&gt;&amp;amp;copy;&lt;/code&gt; named reference, the equivalent numeric references
&lt;code&gt;&amp;amp;#169;&lt;/code&gt; or &lt;code&gt;&amp;amp;#x00A9&lt;/code&gt; may be used instead.  While the result on the rendered page
is the same, I feel that the named references are more readable than the numeric
references.
However, in cases where there is no named reference for a given Unicode character, the
numeric references are very handy.&lt;/p&gt;
&lt;p&gt;Like the way in which backslash escapes are
handled, there are certain blocks that the character references cannot be used in.  In
particular, they are not recognized in code blocks and code spans but are recognized
in most other locations.  For example&lt;sup id="fnref:refExample"&gt;&lt;a class="footnote-ref" href="#fn:refExample"&gt;3&lt;/a&gt;&lt;/sup&gt;, given the following Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the character references in the fenced block info string are recognized, but the
character references within the code block are not recognized.  As such, after
translating this Markdown into HTML, the following HTML is expected:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt; &lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"language-föö"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;f&lt;span class="ni"&gt;&amp;amp;ouml;&amp;amp;ouml;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the example, as expected, the character references that feed the &lt;code&gt;class&lt;/code&gt; attribute
for the &lt;code&gt;code&lt;/code&gt; tag were translated, while the character references within the bounds of
the &lt;code&gt;code&lt;/code&gt; tag, which are used to denote a code block, are left alone.&lt;/p&gt;
&lt;p&gt;Similar to my experience in processing the backslashes, the implementation for all
three-character references were processed in roughly the same manner.  Instead of a
single character to look for with backslash escapes, character references have a
set of allowable character sequences, but otherwise the processing is the same.  Once
again, the processing was simple, just follow simple rules.&lt;/p&gt;
&lt;p&gt;However, while it was not particularly difficult, determining the proper
handling of the &lt;code&gt;entities.json&lt;/code&gt; file used as a reference for HTML named entities took a
bit of thinking to get right.  The main decision was whether to download it
each time, cache it somewhere once downloaded, or just do a “one-time” include of it
into the project as a resource.  In the end, I
decided to take the later path, placing the file in the &lt;code&gt;pymarkdown/resources/&lt;/code&gt;
directory.  My assumption is that file does not change that often, perhaps once a month
at its worst.  As I added the file exactly as it was downloaded from the source at
&lt;a href="https://html.spec.whatwg.org/entities.json"&gt;the HTML5 home page&lt;/a&gt;, I believe I can check
on it from time to time, updating the file when required.  With that decision made, I
just needed to do some research on the best way to include resources into a project,
and the rest was once again just following well documented instructions.&lt;/p&gt;
&lt;h3 id="code-spans"&gt;Code Spans&lt;a class="headerlink" href="#code-spans" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Code spans are like code blocks, in that they both protect the characters that are
within their confines.  However, while code blocks are designed to protect multiple
lines of text, such as source code examples, code spans are designed to protect text
within a single paragraph.  To create
a code span, the text to be protected is simply surrounded by one or more backtick (‘`’)
characters on each side, making sure that the number of starting backticks and closing
backticks are the same.&lt;/p&gt;
&lt;p&gt;As a simple example, the Markdown &lt;code&gt;`foo`&lt;/code&gt; produces the text &lt;code&gt;foo&lt;/code&gt; within a special
HTML tag that has special styling associated within it. Like how code blocks
protect blocks of text that are already formatted in a specific way,  these code spans
use that styling  are used to specify targeted text that
already has meaning attached to it.  In my articles, as with other blog authors that
I have read, I use code spans to indicate that certain strings have literal meaning to
them, such as the literal text to type in at a keyboard.&lt;/p&gt;
&lt;p&gt;One good example of this from the previous section are the examples of the various
Markdown sequences needed to produce the copyright symbol.  If I had simply added
the text &lt;code&gt;&amp;amp;copy;&lt;/code&gt; to the Markdown document, it will be interpreted as a character
sequence, and the ‘©‘ symbol will be generated.  By placing backticks around
that text, such as &lt;code&gt;`&amp;amp;copy;`&lt;/code&gt;, those characters are contained within a code span
and the text is preserved literally.  And for that last sentence where I needed to
include the literal text including backticks, I just made sure to include more
backticks around the text than were contained within the text,
such as &lt;code&gt;`` `&amp;amp;copy;` ``&lt;/code&gt;.&lt;sup id="fnref:doubleBacktick"&gt;&lt;a class="footnote-ref" href="#fn:doubleBacktick"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;I knew that the parsing and rendering of the tokens was about to get more complex in
order to properly implement the code span processing.  To keep the code span, the
text before it, and the text after it in the right order, I changed the inline parsing
to allow for a markdown token to be emitted.  When the new code span Markdown token is
emitted, the surrounding code first adds a new text block containing any text
collected up until that point, emits the new token, and then resets the
collected text back to the empty string.  This correctly ordered the tokens and
is generic enough to hopefully future-proof similar parsing in the future.&lt;/p&gt;
&lt;p&gt;There were only a small number of issues with the existing scenarios that needed to be
addressed, now that code spans were handled properly.  Fixing those tests was simple
and just required resampling the parser’s output.  But during that testing, I realized
I had made a mistake with the handling of one of the header blocks.  When I wrote the
original code for the Atx Header blocks, as documented in the article on
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/#group-2-headers"&gt;Parsing Normal Markdown Blocks&lt;/a&gt;,
I hadn’t thought about code spans or other more complex inline elements as part of an
Atx header.  As such, I therefore I wrote a simple implementation that represented the
header text as a simple string within the token.&lt;/p&gt;
&lt;p&gt;Double checking the specification, I verified that there were no restrictions on using
code spans within a SetExt or Atx header block.  As such, I needed to rewrite the
parsing code to support having Atx header blocks contain text blocks, instead of
simply including the enclosed text in the Atx Markdown token.  Instead of tackling
that as part of this group of code, I decided to look to see if there were any other
“little” things that I missed, and I found a few of them.&lt;/p&gt;
&lt;p&gt;Basically, of the issues that I found, most of them were small variations of the
scenarios, things that just got lost in the shuffle or lost in the translation.  As
such, I thought it would be best to take some time, try and note them all down, and
then tackle them together before continuing.  As the only scenario test that was
affected was example 339, I believe that temporarily skipping that test and taking the
time to fix those issues was the right call.  It would mean that I would have to
wait a bit before I could say that code spans were done, but when they were done, I
would know that I did them the right way.  That was, and still is, important to me.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I usually read a specification thoroughly and identify most of the edge cases on my
first pass.  However, I must admit that I dropped the ball with that on this project.
And to be totally honest, I do not expect that it will be the last time either.  It is
a big specification, and there are going to be hits and misses along the way.  What
matters to me is not whether I make the mistakes, but that I do not have enough use
cases, scenarios, and tests to help me identify any mistakes.  With 673 scenarios
already identified in the specification, I know the coverage for scenario will be good,
but there will be gaps that I will still need to address.  Whether it is my dropping
the ball or the specification dropping the ball, the work on the these three inline
elements has improved my confidence that I am prepared to deal with any such issues
that come up.&lt;/p&gt;
&lt;p&gt;A good example of this is my reading of the specification around the use of Atx headers.
I know I missed the part where the specification, in the preamble to
&lt;a href="https://github.github.com/gfm/#example-36"&gt;example 36&lt;/a&gt; says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Contents are parsed as inlines:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In retrospect, not only is this one of the few times inlines with Atx headers was
mentioned but there is also only one scenario that covers them, example 36. So, from
one point of view, the specification could have more scenarios dealing with inlines
and Atx headers.  From an additional point of view, it was mentioned and I just
missed it.  From my personal point of view, it does not matter either way.  What matters
is that I had enough process and tools in place to catch it.  And once I saw that
issue, it helped me take a deeper look at some of the other tests, finding small issues
with the output from those tests.&lt;/p&gt;
&lt;p&gt;From a quality point of view, my confidence was holding steady or increasing.
As I mentioned a couple of paragraphs ago, I do not expect to be perfect, I just hope
to have the right tools and processes in place to help me figure out when I miss
something or get something wrong.  Sure, I realized that taking some time to work on
fixing these issues was going to put my work on the linter on hold for another week.
But my confidence that the linter was on solid footing increased because I
found some issues.&lt;/p&gt;
&lt;p&gt;For me, quality is not about being perfect, it is about movement in the right direction.
And finding those issues, was a step in that right direction.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After documenting those issues at the end of the &lt;code&gt;test_markdown_list.py&lt;/code&gt; file, I
thought it was best to do a quality pass and resolve those issues before moving on to
other inline processes.  As such, the next article focuses on what bugs I found in the
scenario tests, and how I addressed them.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:escapingAmp"&gt;
&lt;p&gt;Just to be complete, the character escapes in the next section also provide a way to include the ‘&amp;amp;‘ sequence in Markdown.  Using character references, this is by using the text &lt;code&gt;&amp;amp;amp;amp;&lt;/code&gt; instead of &lt;code&gt;\&amp;amp;amp;&lt;/code&gt;.  While both produce identical output, I prefer the first for it’s clarity.  Your mileage may vary. &lt;a class="footnote-backref" href="#fnref:escapingAmp" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:namedEntities"&gt;
&lt;p&gt;To keep things simple for parsers, this file is maintained as a JSON file that is easily interpreted with a small amount of code in most current languages. &lt;a class="footnote-backref" href="#fnref:namedEntities" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:refExample"&gt;
&lt;p&gt;Note that this example is a slightly modified version of &lt;a href="https://github.github.com/gfm/#example-330"&gt;example 330&lt;/a&gt; from the GFM specification. &lt;a class="footnote-backref" href="#fnref:refExample" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:doubleBacktick"&gt;
&lt;p&gt;For a good example of this, see &lt;a href="https://github.github.com/gfm/#example-339"&gt;example 339&lt;/a&gt; in the GFM specification. &lt;a class="footnote-backref" href="#fnref:doubleBacktick" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Taking Time to Refactor -- Post-Block Implementation</title><link href="https://jackdewinter.github.io/2020/02/17/markdown-linter-taking-time-to-refactor-post-block-implementation/" rel="alternate"></link><published>2020-02-17T00:00:00-08:00</published><updated>2020-02-17T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-17:/2020/02/17/markdown-linter-taking-time-to-refactor-post-block-implementation/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The title of the article is not very glamorous, but it describes the changes I made to
the project after the block processing and before the inline processing.  From a project
completeness viewpoint, all the block elements were done except for table blocks and
link reference definitions, and those …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The title of the article is not very glamorous, but it describes the changes I made to
the project after the block processing and before the inline processing.  From a project
completeness viewpoint, all the block elements were done except for table blocks and
link reference definitions, and those were temporarily shelved.  The big decision before
me was whether to plow ahead with inline processing or take some time to clean
things up before continuing.&lt;/p&gt;
&lt;p&gt;After weighing the options in my head for a while, I decided to take some time to tidy
up my work on my PyScan script and document it in
&lt;a href="https://jackdewinter.github.io/2020/01/13/measuring-testing-in-python-scripts/"&gt;this article&lt;/a&gt;.
Part of that decision was based on the time of year (it was the holiday season) and the
other part of the decision was based on timing for the PyMarkdown project.  At this
point, the blocks were mostly finished, and the inline processing was the next feature
to be implemented.  To me, it just made good sense to clean up the PyScan tool, write
an article or two on it, and refactor some of the PyMarkdown project before moving
forward with inline processing.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/98b479816d74d04715a1f2c23c6941836ad1a70c"&gt;20 December 2019&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/eebbf07d72836f14fb3b20ef2d3c1e0139e942a2"&gt;31 January 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="refactor-1-extracting-function-groups"&gt;Refactor #1: Extracting Function Groups&lt;a class="headerlink" href="#refactor-1-extracting-function-groups" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first things that I wanted to refactor were the generic helper functions used for
parsing and the helper functions used for dealing with HTML.  While the parsing helper
functions were already at the end of the &lt;code&gt;tokenized_markdown.py&lt;/code&gt; file, it made sense to
move the HTML helper functions down to the same location at the end of the file.  Once
that was accomplished, it took me about 2 milliseconds to figure out that they should
be in their own modules.  Hence, the parsing helper functions were moved out into the
&lt;code&gt;parser_helper.py&lt;/code&gt; file and the HTML helper functions were moved out into the
&lt;code&gt;html_helper.py&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Along the way, proper unit tests were added for these functions.  As part of the normal
process of parsing the Markdown document, they had been battle tested by their usage,
but having their own dedicated unit tests was the right thing to do.  The unit tests
for the parsing helper functions were all added with filenames that are the string
&lt;code&gt;test_&lt;/code&gt; followed by the name of the distinct function that they test.  As the HTML
helper functions more tightly coupled that the parser functions, I kept their unit
tests coupled by added all of them to the &lt;code&gt;test_html_tags.py&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;This refactoring was performed to reduce the complexity and maintenance of the main
module.  By moving these functions to well-defined modules of their own, I instantly
found that it was easy to find functions in either module, instead of search for them
at the end of the main file.  For me, that feedback is always a good sign that the
refactor was the right thing to do.&lt;/p&gt;
&lt;h2 id="refactor-2-reducing-complexity-with-is_character_at_index_one_of"&gt;Refactor #2: Reducing Complexity with is_character_at_index_one_of&lt;a class="headerlink" href="#refactor-2-reducing-complexity-with-is_character_at_index_one_of" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I was looking through the code for the previous refactoring, I noticed that there
were a few functions that were “too big”.  From experience, I find that these
types of functions usually have more than one responsibility, and reducing those
responsibilities reduces their complexity.  The first example of this that I found was
the &lt;code&gt;is_fenced_code_block&lt;/code&gt; function, which included the following series of lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;skip_whitespace_check&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"~"&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"`"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the first two lines were specific to the function, the last two lines followed a
pattern that happened again and again in that module.  Because those last two lines are
really checking to see if the next character is one of the two values, I extracted
that logic into a new &lt;code&gt;is_character_at_index_one_of&lt;/code&gt; function for the &lt;code&gt;ParserHelper&lt;/code&gt;
module, and added tests into &lt;code&gt;test_is_character_at_index.py&lt;/code&gt; module.&lt;/p&gt;
&lt;p&gt;This refactoring had a noticeable impact on the complexity of each of the modules that
used the new function.  This impact was a reduction in the number of branches in each
function, with each count decreasing by one for each character to look for.  As an
example, the &lt;code&gt;is_fenced_code_block&lt;/code&gt; code above went from the snippet above to the
following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;skip_whitespace_check&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_character_at_index_one_of&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fenced_code_block_start_characters&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is a reduction from 5 branches down to 3 branches, making that function and that
module less complex in the process.  In addition, instead of reading those two lines
and trying to figure out what they are doing, the function call to the
&lt;code&gt;is_character_at_index_one_of&lt;/code&gt; function eliminates the “what is it doing” step, making
it easier for someone reading the code to understand those lines.&lt;/p&gt;
&lt;h2 id="refactor-3-simplifying-the-close_open_blocks-function"&gt;Refactor #3: Simplifying The close_open_blocks Function&lt;a class="headerlink" href="#refactor-3-simplifying-the-close_open_blocks-function" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This refactoring was a simple one, but for me it had a noticeable impact on helping
me get a clearer understanding of the function.  Prior to the change, the
&lt;code&gt;close_open_blocks&lt;/code&gt; function had 2 distinct responsibilities: determine if the element
on the top of the stack needed to be closed, and if so, remove that element from the
top and close the block. While I was able to read the function and use it properly,
I often had a little question in my head about whether I was using the
function properly.&lt;/p&gt;
&lt;p&gt;After the refactoring, the code containing the first responsibility remained in the
&lt;code&gt;close_open_blocks&lt;/code&gt; function and the code for the second responsibility was placed in
the new &lt;code&gt;remove_top_element_from_stack&lt;/code&gt; function.  When I looked at those two functions
during the writing of this article, I was able to see a very clear picture of what each
function is doing, with clear delineations of those responsibilities.  The
&lt;code&gt;close_open_blocks&lt;/code&gt; implements a while loop with 4 distinct ways to exit out of the
loop, and the &lt;code&gt;remove_top_element_from_stack&lt;/code&gt; function remove the top element, adding
the appropriate tokens to the document’s token stream.  Clear and concise, hence easy
to read.&lt;/p&gt;
&lt;p&gt;This function is core to the processing of the blocks and making it clearer was
important to me.  While it was a small refactor, it increased my confidence that the
function, and any functions that called it, were operating properly.  I believe that my
confidence increased because it went from one “messy” function to two separate
functions with very clear intentions.  By rewriting the code into two functions and
keeping each function simple, the messiness vanished.&lt;/p&gt;
&lt;h2 id="refactor-4-cleaning-up-the-determine_html_block_type-function"&gt;Refactor #4: Cleaning Up the determine_html_block_type Function&lt;a class="headerlink" href="#refactor-4-cleaning-up-the-determine_html_block_type-function" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I will admit, the next candidate, the &lt;code&gt;determine_html_block_type&lt;/code&gt; function was a mess.
At 88 lines long and 24 branches, it was clearly a function with too many
responsibilities.  Like the work documented in the previous section, I started to
take a look at this function and try and figure out what it was doing.  When I finished,
I came away with three responsibilities that the function was performing:
handling the special case (html block types 1 to 5), handling the normal cases (html
block types 6 and 7), and some cleaning up of the results for html block type 7.  That
was two responsibilities too many.&lt;/p&gt;
&lt;p&gt;Similar to the work above, the &lt;code&gt;determine_html_block_type&lt;/code&gt; function was
broken up along the identified lines of responsibility.  The
&lt;code&gt;check_for_special_html_blocks&lt;/code&gt; function was created to handle the special cases, the
&lt;code&gt;check_for_normal_html_blocks&lt;/code&gt; function was created to handle the normal cases, and the
&lt;code&gt;determine_html_block_type&lt;/code&gt; function contained orchestration logic for calling those
two functions, plus the special cleaning up for the html block type 7 logic.&lt;/p&gt;
&lt;p&gt;While this function is not as core to the parser as the &lt;code&gt;close_open_blocks&lt;/code&gt; function,
its refactoring had a similar effect.  Each of the added functions contained a single
responsibility, this making the usage of all three functions together easy to determine.
For me, that was good progress.&lt;/p&gt;
&lt;h2 id="refactor-4-clearing-pylint-warnings"&gt;Refactor #4: Clearing PyLint warnings&lt;a class="headerlink" href="#refactor-4-clearing-pylint-warnings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the writing of this article, the first thought that came to mind when writing
this section was that I should be ashamed that it took me until this point to address
the PyLint warnings on the project.  Taking a bit of a deeper look into how I
felt about this, I believe it had to do with where I draw the line between
“just playing around” and “real code”.  For me, I believe this transition is when a
project moves from a Proof-Of-Concept project to a Real™ project.  I am not 100%
sure, but I believe that it was at this point, give or take a couple of days, that I
felt that this was a real project.  While it is hard to pin down why, I believe that
having the block section of the specification done helped my mind crystalize that
the project is going to happen.  It was as if someone had whispered “This is going
to happen” in my ear, and that I needed to tidy things up.  Once I figured that out,
it just felt like a natural transition, nothing to be ashamed about.&lt;/p&gt;
&lt;p&gt;Now that this was a Real™ project, I needed to ensure that any PyLint
warnings were addressed or suppressed.  While I prefer to address these issues, some of
the warnings, such as the &lt;code&gt;too-many-arguments&lt;/code&gt; warning, occupy one of my grey areas.
Especially
with parsers, a lot of state information needs to be passed around, to ensure the
parsing is performed properly.  This often results in functions that take too many
arguments.  At this stage of the project, I decided to suppress those warnings, with a
number of &lt;code&gt;too-many-locals&lt;/code&gt; warnings until later in the project, when I have a better
sense of how to optimize those function calls for this parser.&lt;/p&gt;
&lt;p&gt;This refactoring helped me remember an adage a friend taught me about software:
“It isn’t if there is a problem with your code, it is a question of how often the
problems within your code occur.”  More of a realist than a pessimist, he figured that
each line of code brought a new set of issues and bugs with it, and it was our job to
discover and handle those issues that our users would find before they found them.
For me, it was a good refresher in humility when developing software.&lt;/p&gt;
&lt;h2 id="refactor-5-reducing-complexity-with-the-92at_index92-functions"&gt;Refactor #5: Reducing Complexity with the \&lt;em&gt;at_index\&lt;/em&gt; Functions&lt;a class="headerlink" href="#refactor-5-reducing-complexity-with-the-92at_index92-functions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Ever since the section above on
&lt;a href="https://jackdewinter.github.io/2020/02/17/markdown-linter-taking-time-to-refactor-post-block-implementation/#bob"&gt;parser functions&lt;/a&gt;,
I had been slowly searching for other patterns that I could refactor.  In the process, I
found a group of patterns that were not complex, but would benefit from a small
refactor.  Basically, a refactoring of that pattern wouldn’t make a lot of
difference in reducing the number of branches, but it would reduce the complexity of
the functions by making them easier to read.&lt;/p&gt;
&lt;p&gt;The group of patterns that I found all centered around finding out whether a
character or a string was at a given location in the string.  Specifically, the parser
contained three of these patterns that I felt were worth extracting into their own
functions: &lt;code&gt;is_character_at_index&lt;/code&gt;, &lt;code&gt;are_characters_at_index&lt;/code&gt;, and
&lt;code&gt;is_character_at_index_not&lt;/code&gt;.  None of these functions would facilitate a large
improvement, but the change from the following text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0"&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s2"&gt;"9"&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to this text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_character_at_index_one_of&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;produces more readable code by simply stating the intent of those lines, instead of
leaving the reader to interpret them.&lt;/p&gt;
&lt;p&gt;While I admit that it was not a big change, to me this refactoring provided some extra
confidence that the project was getting to a cleaner place.  Sometimes refactoring
produces big, measurable impacts, and sometimes they produce little ripples that are
barely noticeable.  However, sometimes those little ripples can mean a lot, and worth
a lot.&lt;/p&gt;
&lt;h2 id="refactor-6-increasing-code-coverage"&gt;Refactor #6: Increasing Code Coverage&lt;a class="headerlink" href="#refactor-6-increasing-code-coverage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a few of these parsing refactors, I noticed that the PyScan numbers
for code coverage were in the high nineties, which is very good for a number of
projects.  However, in a project that was designed from the ground up for high
code coverage numbers, such as the PyMarkdown project, there is almost always room
to do a bit better.&lt;/p&gt;
&lt;p&gt;In the case of the implementation of the HTML blocks, I implemented defensive
programming to try to ensure that edge cases were protected against.  In re-reading
the HTML block specification a couple of times, the focus of the specification seemed
to be focused on the main use cases, not the edge cases.  As such,
the code coverage report gave me good input on how to add 4 new use cases that helped
ensure that the edge cases for HTML blocks were fully covered.&lt;/p&gt;
&lt;p&gt;This type of refactoring is a difficult one for me to justify to some people, but I
feel strongly about it.  The justification centers around what level of code coverage
is considered “good enough”.  For myself, there are 2 main factors that weigh into my
decision on what is good enough with code quality: was the project designed with
testing in mind and what is the effort required to address the next issue.  In this
case, as minimal effort was required to add the 4 simple scenario tests to address the
issue, I would easily argue that it was not good enough.  From my point of view, the
small cost easily justified the benefit.&lt;/p&gt;
&lt;h2 id="refactor-7-translating-token-strings-to-actual-tokens"&gt;Refactor #7: Translating Token Strings to Actual Tokens&lt;a class="headerlink" href="#refactor-7-translating-token-strings-to-actual-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having made the jump in my head from a Proof-of-Concept project to a Real™
project, I decided it was time to change the stack tokens and Markdown tokens from
simple text strings to actual token objects.  Up to this point, I was more concerned
that the tokens looked right in the output stream, and there were only relatively few
cases where that output needed to be interrogated later.  With inline
processing on the horizon, which would heavily make use of token content, it made sense
to me to undergo this change before the inline processing started.&lt;/p&gt;
&lt;p&gt;The two places where I had made this tradeoff were the stack tokens and the Markdown
document tokens.  The stack tokens denote where in the processing the parser is and
the Markdown document tokens denote what was found during the processing.  In both
cases, it was more important to me to see the right patterns being parsed than to tie
them down to a given structure.  Based on experience, I wanted to do the least possible
work to get to this point, and then have the structure for each object emerge.&lt;/p&gt;
&lt;p&gt;For the &lt;code&gt;StackToken&lt;/code&gt; object, the structure that emerged was simple.  Each class
is responsible for any of it’s own variables, but also for providing a read-only, text
version of these variables, assigned to the base class’s &lt;code&gt;extra_data&lt;/code&gt; variable.  In this
way, the base class can include a number of the useful functions without requiring any
knowledge about the child classes.  By implementing the &lt;code&gt;__str__&lt;/code&gt;, &lt;code&gt;__repr__&lt;/code&gt;, &lt;code&gt;__eq__&lt;/code&gt;,
and &lt;code&gt;generate_close_token&lt;/code&gt; in this way, each child class was kept very simple and
straightforward.  In addition, instead of using Python’s &lt;code&gt;isinstance&lt;/code&gt; function to figure
out the type of token, I added &lt;code&gt;is_*&lt;/code&gt; methods for each token type to make the code
referencing the tokens more readable.&lt;/p&gt;
&lt;p&gt;The refactoring for the &lt;code&gt;MarkdownToken&lt;/code&gt; object was almost the same as for the
&lt;code&gt;StackToken&lt;/code&gt; object, but with a couple
of key differences.  With the &lt;code&gt;StackToken&lt;/code&gt;, the token itself was the focus of the
object, whereas with the &lt;code&gt;MarkdownToken&lt;/code&gt;, it is the data contained within the token
that is key.  The other big difference is that &lt;code&gt;MarkdownToken&lt;/code&gt; objects are the artifacts
that will be consumed and analyzed by the PyMarkdown project, not just an internal
representation.  As I had a lot of positive success with the design and use of the
&lt;code&gt;StackToken&lt;/code&gt; class, I modelled the &lt;code&gt;MarkdownToken&lt;/code&gt; class in a similar fashion, keeping
in mind the differences and altering the design to properly accommodate them.  From a
design point of view, things did not change things that much, but I needed to make sure
those objects look and function right, as they are very visible.&lt;/p&gt;
&lt;p&gt;This refactor was a long time coming, but I felt that it was the right time to do it.
As I mentioned in previous sections, the project felt more like a Real™ project
and not a proof of concept.  With a good bulk of the parsing completed, and with a
solid opinion of how I was going to orchestrate the remaining pieces, it was the right
time to nail down how those tokens would look to users of the project.  While I could
have done that earlier in the project, I believe that I would not have been able to
do so with the same confidence that I made the right choice.  For this project, I
believe that leaving the tokens in the raw form to this point was the best move
possible.&lt;/p&gt;
&lt;h2 id="refactor-8-consolidating-text-blocks"&gt;Refactor #8: Consolidating Text Blocks&lt;a class="headerlink" href="#refactor-8-consolidating-text-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Of all the refactors that I have talked about in this article, this refactor was the
one that I really needed to do.  Inline processing addresses the group of features that
expand on Markdown text within the blocks, and a lot of those processes assume that the
text within their blocks is one long string to process.  Currently, the text tokens
were distinct and disjoint, each one added in the order they were processed.  To get
ready for inline processing, those text tokens needed to be consolidated.&lt;/p&gt;
&lt;p&gt;There were two possible paths to take to accomplish this:  deal with the processing as
the text tokens were added or deal with them in a subsequent processing step.  As I want
to keep the processing logic as simple as possible, I decided that a follow-up step to
consolidate those tokens was the best course of action.  To accommodate this change, I
added the &lt;code&gt;coalesce_text_blocks&lt;/code&gt; function to simply go through the document tokens,
look for 2 text tokens beside each other, and append the second token’s text to the
first token.  Then, in the &lt;code&gt;transform&lt;/code&gt; function, instead of just returning the results
from the &lt;code&gt;parse_blocks_pass&lt;/code&gt; function, those results were passed to the
&lt;code&gt;coalesce_text_blocks&lt;/code&gt; and those were returned.&lt;/p&gt;
&lt;p&gt;While this change was a relatively small change, it impacted the token output for a lot
of the test cases.  In a meaningful way, that impact increased my confidence that
tackling it was the right choice to complete before inline processing started.  The
impact of the change on the test cases validated that it was a far-reaching change,
one that was better to have happen before the next stage of processing.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unlike the other articles in this series, this article was about how I took a bit
of a breather and focused on improving the quality of the PyMarkdown project.  As
the next set of features involves inline processing of text blocks, I believe
whole heartedly that taking that break to focus on refactoring increased my confidence
that I was on the right track with the parser.  &lt;/p&gt;
&lt;p&gt;Why do I feel that way?&lt;/p&gt;
&lt;p&gt;Looking into the near future, I know that inline processing will increase the
complexity to the project, and any effort to reduce the project’s complexity ahead of
that will directly help reduce the complexity of the inline processing.  Further into
the future, there are extensions to
Markdown that I will need to add that will also increase the complexity of the
project.  Add to that my plans to comply with other Markdown specifications, such as
the CommonMark specification, which will also increase the complexity.&lt;/p&gt;
&lt;p&gt;Why refactor? I want to keep the project simple and uncomplicated.  From a software
quality point of view, each refactor makes the project simpler and more
uncomplicated.  While some of the changes did not move the needle on the software
quality meter much, each change helps.&lt;/p&gt;
&lt;p&gt;In the end, I refactor projects to keep them simple.  As Einstein said:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Make everything as simple as possible, but not simpler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having teased the addition of inline processing to the project for most of this
article, the next article will be on the implementation of the first 3 aspects of
inline processing that I tackled.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Adding HTML Blocks</title><link href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/" rel="alternate"></link><published>2020-02-10T00:00:00-08:00</published><updated>2020-02-10T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-10:/2020/02/10/markdown-linter-adding-html-blocks/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed most of the Markdown block elements, as documented
in the last two articles on
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;leaf blocks&lt;/a&gt; and
&lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/"&gt;container blocks&lt;/a&gt;,
I wanted to go back and revisit the HTML blocks that I deferred.  For anyone following
this series, in the
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/#group-4-stopping-at-a-good-place"&gt;Stopping At A Good Place section&lt;/a&gt;
of the …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed most of the Markdown block elements, as documented
in the last two articles on
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;leaf blocks&lt;/a&gt; and
&lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/"&gt;container blocks&lt;/a&gt;,
I wanted to go back and revisit the HTML blocks that I deferred.  For anyone following
this series, in the
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/#group-4-stopping-at-a-good-place"&gt;Stopping At A Good Place section&lt;/a&gt;
of the “Parsing Normal Markdown Blocks” article, I determined that there were 3 types
of leaf blocks that would be difficult to implement, so I deferred them.  Between
my lack of use most of those deferred features and my distinct status as the first
user of the parser, I thought this was a decent trade off in the short run.  With
increased confidence from implementing the other block types, I thought it was
a good time to deal with this block type.&lt;/p&gt;
&lt;p&gt;Before continuing, I believe it is important for me to highlight some information about
HTML blocks in Markdown.  I have never needed to use HTML
blocks or raw HTML (covered in a later article) in any of my own Markdown documents.
Quick research revealed that there are some interesting cases where injecting HTML
blocks is a benefit.  However, that same research also noted that allowing either type
of HTML in Markdown is a potential security issue, and as such, may be disabled for a
given Markdown-to-HTML generator.  Regardless of my usage patterns or security patterns,
I wanted to be sure to include it in the PyMarkdown project for completeness.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/24fd972aef725bc55659ad3c2e7c1b93737a1874"&gt;20 December 2019&lt;/a&gt;.
This work includes implementing the parsing logic for the HTML Blocks as documented in
the GFM specification and implementing the parsing to pass all the scenario tests
for HTML blocks that were previous entered.&lt;/p&gt;
&lt;h2 id="why-did-i-defer-html-blocks"&gt;Why Did I Defer HTML Blocks?&lt;a class="headerlink" href="#why-did-i-defer-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The HTML blocks were one of those 3 deferred types because a quick reading of the
specification lead me to believe the HTML block implementation would be tricky.&lt;/p&gt;
&lt;p&gt;Why?  Take a minute and read or browse the
&lt;a href="https://github.github.com/gfm/#html-blocks"&gt;HTML blocks section&lt;/a&gt; of the
GitHub Flavored Markdown (GFM) Specification.  Don’t worry, I’ll wait while you do that.&lt;/p&gt;
&lt;p&gt;Done?  What did you think?  My initial read of the specification made me think that it
was going to be a complete mess to figure out properly.  After a walk to clear my head,
I took another look at the section.  When I factored in the work, I did to implement the
container blocks, this section looked like it would be tedious, but not too bad.  After
handling container blocks within container blocks, the straight parsing of a leaf block
would not be too bad. Right?&lt;/p&gt;
&lt;p&gt;I admit, it still looked kind of daunting to me.  From my observations, the 42 use
cases for
the HTML blocks was far more than the count for all of the other block groups
&lt;sup id="fnref:countScenarios"&gt;&lt;a class="footnote-ref" href="#fn:countScenarios"&gt;1&lt;/a&gt;&lt;/sup&gt; except for the list items group, at 47 use cases. And yes, the count
is mostly larger than the count for container blocks (with block quotes at 22 use
cases) and one half of the use cases for list blocks (with lists at 25 use cases and
list items at 47 use cases).  The data
backed my daunting feeling up, which was a relief.  Thinking about how I got to that
feeling, I realized that in reading the specification, I was telling myself a
story about how hard it would be to implement based on the sheer number of use cases.
So how was I going to change that narrative I was telling myself?&lt;/p&gt;
&lt;h2 id="changing-the-narrative"&gt;Changing the Narrative&lt;a class="headerlink" href="#changing-the-narrative" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In &lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/#what-was-my-experience-so-far"&gt;the last article&lt;/a&gt;,
I mentioned that one of my family’s favorite sayings is: “Stuff happens, pick yourself
up, dust yourself off, and figure out what to do next.”  “Stuff happens” was the
decision to defer the HTML blocks, “pick yourself up” was the decision to pick them up
again, “dust yourself off” was figuring out why I deferred the blocks, leaving the
“figure out what to do next” part.  One of my favorite tools to figure out what to do
next is to see if I can change the narrative, or story, with whatever it is that
I am doing.&lt;/p&gt;
&lt;p&gt;Why is this important?&lt;/p&gt;
&lt;p&gt;There are facts and opinions
that are part of every story.  Did the main character go to the cantina before boarding
the freighter with the smuggler?  That is a fact.  Whether or not the captain of that
freighter is a smuggler can be an opinion, depending on supporting facts.  How much
trust the main character had in that smuggler when boarding the freighter is mostly an
opinion.  The closer something is to a fact, the harder it is to change. Opinions can
be changed in many cases if you can find the right story to tell.&lt;/p&gt;
&lt;p&gt;The HTML blocks having 42 use cases to define its behavior is a fact, and facts do not
change easily.  Taking a deeper look at the 7 categories at the
start of the specification’s section on HTML blocks, I can make a good argument that
there are 3 sets of HTML tags instead of the 7 presented:  the meta tags, the special
tags, and everything else.  Furthermore, the first 20 use cases present general cases
while the next 18 use cases, and the last 4 use cases talk about specific rules and why
they were specified.&lt;/p&gt;
&lt;p&gt;Given this information, I can change the story I am telling myself by breaking down
the previous story into smaller stories, each with a specific focus.  Instead of one
group of 42 use cases, I can
have 3 smaller groups: 1 for general HTML blocks with 20 use cases, 1 for specific
HTML blocks with 18 use cases, and finally a “wrap-up” group of 4 use cases that better
explains why the specified rules are important.&lt;/p&gt;
&lt;p&gt;Why is this better?&lt;/p&gt;
&lt;p&gt;At 42 use cases for HTML blocks, it is the second biggest block
of use cases, and is somewhat scary.  Breaking that group up into 2 groups of about 20
use cases followed by a small group with 4 example use cases is something I can
comprehend better, implement better, therefore removing my concerns about the large
scope.&lt;/p&gt;
&lt;p&gt;In addition, experience has taught me that when translating use cases to scenario tests,
the last 2 to 3 translations are frequently show-stoppers or require major reworking to
properly translate and get working.
With a big group of 42 use cases, I know I would be expecting that behavior to happen,
with a large amount of rework to do when it happened.  After breaking down the problem
into the 3 smaller groups, I was somewhat confident that if the same situation occurs,
the amount of rework will be limited to approximately 20 scenario tests.  For me,
reducing that perceived effort helped me keep my confidence up instead of having it
take a hit. Instead of “when it happens” with the 42 use cases, it became “if it
happens” with the smaller groups of 20 use cases.&lt;/p&gt;
&lt;h2 id="let-the-implementation-begin"&gt;Let the Implementation Begin!&lt;a class="headerlink" href="#let-the-implementation-begin" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a boost to my confidence in place, I was able to get a decent amount of work
completed on the HTML blocks, wedged between shopping and work during the end of the
holiday season.  Despite my initial concerns
about the size and complexity of this feature, the development went smoothly.
Given how it went, I believe it lends support to my opinion that breaking down the use
cases into the 3 groups was the right thing to do.&lt;/p&gt;
&lt;p&gt;For those not familiar with Markdown and HTML, there some basic rules for HTML blocks,
and then the 3 categories of HTML blocks themselves: the meta tags, the special tags,
and everything else.  The basic rules are simple.  HTML blocks are always
started with tags that start at the beginning of a new line, and once the start
condition is met for one of the 7 block types, only the matching end condition finishes
off the HTML block.  In some cases, the end conditions can be met on the same line, and
in some cases, the end conditions make sense… and in some they do not. At least not
without understanding the rules!&lt;/p&gt;
&lt;h3 id="meta-tags"&gt;Meta Tags&lt;a class="headerlink" href="#meta-tags" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Block type 1 contains what I refer to as the “meta tags”, because those tags usually
contain information that is at a higher level than normal tags, such as script
information or style information.  For anyone familiar with authoring HTML, the
Markdown interpretation of these tags is almost the same as in a raw HTML document.
The start
condition is that one of the strings &lt;code&gt;&amp;lt;script&lt;/code&gt;, &lt;code&gt;&amp;lt;pre&lt;/code&gt;, or &lt;code&gt;&amp;lt;style&lt;/code&gt; is present,
followed by whitespace, the string &lt;code&gt;&amp;gt;&lt;/code&gt; or the end of the line.  The end condition is
that one of the strings &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;/style&amp;gt;&lt;/code&gt; are present, though the
tags specified in the start condition and end condition do not need to match each
other.&lt;/p&gt;
&lt;p&gt;As such, the following text is considered a complete HTML block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;style&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"text/css"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
h1 { font-size: 140%; font-weight: bold; border-top: 1px solid gray; padding-top: 0.5em; }
&lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;"jquery.min.js"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;"jquery.min.js"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that in the last example, while the Markdown specification considers it a complete
HTML block, it is not a valid HTML snippet.  The Markdown specification does not
specify any validation of the produced output, so beware of garbage-in, garbage-out.&lt;/p&gt;
&lt;p&gt;This HTML block type was easy to figure out, hence it was easy to implement.
Pretty straight forward: Look for one of the start strings, capture everything until
we find one of the end strings.  Quick and painless.&lt;/p&gt;
&lt;h3 id="special-tags"&gt;Special Tags&lt;a class="headerlink" href="#special-tags" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Block types 2 to 5 are what I refer to as the special tags.  In order, the HTML
specification refers to these as the comment tag, the processing instruction tag,
the declaration tag, and the CDATA tag.  Each of these tags is authored exactly as
would be expected in a normal HTML document and has its own distinct purpose.  In
each case, the start condition is a simple string, and the end condition is the
inversion of that string.&lt;/p&gt;
&lt;p&gt;While most of these tags have seldom used or esoteric purposes, the comment tag is used
frequently in HTML code, and is common in HTML documents.  Similar to block type 1
above, the following text is considered a complete HTML block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;    style type="text/css"&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;h1 { font-size: 140%; font-weight: bold; border-top: 1px solid gray; padding-top: 0.5em; }&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;!&lt;/span&gt;&lt;span class="c1"&gt;-- this is a comment --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like the previous HTML block type, these HTML block types were also easy to
figure out and implement.  Just like before: look for one of the start strings, capture
everything until we find one of the end strings.  Just as quick and just as painless.&lt;/p&gt;
&lt;h3 id="everything-else-tags"&gt;“Everything Else” Tags&lt;a class="headerlink" href="#everything-else-tags" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With block types 1 to 5 out of the way, the work focused in on the remaining
block types 6 and 7.  These two block types are different than the other blocks, with
their most prominent difference being that their end condition is a simple blank line.
Another difference is that there is a long list of tag names that are eligible for block
type 6, while any other tag is relegated to block type 7.  This becomes important as the
start conditions of block type 6 are the string &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;lt;/&lt;/code&gt;, followed by the tag name,
and then followed by whitespace, the string &lt;code&gt;&amp;gt;&lt;/code&gt;, the string &lt;code&gt;/&amp;gt;&lt;/code&gt; or the end of the line.
In contrast, the start conditions for block type 7 are that the HTML must either be a
complete open tag or a complete close tag, followed by optional whitespace and the end
of the line.  As an additional requirement, a block type 7 HTML block cannot interrupt
a paragraph.&lt;/p&gt;
&lt;p&gt;To me, these rules are confusing to anyone authoring even a small piece of HTML in
Markdown, adding to the reasons for me to suggest to people not to use HTML in Markdown.
While this confusion is not evident in the examples for the block types 1 to 5,
consider this sample:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;canvas&lt;/span&gt;
    &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"my-canvas"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;pre&amp;gt;&lt;/span&gt;
**Hello**,

_world_.
&lt;span class="nt"&gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/canvas&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and this sample:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;table&lt;/span&gt;
    &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"column"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;pre&amp;gt;&lt;/span&gt;
**Hello**,

_world_.
&lt;span class="nt"&gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without looking at the information in the specification, how easy is it to tell what the
output of each sample is?  To be honest, I had to refer back to the
&lt;a href="https://github.github.com/gfm/#html-blocks"&gt;HTML block definitions&lt;/a&gt; in the GFM
specification twice when I was writing these samples and three times when I was
verifying the samples before publishing this article.  That does not bode well, does it?&lt;/p&gt;
&lt;p&gt;For the first example, the &lt;code&gt;canvas&lt;/code&gt; tag name is not in the list for block type 6, and a
block type 7 evaluation fails as the tag is neither a complete start tag nor a complete
end tag.  As such, the &lt;code&gt;canvas&lt;/code&gt; start tag ends up being normal text, to be wrapped in a
paragraph.  The next tag, the &lt;code&gt;pre&lt;/code&gt; start tag, gets identified as a block type 1 start,
finishing at its own &lt;code&gt;pre&lt;/code&gt; end tag, with the remaining &lt;code&gt;canvas&lt;/code&gt; end tag going into its
own paragraph.  I know that was not what I expected at first glance.&lt;/p&gt;
&lt;p&gt;The second example has different issues.  Because the &lt;code&gt;table&lt;/code&gt; tag name is in the block
type 6 list of allowable tag names, the start conditions only state that it needs to
start with the first part of a start tag or end tag, which the string &lt;code&gt;&amp;lt;table&lt;/code&gt;
satisfies.  However, as the end condition for block type 6 HTML blocks is a blank
line, the HTML block ends after &lt;code&gt;**Hello**,&lt;/code&gt; and before &lt;code&gt;_world_.&lt;/code&gt;.  At this point,
the text &lt;code&gt;_world_.&lt;/code&gt; is parsed as normal text, and the text &lt;code&gt;&amp;lt;/pre&amp;gt;&lt;/code&gt; is interpreted as
a complete end tag by the block type 7 rules, carrying a block type 7 HTML block to
the end of the sample.  When reading a similar example as part of
&lt;a href="https://github.github.com/gfm/#example-118"&gt;example 118&lt;/a&gt;, it did take several tries
to figure out what was going on.&lt;/p&gt;
&lt;p&gt;These block types provided a bit of complexity that was different than the previous
blocks.  As such, I hit a couple of roadblocks that I had to work through.  It wasn’t
that the implementation was much more complicated than the previous HTML block types,
they weren’t.  It is
almost the same process: find one of the start conditions, and capture everything
until a blank line.  Sure, the start conditions were a bit meatier, but other than
that, it was relatively simple.  It was that they start conditions and end conditions
were different for these 2 HTML block types that made me look back at the use cases and
scenario tests with a couple of “huh”s until I that difference registered in my head.
And that list separating HTML block type 6 from 7… sheesh.&lt;/p&gt;
&lt;h2 id="my-recommendation"&gt;My Recommendation&lt;a class="headerlink" href="#my-recommendation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When it comes to HTML blocks, I implemented them as part of the parser because they
are part of the specification.  But because of the complexity in understanding
HTML blocks, I whole heartedly recommend avoiding using HTML blocks if possible.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I took my time with the implementation for HTML blocks due to the complexities stated
above.  For the most part, the code I implemented worked on the first or second try,
with few cases where it took more tries and debugging than that.  I believe the key
to the relatively easy implementation was breaking the groups and tasks down into
multiple, smaller groups and smaller tasks.  In retrospect, I believe this enabled me to
more readily get my mind around the task to accomplish, and not get overwhelmed by
the size of the problem.&lt;/p&gt;
&lt;p&gt;Implementing that thinking for the project, while not concrete, helped me see other
things for the project in a better perspective. Most of the things I initially thought
would be complex turned out to not be that complex.  The long list of tag names for
block type 6?  Strings in a list object. The end conditions?  Either looking for a
blank line or one of a set of strings in one of the following lines.  Getting the use
cases right in the scenario tests?  Really simple.  I still contend that authoring HTML
in Markdown is complex, but the implementation was easy.&lt;/p&gt;
&lt;p&gt;Another boost to my confidence was tackling the HTML blocks and getting them out of
my “technical debt column”.  While I believe that I made the right decision to defer
the HTML blocks for the right reasons, it still felt good to get them dealt with.
Like my experience with translating the last 2-3 uses cases into scenario
tests, thinking about revisiting any technical debt also triggers similar expectations
of the reworking of existing code, if that revisiting is actually possible at all.
Taking something out of technical debt and being able to remove that uncertainty
helped my confidence towards the completion of the parser for this project.&lt;/p&gt;
&lt;p&gt;All in all, I believe things are still headed in the right direction!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the implementation of the PyMarkdown parser, I have been using my PyScan script
to great benefit.  As such, I decided to take the time to polish it up a bit and
document it in
&lt;a href="https://jackdewinter.github.io/2020/01/13/measuring-testing-in-python-scripts/"&gt;this article&lt;/a&gt; on Software Quality.
While doing that, I took some time to refactor the PyMarkdown code to make it easier to
work with, preparing it for the inline processing that was to come next.  The
next article will go over the refactoring that I did, and how it helped the project.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:countScenarios"&gt;
&lt;p&gt;The totals are as follows: paragraphs (9), tabs (11), indented code blocks (15), atx headings (18), thematic breaks (19), block quotes (22), lists (25),setext headings (27), and fenced code blocks (29). &lt;a class="footnote-backref" href="#fnref:countScenarios" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Adding Block Quotes and Lists</title><link href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/" rel="alternate"></link><published>2020-02-03T00:00:00-08:00</published><updated>2020-02-03T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-03:/2020/02/03/markdown-linter-adding-block-quotes-and-lists/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having the leaf blocks mostly in place, as documented
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;in the last article&lt;/a&gt;, the next items
on the implementation list were the list blocks and the block
quote blocks.  These Markdown blocks, referred to as Container Blocks in the
&lt;a href="https://github.github.com/gfm/#container-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the more complicated blocks …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having the leaf blocks mostly in place, as documented
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;in the last article&lt;/a&gt;, the next items
on the implementation list were the list blocks and the block
quote blocks.  These Markdown blocks, referred to as Container Blocks in the
&lt;a href="https://github.github.com/gfm/#container-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the more complicated blocks to deal with, as they are capable of containing other
blocks.  As there are
&lt;a href="https://github.github.com/gfm/#phase-1-block-structure"&gt;specific suggestions&lt;/a&gt;
on how to parse these blocks, my confidence took a hit when I started looking at this
section. My viewpoint: if the specification writers thought it was difficult to
implement that they wrote suggestions on how to handle it, it must not be as easy as
the leaf blocks!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/49407f86564479934ee92fb59597ba830a46fde8"&gt;08 December 2019&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/00bbef09eba4fd5d7c663ca6e991b48e5b96c60e"&gt;15 December 2019&lt;/a&gt;.  This work includes creating the
scenario tests for all the Container Blocks as documented in the GFM specification
and implementing the parsing to pass most those tests except for the nested cases.&lt;/p&gt;
&lt;h2 id="container-blocks-leaf-blocks-and-interactions-oh-my"&gt;Container Blocks, Leaf Blocks, and Interactions (Oh My!)&lt;a class="headerlink" href="#container-blocks-leaf-blocks-and-interactions-oh-my" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before container blocks, parsing was easy.  A block starts, and when the parser
encounters the termination conditions, it ends.  There are a few rules about when
blocks can start and end, such as
&lt;a href="https://github.github.com/gfm/#example-83"&gt;“An indented code block cannot interrupt a paragraph.”&lt;/a&gt;,
but for the most part, there is little interaction between the leaf blocks.  The leaf
blocks are clean and tidy.  Not so much with container blocks.&lt;/p&gt;
&lt;p&gt;Container blocks, by their very definition, contain other blocks, namely leaf blocks and
container blocks.  While this makes certain visual elements easier, this also means
specific rules about what interactions are allowed between the blocks.  On top of that,
as container blocks can contain other container blocks, testing is required to ensure
that an arbitrary number of nested containers is properly supported.&lt;/p&gt;
&lt;p&gt;A great example of nesting container blocks is the Markdown implementation of sublists.
A list containing a list containing a list is simple in Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;first&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;second&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;third&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That example is not a single list, but 3 separate lists.  The &lt;code&gt;first level&lt;/code&gt; list is the
first level list, containing the list &lt;code&gt;second level&lt;/code&gt;, which contains the list
&lt;code&gt;third level&lt;/code&gt;.  And while sublists are a simple case of container blocks, more complex
cases are possible, such as this one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;first&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;```&lt;/span&gt;&lt;span class="nb"&gt;text&lt;/span&gt;
    &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt;
    &lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This list is like the first list, except it contains a fenced code block as the
contained block.  Both examples are just a few of the possibilities of how
container blocks can contain other blocks.  Looking through the specification, I
quickly lost count of the number of combinations possible.&lt;/p&gt;
&lt;h2 id="enter-lazy-continuations"&gt;Enter Lazy Continuations&lt;a class="headerlink" href="#enter-lazy-continuations" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If the interactions between container blocks and the blocks they contain was not a fun
enough exercise in mental agility, enter lazy continuations.  From the GitHub Flavored
Markdown (GFM) Specification’s
&lt;a href="https://github.github.com/gfm/#block-quotes"&gt;block quotes section&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Laziness&lt;/strong&gt;. If a string of lines Ls constitute a block quote with contents Bs, then the result of deleting the initial block quote marker from one or more lines in which the next non-whitespace character after the block quote marker is paragraph continuation text is a block quote with Bs as its content.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and from the &lt;a href="https://github.github.com/gfm/#list-items"&gt;list items section&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Laziness&lt;/strong&gt;. If a string of lines Ls constitute a list item with contents Bs, then the result of deleting some or all of the indentation from one or more lines in which the next non-whitespace character after the indentation is paragraph continuation text is a list item with the same contents and attributes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, what they are both saying is that if a paragraph has been started with block
quotes or within a list AND if a line is clearly a continuation of a paragraph, then it
is valid to remove some or all of the container block markers.  For a more concrete
example, &lt;a href="https://github.github.com/gfm/#example-211"&gt;example 211&lt;/a&gt; has the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;baz&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is parsed the same as if the following Markdown were written as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After reading those sections and letting them sink in, my confidence took a dip.  This
was not going to be an easy concept to get right.  But the sooner I dealt with those
scenarios, the sooner I could try and implement them the right way.  Knowing this, I
went forward with the implementation phase of the container blocks.&lt;/p&gt;
&lt;h2 id="getting-down-to-work-the-easy-scenarios"&gt;Getting Down to Work - The Easy Scenarios&lt;a class="headerlink" href="#getting-down-to-work-the-easy-scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I often recommend to friends and
co-workers that taking a break and doing something unconnected to the “chore” helps
your mind get things together.  As such, before getting started on this work, I
decided to walk our dog for a while and let some of these concepts mull around in my
head. I am not sure if it was the exercise or the change in scenery, but it helped to
clear the cobwebs from my head and helped me to see things about the project more
clearly.&lt;/p&gt;
&lt;p&gt;The big thing that it accomplished was to help me cleanly separate out the easy tasks
from the more difficult tasks. The easy tasks? Simple block quotes and simple lists,
including sub-lists.  The difficult tasks?  Lazy continuations and mixed container
types.  I remember feeling that taking this time helped my confidence on the project,
as I was taking simple steps to understand where the difficulties were most likely to
show up.  This process also allowed me to think about those hard issues a bit while
implementing the easier features.  While I was not devoting any serious time to the
more complicated features, it was good to just have my mind aware of which sections of
code that I was going to need to keep flexible going forward.&lt;/p&gt;
&lt;p&gt;Keeping this in mind, I started with block quotes, adding the block quote test cases to
&lt;code&gt;test_markdown_block_quotes.py&lt;/code&gt;, disabling any tests that I figured were not in the
easy category.  I then proceeded to implement the code, in the same way as detailed in
the
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;prior article on leaf blocks&lt;/a&gt;.
Implementing the easy scenario tests for the block quotes was a decent sized task,
mostly completed during two days on a weekend where I had some time.  This also included
fixing scenario tests in 6 other test files that has block quotes in their scenarios.&lt;/p&gt;
&lt;p&gt;Working on the basic list items over the next week, by the middle of the next weekend
they were completed, in a similar fashion to how the block quotes were completed: new
scenario tests were added, the easy ones were then tested, enabled, and verified for
completion, and the more difficult ones were disabled.  Similar to the block quotes,
getting this right took roughly a week, and that work also had impact on scenario
tests other than the ones I added.&lt;/p&gt;
&lt;p&gt;During this process, I believed I found the parsing of lists more difficult.  Thinking
about the
implementation in hindsight, I believe it was mostly due to their parsing requirements.
The fact is that block quotes have a single character &lt;code&gt;&amp;gt;&lt;/code&gt; to consider for parsing,
while the lists can be unordered and start with the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; character or the
lists can be ordered and start with a number and the &lt;code&gt;)&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; or character.  In
addition, for ordered lists, there is also the parsing of the start number and how to
interpret it.  Looking at the two blocks that way, block quote blocks seem a lot easier
to me.&lt;/p&gt;
&lt;p&gt;However, now that I have had a bit of time since that code was written, I believe that
those two features were closer in difficulty that I initially thought.  Having
implemented both block quotes and lists, I think that they both had something that was
difficult that needed overcoming.  Since I have done a lot of parsers in my past, the
number of variations in parsing the lists were immediately noticeable to me, while the
block quotes were easy to parse.  Balancing that out, once parsed the lists were
easy to coordinate, while the block quotes took a bit more finessing to get right.
In the end, I believe it was a pretty event effort to get both done properly.&lt;/p&gt;
&lt;p&gt;At least until nested mixed container blocks.&lt;/p&gt;
&lt;h2 id="nested-and-mixed-containers"&gt;Nested and Mixed Containers&lt;a class="headerlink" href="#nested-and-mixed-containers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Nested container blocks, specifically mixed nested container blocks, is where things
got messy.  To be 100% honest, I am pretty sure I did not get everything right with the
implementation, and I already have plans to rewrite this logic. More on that later.&lt;/p&gt;
&lt;p&gt;I started implementing these features knowing that they probably made up the remaining
10% of the scenarios. I also figured that to handle these specific scenarios properly
would require as much time and effort as the prior 90% of the scenarios.  This was not
really a surprise, as in software development getting a project to the 70-90% finished
mark is almost always the easy part.&lt;/p&gt;
&lt;p&gt;Over the next week’s work, I reset my fork of the code back to its initial state 3 or 4
times.  In each case, I just got to a point where I either hit a block in going forward,
I wasn’t happy and confident about the solution, or both.  In one of those cases, the
code was passing the scenario tests that I was trying to enable, but it just did not
feel like I could extend it to the next scenario.  I needed to be honest with myself and
make an honest determination of how good the code I just wrote was.&lt;/p&gt;
&lt;p&gt;In the end, I completed some of the sublists and nested block quotes, requiring only 4
scenario tests to be disabled or skipped.  The ones that were disabled were the 10% of
the 10%, the cases where there were 3 or more levels of block quotes and lists mixed
together. I was not happy with it, but after a week, I knew I needed to move on
with the project.  Grudgingly, I acknowledged that I would need to rewrite this later.&lt;/p&gt;
&lt;h2 id="why-rewrite-already"&gt;Why Rewrite Already?&lt;a class="headerlink" href="#why-rewrite-already" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I am very confident that I coded the easy level cases correctly, as I have solid
scenario tests, and a decent volume of them, to test the various use cases.  For the
medium difficulty cases, such as a container within a container, I have a decent amount
of confidence that the scenario tests are capturing most of the permutations.  It is
the more complicated cases that I really am not confident about.  And when I say I am
not confident; it is not that I am not sure if it is handling the test properly: that
is a binary thing.  The test is passing, or the test is failing, and thus disabled.  I
am not confident that all those tests work for all use cases like that the scenario
tests represent.&lt;/p&gt;
&lt;p&gt;Part of any project is learning what works and what does not work.  As I started
looking at implementing
&lt;a href="https://github.github.com/gfm/#example-237"&gt;example 237&lt;/a&gt;, I read the
following paragraph located right before the example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is tempting to think of this in terms of columns: the continuation blocks must be indented at least to the column of the first non-whitespace character after the list marker. However, that is not quite right. The spaces after the list marker determine how much relative indentation is needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It was then that I was pretty sure I had coded the container blocks in terms of columns
instead of spaces.  Add that to the list of rewrites needed.&lt;/p&gt;
&lt;p&gt;The other category where my confidence is not high is with multiple levels of mixed
container blocks.  Once I complete the rewrite above, I can properly evaluate how well
I can nest the containers, but at that moment it was not high.  At that point,
example 237 will be a good scenario test to determine how well I have those set up.
Having taken some time to really evaluate the code and the scenario tests, I just have
a suspicion that there is at least 1-2 bugs in the code that I wrote.  For now, that is
on my list of possible rewrites, with a medium to high probability of being needed.&lt;/p&gt;
&lt;p&gt;The saving grace for both of these scenarios that I believe need rewrites?  Their
frequency.  The scenarios for blocks, leaf blocks and container blocks, comprise
about half of the specification, ending with
&lt;a href="https://github.github.com/gfm/#example-306"&gt;example 306&lt;/a&gt;.  According to my test failure
report, only 4 of the list block tests had to be marked as skipped, hence they were not
passing.  At approximately 1.3% of the total scenarios, it is not a big impact.  In
writing this block, I have used lists frequently, block quotes sporadically, and block
quotes with lists even less.  I am not sure if my writing is representative of
everyone’s writing, but at least for now, it is a good place to start.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;All the leaf blocks were finished in about a week.  The easy and medium cases for
the container blocks were finished about a week.  The hard cases for the container
blocks… not finished after a week, but close.&lt;/p&gt;
&lt;p&gt;Was I disappointed?  Sure.  But in comparison to other issues I have had with projects,
this was not even near the top 20 in terms of disappointment.  To be honest, in terms
of how projects have gone for me over the years, this has been a decent project to
work on.  Every project has its issues, and this was just the set of issues that
happened to occur on this project.&lt;/p&gt;
&lt;p&gt;I know it may sound a bit silly, but me and my immediate family have a saying we like
to repeat when things get tough: “Stuff&lt;sup id="fnref:notStuff"&gt;&lt;a class="footnote-ref" href="#fn:notStuff"&gt;1&lt;/a&gt;&lt;/sup&gt; happens, pick yourself up, dust
yourself off, and figure out what to do next.”  The disabled tests happened, so I took
some time to find my focus, and came up with a plan to deal with it.  Not a great
plan, but it meant I could go forward with the remaining scenarios and circle back
once I accumulated more experience with the parser.&lt;/p&gt;
&lt;p&gt;Sure there already was some
&lt;a href="https://en.wikipedia.org/wiki/Technical_debt"&gt;technical debt&lt;/a&gt;
for this project, but other than that, I believe it is going well.  At this point it
was just before Christmas, and I had a Markdown parser that was coming along
well.  My confidence in the implemented leaf blocks was high, as was my confidence in
the easy 90% of the container block implementation.  The more difficult 10% of the
container blocks was still undecided, but I had a plan to deal with it going forward.
While not a sterling situation, it was definitely a good position for me to be in.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before I took some time to improve my PyScan tool, I worked on adding HTML block
support for the PyMarkdown project.  As HTML in Markdown has some funny logic associated
with it, the next article will be devoted entirely to the HTML blocks.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:notStuff"&gt;
&lt;p&gt;When my kids were younger, I did indeed use the word “stuff”.  As my kids got older, we changed that word to another one that also starts with “s”.  The actual word that we now use should be easy to figure out! &lt;a class="footnote-backref" href="#fnref:notStuff" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry><entry><title>Markdown Linter - Parsing Normal Markdown Blocks</title><link href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/" rel="alternate"></link><published>2020-01-27T00:00:00-08:00</published><updated>2020-01-27T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-01-27:/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the &lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;project requirements&lt;/a&gt;,
the &lt;a href="https://jackdewinter.github.io/2019/12/16/markdown-linter-setting-up-parser-tests/"&gt;test framework&lt;/a&gt;,
and the &lt;a href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/"&gt;test strategy&lt;/a&gt; in place,
it was time to start working on the most frequently used and easy-to-parse Markdown
items.  These Markdown blocks, referred to as Leaf Blocks in the
&lt;a href="https://github.github.com/gfm/#leaf-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the root of many Markdown …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the &lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;project requirements&lt;/a&gt;,
the &lt;a href="https://jackdewinter.github.io/2019/12/16/markdown-linter-setting-up-parser-tests/"&gt;test framework&lt;/a&gt;,
and the &lt;a href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/"&gt;test strategy&lt;/a&gt; in place,
it was time to start working on the most frequently used and easy-to-parse Markdown
items.  These Markdown blocks, referred to as Leaf Blocks in the
&lt;a href="https://github.github.com/gfm/#leaf-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the root of many Markdown documents and have the virtue of being easy to parse.
With small exceptions, each of the Leaf Blocks is self-contained.  For the most part,
those exceptions arise in how the Leaf Blocks interact with each other.
In all cases, this interaction is small and does not require complicated logic to
understand.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits that occurred between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4ad7ebd46d7651d20a8b470b4d287e49cebfff75"&gt;30 November 2019&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/aee7a3def2dffc8531814a8b87365068d07730dc"&gt;05 December 2019&lt;/a&gt;.  This work includes creating the
scenario tests for all the Leaf Blocks as documented in the GFM specification
and implementing the parsing to pass all of those tests except for the Link Reference
Definitions, HTML Blocks, and Tables.&lt;/p&gt;
&lt;p&gt;While the documentation of what needed to be done (GFM Specification) and what was done
(GitHub commits) is straightforward, the “hows” and “whys” of what I implemented
is worth talking about.  The process that I followed for the implementation of the Leaf
Blocks did not uncover any development issues during implementation.  However, without
giving too much away, the same process applied to other block types (to be talked about
in future articles) did uncover issues that were not so easy to resolve.  As there were
complications that arose with those feature implementations, I wanted to provide a
consistent documentation of the process from the beginning, to provide a complete
picture of how things progressed.   I firmly believe that it is always good to show the
complete story of what happened, and not only one side of the story. Let’s go!&lt;/p&gt;
&lt;h2 id="moving-forward-with-implementation"&gt;Moving Forward with Implementation&lt;a class="headerlink" href="#moving-forward-with-implementation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Even though the first commit for processing Markdown elements is on 30 November 2019, my
work on implementing them started on 25 November 2019.  Based on the test framework and
strategy documented in previous articles, the first thing to do was to write the
scenario tests cases, even if most of those tests were initially disabled or skipped.
This was easily done by annotating each test function with &lt;code&gt;@pytest.mark.skip&lt;/code&gt;. Once
I implemented the code to satisfy a given test, I removed that skip annotation for
that specific test.  While I would made modifications on how I disabled tests later,
this was a good point for me to start off at.&lt;/p&gt;
&lt;h2 id="what-was-the-workflow"&gt;What Was the Workflow?&lt;a class="headerlink" href="#what-was-the-workflow" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From the outset, the basic implementation workflow was as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;figure out the next section to work on&lt;/li&gt;
&lt;li&gt;figure out the next section-feature to implement&lt;/li&gt;
&lt;li&gt;enable the relevant tests for that section-feature&lt;/li&gt;
&lt;li&gt;add or change the code in &lt;code&gt;tokenized_markdown.py&lt;/code&gt; to implement that feature&lt;/li&gt;
&lt;li&gt;execute all enabled tests, with special attention to the feature added in item 4.&lt;/li&gt;
&lt;li&gt;if there were any test errors; debug, fix and go back to &lt;code&gt;item 4.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stage the changes in the project before&lt;/li&gt;
&lt;li&gt;if there are more features in the current section, go back to &lt;code&gt;item 2.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;verify each test case’s input and output against the specification&lt;/li&gt;
&lt;li&gt;if any verification errors are found; debug, fix and go back to &lt;code&gt;item 4.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;if there are any leaf block sections left to work on, go back to &lt;code&gt;item 1.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It was not really glamourous, but it worked well.  Looking closely at the list, it is
easy for me to see why… I took an agile approach without really being aware of it.
According to the Wikipedia article on
&lt;a href="https://en.wikipedia.org/wiki/Agile_software_development#Agile_software_development_practices"&gt;Agile Software Development&lt;/a&gt;,
there are a number of good practices that I was following.  Because I was doing testing
as I went, the is a good argument to be made that I was practicing
&lt;a href="https://en.wikipedia.org/wiki/Agile_testing"&gt;Agile Testing&lt;/a&gt; and
&lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;Test Driven Development&lt;/a&gt;.
As the tests are also the acceptance criteria for this stage of the project,
&lt;a href="https://en.wikipedia.org/wiki/Acceptance_test-driven_development"&gt;Acceptance Test Driven Development&lt;/a&gt;
could also be tacked on to those two Agile practices.  Finally, as the workflow is
iterative by its very nature, the workflow also qualifies as
&lt;a href="https://en.wikipedia.org/wiki/Iterative_and_incremental_development"&gt;Iterative and Incremental Development&lt;/a&gt;.
All in all, I see a few solid agile patterns within the workflow.&lt;/p&gt;
&lt;p&gt;Agile aspirations aside, the real test of this workflow is that it works for me and
works well.  I was able to stick to the process easily. It very nicely
compartmentalized my work into nice iterations that were easy for me to keep in my
head. It was also simple enough that if I needed to refocus myself, I just had to
figure out where I was in the workflow and where I was in the specification, and I
was able to get back to work!  In addition, I feel that if I had performed this
development as part of a team, the frequent commits and complete with enabled tests
would enable me to share my progress with the rest of the team, and solicit their
feedback in a quick and iterative manner.&lt;/p&gt;
&lt;p&gt;More importantly, at no point in the development practice did I feel that I bit off more
than I could handle.  Of course, there were times where I was wondering how long it was
going to take me and how I would handle some features… I am only human!  But the agile
nature of how the workflow is structured kept me grounded and focused on the feature
that was in front of me.  I just reminded myself to keep that focus, and feature by
feature, the foundations of the parser came together.&lt;/p&gt;
&lt;p&gt;In the end, this workflow was not about being agile or taking easy to implement steps.
It is about finding something that works well for the team… namely me.&lt;/p&gt;
&lt;h2 id="how-did-things-progress"&gt;How Did Things Progress?&lt;a class="headerlink" href="#how-did-things-progress" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The order in which things are tackled is important.  Doing the big
stuff at the start of the project sometimes pays off, but it can often be demoralizing.
Doing the small stuff first can lay some great foundations but miss the larger target
due to the smaller focus.  To accomplish this for the PyMarkdown project, I broke
this part of the project down into 4 groups of Markdown elements.  Each group of
Markdown elements that were handled added new information to the stream of tokens
that were being generated by the parser, allowing for future examination.  It was
very important to me to ensure that the token stream was kept working, the
implementation always moving forwards.&lt;/p&gt;
&lt;h3 id="group-1-foundational-elements"&gt;Group 1: Foundational Elements&lt;a class="headerlink" href="#group-1-foundational-elements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first group that I worked on were the rudimentary elements of blank lines,
paragraphs, and thematic breaks.  This was a good first
group to work on, as these were all common Markdown elements that people use and are
foundational to the rest of the work.  As such, they were good confidence boosters for
the tribulations that I expected that would occur later with the more complicated
elements.&lt;/p&gt;
&lt;p&gt;The only real issue that I had with this first group was due to my lack of confidence
about the Markdown specification itself.  From my days on the
&lt;a href="https://www.ietf.org/"&gt;Internet Engineering Task Force&lt;/a&gt;,
I am used to clear grammar specifications written in
&lt;a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form"&gt;Backus-Naur form&lt;/a&gt;.
However, this specification has no such representation and is written mainly as a
series of use cases and text to describe each use case.  It took me a while to see that
what I perceived initially as a downfall was a bonus.  Instead of having to
search for examples or to make them up myself, they were already provided.  Once I got
used to that concept, my confidence increased, and I started to implement each test more
quickly than the last one.&lt;/p&gt;
&lt;p&gt;While it did not seem like much at the time, at this point the parser was capable of
handling the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;captured&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="o"&gt;***&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="group-1-sidebar-tabs"&gt;Group 1 Sidebar: Tabs&lt;a class="headerlink" href="#group-1-sidebar-tabs" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;I started to tackle the GFM specification decision that any tab character is
replaced with exactly 4 space characters.  For the most part, this had
little bearing on the foundational elements, but the subject of
&lt;a href="https://www.bing.com/search?q=tabs+vs+spaces"&gt;tabs versus spaces&lt;/a&gt; has ignited
&lt;a href="https://www.reddit.com/r/programming/comments/3xbyh6/the_software_development_holy_wars_part_i_the/"&gt;programming holy wars&lt;/a&gt;
that last to this day.  I thought it was useful and prudent to deal with it
and get it out of the way early.&lt;/p&gt;
&lt;p&gt;Smartly, Markdown avoids these arguments with a strong statement that 1 tab character
equals 4 space characters, and a decent argument to reinforce that the decision is the
right one. Except for the indented code block, every Markdown element is
only recognized if it starts with less than 4 spaces.  An indented code block line is
only recognized if it starts with 4 spaces.  Therefore, a shortcut for any indented
code block is to start the line with 1 tab character, due to its 1:4 mapping.  To be
honest, I feel this is brilliant in its simplicity.&lt;/p&gt;
&lt;h3 id="group-2-headers"&gt;Group 2: Headers&lt;a class="headerlink" href="#group-2-headers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The next group that I tackled were the header markers, referred to in the specification
as the &lt;code&gt;setext&lt;/code&gt; and &lt;code&gt;atx&lt;/code&gt; elements.  Weird names though they are, they are the up to 6
&lt;code&gt;#&lt;/code&gt; characters at the start of the line, or the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt; characters underlining
text from a previous paragraph.  While the &lt;code&gt;atx&lt;/code&gt; elements (the &lt;code&gt;#&lt;/code&gt; characters) was
straight forward, the ‘underlining’ aspect of the &lt;code&gt;setext&lt;/code&gt; element made it
interesting.  As that element essentially makes the last paragraph a heading, I had to
search backwards in the list of generated tokens for the first time.&lt;/p&gt;
&lt;p&gt;It was also at this point that I decided to perform some refactoring to better
handle string processing.  The simple truth about any parser is that it requires
gratuitous amounts of “string fiddling” &lt;sup id="fnref:stringFiddle"&gt;&lt;a class="footnote-ref" href="#fn:stringFiddle"&gt;1&lt;/a&gt;&lt;/sup&gt;.  Most efficient parsers work
aggressively to parse their documents in a way that minimizes the number of actual
strings created while parsing.  A good example of efficient “string fiddling” can be
seen in the following example of parsing the sentence &lt;code&gt;I have a black dog&lt;/code&gt;.  When
parsing out the word &lt;code&gt;black&lt;/code&gt;, the most optimal parsers will find the index of the &lt;code&gt;b&lt;/code&gt;
in &lt;code&gt;black&lt;/code&gt;, then find the space character after the &lt;code&gt;k&lt;/code&gt;, using the language’s
&lt;code&gt;substring&lt;/code&gt; function  and those two indexes to create a single string with &lt;code&gt;black&lt;/code&gt; in
it.  Less optimal parsers will find the &lt;code&gt;b&lt;/code&gt;
append it to the end of an empty string (creating a new string with &lt;code&gt;b&lt;/code&gt;), then find
the &lt;code&gt;l&lt;/code&gt; character and appended it, etc.  This can easily cause 6 strings to be created
during the parsing of the word &lt;code&gt;black&lt;/code&gt;, when only 1 is needed.  As some of the
Markdown documents that the parser will handle are large, it is important to remember
optimizations like this as features are added.&lt;/p&gt;
&lt;p&gt;Keeping this in mind, I started looking for “string fiddling” patterns that looked ripe
for refactoring.  The most obvious one was the
&lt;code&gt;determine_whitespace_length&lt;/code&gt; function that took care of any tabs in the input data.
While I would rip this out later, opting instead to do a simple search-and-replace for
tabs at the start of parsing, the &lt;code&gt;determine_whitespace_length&lt;/code&gt; function kept things
manageable for tabs characters.  There were also the &lt;code&gt;extract_whitespace*&lt;/code&gt; functions for
extracting whitespace and the &lt;code&gt;collect_while_character&lt;/code&gt; function for collecting data
for a string while the input was a given character.  Taking a peek ahead in
the specification, it was easy to see that moving the code into those functions was going to pay off.&lt;/p&gt;
&lt;p&gt;When it comes down to it, there were no real issues that I experienced with the
headers.  My confidence was still building from the foundational group above, but there
was nothing weird or challenging that I did not handle with a bit of serious thought
and planning.&lt;/p&gt;
&lt;p&gt;At this point, the parser could handle the following Markdown elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Markdown&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;captured&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;But&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;
&lt;span class="c1"&gt;-------------------&lt;/span&gt;

&lt;span class="o"&gt;***&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="group-3-indented-and-fenced-code-blocks"&gt;Group 3: Indented and Fenced Code Blocks&lt;a class="headerlink" href="#group-3-indented-and-fenced-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Marching right along, indented and fenced code blocks were next on the list.  Both are
used to denote sections of text that are to be represented literally, but one is easier
and one is more flexible.  The indented code blocks require 4 space characters (or a
tab character) at the start of the line to denote the block, and text is presented
plainly.  However, the fenced code blocks start and end with an equal number of &lt;code&gt;`&lt;/code&gt;
or &lt;code&gt;~&lt;/code&gt; characters and include provisions for naming the type of text used within the
code block.  This naming allows processors to specify a given style to apply to the
code block, allowing processors and style sheets to ‘colorize’ the text according to
the the specified type name.&lt;/p&gt;
&lt;p&gt;This grouping was easy to process, adding the &lt;code&gt;extract_until_whitespace&lt;/code&gt; function
to the growing list of helper functions.  The interesting part to the code blocks was
that I needed to add extra processing of normal text to handle the text within the code
blocks.  Prior to these code blocks, any text that did not fall into one of the other
categories was simply wrapped in a paragraph.  Both blocks have specific end
conditions, and until those end conditions are met, the collection continues.  This
meant adding extra code at the start of line parsing to determine if it was within one
of the code blocks.  If the end condition was met, then the end block token was emitted,
and if not, a text block would be emitted without further parsing.&lt;/p&gt;
&lt;p&gt;It was at this point that I started seeing the intertwining nature of some of the use
cases.  An indented code block cannot interrupt a paragraph, but a fenced code block
can.  So when looking for the indented code block, I had to explicitly disallow one
from starting if the block currently being process was a paragraph.  While this was
only a small case, it became obvious to me from a quick scan over the specification
that this type of pattern was going to repeat more than once.  As such, I started
moving the start and stop logic into their own functions, whether they required it or
not.  This improved the readability and enabled me to get a better view on what was
being handled and where.&lt;/p&gt;
&lt;p&gt;At this point, the parser could handle the following Markdown elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Markdown&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;captured&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="o"&gt;```&lt;/span&gt;&lt;span class="n"&gt;Python&lt;/span&gt;
    &lt;span class="n"&gt;rt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"1:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;

&lt;span class="n"&gt;But&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;
&lt;span class="c1"&gt;-------------------&lt;/span&gt;

    &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;

&lt;span class="o"&gt;***&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Please note that the fenced code block specifies &lt;code&gt;python&lt;/code&gt; as it’s type, allowing the
colorization of the text with the assumption that the code block is Python code.&lt;/p&gt;
&lt;h3 id="group-4-stopping-at-a-good-place"&gt;Group 4: Stopping at a Good Place&lt;a class="headerlink" href="#group-4-stopping-at-a-good-place" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sometimes it makes sense to march forward without much attention to the surroundings,
and sometimes it makes sense to stop at a good place along the way.  In taking a quick
look at HTML blocks, I figured they were going to be tricky, and I had the same
determination with the table element.  Taking a look at the link reference definitions,
I noticed that they required inline expansion of text within the blocks, something that
I wasn’t even remotely close to yet.  These three leaf blocks were in the final group:
the To Be Done Later group.&lt;/p&gt;
&lt;p&gt;To ensure that I had a good place to come back to when I was ready for the each of these
blocks, I made sure to go through and implement, verify, and then disable each
test for every leaf block.&lt;/p&gt;
&lt;p&gt;Depending on the leaf block, I handled the disabling of the tests differently. To
properly deal with the link reference definitions, I needed the inline processing
capabilities that I knew were many weeks away.  As such, I kept those tests disabled
in the previous documented way of using the &lt;code&gt;@pytest.mark.skip&lt;/code&gt; annotation.  This was
a big shout out to me that these were going to need to be completed after almost
everything else.&lt;/p&gt;
&lt;p&gt;In the case of any other of the leaf node tests, I captured the
current tokens emitted for that case and placed them in the corresponding test.  While
it might seem weird, my belief was that by testing each test case this way, I would
increase overall coverage and possibly hit edge cases not currently documented in a
use case.  It also meant that once I started implementing the HTML blocks and table
blocks, those tests would just start failing in predictable fashion.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It is always easier to look back and see what worked and what did not work, than to
observe it at the time.  With only a few issues, I personally felt like I dodged a
lot of pain due to the specification and planning.  While BNF grammars are easy to
implement, the general rule is to “be strict in what you generate and lenient in what
you accept”.  As such, coming up with “valid” parse cases is a task that takes a long
time to complete.  By having the acceptable test cases as part of the core
specification, the time that I would normally spend in the development and testing phase
was greatly reduced.  True, it took me a while to get used to it, but when I did, it
just worked and worked well.&lt;/p&gt;
&lt;p&gt;One of the practices that I engaged in during the development of the parser is to
liberally spread around &lt;code&gt;print&lt;/code&gt; statements as I went.  As I was adding these statements,
my dominant thought was to collect enough information to determine which pieces of
information were the most relevant for log messages to be added later.  However,
as I proceeded, that information also had the additional benefits of being immensely
helpful to debug any parsing issues, and indispensable in the verification of the code
itself.  While I know I need to remove those statements or convert them before the
project is completed, their presence is indeed beneficial.&lt;/p&gt;
&lt;p&gt;All in all, I think I had a great start to an interesting project and learned a bit
in the process… and learning is always good!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next up on the list is adding block quote and list support to the parser.  Stay tuned!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:stringFiddle"&gt;
&lt;p&gt;I remember this term being used all the way back to my university days.  The closest I have been able to come to a definition is the Oxford dictionary’s definition: touch or fidget with something in a restless or nervous way.  Perhaps this is alluding to amount of work to get most string operations “just right”? &lt;a class="footnote-backref" href="#fnref:stringFiddle" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="linter tokenizer"></category></entry></feed>