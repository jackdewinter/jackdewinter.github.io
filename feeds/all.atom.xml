<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jack's Digital Workbench</title><link href="https://jackdewinter.github.io/" rel="alternate"></link><link href="https://jackdewinter.github.io/feeds/all.atom.xml" rel="self"></link><id>https://jackdewinter.github.io/</id><updated>2021-01-25T00:00:00-08:00</updated><entry><title>Markdown Linter - Delving Into the Issues - 18</title><link href="https://jackdewinter.github.io/2021/01/25/markdown-linter-delving-into-the-issues-18/" rel="alternate"></link><published>2021-01-25T00:00:00-08:00</published><updated>2021-01-25T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2021-01-25:/2021/01/25/markdown-linter-delving-into-the-issues-18/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2021/01/18/markdown-linter-delving-into-the-issues-17/"&gt;last article&lt;/a&gt;, I documented how
I was working hard to get to the end of the unprioritized items in my issues list
and on to the prioritized parts of the list.  This article details the work that
I am doing to make that push happen.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2021/01/18/markdown-linter-delving-into-the-issues-17/"&gt;last article&lt;/a&gt;, I documented how
I was working hard to get to the end of the unprioritized items in my issues list
and on to the prioritized parts of the list.  This article details the work that
I am doing to make that push happen.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now a week or so removed from the New Year’s Holiday break, it was refreshing to know
that I was still able to resolve a healthy collection of items from the issues list.
Sure, it was not the same volume as during the holiday, but it was still a healthy
volume of issues to resolve.&lt;/p&gt;
&lt;p&gt;And I definitely felt that I was getting closer to the end of the initial phase of the
PyMarkdown project.  I was pretty sure that I would not be able to resolve every item
from the unprioritized section of the issues list this week, but I was confident that
it was going to happen in the week after.  I just had to maintain a good velicity of
resolving issues, and I would get there soon!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/dcffbeb19cce01f2a4acdf51c572712b0e303af8"&gt;11 Jan 2021&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/8b0e5abc8ba7996ed35387c44914e3696b068885"&gt;17 Jan 2021&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="doing-some-simple-cleanup"&gt;Doing Some Simple Cleanup&lt;a class="headerlink" href="#doing-some-simple-cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As always, I try and ease into the project work for the week with something simple.  This
week was no different.  And while this change might seem to be of no consequence to others,
to me it was a question of readability and searchability.  The task?  To replace newline
characters in the source code with &lt;code&gt;ParserHelper.newline_character&lt;/code&gt; and to replace the
colon character (&lt;code&gt;:&lt;/code&gt;) separating the extra data field for the Markdown tokens with
&lt;code&gt;MarkdownToken.extra_data_separator&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While it might not be obvious to people that are not dealing with the source code, the
presence of those two characters in an unescaped and unreferenced form had caused me a lot
of frustration.  I guess if I had to pin down a cause why that happened, it was because
a newline character and a single colon character are easy to miss when scanning through
source code.  I wanted something that I could easily find, and not something that I would
easily miss, as had happened numerous times during debugging sessions.  For me, the
cost of this change was easily outweighed by the benefit for readability.&lt;/p&gt;
&lt;p&gt;It was not a change that fixed an issue or enabled a scenario tests, but I was able
to notice the difference almost instantly.  It just helped me see the code better,
and that was its goal!&lt;/p&gt;
&lt;h2 id="upgrading-to-python-38"&gt;Upgrading To Python 3.8&lt;a class="headerlink" href="#upgrading-to-python-38" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having started a year ago, Python 3.7 was the stable release of Python at the time the
project started.  At that time, Python 3.8 had just been released on 14 October 2019
&lt;sup id="fnref:courtesy"&gt;&lt;a class="footnote-ref" href="#fn:courtesy"&gt;1&lt;/a&gt;&lt;/sup&gt;, a couple of weeks before I started working on the code.  With the
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/d2c3b2c2cbbc6e9f5524c38571dedcec305915b0"&gt;first commit&lt;/a&gt;
of the source code on 22 Nov 2019, it just seemed like a safer bet to stay with version
3.7 until the bugs were worked out of the then brand new Python release.&lt;/p&gt;
&lt;p&gt;Just over a year later, with Python 3.9 released on 15 Oct 2020&lt;sup id="fnref2:courtesy"&gt;&lt;a class="footnote-ref" href="#fn:courtesy"&gt;1&lt;/a&gt;&lt;/sup&gt;, it felt like a
good time to upgrade one minor version with the same reasoning in mind.  However, there was
also another reason: performance.  Having started to explore the performance of the project
on sample Markdown pages, I found that the project’s parser was taking a long time to
parse a simple Markdown file.  Using
&lt;a href="https://docs.python.org/3/library/profile.html#module-cProfile"&gt;cProfile&lt;/a&gt; and
&lt;a href="https://jiffyclub.github.io/snakeviz/"&gt;SnakeViz&lt;/a&gt;,
I knew that the number one problem that I had with performance was the way I used log
statements.  Without going too far into my research&lt;sup id="fnref:moreLater"&gt;&lt;a class="footnote-ref" href="#fn:moreLater"&gt;2&lt;/a&gt;&lt;/sup&gt;, in order solve the
performance issue while keeping the extra functionality that helped me debug more
efficiently, I would soon need to write my own logging wrapper.  To do this properly, my
&lt;a href="https://docs.python.org/3/library/logging.html#logging.Logger.debug"&gt;research on logging&lt;/a&gt;
indicated that I would need to use the &lt;code&gt;stacklevel&lt;/code&gt; argument to allow the wrapper to
function while logging the location where the wrapper’s log statement was called from.
The catch?  It was introduced in Python 3.8.&lt;/p&gt;
&lt;p&gt;With a good reason to update and a good, stable version of Python 3.8 to update to, I
proceeded with the upgrade with relatively few issues.  The main issue that I hit was that
I needed to ensure that I uninstalled Python 3.7 in the project, install Python 3.8 on my
system (including all environment variables), and then install Python 3.8 in the project.
Once that was done, the only other issue that I had was with the
&lt;a href="https://pypi.org/project/black/"&gt;Black&lt;/a&gt;
Python formatter.  In that case, I needed to examine the graph for that package and make
sure that I installed the correct version of the dependent library in the project.&lt;/p&gt;
&lt;p&gt;After that small headache, which took minutes to solve, everything was working fine and continues to work fine.&lt;/p&gt;
&lt;h2 id="more-fun-with-link-reference-definitions"&gt;More Fun With Link Reference Definitions&lt;a class="headerlink" href="#more-fun-with-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first thing to mention about the next task is that while the commit was performed
earlier than the 3.8 Upgrade commit, chronologically this task came after the upgrade
task.  The reason that this is relevant is that the project uses the default settings
for Black, and either those defaults or the algorithm implementing the line folding
changed after the upgrade was completed.  Why is this relevant?  While the commit itself
looks like it has a lot of changes, many of those changes occurred in folding the lines
according to upgraded settings.  And as I was focused on the Link Reference Definitions,
I did not notice those formatting changes until after I had made a number of changes.
It was just easier to commit them together at that point than to pull them apart.&lt;/p&gt;
&lt;p&gt;Other than that noise, there were three new scenario tests introduced, testing
Link Reference Definition elements broken up across container block boundaries.  The
first test added, test function &lt;code&gt;test_link_reference_definitions_extra_01&lt;/code&gt;, was created
with a single Unordered List element character, followed by a valid Link Reference
Definition spread over two lines, with the second line not being indented:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second test, function &lt;code&gt;test_link_reference_definitions_extra_02&lt;/code&gt;, used the same
format, but used a Block Quote element prefix instead of an Unordered List prefix.
Finally, to provide a touchstone, I added function
&lt;code&gt;test_link_reference_definitions_extra_02&lt;/code&gt; that has both lines of the Link Reference
Definition preceded by the Block Quote element prefix.  While it was a duplicate
test, I felt it was a good reminder of how a test with both lines worked, and thus
it was a good reference test.&lt;/p&gt;
&lt;p&gt;Now, according to the specification, the List element continues if the next line starts
with enough whitespace
to maintain the indent or if it is a continuation of a Paragraph within the list.  As the
Link Reference Definition is not a Paragraph when parsed the first time, the second line
terminates the list, and causes the Link Reference Definition to be requeued and parsed as
a normal Paragraph on the second parse through.  Or so I thought.&lt;/p&gt;
&lt;h3 id="github-flavored-markdown-vs-commonmark"&gt;Github Flavored Markdown vs CommonMark&lt;a class="headerlink" href="#github-flavored-markdown-vs-commonmark" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While both specification are usually in sync with each other, sometimes the
&lt;a href="https://github.github.com/gfm/"&gt;GFM Specification&lt;/a&gt;
and the reference CommonMark implementation
&lt;a href="https://github.com/commonmark/commonmark.js"&gt;CommonMark.Js&lt;/a&gt;
called from
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;Babelmark 2&lt;/a&gt;
differ in small implementation details.  I had experimented with the Block Quote
scenario test for three or so hours before I submitted a question to the
&lt;a href="https://talk.commonmark.org/t/block-quotes-laziness-and-link-reference-definitions/3751"&gt;CommonMark forums&lt;/a&gt;
asking if I had misunderstood something in the specification.&lt;/p&gt;
&lt;p&gt;The answer that came back was a supportive answer, but at the same time, an honest answer.
The approach that CommonMark’s reference parser had taken was to parse the lines as the
start of an Unordered List followed by a Paragraph block.  Only after that Paragraph block
had been parsed, with the paragraph continuation kicking in, does the parser look for a
Link Reference Definition at the start of that Paragraph.&lt;/p&gt;
&lt;p&gt;Is this 100% according to the GFM specification?  No.  But does it make sense for the
CommonMark team to do this?  I would argue yes.  Getting Link Reference Definitions correct
in the PyMarkdown parser has continued to be a pain to this day.  Based on my limited
experience, while
Link Reference Definitions can be spread over multiple lines, there are very few cases
where that is done in “real life”.  From a correctness viewpoint, if I had to guess on the
percentages,
I believe I would estimate that their approach correctly parses 99.5% of the Link Reference
Definition elements, with only some “weird” multiline Link Reference Definition scenarios
not being parsed.&lt;/p&gt;
&lt;p&gt;But that left me with a decision.  What was the correct thing to do for the PyMarkdown
parser?&lt;/p&gt;
&lt;h3 id="which-to-choose"&gt;Which To Choose?&lt;a class="headerlink" href="#which-to-choose" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After thinking about this overnight, I decided that the best approach for the project was
to align with the CommonMark reference implementation, while also discussing the
differences from
the GFM Specification with the CommonMark team in the forums.  By making that choice,
I had confidence that I would have something to compare against for correctness that was
both concrete and
measurable.  It either would parse properly against &lt;code&gt;commonmark.js 0.29.2&lt;/code&gt; and be
considered correct or it would
not and be considered a parsing failure. As for any differences, I could clearly note
them in documentation somewhere, and talk about them on the forums with the owners of
CommonMark and the GFM specification, trying to improve both.  It was not a perfect answer,
things rarely are perfect.&lt;/p&gt;
&lt;p&gt;With that decision in hand, I marked all three new tests as skipped before starting to
work on the Block Quote functions.  Based on what I was seeing in the test failures,
everything looked fine in the HTML output, except that the output was missing an entry
in the Block Quote for the parsed line.  Taking a wild guess, I determined that I needed
to introduce something in the &lt;code&gt;handle_block_quote_block&lt;/code&gt; function to ensure that the number
of lines in the Block Quote element were correct.&lt;/p&gt;
&lt;p&gt;Surprisingly, that was the fix that was needed.  No changes in the Markdown transformer
were needed, and no changes in the consistency check was needed.  Not sure what I had
going on that evening, I decided to mark the List Block version of the scenario test,
the function &lt;code&gt;test_link_reference_definitions_extra_01&lt;/code&gt;, as disabled.  Cleaning up
the code and committing it to the repository.  It was a good place to stop while I
figured out what was going on in the evening.&lt;/p&gt;
&lt;h3 id="getting-back-to-it"&gt;Getting Back To It&lt;a class="headerlink" href="#getting-back-to-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the plans for that evening falling through, I found that I had a couple of hours
free that evening. Not wanting to let them go to waste, I decided to see if I could tackle
the
&lt;code&gt;test_link_reference_definitions_extra_01&lt;/code&gt; function that I elected not to get working
in the previous section.  To ensure I was moving in the correct direction, I added
extra variations of the test that included one and two spaces before the second half
of the Link Reference Definition element, as well as one with each half of the Link
Reference Definition in its own List Item.&lt;/p&gt;
&lt;p&gt;As I have had numerous problems with List Blocks in the past, I expected to expend a
lot of effort to clean these cases up, but only a little bit of effort was required.
Specifically, the only change that was needed with in the &lt;code&gt;ListBlockProcessor&lt;/code&gt; class
and its &lt;code&gt;__check_for_list_closures&lt;/code&gt; function.  Like the previous section and the
Link Reference Definition element that spanned Block Quote element levels, the CommonMark
reference implementation was treating the Link Reference Definition text as a Paragraph
before detecting the Link Reference Definition element itself.  To replicate this
behavior, I needed to modify the &lt;code&gt;__check_for_list_closures&lt;/code&gt; function to keep the
‘paragraph’ open if it was parsing a Link Reference Definition.&lt;/p&gt;
&lt;p&gt;Making those modification, I was able to get the main function,
&lt;code&gt;test_link_reference_definitions_extra_01&lt;/code&gt;, working, as well as the sibling functions
&lt;code&gt;test_link_reference_definitions_extra_01a&lt;/code&gt; and
&lt;code&gt;test_link_reference_definitions_extra_01b&lt;/code&gt;.  This meant that a Link Reference
Definition split over a List Block and the end of that block with various amounts of
indentation was working properly.  However, function
&lt;code&gt;test_link_reference_definitions_extra_01c&lt;/code&gt;, where I split the Link Reference Definition
over two List Items was not working at all.  With my time used up in the evening, I
marked it as skipped, cleaned it up, committed it, and went to sleep for the night.&lt;/p&gt;
&lt;h2 id="and-more-link-reference-definitions"&gt;And More Link Reference Definitions&lt;a class="headerlink" href="#and-more-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I was looking at the content of the existing scenario tests, I noticed that I
did not have a couple of tests that had simple multi-line Raw HTML elements and
multi-line Code Span elements in links.  Basically, I wanted to take
&lt;a href="https://github.github.com/gfm/#example-644"&gt;example 644&lt;/a&gt; for Raw HTML elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;!&lt;/span&gt;&lt;span class="c1"&gt;-- this is a&lt;/span&gt;
&lt;span class="k"&gt;comment&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;hyphen&lt;/span&gt; &lt;span class="c1"&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and &lt;a href="https://github.github.com/gfm/#example-345"&gt;example 345&lt;/a&gt; for Code Spans:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;``&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;  
&lt;span class="n"&gt;baz&lt;/span&gt;
&lt;span class="o"&gt;``&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and place them within both Inline Links and Reference Links.  I was hoping that this
was a simple test, but I was not sure.&lt;/p&gt;
&lt;p&gt;Adding all four tests, (two for Inline Links and two for Reference Links), I was pleasantly
surprised that all four tests passed without any changes.  While I am aware that I am
getting closer and closer to the initial release of the project, I still find that I
expect things to fail as a default setting.  As I am usually an optimistic person, my
only explanation for that failure viewpoint is one of writing too many automation tests
in my career.  When I note something down in the issues list, I believe that I feel that
most of those items are going to be things that I forgot to cover, not things that I wish
to ensure are covered.&lt;/p&gt;
&lt;p&gt;Regardless, I need to figure that out and work on it a bit.  I do have a lot of confidence
in the PyMarkdown project and its accuracy, and I need to project that more.&lt;/p&gt;
&lt;h2 id="fixing-disabled-tests"&gt;Fixing Disabled Tests&lt;a class="headerlink" href="#fixing-disabled-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a good night’s sleep and a good day’s worth of work under my belt, I settled down
in the evening to work on the next issue: enabling test functions
&lt;code&gt;test_block_quotes_extra_02ax&lt;/code&gt; to &lt;code&gt;test_block_quotes_extra_02ad&lt;/code&gt;.  The good news was
that the HTML transformer and the Markdown transformer were both working properly.
The bad news was that the consistency checks were failing for all these tests.&lt;/p&gt;
&lt;p&gt;It took me a bit to get going that evening, but when I did, it was obvious to me that the
problem was that the consistency checks were not recognizing the active Block Quote
element.  Following along in the &lt;code&gt;verify_line_and_column_numbers&lt;/code&gt; method, it became
obvious that the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;container_block_stack&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_block_quote_start&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was not evaluating to &lt;code&gt;true&lt;/code&gt; for the four test functions that I was evaluating.  But
how to fix them?&lt;/p&gt;
&lt;p&gt;It took me a while to realize that the reason that the condition was not evaluating to
&lt;code&gt;True&lt;/code&gt; was that the Block Quote token was not always the last token on that list.
When I read the variable named &lt;code&gt;container_block_stack&lt;/code&gt;, in my head I was parsing it as
“the stack for container Block Quotes”, not “the stack for container blocks”.  Once
I figured that out, the answer became obvious.  I created a new function
&lt;code&gt;find_last_block_quote_on_stack&lt;/code&gt; that went back in the stack until it found to last
Block Quote token and returned it.  From there, I replaced any occurrence of
&lt;code&gt;container_block_stack[-1]&lt;/code&gt; with &lt;code&gt;last_block_quote_token&lt;/code&gt;.  Therefore, the code
from above became:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;last_block_quote_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_last_block_quote_on_stack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;container_block_stack&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_block_quote_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I ran the tests, and after clearing up a couple of typing mistakes, the tests all
worked properly, and they were now passing!&lt;/p&gt;
&lt;h2 id="a-quick-fix-i-hope"&gt;A Quick Fix… I Hope!&lt;a class="headerlink" href="#a-quick-fix-i-hope" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking at the end of the uncategorized section of the issues list, there was one item
that I felt confident that I could quickly deal with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;634&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;forcing&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To start working on this item, I made six copies of test function &lt;code&gt;test_html_blocks_123&lt;/code&gt;.
The first copy was in a List Block element, the next three copies were in various forms
of a Block Quote element, the fifth copy was within a SetExt Heading element, and the
last copy was within an Atx Heading element.  The hard part of each of these tests was
that I needed to make sure I was generating an HTML Block token and not a Raw HTML
token.  That took extra care but did not slow me down that much.&lt;/p&gt;
&lt;p&gt;Like a handful of other issues like this that I have fixed, the answer to this
one leapt out at me as soon as I looked through the log files.  When the next line
was examined to figure out if the Block Quote element should be continued, the
&lt;code&gt;check_for_lazy_handling&lt;/code&gt; was allowing it to continue.  The only issue here was that
it was an HTML block, a leaf block type that does not have any continuation logic in
the specification.  Having noticed that, it was easy to change the following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_code_block&lt;/span&gt;
        &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_leaf_block_start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_code_block&lt;/span&gt;
        &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_html_block&lt;/span&gt;
        &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_leaf_block_start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;thereby fixing the issue.  Running the scenario tests again, the tests were indeed fixed
without needed any other changes.&lt;/p&gt;
&lt;h2 id="that-weeks-big-thing"&gt;That Week’s Big Thing&lt;a class="headerlink" href="#that-weeks-big-thing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Wrapping up the work for that week, I wanted to make another dent in the issues list,
so I decided to at least get the tests set up for the following item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;links&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="k"&gt;inner&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;mine&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;see&lt;/span&gt; &lt;span class="n"&gt;__collect_text_from_blocks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The base concept of this item was simple: create a group of tests to verify how inline
elements were represented when placed within a Link element.  To make sure that I was
doing a good scenario test, I made the choice to use a Reference Link element.  By
doing this, I would be testing the link label normalization code and the representation
code at the same time.&lt;/p&gt;
&lt;p&gt;Starting with &lt;code&gt;test_reference_links_extra_03x&lt;/code&gt;, I created a Link element with a link
label that contained a backslash in the link label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there, I then created a copy of that test that encapsulated that link label within
another link label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;yy&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and finally, I created a copy of that test, changing the Link element to an Image element:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;yy&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, after a bit of thinking, I decided there was only one combination I was missing,
so I added that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;yy&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That being done, I then repeated that process with &lt;code&gt;&amp;amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;copy;&lt;/code&gt; for character
entity references, code spans, emphasis, autolinks, raw HTML, and hard line breaks.
By the time I was done, I had added 40 scenario tests to cover all these cases.&lt;/p&gt;
&lt;p&gt;Starting to execute the scenario tests, all the tests that just dealt with Link elements
were passing without any changes.  The Image elements, they were a different story.
The failures seemed to stare back at me, standing in the way of me writing the
article for that week.  It was just time to start debugging and figuring things out.&lt;/p&gt;
&lt;p&gt;After a bit of debugging, I seemed to notice that the test failures seemed to be in three
separate groups of issues.  The first group of issues was that the
&lt;code&gt;__collect_text_from_blocks&lt;/code&gt; function used to grab the existing tokens and render them
as text was not complete.  But that was not the entire issue, but I felt that there
was too much “noise” in the way for me to see the issue clearly.  Resolving to reduce
the noise in the issue, I started working on the main part of the issue.  In the cases
where the inline element was on its own inside the parent
Link element, the Code Span element, the Raw HTML element, and the Autolink element
were not representing their elements properly.  A bit of exploration and debugging took
care of that.  With that noise out of the way, I was able to see the other part of that
issue better, and added the condition:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;is_inside_of_link&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;at the start of each of those handlers.  The noise that I had experience was simply that
in cases where a possible Link element was within another Link element’s link label,
each of the changed elements just needed to emit nothing to the collection.  Running
the tests again, it verified that observations, but I also saw something else.&lt;/p&gt;
&lt;p&gt;Only after getting rid of those issues was I able to see that the
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt;
function was not handling Emphasis start and end elements properly, failing an assert
near the end of that function.  That fix was easy, adding four lines to the &lt;code&gt;elif&lt;/code&gt;
statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;inline_blocks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_inline_emphasis&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;inline_blocks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_inline_emphasis_end&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With both of those issues dealt with, the couple of failures that remained were easy ones.
Looking at the HTML output, there were a number of &lt;code&gt;/a&lt;/code&gt; character sequences in the HTML
output.  Being the signature for replacement references, I quickly change of the code for
the Text element from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;inline_blocks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resolve_references_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;inline_blocks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="beware-of-special-cases"&gt;Beware Of Special Cases&lt;a class="headerlink" href="#beware-of-special-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Running the tests again, all the tests were passing except for those that dealt with the
&lt;code&gt;&amp;amp;amp;&lt;/code&gt; sequence.  All the tests dealing with the &lt;code&gt;&amp;amp;copy;&lt;/code&gt; sequence were working fine,
so I had to think quickly to figure out what the problem might be.  Because I am used to
looking at processed HTML code, I initially did not see any problem with a &lt;code&gt;&amp;amp;amp;&lt;/code&gt; sequence
in the HTML output.  It looked right.&lt;/p&gt;
&lt;p&gt;Then it hit me.  The problem was not with the HTML output, it was with the processing of
the Markdown input.  In the cases that I had problems with, the desired HTML output had
&lt;code&gt;&amp;amp;amp;amp;&lt;/code&gt; which did not look right until I thought about it.  Whereas the &lt;code&gt;&amp;amp;copy;&lt;/code&gt;
character sequence is interpreted as a named charactery entity and replaced with the
© symbol, the sequence &lt;code&gt;&amp;amp;amp;&lt;/code&gt; was not being interpreted in the same way.  The
desired HTML output was correct!  The initial &lt;code&gt;&amp;amp;&lt;/code&gt; from the sequence was being replaced
with the sequence &lt;code&gt;&amp;amp;amp;&lt;/code&gt; to ensure it was displayed properly, removing any chance of
it being interpreted as a named character entity.&lt;/p&gt;
&lt;p&gt;Making a quick decision, I looked at the &lt;code&gt;InlineHelper&lt;/code&gt; class and noticed the
&lt;code&gt;append_text&lt;/code&gt; function used to ensure that such strings were properly interpreted.
Taking a quick look at the imports for &lt;code&gt;InlineHelper&lt;/code&gt; and &lt;code&gt;LinkHelper&lt;/code&gt;, I thought there
was a chance of a circular reference occurring.  Given that observation, I decided to
make a copy of the &lt;code&gt;append_text&lt;/code&gt; function in the &lt;code&gt;LinkHelper&lt;/code&gt; class to get around the
possibility of the circular reference.&lt;/p&gt;
&lt;p&gt;Finally, after a couple of hours of work, all 40 tests were passing.  It was a bit of
a trek to get there, but it was worth it!&lt;/p&gt;
&lt;h2 id="whoops"&gt;Whoops&lt;a class="headerlink" href="#whoops" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I was starting to write the article, I also started to look into what it would take
to remove the duplicate of the &lt;code&gt;append_text&lt;/code&gt; function in the &lt;code&gt;LinkHelper&lt;/code&gt; class.  I had
introduced the clone into the &lt;code&gt;LinkHelper&lt;/code&gt; class to avoid any issues with referencing
the &lt;code&gt;InlineHelper&lt;/code&gt; class from the &lt;code&gt;LinkHelper&lt;/code&gt; class.  It was as I was starting my
research into this task that I discovered something that I had previously missed.  The
&lt;code&gt;LinkHelper&lt;/code&gt; class was already referencing the &lt;code&gt;InlineHelper&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;After a bit of “how did I miss that?”, I replaced the call to &lt;code&gt;LinkHelper.append_text&lt;/code&gt; with
&lt;code&gt;InlineHelper.append_text&lt;/code&gt; and everything worked fine.  Removing the instance of the
&lt;code&gt;append_text&lt;/code&gt; function from the &lt;code&gt;LinkHelper&lt;/code&gt; class, I ran the complete suite of scenario
tests again, and everything worked fine.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking back at the work I did during the week, it was hard not to get jazzed
about the progress.  I started off by doing a simple fix that made the source code
more readable, enhancing my ability to read the source code.  Then I upgraded the
base Python version to 3.8, knowing that it would allow me to write the wrapper I wanted
around Python’s logging functions.  Add to that the coverage and testing I was able to
add and verify for Link elements, Image elements, and Link Reference Definitions, and
it was really good work!  &lt;/p&gt;
&lt;p&gt;At some point I noticed the number of scenario tests that I execute with each change.
At approximately 2000 tests, I am confident that I am hitting a very large degree of
all scenarios for Markdown transformation, not just the “Golden” scenarios, and that
was also a boost to my confidence.  While I can expect things that I note as an issue
to not work, I also need to make sure I appreciate what is working.  Having a solid
set of tests like that is what allows me to refactor with confidence that I am not
negatively impact the code.&lt;/p&gt;
&lt;p&gt;Refactor?  Sigh.  One of the things I know I am looking forward to is looking at
the refactor tasks in the prioritized sections and getting a couple of them underway.
The fact that they are present in those sections is a good reminder to me that I
can always learn how to do things better, and how to make the project more maintainable.
And that is always something I can look forward to!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a solid amount of work done this week, I am hoping to be able to clear out the
uncategorized section of the issues list in the next week.  Will I make it?  Stay tuned!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:courtesy"&gt;
&lt;p&gt;Information courtesy of the &lt;a href="https://www.python.org/downloads/"&gt;Python download page&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:courtesy" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="#fnref2:courtesy" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:moreLater"&gt;
&lt;p&gt;I will be covering this in a separate series of articles in the near future. &lt;a class="footnote-backref" href="#fnref:moreLater" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 17</title><link href="https://jackdewinter.github.io/2021/01/18/markdown-linter-delving-into-the-issues-17/" rel="alternate"></link><published>2021-01-18T00:00:00-08:00</published><updated>2021-01-18T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2021-01-18:/2021/01/18/markdown-linter-delving-into-the-issues-17/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2021/01/11/markdown-linter-delving-into-the-issues-16/"&gt;last article&lt;/a&gt;,
I continued working on some big-ticket items from the issues list, making the most
of my New Year Holiday break.  Back in “normal time”, I am tackling Block Quote items,
to try to get to the prioritized part of my issues list within the next …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2021/01/11/markdown-linter-delving-into-the-issues-16/"&gt;last article&lt;/a&gt;,
I continued working on some big-ticket items from the issues list, making the most
of my New Year Holiday break.  Back in “normal time”, I am tackling Block Quote items,
to try to get to the prioritized part of my issues list within the next week or two.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I knew that I was not going to solve the same volume of items as last week, I was
confident that I could use this week to make some good
progress in dealing with Block Quote elements and their interaction with other elements.
I also knew that my mental space was going to be limited this week due to the end of
the holidays.  I was not the only one that took the time off from my day job, as most of
the company that I work for took the same two weeks off.  And with everyone coming back to
work at the same time, there were bound to be lots of meetings to make sure everyone was
resynced for the New Year. And that week there… were… lots… of… meetings.&lt;/p&gt;
&lt;p&gt;Factoring that into account, I started my work for that week with a reset of my personal
expectations on what I believe I can accomplish in a week. I felt that it was important to
my sanity to take the time to seriously understand that I did not need to continue taking
care of multiple big-ticket items. Just a handful of normal items would suffice.  I knew
that if I could manage to make the
switch to that mindset, it would be a good week.  So, with that in mind, the work started.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/a6390d02a8dc98e2092e0494f31f5f0a1fd3b5ba"&gt;07 Jan 2021&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/8b0e5abc8ba7996ed35387c44914e3696b068885"&gt;11 Jan 2021&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-with-something-simple"&gt;Starting with Something Simple&lt;a class="headerlink" href="#starting-with-something-simple" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As a matter of pride, I try and keep the PyMarkdown code base clean and following
&lt;a href="https://flake8.pycqa.org/en/latest/"&gt;flake8&lt;/a&gt; and
&lt;a href="https://pylint.org/"&gt;pylint&lt;/a&gt;
guidelines.  While I mostly correct any raised issues right away, I often choose to
temporarily disable these issues until another time where I can resolve them. My logic
in making that decision is that it usually better for me to concentrate on the big picture
in the moment, addressing any raised issues when I have some less hectic bursts time.
As such, at various points in the code base, there are comments such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# pylint: disable=too-many-public-methods&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to disable a warning and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# pylint: enable=too-many-public-methods&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to enable the warning again.&lt;/p&gt;
&lt;p&gt;But as I am only human, I sometimes forget to balance these statements out, disabling a
warning that
is only disabled, not enabling a warning that was disabled, or enabling a warning that was
not disabled.  Writing up a simple Python script, I quickly figured out where these issues
were and corrected them.  While it was not a very important thing to do, it was just nice
to ensure that I had these nailed down.  A good start to the week.&lt;/p&gt;
&lt;h2 id="rounding-out-multiline-inline-elements"&gt;Rounding Out Multiline Inline Elements&lt;a class="headerlink" href="#rounding-out-multiline-inline-elements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One thing that I was sure that I had not covered properly were newline characters
contained with
Code Span elements and Raw HTML elements.  While I had corrected a handful of issues from
this area in the past, I did not feel that I had properly covered all the necessary cases,
and I wanted to address that discrepancy.&lt;/p&gt;
&lt;p&gt;Like I normally do, I started with scenario test creation.  This began by taking
a good look at the available scenario tests in the &lt;code&gt;test_markdown_raw_html.py&lt;/code&gt; module and
the
&lt;code&gt;test_markdown_code_spans.py&lt;/code&gt; module.  For the first module, I added variations of test
function &lt;code&gt;test_raw_html_634&lt;/code&gt;, focusing on any container block elements
or leaf block elements that I had not covered elsewhere.  I then repeated this process
for the other module by adding variations on the &lt;code&gt;test_code_spans_346&lt;/code&gt; test function.
This resulted in eleven new scenario tests being added, four for the Raw Html element and
seven for the Code Span element.&lt;/p&gt;
&lt;p&gt;From a top-level point of view, the scenario tests for Raw HTML elements worked fine, and
did not reveal
any additional issues.  The Code Span element tests were another matter.  While I had
previously dealt with newline characters in the main body of the Code Span element, I had
forgotten to perform the same actions on the leading and trailing whitespace for the
element.  Feeling embarrassed that I forgot the whitespace parts of the token, I quickly
made changes to the &lt;code&gt;handle_inline_backtick&lt;/code&gt; function and the &lt;code&gt;__collect_text_from_blocks&lt;/code&gt;
function to ensure that the correct tokens were being generated.&lt;/p&gt;
&lt;p&gt;To balance these changes out, I also changed the &lt;code&gt;__verify_next_inline_code_span&lt;/code&gt; function
in the consistency checks to pay attention to the leading and trailing whitespace.  Like
the changes detailed in the last paragraph, these changes were not difficult once I knew
what the problem was.  But looking at the code while I was making these changes, I realized
that I should not feel embarrassed.  While I was being thorough with my testing, the issues
that I was finding were more corner cases than anything else.  Put bluntly, unless I was
testing corner cases, I was sure that I would not create a Raw Html element like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="ss"&gt;""&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or a Code Span element like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="k"&gt;some&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;really&lt;/span&gt; &lt;span class="n"&gt;nasty&lt;/span&gt;
&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unless some specific formatting called for it in a really weird circumstance, I believe I
would always write them on one line, not multiple lines.&lt;/p&gt;
&lt;p&gt;But it was good to get the corner cases.  In my head, I know that if I am focusing on the
corner cases, I feel confident about the normal cases.  That is a good place for me to be!&lt;/p&gt;
&lt;h2 id="adding-glob-support"&gt;Adding Glob Support&lt;a class="headerlink" href="#adding-glob-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While not a part of the issues list, one of the things that I had been experimenting on
in some “down time” was adding
&lt;a href="https://docs.python.org/3/library/glob.html"&gt;Glob support&lt;/a&gt;
to the project.  This work came about as the quick script that I threw together for
validating
&lt;a href="https://jackdewinter.github.io/2021/01/18/markdown-linter-delving-into-the-issues-17/#starting-with-something-simple"&gt;PyLint disables and enables&lt;/a&gt;
needed to be able to specify a targetted set of files with Python &lt;code&gt;glob&lt;/code&gt; support. Using
the same type of mainline base as the PyMarkdown project,
I figured the PyLint scanner script was a low-cost, low-risk place to see how much
effort it would take to implement it in the PyMarkdown project.&lt;/p&gt;
&lt;p&gt;It turned out to be very easy.  The &lt;code&gt;__determine_files_to_scan&lt;/code&gt; function was the main
point of contact for determining the files to process.  It took exact file paths,
to either a directory or a file, and returned set containing all valid paths.  In the
case of a file path, it simply added the full path to that file to the collection to be
returned.  In the case of a directory, the directory was scanned, and all matching files
were added to that same collection.  Nice, self-contained, and simple.&lt;/p&gt;
&lt;p&gt;Being self-contained, it was easy to modify this function to add glob support.  To handle
those simple cases, I moved that functionality out of the main function and into a new
helper function &lt;code&gt;__process_next_path&lt;/code&gt;.  With that extracted, I rewrote the
&lt;code&gt;__determine_files_to_scan&lt;/code&gt; function as follows.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s2"&gt;"*"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;next_path&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s2"&gt;"?"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;next_path&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;globbed_paths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;glob&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;glob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;globbed_paths&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="s2"&gt;"Provided glob path '"&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;next_path&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"' did not match any files."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;did_error_scanning_files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;next_globbed_path&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;globbed_paths&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;next_globbed_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_globbed_path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__process_next_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_globbed_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;files_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__process_next_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;files_to_parse&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;did_error_scanning_files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the call &lt;code&gt;glob.glob&lt;/code&gt; already returns an array of matching elements, I was already
most of the way to having this implemented. All I needed to do was to properly add the
elements returned from the &lt;code&gt;glob&lt;/code&gt; call to the collection.  So, instead of rewriting the
code to add matching elements to the &lt;code&gt;files_to_parse&lt;/code&gt; variable, I just called the already
debugged &lt;code&gt;__process_next_path&lt;/code&gt; function to do all the heavy lifting.&lt;/p&gt;
&lt;p&gt;Once that was done, manual testing of the new functionality went fine.  Some new scenario
tests needed to be added, and a couple of existing scenario tests needed to be changed
slightly, but nothing unexpected.  After an hour or so, the work was done and tested.
While not terribly exciting, I could now do some manual testing of the PyMarkdown project
against a set of files that was not a single file, nor every eligible file in that
directory.  And it just felt good to get a small task like that out of the way!&lt;/p&gt;
&lt;h2 id="filling-out-existing-tests"&gt;Filling Out Existing Tests&lt;a class="headerlink" href="#filling-out-existing-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Narrowing down the items to work on from the issues list, the one that I settled on was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;test_block_quotes_extra_02a&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="n"&gt;levels&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;lists&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To start the work on this item, I added three variations of the
&lt;code&gt;test_block_quotes_extra_02&lt;/code&gt; test function, altering the number of lists in the document
and their locations.  Noticing that I could do the same type
of variations for Block Quote elements, I also added ten new scenario test functions
that were variation on the &lt;code&gt;test_block_quotes_extra_04&lt;/code&gt; function, mixing Block Quote
elements with the various types of non-inline elements.&lt;/p&gt;
&lt;p&gt;Executing the bulk of the new tests, I was pleasantly surprised that everything except for
the consistency checks were passing without any changes being needed.  Even the changes
needed for the consistency checks were relatively minor and in two main groups.&lt;/p&gt;
&lt;p&gt;The first group of changes were in the inline handling part of the
&lt;code&gt;verify_line_and_column_numbers&lt;/code&gt; function.  These changes were not material in nature
but served to ensure that the &lt;code&gt;leading_text_index&lt;/code&gt; field from the Block Quote token
was properly updated.  This required the inspection of each inline token to determine if
any newline characters are encountered.  If any are encountered, the &lt;code&gt;leading_text_index&lt;/code&gt;
field is incremented by the number of newline characters, ensuring that any references
to that field reference the correct line prefix.&lt;/p&gt;
&lt;p&gt;Seemingly balancing that change, there were a handful of end Leaf tokens that also needed
adjusting to properly support the
&lt;code&gt;leading_text_index&lt;/code&gt; field.  Through trial and error, I quickly
isolated each type of token, and was able to properly increment the
&lt;code&gt;leading_text_index&lt;/code&gt; field to handle the end token.  It was not a big task, but it was one
that I needed to be very methodical on.  I did find that I needed to do adjust each at
least once as each test was providing coverage for a specific scenario that had been
missed.  While it was not that much extra work for each individual test, the amount of work
required over all the tests added up quickly.&lt;/p&gt;
&lt;h2 id="properly-handling-link-reference-definitions"&gt;Properly Handling Link Reference Definitions&lt;a class="headerlink" href="#properly-handling-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the case of test function &lt;code&gt;test_block_quotes_extra_04f&lt;/code&gt;, the issue was that it
was just broken.  No niceties or anything else, just broken.  Added during the
last section’s work and disabled, the Markdown was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; [
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;abc&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; ]&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;uri&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What made this test function broken was not the Markdown itself, but the generated tokens
for it.  For whatever reason, the parsing of the Block Quote was both started and ended
on the first line, only to be restarted on the second line.  Because of the container
nature of the Block Quote element, this then spread the text required for the Inline Link
element split over two distinct Block Quotes.  It was just wrong!&lt;/p&gt;
&lt;h3 id="setting-the-stage"&gt;Setting the Stage&lt;a class="headerlink" href="#setting-the-stage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The debugging took a couple of hours to work through, but it was rewarding when I solved
it.  The problem with the parsing boiled down to my favorite element (heavy sarcasm
is implied), the Link Reference Definition element.  Because of the unique nature of this
element and how it is parsed, I had to add the ability to rewind or requeue the parser so
that failed lines from a Link Reference Definition could be properly processed.  And while
it had worked properly until this point, test function &lt;code&gt;test_block_quotes_extra_04f&lt;/code&gt;
provided an interesting twist to normal operation, and therefore, an interesting problem.  &lt;/p&gt;
&lt;p&gt;Because of design decisions for Markdown, the Link element and the Link Reference
Definition element both start with the same sequence: &lt;code&gt;[link]&lt;/code&gt;.  If this sequence is
followed by an
open square bracket character &lt;code&gt;[&lt;/code&gt;, then it probably specifies a collapsed or full link.
If this sequence is followed by an open parenthesis character &lt;code&gt;(&lt;/code&gt;, then it probably
specifies an inline link.  If this sequence is followed by a colon character &lt;code&gt;:&lt;/code&gt;, then it
probably specifies a Link Reference Definition.  And finally, if not followed by any of
the above, it is probably a shortcut link.&lt;/p&gt;
&lt;p&gt;Most of those combinations do not matter, except for my friend (once again, heavy sarcasm
implied), the Link Reference Definition.  While the Link element and its types are all
processed in the inline phase of processing, the Link Reference Definition is processed
much earlier in the block phase of processing.  Due to that difference, the Link element
processing is done with the entire contents of the processed Text token being available,
but the Link Reference Definition processing is done one line at a time.&lt;/p&gt;
&lt;h3 id="working-through-the-process"&gt;Working Through the Process&lt;a class="headerlink" href="#working-through-the-process" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Why was that information relevant?  In the case of the above Markdown, the specified text
supports both
a Link element and a Link Reference Definition element until line 3.  Before that point,
the Link Reference Definition processing continues forward.  When that point is reached on
line 3, the line is processed for
suitability as a Link Reference Definition, it fails, and the requeue mechanism needs to
be enacted so that the lines can be interpreted properly.  Unlike any previous scenario
tests, in this case, that requeue mechanism was not sufficient.&lt;/p&gt;
&lt;p&gt;What was being requeued was only the information after processing.  When the requeue
mechanism kicked in, it was trying to return to the state that was in place when
the Link Reference Definition started.  But when it started processing the requeued
information, it did so with the processed line of information.  That line was missing the
Block Quote prefix, causing the Block Quote to be closed.  It took a while to get there,
but I did figure out why that was happening with the closing of the Block Quote!&lt;/p&gt;
&lt;h3 id="fixing-the-issue"&gt;Fixing the Issue&lt;a class="headerlink" href="#fixing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In this case, the line that had been passed to the Link Reference Definition processor
did not have the Block Quote prefix attached to it.  Having been removed at the container
level before being passed on for Leaf Block processing, the lines to requeue were
missing information.  To fix that issue, I had to figure out a way to ensure that I could
retain that information so that it could be requeued if needed.  Therefore, I introduced a
the &lt;code&gt;unmodified_line_to_parse&lt;/code&gt; variable that contains the line as read, unmodified by
any processing.&lt;/p&gt;
&lt;p&gt;This got me a lot of mileage in fixing this issue, but after rerunning some of the tests,
a couple of the tests were failing because there was another issue somewhere.  Debugging
that issue over the course of
an hour, I found that there was another requeue issue that I needed to address: the
main document and the main token stack.  In a couple of the new scenarios, when the
processing of the Link Reference Definition was started, another type of block element was
ended.  The effect of this was that a new Markdown token was placed in the document and a
new stack token was placed on the main token stack.  While the rewinding took care of the
data, it did not take care of that state information.&lt;/p&gt;
&lt;p&gt;Dealing with that issue was somewhat simple but took a while to get right.  Before
starting the processing of the Link Reference Definition, I keep track of the lengths
of both the main document and the token stack.  If I need to requeue elements, I simply
remove any entries that are past that mark.  It is not very graceful, but it was
successful and worked wonderfully.&lt;/p&gt;
&lt;h2 id="squeezing-one-more-task-in"&gt;Squeezing One More Task In&lt;a class="headerlink" href="#squeezing-one-more-task-in" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If things are going normally, I organize and write my articles on Sunday, with the
editing the draft article going into Monday evening.  During that time, I do take a
fair number of breaks to ensure that I am writing and editting with a clear mind.
But just because I start
working on the article, it does not mean that I stop thinking about whatever it is I was
working on.  Usually, it is a battle between getting the writing done and my urge to
complete what I started.  Most of the time, the article wins. In this case, it did not.&lt;/p&gt;
&lt;p&gt;On Saturday morning, I had started working on figuring out
how to get test function &lt;code&gt;test_block_quotes_extra_03b&lt;/code&gt; working.  And while I had made some
progress on it, I was still working on it.  For whatever reason, when placed within a
Block Quote element, Link Reference Definitions were not being recognized properly. I had
started working on this right after fixing test function &lt;code&gt;test_block_quotes_extra_04f&lt;/code&gt;
and  I had spent a decent amount of time trying to get it working. But with a busy weekend
in my personal life, I was not able to get a good, solid, contiguous couple of hours to
work on this
issue as I had hoped to do.  As such, I had started to try to figure out this issue about
five times and gave up after each short try.  It gnawed at me that I could not figure it
out.  It had not taken me long to resolve the previous set of issues, why was it
taking me so long with this one?&lt;/p&gt;
&lt;h3 id="regrouping"&gt;Regrouping&lt;a class="headerlink" href="#regrouping" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After completing the bulk of the rough draft of the article, I took some time to relax
and clear my head, knowing that I needed to look at the problem again.&lt;/p&gt;
&lt;p&gt;This time, I had a lot better results with my debugging.  Starting with the basics,
I turned on debug logging for the test and followed along in the source code as I read each
line of the debug output.  It was then that I noticed the issue: the Block Quote token
itself was wrong.  As I looked through the logs, everything was fine up until the requeue
from the Link Reference Definition happened.  From there, everything was just off.&lt;/p&gt;
&lt;p&gt;Taking some time to think about it, I decided to take our dog Bruce for a walk.  During
that walk, I tried hard not to think about the issue, and mostly succeeded.  When I came
back, I was able to examine the log files again, knowing that the Block Quote token was
off, and that I had to find the cause.  Within five minutes, I had the answer.  It was
once again a state issue.  Before the requeue happened, as each line was being processed
within a Block Quote, new information was added to the Block Quote token.  This information
was about the leading text that was removed from each line in the container processor,
ensuring that the leaf processor only had to deal with leaf block related issues.  To
ensure that the Markdown could be properly rehydrated, this information was stored in the
Block Quote token itself.  But when the requeue happened, nothing was done to erase the
information added to the token between the start of the Link Reference Definition parsing
and the start of the requeue.  Or at least that is what I thought had happened.&lt;/p&gt;
&lt;p&gt;Doing some quick testing, I quickly proved my theory to be correct.  As I followed
along in the logs for the test function, I saw the amount of leading text in the Block
Quote token increase, but never decrease.  To further prove that I was on the right track,
I compared the number of lines that were requeued to the number of extra lines of leading
text present in the token, and it was a match!&lt;/p&gt;
&lt;h3 id="fixing-the-issue_1"&gt;Fixing The Issue&lt;a class="headerlink" href="#fixing-the-issue_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With a solid lead on what the cause was, the most concrete manner of proving that I had
the right cause to fix it.  After mulling around various ideas in my head, the one that
won out was to simply store a copy of the Block Quote token in the Link Reference
Definition token at the start of processing.  With the other requeue logic in place,
once I had done all the other requeuing, I simply replaced the changed Block Quote token
with the copy of the original token.  Running through the tests, this worked right away!&lt;/p&gt;
&lt;p&gt;After having taken such a long way to get there, I now had it fixed.  But since I had
ended up solving the issue somewhat late on Sunday evening, I decided to put the changed
code
aside and to continue edit that week’s article.  It was enough to knowing that I had
solved it and that it just needed cleaning up before committing.  It was then after I
had completed my final edit of the article on Monday night that I noticed that I had
finished early on Monday night with a lot of time to spare.  With that extra time in hand,
I was able to take the roughly finished solution and polish it up enough to commit it.
While technically it should be a part of next week’s article, it just felt right to
include it with this article, as that is where most of the work occurred.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a busy week of getting rid of some big-ticket issues, it was very nice to
reduce my scope and focus on the smaller items.  Not that I mind working on the big
items, it is just that they require me to maintain a larger scope of focus, thereby
tiring me out a bit more.  The smaller items are not always as satisfying to resolve,
but they are also not as draining.&lt;/p&gt;
&lt;p&gt;During the article, I mentioned that I was becoming more aware that I was dealing more
with corner cases than anything else, and that was a good feeling.  I am very confident
that any of the main scenarios driving the parser have already been addressed. With those
out of the way, it stands to reason that any issues that I am finding are the weird cases
that do not occur that often.  It just makes sense to me.&lt;/p&gt;
&lt;p&gt;It also means that I am getting more confident that I am nearing the end of this testing
phase of the PyMarkdown project.  My main drive for the project was to complete the project
on my own terms, with the level of quality and testing that I expect from other projects.
While I could have started releasing this project a while ago, I wanted to make sure that
I have reached that level before I ship the project, and work on improving it from there.
And with the knowledge that I am cleaning up corner cases, I know that I now closer to
that point with the PyMarkdown project than I have ever been before!&lt;/p&gt;
&lt;p&gt;And it is a good feeling!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I do not want to sound like a broken record, but it is back to the same process of
finding the next item to work on, and getting it resolved.  The only difference was
that I was getting close to eliminating all the “open range” items in favor of the
prioritized issues.  Progress!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 16</title><link href="https://jackdewinter.github.io/2021/01/11/markdown-linter-delving-into-the-issues-16/" rel="alternate"></link><published>2021-01-11T00:00:00-08:00</published><updated>2021-01-11T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2021-01-11:/2021/01/11/markdown-linter-delving-into-the-issues-16/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2021/01/04/markdown-linter-delving-into-the-issues-15/"&gt;last article&lt;/a&gt;,
I continued working on Block Quote issues and some general clean up that I have wanted to
do for a couple of months now.  With one week left in my holiday, I wanted to make sure
I tackled as many of the big-ticket items that …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2021/01/04/markdown-linter-delving-into-the-issues-15/"&gt;last article&lt;/a&gt;,
I continued working on Block Quote issues and some general clean up that I have wanted to
do for a couple of months now.  With one week left in my holiday, I wanted to make sure
I tackled as many of the big-ticket items that I can while I have the time.  If I am
going to be doing some work during my holiday, I want to make it count!&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a couple of weeks off for the holidays and relatively light “honey-do”&lt;sup id="fnref:honey"&gt;&lt;a class="footnote-ref" href="#fn:honey"&gt;1&lt;/a&gt;&lt;/sup&gt;
schedule,
I had some free time to devote to getting the project closer to the goal line.  While
I did not want to lose focus on getting the smaller items completed, I had a number
of big-ticket items that I wanted to do.  Because of their size or scope, I wanted to
ensure that I had a dedicated amount of contiguous time to work on each item.  Except
for the occasional weekend, I figured that this would be the best time to work on them
and hopefully get all of them completed in one big push. With a good week left of
New Year’s holiday left to go, it seemed like a good idea to try and get as much done
as i could in the short amount of time I had.  At least, that was my plan.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/9582d7f984dad91539877a073ef251f272f592e5"&gt;28 Dec 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/a0281da5414ec2c45fb32c3d687027ba21f1ccb6"&gt;03 Jan 2021&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="enhancing-code-quality"&gt;Enhancing Code Quality&lt;a class="headerlink" href="#enhancing-code-quality" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Continuing with the large item cleanup that I had started in the previous week; I was
eager to get some refactoring done on the Markdown token classes.  The first step towards
refactoring those classes was to make each token as read-only as possible, to avoid the
possibility of changing the tokens.  To accomplish this task, I just went through each
token in
order, adding the &lt;code&gt;__&lt;/code&gt; prefix to most of the field names, thereby making them private.
With each of those fields now private, I added a new getter property for each field
named after the original field name.  As the property name for the new getter function
matched the old name of the field, any read-only access was able to continue without any
issues.&lt;/p&gt;
&lt;p&gt;As with any such change, there are always exceptions that need to be dealt with
individually.  One such case was the &lt;code&gt;active&lt;/code&gt; field of the &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt;
class. The first exception was that instead of retaining the name &lt;code&gt;active&lt;/code&gt;, I felt that
the name &lt;code&gt;is_active&lt;/code&gt; was more descriptive.  The second exception was that this token
type is used to look for starts and ends of various inline token sequences.  As such,
when those sequences are found, the previous instances of those tokens are marked as
inactive, meaning they will not be used any more.  To take care of this, I introduced
to that token a new function &lt;code&gt;deactivate&lt;/code&gt;, specifically used to deactivate the token
without exposing the token’s member variable in its private form.&lt;/p&gt;
&lt;p&gt;Once this refactoring was completed, I realized that the &lt;code&gt;markdown_token.py&lt;/code&gt; module
was way too large for my liking and needed to be broken down.  Keeping the base
&lt;code&gt;MarkdownToken&lt;/code&gt; and &lt;code&gt;EndMarkdownToken&lt;/code&gt; classes in their original file, I started to
move every Markdown token to one of three new modules: one for container block tokens,
one for leaf block tokens, and one for inline tokens.  Once the tokens were in their
new modules and all tests passed, I added a new base token class for each of the three
new modules and switched the base class for each token to the new base token in the
same module.  By switching over each token to use these three new base classes, I was
able to further reduce the amount of code in each token.  While it was not too much of
a reduction, it was a reduction I felt good about.&lt;/p&gt;
&lt;h2 id="enhancing-some-more"&gt;Enhancing Some More&lt;a class="headerlink" href="#enhancing-some-more" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I started working on this group of tasks, the first thing that came to mind was
the words to an old campfire song I learned long ago in Boy Scouts of Canada.  While
it is a silly song named
&lt;a href="https://makingmusicfun.net/htm/f_mmf_music_library_songbook/nelly_in_the_barn_lyrics.php"&gt;Nelly In The Barn&lt;/a&gt;,
the bit between the verses goes:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Second verse, same as the first, a little bit louder and a little bit worse!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I could think of no phrase better to describe what I needed to do with the &lt;code&gt;StackToken&lt;/code&gt;
class.  Having had good success with changing all the &lt;code&gt;MarkdownToken&lt;/code&gt; classes to use
private fields and &lt;code&gt;is_x&lt;/code&gt; methods (as detailed in my last article), I felt that the
&lt;code&gt;StackToken&lt;/code&gt; class needed the same treatment.&lt;/p&gt;
&lt;p&gt;Unlike the almost 20 classes for &lt;code&gt;MarkdownToken&lt;/code&gt; descended classes, the transformation
on the 9 classes descended from &lt;code&gt;StackToken&lt;/code&gt; went by quickly.  Like the changes made to the
&lt;code&gt;MarkdownToken&lt;/code&gt;
classes, I was emboldened to make these changes due to the confidence of having a large
group of scenario tests that I can use to look for any issues.  Without that large
group of tests, I would be worried that I would fix one thing, only to break something
else in a related piece of code that I forgot about.&lt;/p&gt;
&lt;h2 id="closing-the-test-loop"&gt;Closing the Test Loop&lt;a class="headerlink" href="#closing-the-test-loop" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I noted in the section of the last article entitled
&lt;a href="{filename}/articles/SoftwareQuality/#making-the-test-invocation-more-efficient#making-the-test-invocation-more-efficient"&gt;Making the Test Invocation More Efficient&lt;/a&gt;,
I implemented a change to how I invoked the test infrastructure to reduce the needed code
from eight lines (1 blank line, 2 comment lines, and 5 code lines) to two lines (1 comment
line and 1 code line).  Having done some further examination of those changes, I felt that
those changes had settled in nicely and it was time to propagate those changes to all
similar test functions.&lt;/p&gt;
&lt;p&gt;I had a good model for the changes, but even so, the work was very monotonous.  With just
short of 2000 scenario tests that required changing, it was a test of wills: me versus
the code base.  To keep myself motivated, I kept a search window open on the side of my
editor, selecting a new group of tests to modify whenever I found myself getting bored.
Even after taking extra breaks to do household chores, I still found that it was a tough
task.  But I knew it was a good task to do, so even though I could feel the lobes of my
brain numbing with each keystroke, I pressed forward with making the changes.&lt;/p&gt;
&lt;h2 id="keeping-things-simple"&gt;Keeping Things Simple&lt;a class="headerlink" href="#keeping-things-simple" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having ensured that all end Markdown tokens had their &lt;code&gt;start_markdown_token&lt;/code&gt; field set, I
looked at the code to figure out if there were any redundancies that were introduced with
that change.  As
that field points to the start Markdown token, there was a good chance that I had stored
duplicate data in the &lt;code&gt;EndMarkdownToken&lt;/code&gt; to avoid having to calculate the start Markdown
token for some of the tokens.  It was just a matter of identifying any such tokens.&lt;/p&gt;
&lt;p&gt;While I was sincerely expecting more of an impact, the only change that I was able to
perform was around the end Markdown token generated for the &lt;code&gt;EmphasisMarkdownToken&lt;/code&gt;
token.  To get around the constraints at the time that it was written, I had added
duplicated data to that end token
to denote the length of the emphasis and the emphasis character.  With that actual start
token now available for reference, I was able to replace the duplicate data stored in the
&lt;code&gt;EndMarkdownToken&lt;/code&gt; with a reference to the &lt;code&gt;EmphasisMarkdownToken&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;No longer needing that duplicate data, I removed it from the &lt;code&gt;__process_emphasis_pair&lt;/code&gt;
function. The fallout of that change was approximately 200 instances where I needed to
replace the now useless data with the string &lt;code&gt;:&lt;/code&gt;.  To make things easier while editing,
I simply kept the text &lt;code&gt;:::&lt;/code&gt; in the clipboard, searched for &lt;code&gt;[end-emphasis(&lt;/code&gt;, and replaced
the first three characters after the &lt;code&gt;)&lt;/code&gt; character.  It was mind numbing work that I did
in three or four shifts, but I got it done.  Running the tests, everything was working
except for a couple of tests.  Investigating each of those failed tests, the failures
were all simple typing errors, quickly fixed to make the tests pass.&lt;/p&gt;
&lt;h2 id="reorganizing-the-series-m-file"&gt;Reorganizing the Series M File&lt;a class="headerlink" href="#reorganizing-the-series-m-file" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This task was a pure cut-and-paste task, but one that I really needed to do. At over
10 thousand lines of code, the &lt;code&gt;test_markdown_paragraph_series_m.py&lt;/code&gt; module was just
way too big!  I was initially okay with the size of the module, seeing that all the
scenario tests in the file were related to each other.  But as I started to add more
and more tests to that one large file, it was becoming too difficult to work on
in that form.  As such, I simply create one file for each group of tests, such
as &lt;code&gt;test_markdown_paragraph_series_m_fb.py&lt;/code&gt; for the Fenced Code Block tests, and moved
the test functions into their new home.&lt;/p&gt;
&lt;h2 id="collapsing-ordered-and-unordered-list-processing"&gt;Collapsing Ordered and Unordered List Processing&lt;a class="headerlink" href="#collapsing-ordered-and-unordered-list-processing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the start of the project, while I was working through the initial parts of the parser,
I was not sure that the processing of Ordered List Blocks and Unordered List Blocks would
overlap.  With almost a year of processing accomplished, I now had a very solid observation
on that subject.  Most of the processing overlapped, and overlapped cleanly.  Now it was
just a manner of taking the time to surgically merge two List Block token concepts into one
in different places in the source code.&lt;/p&gt;
&lt;h3 id="the-first-step"&gt;The First Step&lt;a class="headerlink" href="#the-first-step" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A big first step on this journey was to move the code for calculating the looseness of
a HTML rendered list from the &lt;code&gt;TransformToGfm&lt;/code&gt; class into the new
&lt;code&gt;TransformToGfmListLooseness&lt;/code&gt; class.  While it was just a simple cut-and-paste move,
I feel that the move left the &lt;code&gt;TransformToGfm&lt;/code&gt; class better able to focus on the HTML
transformation, instead of also having the responsibility of figuring out the list
looseness.  It just felt cleaner to have that responsibility in its own class and module.&lt;/p&gt;
&lt;p&gt;Along with that change, I made equal changes to how the List Block starts were processed
in the HTML transformer and the Markdown Transformer.  In the HTML transformer, the
&lt;code&gt;__handle_start_unordered_list_token&lt;/code&gt; function was renamed to &lt;code&gt;__handle_start_list_token&lt;/code&gt;
and the &lt;code&gt;__handle_start_ordered_list_token&lt;/code&gt; function code was merged into that function.
In the Markdown transformer, the same process was repeated with the
&lt;code&gt;__rehydrate_unordered_list_start&lt;/code&gt; function was renamed to &lt;code&gt;__rehydrate_list_start&lt;/code&gt;
and the &lt;code&gt;__rehydrate_unordered_list_start_end&lt;/code&gt; function code was merged into that function.&lt;/p&gt;
&lt;p&gt;That merge allowed for the handler calls in each module to deal more simply with the List
Blocks, something that was worth it to me.&lt;/p&gt;
&lt;h3 id="equalizing-the-two-list-blocks"&gt;Equalizing the Two List Blocks&lt;a class="headerlink" href="#equalizing-the-two-list-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having done a lot of testing with the Unordered List Blocks, I felt it was time to give
some extra focus to the Ordered List Blocks.  Before the holiday break
started, I had noticed a handful of cases where the Ordered List Blocks had errors in
them that I thought should have been caught by existing tests.  While fixing this issue
was not the primary goal of this round of refactoring, I considered it a simple  secondary
goal that I should only have to fix list issues once, not twice.&lt;/p&gt;
&lt;p&gt;Looking at the second half of the &lt;code&gt;is_ulist_start&lt;/code&gt; function, I noticed that there
were significant differences from its sibling &lt;code&gt;is_olist_start&lt;/code&gt; function.  Slowly, I started
making changes to the &lt;code&gt;is_ulist_start&lt;/code&gt; function, bringing it more in line with it sibling.
But after making those changes, I still had the task of making sure that those changes
were working properly.  As any failures were not already caught, but discovered through
other tests, I figured that I needed to stop up my test game.&lt;/p&gt;
&lt;p&gt;To start this off, I picked six scenarios from each of Series M tests and made copies of
those tests.  Instead of using the Order List Blocks in those tests, I replaced the Ordered
List Blocks with Unordered List Blocks.  It was only after adding those 108 scenario tests
that I was confident that those changes had a good start at getting coverage.  And it paid
off too.  The only issues that were found were in the
&lt;code&gt;__perform_container_post_processing_lists&lt;/code&gt; function, where the data to be merged with
the surrounding list had to be massaged before a call to &lt;code&gt;__merge_with_container_data&lt;/code&gt; and
restored after that call was completed.&lt;/p&gt;
&lt;h3 id="refining-list-start-functions"&gt;Refining List Start Functions&lt;a class="headerlink" href="#refining-list-start-functions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The final set of functionality to merge was the &lt;code&gt;is_ulist_start&lt;/code&gt; function and the
&lt;code&gt;is_olist_start&lt;/code&gt; function.  Both of these functions had been on my “refactor” list for a
while, so I was glad to get started on them.  On closer examination, there were only a
few statements or values that changed between the two functions.  Once
the setup was accomplished in the first half of the function, the second half was near
identical.  Creating a new &lt;code&gt;__xxx&lt;/code&gt; function, I cut the second half of one of those two
functions and pasted it in that new function.  After checking to make sure nothing was lost
in the cut-and-paste, I compared it line-by-line with the similar code in the other
function, adjusting both functions to be represented by the new function.&lt;/p&gt;
&lt;p&gt;After a couple of rewind moments, the new &lt;code&gt;__xxx&lt;/code&gt; function incorporated the process from
both original functions.  With that accomplished and staged, I removed the second function
and used the new function in its place.  After fixing a couple of small issues, the new
function was up and running and working for both Ordered List Blocks and Unordered List
Blocks.&lt;/p&gt;
&lt;p&gt;At that time, I remember looking at the code and thinking that I had only completed half
of the job.  Repeating the same process that got me to that point, I soon renamed the
&lt;code&gt;__xxx&lt;/code&gt; function to &lt;code&gt;__is_start_phase_two&lt;/code&gt;, and further extracted code into a new
&lt;code&gt;__is_start_phase_one&lt;/code&gt; function.  With that done, the &lt;code&gt;is_olist_start&lt;/code&gt; function was
already slim, and I extracted the remaining logic into the &lt;code&gt;__is_start_olist&lt;/code&gt; function
to keep it slim, replicating that processing with the &lt;code&gt;is_ulist_start&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;In the end, I was very satisfied with the amount of refactoring that I was able to
accomplish.  Both methods were now six statements long, with 95% of the differing
functionality in the &lt;code&gt;__is_start_olist&lt;/code&gt; function and the &lt;code&gt;__is_start_ulist&lt;/code&gt; function.
While it was a good feeling getting the refactoring done, it was an even better feeling
knowing that I had a healthy set of test cases that I could count on when refactoring!&lt;/p&gt;
&lt;h2 id="consolidating-new-block-starts"&gt;Consolidating New Block Starts&lt;a class="headerlink" href="#consolidating-new-block-starts" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having poured through the code looking for things to simplify, I was keenly aware of one
set of function calls that I could simplify: detecting new block starts.  Developed in
different parts of the code for similar reasons, both the List Block Processor’s
&lt;code&gt;__check_for_list_closures&lt;/code&gt; function and the Block Quote Processor’s
&lt;code&gt;check_for_lazy_handling&lt;/code&gt; function were performing almost the same set of
instructions.  One by one, the different Leaf Block start functions were being invoked
to determine if a newline indicated the start of a new block.&lt;/p&gt;
&lt;p&gt;It was not a big change but consolidating that code into the
&lt;code&gt;is_paragraph_ending_leaf_block_start&lt;/code&gt; function just made things cleaner.  There was just
one function to call with good documentation on what was going on.  It just made sense
to me.&lt;/p&gt;
&lt;h2 id="verifying-paragraph-usage"&gt;Verifying Paragraph Usage&lt;a class="headerlink" href="#verifying-paragraph-usage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Just before I started writing on that Sunday morning, I decided to add something that was
hopefully going to be a slam dunk.  While I was reasonably sure that all the various
referenced to Paragraph elements and any newlines within them were accounted for, I wanted
to be doubly sure.  So, to be sure of that, I added the following code to the end of
the &lt;code&gt;__rehydrate_paragraph_end&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt;
        &lt;span class="n"&gt;expected_rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_rehydrate_index&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"rehydrate_index+1="&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;";expected_rehydrate_index="&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_rehydrate_index&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, by the end of the Paragraph element’s processing, the &lt;code&gt;rehydrate_index&lt;/code&gt; member
variable should have been incremented once for each newline contained within the paragraph.
If this did not happen, it means that the use of that &lt;code&gt;rehydrate_index&lt;/code&gt; member variable is
potentially off and needs to be fixed.&lt;/p&gt;
&lt;p&gt;Surprisingly, even after adding some extra tests, the only one element had issues: the
Raw HTML element.  In the main parser’s &lt;code&gt;parse_raw_html&lt;/code&gt; function, the raw text to use
for the tag was not properly accounting for the newline, something that was quickly fixed.
This pattern continued in the Markdown generator’s &lt;code&gt;__rehydrate_inline_raw_html&lt;/code&gt; function,
where I specifically created the &lt;code&gt;__handle_extracted_paragraph_whitespace&lt;/code&gt; to handle the
pulling apart and reintegration of that information.  This was a useful function to have
as I found some small issues with the &lt;code&gt;__rehydrate_inline_code_span&lt;/code&gt; function that required
applying that function to the various parts of the Code Span element.  Finally, to round
out the fixes, the &lt;code&gt;__verify_next_inline_raw_html&lt;/code&gt; function needed to have a similar
approach taken to address the last issues with the &lt;code&gt;rehydrate_index&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given that it could have been a lot more cumbersome to fix, I was happy that I got off with
a relatively light amount of work!&lt;/p&gt;
&lt;h2 id="as-i-was-making-these-changes"&gt;As I Was Making These Changes…&lt;a class="headerlink" href="#as-i-was-making-these-changes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the middle of these changes, I rearranged the items in the issues list.  My goal was
to take the priorities that I had in my mind and reinforce them in the list.  The only
exceptions to this reorganization were anything that was an immediate focus of what I was
doing at the moment.  The way I rationalized this was that anything that I could set down
for a while was something that I could figure out when to get to it.  With an item that
remained on the list or was newly added to the list, I deemed that the items were more of
an immediate task to get done, and just needed doing.&lt;/p&gt;
&lt;p&gt;While it may seem like a bit of a wishy-washy rule, it was one that I still felt fine with
after a couple of days of having the prioritization in place.  Granted, it felt like I was
churning through the immediate task section, but that also felt right.  As I am working on
whatever current task that I need to work on, I observe things in the code and have
questions about whether I took the right approach.  Writing those things down in
the issues list allows me to continue with the task without losing too much of the essence
of what I wanted to verify or question.  To me, that just seems like a good approach!&lt;/p&gt;
&lt;h2 id="preparing-for-the-future"&gt;Preparing for The Future&lt;a class="headerlink" href="#preparing-for-the-future" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A major part of this week’s work was to clean things up a bit with bigger tasks that I
do not normally have time for.  As such, I decided to spend about four to five hours during
the week experimenting with &lt;code&gt;SnakeViz&lt;/code&gt; and incorporating primitive SnakeViz support
into the project.  While it is too early to say what needs the most
improvement, I can say that I was able to get some good experience working with the tool
and the output HTML that helps visualize the performance.  I engaged in the
experimentation specifically to gain some experience with code profiling, and I can
honestly say that I think I got the experience that I was looking for!&lt;/p&gt;
&lt;p&gt;The smart thing about using SnakeViz to profile is that it is interactive.  To ensure
that a user can dig down and get relevant information, SnakeViz takes a performance
analysis file and hosts fragments of it through a webserver that it starts.  As the
webserver is starting, SnakeViz also launches it own page in its users own browser.
After that, it is just a matter of clicking around and displaying information on any
number of functions that were executed during the code profile run.&lt;/p&gt;
&lt;p&gt;I do not know if everyone will have the same experience that I did, but I found the
interface simple and easy to use.  When I start focusing on performance, I know I will
spend a decent amount of time looking at the &lt;code&gt;tottime&lt;/code&gt; column which displays the total
amount of time that was spent in each function during the entire code profile run.
I expect I will look at the top few items on that list and try and figure out why they
are taking that much time.  After making some guesses and changes to the code to match,
rerunning the code profile run with the exact same data will be pivotal.&lt;/p&gt;
&lt;p&gt;While it is still at least a month or so off, I am looking forward to using this tool
and making the code perform well!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In terms of actual issues that I fixed during this week, the count was either low or
zero depending on who was doing the accounting.  But the big win was getting most of
the big-ticket items taken care of.  To be honest, it was a lot of pressure off my
mind getting those big items done.  From my viewpoint, I am not sure that I would have
felt okay with an initial release the project without those items being addressed.  It
was just good housekeeping, and now it was done!&lt;/p&gt;
&lt;p&gt;It just felt good to make the time to get those big-ticket items resolved.  While it
can be argued that there were not that many real changes to the code base, each of those
changes made a significant impact to my confidence about the project.  The refactoring
to provide easy and private access to the tokens?  It increased my confidence that I
have not missed any weird side effects.  The reorganizing and simple cleanup? It increased
my confidence that I had extra “stuff” to maintain across the code base that would make
things more complicated.  Consolidating the List Block code?  It increased my confidence
that I have captured a healthy set of scenarios that properly test both Ordered List Blocks
and Unordered List Blocks.  Each change simply increased my confidence by safely
reducing the amount of required code in the project.&lt;/p&gt;
&lt;p&gt;It also felt good for another reason: it was fun.  Sure, there were boring parts, like
making 2000 changes for the scenario test refactor.  That was definitely not fun.  But
that was kind of fun because it was something for the project that was different.  It
was not the same old test-fix-run and repeat process that I had been doing for months.  It
was just something different.  And that was just fun to do sometimes.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With most of the big-ticket tasks out of the way, I needed to buckle down and try and
resolve as many of the Block Quote items in the unprioritized section as possible.
While it would not be as fun as the big-ticket items, it knew they were worth doing and
it would get me closer to an initial release.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:honey"&gt;
&lt;p&gt;To be fair, in our household we have one honey-do list for me and one honey-do list for my spouse.  And we both ignore some items until reminded and get some items off the list on our own.  You know, typical list. &lt;a class="footnote-backref" href="#fnref:honey" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 15</title><link href="https://jackdewinter.github.io/2021/01/04/markdown-linter-delving-into-the-issues-15/" rel="alternate"></link><published>2021-01-04T00:00:00-08:00</published><updated>2021-01-04T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2021-01-04:/2021/01/04/markdown-linter-delving-into-the-issues-15/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/28/markdown-linter-delving-into-the-issues-14/"&gt;last article&lt;/a&gt;,
I continued working on Block Quote issues and issues with Block Quotes and their
interactions with List Blocks.  In this article, I document that work that was done
to address those issues and resolve them.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a couple of weeks off for the holidays …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/28/markdown-linter-delving-into-the-issues-14/"&gt;last article&lt;/a&gt;,
I continued working on Block Quote issues and issues with Block Quotes and their
interactions with List Blocks.  In this article, I document that work that was done
to address those issues and resolve them.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a couple of weeks off for the holidays and relatively light “honey-do” schedule
around the house, I was hoping to have some good relaxing days along with some good
productive project days.  In my head, I was mentally starting to evaluate each of the
remaining items in the list, assigning them a priority between 1 (highest) and
4 (lowest).  I knew completing the Block Quote issues and Block Quote adjacent issues
has a priority of 1, but I needed to take some time to think about the others.  And
while I was thinking about those others, it was a good time to get some solid work in!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4c0432c60f6a3984052a585861c017ee2df0036d"&gt;22 Dec 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/b5b42bce4f351febd62ad0303087ee0a9b190296"&gt;27 Dec 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="creating-a-new-scenario-series"&gt;Creating A New Scenario Series&lt;a class="headerlink" href="#creating-a-new-scenario-series" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After doing a block of work with Block Quotes, I thought it was a good time to start
making a new scenario test group for them, Series N.  To start this new series off, I
simply copied and pasted
example scenarios from other series and began to work through the permutations.  Once
I had those roughly filled out, I created the &lt;code&gt;test_markdown_paragraph_series_n.py&lt;/code&gt;
module to hold the scenario tests, and just started working on putting them together.
After I had the first group of tests in Series N filled out, it was almost cut-and-paste
to get the next group of tests ready, with a simple change to the specific Markdown
element I was testing in that group.&lt;/p&gt;
&lt;p&gt;As nothing is ever easy (it seems…), I ran into some failures that I needed to fix.
The first set of failures occurred with unquoted HTML Blocks, in that those HTML
Blocks did not end the Block Quote element.  This was quickly followed up by the same
issue occurring with Atx Heading elements.  As I had already solved this problem for
List Blocks, it was quickly fixed by adding checks in the &lt;code&gt;check_for_lazy_handling&lt;/code&gt;
function for both the Atx Heading element starting (&lt;code&gt;LeafBlockProcessor.is_atx_heading&lt;/code&gt;)
or the HTML Block element starting (&lt;code&gt;HtmlHelper.is_html_block&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;At the same time, to handle two extra list-based scenarios, I added the
&lt;code&gt;test_block_quotes_213aa&lt;/code&gt; function and &lt;code&gt;test_block_quotes_213ab&lt;/code&gt; function as variations
on the &lt;code&gt;test_block_quotes_213a&lt;/code&gt; test function.  I tried for a good hour or so to resolve
the issues with all these functions, but I did not make a lot of progress.  In the
end, I got test function &lt;code&gt;test_block_quotes_213ab&lt;/code&gt; working, but functions
&lt;code&gt;test_block_quotes_213a&lt;/code&gt; and &lt;code&gt;test_block_quotes_213aa&lt;/code&gt; just did not want to seem to
work.&lt;/p&gt;
&lt;p&gt;My main priority at the time was filling out the Series N set of tests, so I left
those two tests disabled while I proceeded to fill out the Series N tests.  Nothing
exciting to report from that task… it was just a lot of moving, documenting,
checking, and rechecking. You know, the normal stuff.&lt;/p&gt;
&lt;h3 id="addressing-those-tests"&gt;Addressing Those Tests&lt;a class="headerlink" href="#addressing-those-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In looking good and hard at those disabled tests, I was able to eventually see that a
good group of those tests were dealing with nested containers.  Specifically, they
were dealing with a Block Quote element inside of a List Block element, or the other
way around. Putting the disabled tests, their Markdown documents, and their
expected tokens under a metaphorical microscope, it was a while before I noticed
something that I had previously missed.  When I followed the examples closely, it
looked like Block Quote elements within
a List Block element were not being properly closed in each example.&lt;/p&gt;
&lt;p&gt;In debugging this issue, I added a handful of extra tests to help me analyze the
situation. The Markdown for one of those tests, the &lt;code&gt;test_block_quotes_extra_02a&lt;/code&gt; test
function, is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;quote&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the list of tokens produced for that Markdown were:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[
    '[block-quote(1,1)::&amp;gt; \n&amp;gt; \n&amp;gt;\n&amp;gt; ]',
    '[para(1,3):]',
    '[text(1,3):start:]',
    '[end-para:::True]',
    '[ulist(2,3):-::4:  ]',
    '[para(2,5):]',
    '[text(2,5):quote:]',
    '[end-para:::True]',
    '[BLANK(3,2):]',
    '[para(4,3):]',
    '[text(4,3):end:]',
    '[end-para:::True]',
    '[end-ulist:::True]',
    '[end-block-quote:::True]'
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As I worked through the example, following the Markdown document and the parser’s
tokens,
I discovered the issue.  The Blank Line element on line 3 ended the first Paragraph
element, and I was good with that.  But more importantly, because that Paragraph element
was closed due to the Blank Line being encountered, the new text on line 4 was not
eligible to be included as paragraph continuation text.  Based on that information, the
new Paragraph element for line 4 needed to be created outside of the List Block element,
as it did not have the indentation to support being included in the list.&lt;/p&gt;
&lt;p&gt;Basically, the end Unordered List Block token was in the wrong place.  To fix it, I would
need to move it above the occurrence of the Blank Line element.&lt;/p&gt;
&lt;h3 id="fixing-it-right"&gt;Fixing It Right!&lt;a class="headerlink" href="#fixing-it-right" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Being an issue with the tokenization of the Markdown Document, I needed to start
with the parser and the &lt;code&gt;BlockQuoteProcessor&lt;/code&gt; class.  From the above information, I knew
that I needed to alter the way in which the &lt;code&gt;parser_state.handle_blank_line_fn&lt;/code&gt; function
was called, as it was not properly closing the right blocks.  After trying a few
other things, I reverted to a very basic approach to solve the issue:  forgo the
complicated calculations and just do the simple calculation where needed.  So, in the
&lt;code&gt;__handle_block_quote_section&lt;/code&gt; function, before the &lt;code&gt;handle_blank_line_fn&lt;/code&gt; function is
called, a quick calculation is done to see if the List Block should possibly be closed.
If so, the actual index number is set in the &lt;code&gt;forced_close_until_index&lt;/code&gt; variable.  Then,
making a small change to the &lt;code&gt;handle_blank_line_fn&lt;/code&gt; function, that variable is passed in
and all tokens on the stack are closed until they get to that point.&lt;/p&gt;
&lt;p&gt;At the time, it felt like I was using a large sledgehammer to fix a small problem, but
it worked.  The tokens were being generated properly, and I was able to move on from
there. While I could them go on to describe all the problems I had with the Markdown
transformer, I will spare any reader the pain.  While the basic handling of Block Quote
elements was working
fine, the proper handling of indents within Block Quote elements needed a good solid
day’s overhaul to get it right.  It was a good thing I was on holiday, because I had
that time to devote to working through all the issues and getting the Markdown
rehydration of Block Quotes and their indents just right.&lt;/p&gt;
&lt;p&gt;Following that, I expected a lot of issues with the consistency checks, but there was
only one major issue.  In the &lt;code&gt;__validate_new_line&lt;/code&gt; function, the &lt;code&gt;leading_text_index&lt;/code&gt;
member variable of the Block Quote token was not being updated properly, resulting in
an off-by-one error.  Unlike the problems with the Markdown transformer, this issue
took less than half an hour to find and fix.  Phew!&lt;/p&gt;
&lt;p&gt;In the end, I was able to enable four of the &lt;code&gt;test_block_quotes_213&lt;/code&gt; test functions
and all five of the new test functions that I had added.  That was a good feeling.&lt;/p&gt;
&lt;h3 id="still-missing-one"&gt;Still Missing One&lt;a class="headerlink" href="#still-missing-one" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After a good night’s worth of sleep, I got back to tackling the disabled functions,
specifically test function &lt;code&gt;test_block_quotes_213aa&lt;/code&gt;.  With a Markdown document of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;boo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it was immediately obvious that this was somewhat related to the work that I completed
the day before.  It was just figuring out how that stumped me for a while.&lt;/p&gt;
&lt;p&gt;Adding some debug, I started to suspect that the “can I start a container block” logic
in the &lt;code&gt;__get_nested_container_starts&lt;/code&gt; function was not working properly.  Adding more
specific debugging in that function, my guess was confirmed.  Specifically, there were
cases where I felt it was obvious that a new List Block element should start, but the
code was skipping over those chances.&lt;/p&gt;
&lt;p&gt;Stepping through that code, I noticed weird behavior when I got to this part of that
function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;nested_ulist_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ListBlockProcessor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_ulist_start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nested_olist_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ListBlockProcessor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_olist_start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nested_block_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BlockQuoteProcessor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_block_quote_start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looking at the debug output for that code while debugging the &lt;code&gt;test_block_quotes_213aa&lt;/code&gt;
function, it was obvious that on the second line of the document, the code was not
determining that a new block was starting.  It just skipped right over it.&lt;/p&gt;
&lt;p&gt;Thinking through the issue while I was debugging, this started to make sense.  It was
not triggering on any of the above start checks because the wrong information was being
presented to it.  In fact, the data presented to it for line 2 of the above Markdown
was literally two space characters followed by the Unsigned List Block start character
(&lt;code&gt;-&lt;/code&gt;).  While that specific form of data made sense for the
&lt;code&gt;__get_nested_container_starts&lt;/code&gt;
function, trying to invoke any one of the three Container block start functions with
that data would never succeed.  Each of those functions expected the line to at least
be minimally processed, and that line of data clearly had not been.&lt;/p&gt;
&lt;p&gt;Trying the simple approach first, I tested the following change while debugging function
&lt;code&gt;test_block_quotes_213aa&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;after_ws_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ex_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extract_whitespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;nested_ulist_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ListBlockProcessor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_ulist_start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;after_ws_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ex_whitespace&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and it worked!  Debugging through the test again, that processing allowed the
&lt;code&gt;is_ulist_start&lt;/code&gt; to work with the processed line data, resulting in a non-None
result being returned.  After applying that same change to the other two start Container
block functions, I ran the tests again and everything was good.  The tests were passing
without any additional changes being required of the Markdown transformer or the
consistency checks.  I was stoked!&lt;/p&gt;
&lt;h2 id="making-the-test-invocation-more-efficient"&gt;Making the Test Invocation More Efficient&lt;a class="headerlink" href="#making-the-test-invocation-more-efficient" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I was making the changes to all these scenario tests, one thing was becoming
obvious to me: I was not changing the call pattern.  In the beginning of the project, I
was concerned that I was going to have a wide array of ways to invoke the scenario tests
based on need.  While it was a valid concern at the time, it had not played out that
way.  For each scenario test, I was always adding the following boilerplate code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;actual_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;actual_gfm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transformer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_strings_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_gfm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_gfm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;assert_token_consistency&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While those seven lines are not a lot, over the course of approximately 2,000 scenario
tests, those lines added up.  Thinking about it a bit, I realized that I was not going
to change this format because it was consistently worked well for me.  Declared before
this code block
in each test, the variables &lt;code&gt;source_markdown&lt;/code&gt;, &lt;code&gt;expected_tokens&lt;/code&gt; and &lt;code&gt;expected_gfm&lt;/code&gt; held
the relative information for each test.  Once set, I could not think of any reason to
alter from the pattern of calling the three validation functions, one after another.&lt;/p&gt;
&lt;p&gt;At the same time, if I was going to make this change on a large scale, I wanted to start
out with a smaller scope of work and validate it first.  At that point, I created a new
&lt;code&gt;act_and_assert&lt;/code&gt; function to contain those seven lines of code, and changed that code
block from above to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;# Act &amp;amp; Assert&lt;/span&gt;
    &lt;span class="n"&gt;act_and_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_gfm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After testing it out on a couple of scenario tests, I applied it to all the scenario
tests in the &lt;code&gt;test_markdown_paragraph_series_n.py&lt;/code&gt; module and the
&lt;code&gt;test_markdown_block_quotes.py&lt;/code&gt; module.  Making sure the scenario tests all worked,
including introducing some false failures that I immediately fixed, I decided to leave
it alone for a while.  My thought process was that I would let it “set” in my mind.
If I was still interested in making the change after a week or so, I could
work on it over the course of a couple of weeks.&lt;/p&gt;
&lt;h2 id="link-reference-definitions-and-containers"&gt;Link Reference Definitions and Containers&lt;a class="headerlink" href="#link-reference-definitions-and-containers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking at the issues list, the following item gained my attention:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="n"&gt;definition&lt;/span&gt; &lt;span class="n"&gt;within&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="n"&gt;quote&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While I was not sure it was going to be easy, I at least figured that it would be fun!
At the base level, it was an interesting question.  Block Quote elements and List Block
elements altered the way a line was processed, and Link Reference Definitions could span
lines and not appear to follow the right rules.  To that end, I added three new
scenario tests &lt;code&gt;test_block_quotes_extra_03x&lt;/code&gt; to &lt;code&gt;test_block_quotes_extra_03b&lt;/code&gt; and I
added three new scenario tests &lt;code&gt;test_list_items_extra_01x&lt;/code&gt; to &lt;code&gt;test_list_items_extra_01b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The bad news first.  Try as I may, I was not able to get the new Block Quote tests to
pass within a decent amount of time.  As such, I had to commit them as disabled tests.&lt;/p&gt;
&lt;p&gt;The ContainerBlockProcessor was largely unchanged, with the changes in that class being
made to get rid of code or simplify code, rather than fix issues.  The Markdown transformer
was altered to produce the proper output if there were any leading spaces in the list that
were not being merged in by the Link Reference Definition token.  Those were the easier
two fixes.  The hard changes involved the HTML transformer.&lt;/p&gt;
&lt;h3 id="list-looseness-again"&gt;List Looseness… Again&lt;a class="headerlink" href="#list-looseness-again" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I thought all my issues regarding list looseness were behind me, I was wrong.
Specifically:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A list is loose if any of its constituent list items are separated by blank lines, or if any of its constituent list items directly contain two block-level elements with a blank line between them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Breaking that down, a list is lose if, for any item within the list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it is not the first item and preceded by a blank line&lt;/li&gt;
&lt;li&gt;it is not the last item and followed by a blank line&lt;/li&gt;
&lt;li&gt;any item contains any two block elements that are separated by a blank line&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How is this related to Link Reference Definitions?  When the PyMarkdown processors
parse a Link Reference Definition element, it creates a token that represents that
element so it can be analyzed.  However, from an HTML point of view, it does not exist.
As such, the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is for HTML output purposes equal to the Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, from the HTML transformer point of view, it is a Blank Line element. I had some
code in the &lt;code&gt;__is_token_loose&lt;/code&gt; function to report a Link Reference Definition as a Blank
Line element and in the &lt;code&gt;__calculate_list_looseness&lt;/code&gt; to trigger off a block, but it
was not that simple.  Rereading the above section on looseness, it only really mattered
inside of the list item if that Blank Line element was between two blocks.&lt;/p&gt;
&lt;p&gt;Fixing that specific case took a bit of work in the &lt;code&gt;__calculate_list_looseness&lt;/code&gt; function
to redesign the way I was handling those cases.  In cases where the previous token was
a Blank Line, I had to change the algorithm to look before that element and see if there
was a valid block token there.  It so, the logic from the last point above would come
into play,
and it would discover a valid case to check.  Otherwise, the Blank Line token or the
Link Reference Definition token would be intentionally overlooked, and the search would
continue.&lt;/p&gt;
&lt;h3 id="repeat-with-block-quotes"&gt;Repeat, With Block Quotes&lt;a class="headerlink" href="#repeat-with-block-quotes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It was no surprise that I had to do similar work with Block Quote elements to make sure
that they were also working properly.  To accommodate that, I added five new scenarios
and did a lot of debugging.  In the end, the fix was to add a flag in the
&lt;code&gt;__handle_blank_line&lt;/code&gt; function that triggered when a Link Referenced Definition had
been started.  Rather than avoid the default handling in this case, that handle was
carried out and appended to the already created tokens, resulting the proper output.&lt;/p&gt;
&lt;p&gt;Once that fix was made, getting the consistency checks to agree with it was
easy, with one calculation for the &lt;code&gt;leading_text_index&lt;/code&gt; being off by 1.  After a
simple adjustment to compensate for that case, those tests were now passing.
After only an hour and a half of work to get this working, I understood that I was
lucky that it did not end up taking as long as the last set of issues to fix.  I
was grateful!&lt;/p&gt;
&lt;h2 id="evaluating-how-i-was-spending-my-holiday"&gt;Evaluating How I Was Spending My Holiday&lt;a class="headerlink" href="#evaluating-how-i-was-spending-my-holiday" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I do not think that I am a workaholic, I just like to keep busy.  Whether it is figuring
out how to do something with home automation, working on a puzzle, cleaning up the
garage (again!?), or working on this project, it does not matter.  If it is
something that keeps me from spending hours doing one thing with no recognizable thing
to show for it, I am good.  Spending time with my wife helping her out with shopping
works wonderfully for that.  I get to spend time doing crossword puzzles and other fun
things on my phone while waiting for her to finish at various stores she needs to go
to.  For me, it is all about perspective.&lt;/p&gt;
&lt;p&gt;So, it was part of the way through Christmas Eve Day when I thought about this with
respect to the project.  While it was true that I was resolving items from the issues
list, it just was not feeling like it was the right thing to do at that time.  As I had
the weeks before and after Christmas off, I sat back and decided that I wanted
to do something for the project that would be hard to do at any other time.  I mean,
since I have the time, was I using it to my best advantage?&lt;/p&gt;
&lt;p&gt;Within minutes, I had an answer of “No, I was not using my time wisely!”.  I had a
couple of long-term things I wanted to
do with the code base, but those things would be hard to fit into a normal week’s worth
of work.  It was time to shift gears.&lt;/p&gt;
&lt;h3 id="reducing-the-code-required-to-check-for-a-specific-token"&gt;Reducing the Code Required To Check For A Specific Token&lt;a class="headerlink" href="#reducing-the-code-required-to-check-for-a-specific-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While this was done very leisurly over two days, this change was something I had wanted to
do for a while.  As the project’s growth was organic, I had started out check for the
pressence of a given token by looking at its name.  At that time, given the rule module
&lt;code&gt;rule_md_019.py&lt;/code&gt;, if I wanted to see if a given token was a paragraph, I would use:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is nothing intrinsically wrong with that comparison, but it did have things going
against it.  The first was that I had to make sure to import the MarkdownToken class into
any module where I wanted such a comparison.  Next was my observation that I usually had
to go to the &lt;code&gt;markdown_token.py&lt;/code&gt; module and find out exactly how the token’s type name
was spelled, hopefully avoiding any naming errors.  Finally, I found it bulky.  I guess
if I had to add more description to bulky, it was that it took an awful lot of typing to
figure out that the token was a paragraph.  And if it took a lot of typing, it would also
take a lot of reading to do the same thing.  I needed something simpler.&lt;/p&gt;
&lt;p&gt;Working through a couple of possibilities, I decided to use a simple approach and replace
that entire line with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It required no extra imports, the naming was easy to remember, and it was as simple as I
could make it without short forms that would make it to read.  Sure &lt;code&gt;is_para&lt;/code&gt; might be more
compact, but what was I really going to save with that?&lt;/p&gt;
&lt;p&gt;Over the course of approximately ten commits, I transferred all the Markdown Tokens from the
old way of comparing token types to the new way.  I started with Paragraphs and the other
Leaf Block tokens, moving on to Container Block tokens, before finishing up with
Inline tokens.  By the time I was done, there were more lines and functions present in
the base MarkdownToken class, but the entire code base seemed to read better.&lt;/p&gt;
&lt;p&gt;And that was the point of these changes.  No scenario tests were changed as a part of
this code base change, I just wanted it to read better!&lt;/p&gt;
&lt;h3 id="do-i-make-the-code-more-object-oriented"&gt;Do I Make The Code More Object Oriented?&lt;a class="headerlink" href="#do-i-make-the-code-more-object-oriented" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having made those changes, I felt emboldened to make another set of changes that I had
been itching to do for a while: making the code more object oriented.&lt;/p&gt;
&lt;p&gt;While each programming paradigm has its good points and bad points, object-oriented was
something I have had a lot of experience with.  At its core
&lt;a href="https://en.wikipedia.org/wiki/Object-oriented_programming"&gt;object-oriented programming&lt;/a&gt;
had three pivotal concepts: encapsulation, composition, and polymorphism.  As the
PyMarkdown project generates tokens after parsing the Markdown document, I was most
interested in encapsulation and polymorphism and how they could be applied to tokens.&lt;/p&gt;
&lt;p&gt;From an encapsulation point of view, with a couple of exceptions&lt;sup id="fnref:tokens"&gt;&lt;a class="footnote-ref" href="#fn:tokens"&gt;1&lt;/a&gt;&lt;/sup&gt; there is no
reason to want to change the values of any of those parsed tokens.  In the case of those
exceptional tokens, there is a
multiline concept present in that token that needs to be properly tracked by any
after-parsing process.  Other than providing that tracking information during a specific
after-parsing process, those fields do not have any meaning to a consumer.  Therefore,
it is okay that they are exposed.  However, I did not feel that it was the case with
the other values.&lt;/p&gt;
&lt;p&gt;And from a polymorphism point of view, it makes sense to me that the tokens should be
organized
into groups of tokens that have similar properties: Container Blocks, Leaf Blocks, and
Inlines. As such, it also follows that some properties and methods are present in one or
more of those groups of tokens, but not all those groups.  So having a base class for each
of those groups is something to work towards.&lt;/p&gt;
&lt;p&gt;For both reasons, it just made sense to me to proceed!&lt;/p&gt;
&lt;h3 id="starting-with-endmarkdowntoken"&gt;Starting with EndMarkdownToken&lt;a class="headerlink" href="#starting-with-endmarkdowntoken" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the decision made to move forward with this transition, I started at the base by
making those changes with the &lt;code&gt;EndMarkdownToken&lt;/code&gt; class.  To be honest, as I worked
through the project’s development, I always felt a bit guilty that I had let the use
of this token get out of control.&lt;/p&gt;
&lt;p&gt;From my observations, this class is a “hidden” fourth class of tokens, providing a
close token to any of the tokens that provide for start functionality.  As this
functionality ranges across all three groups of tokens, the &lt;code&gt;EndMarkdownToken&lt;/code&gt; exists off
to the side in its own space.  Because of this special grouping, it was the ideal token
to start with.&lt;/p&gt;
&lt;p&gt;To change this token, I started off with the &lt;code&gt;EndMarkdownToken.type_name_prefix&lt;/code&gt; field
which contains the string that gets prepended to the start of any &lt;code&gt;EndMarkdownToken&lt;/code&gt;
type name.  Moving it into the &lt;code&gt;MarkdownToken&lt;/code&gt; class made the use of that field
self-contained, allowing it be modified into a protected field.&lt;sup id="fnref:protected"&gt;&lt;a class="footnote-ref" href="#fn:protected"&gt;2&lt;/a&gt;&lt;/sup&gt;  To accomplish
that change, I created a new &lt;code&gt;generate_close_markdown_token_from_markdown_token&lt;/code&gt; function
that allowed me to generate the proper &lt;code&gt;EndMarkdownToken&lt;/code&gt; from a given Markdown token.&lt;/p&gt;
&lt;p&gt;To me, this just made sense.  By performing these changes, I had an easy way of
generating
an &lt;code&gt;EndMarkdownToken&lt;/code&gt; that was documented and set all the right fields.  I was able to
make sure that the &lt;code&gt;start_markdown_token&lt;/code&gt; field was set.  As it had not been
set consistently, there were places in the code base where I had to do work arounds to
try
and figure out where the start token for a given end token was.  This was just cleaner.&lt;/p&gt;
&lt;h3 id="simple-refactorings"&gt;Simple Refactorings&lt;a class="headerlink" href="#simple-refactorings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Two of the paradigms that have served me well in my years of software development are
&lt;a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"&gt;D.R.Y.&lt;/a&gt; and
&lt;a href="https://en.wikipedia.org/wiki/SOLID"&gt;S.O.L.I.D&lt;/a&gt;. The ‘L” in S.O.L.I.D. stands for the
&lt;a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"&gt;Liskov substitution principle&lt;/a&gt;,
which (in its abbreviated form) states that an object should be able to be replaced
with another object that adheres to the same contract without any parent objects being
aware of the change.&lt;/p&gt;
&lt;p&gt;With respect to the PyMarkdown project, I had been using the &lt;code&gt;isinstance&lt;/code&gt; built-in
to deal with things instead of following the principle.  However, with the recent
round of refactorings completed, I was able to fix that.  While it may not seem like
much, it made me feel better to change:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AtxHeadingMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;into a more SOLID-like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_atx_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While I know that there is only one implementation of the &lt;code&gt;AtxHeadingMarkdownToken&lt;/code&gt;
class, I was just not comfortable with having calls of &lt;code&gt;isinstance&lt;/code&gt; scattered throughout
the code base.  Over two commits, I was able to eliminate all uses of &lt;code&gt;isinstance&lt;/code&gt; except
for six legitimate uses of it in pivotal parts of the code base.&lt;/p&gt;
&lt;p&gt;As with the other changes, this change was a simple change, but an effective one.  With all
the checks for various tokens using a single manner of access, it was now easier to scan
the code base for locations where a given token was referenced.  That, and to me, it just
looked neater.&lt;/p&gt;
&lt;h3 id="cleaning-up-the-leaf-block-tokens-and-endmarkdowntoken"&gt;Cleaning Up The Leaf Block Tokens and EndMarkdownToken&lt;a class="headerlink" href="#cleaning-up-the-leaf-block-tokens-and-endmarkdowntoken" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;All those changes inspired me, and I gave myself the green light to further encapsulate the
private fields as Python private fields.  It was not even remotely exciting, but it was
something I knew would make the code cleaner and more maintainable.  Using this
stripped-down example of the &lt;code&gt;EndMarkdownToken&lt;/code&gt;, this is where all the tokens started:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;type_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;type_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For each of the Leaf Block tokens, I then started by adding the two underscores to the
start of the field name, per Python requirements.  But as that made the field “invisible”
to other objects, I then needed to add a new function with the &lt;code&gt;property&lt;/code&gt; decorator to
be able to retrieve the value.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;type_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__type_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;type_name&lt;/span&gt;

    &lt;span class="nd"&gt;@property&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;type_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__type_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lather, rinse, repeat.  Nothing special or exciting, which was what I was going for.  There
were no weird cases with these tokens that required a special setter function, so no
workarounds were needed.  And because the previously public field name and the newly added
property name had the exact same name, so changes were needed in other parts of the code.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I really cannot lie on this one.  While it was good to resolve some items off the
issues list, it was really good to get these refactorings done.  I have had those
ideas on how to clean up the project in my mind for weeks, and just getting them
done gave me a bit of an extra pep in my step.  It is not that they were any more
or less important than the other items, it is just that their large scope meant it
was going to be hard to fit them in.  As such, they always went into the “if I
ever have some time” bucket… and never seen again.&lt;/p&gt;
&lt;p&gt;I honestly think that taking the time to focus on what was important to me with
this project was good for me and the project.  It helped me refocus on the things
that I find important.  It helped the project by being able to present a more
concise and readable code base to any interested parties.  In all, it was a win-win.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a week left of holidays, I had hoped to get a similar mix of items dealt with
in the next week as I had the week before. Stay tuned!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:tokens"&gt;
&lt;p&gt;The exceptions as the &lt;code&gt;rehydrate_index&lt;/code&gt; field for Paragraph tokens, the &lt;code&gt;leading_spaces_index&lt;/code&gt; field for List Block tokens, and the &lt;code&gt;leading_text_index&lt;/code&gt; field for Block Quote tokens. &lt;a class="footnote-backref" href="#fnref:tokens" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:protected"&gt;
&lt;p&gt;Python does not have a protected field specifically.  The common practice of naming fields to be used in a protected-like manner is to preface them with a single &lt;code&gt;_&lt;/code&gt;. &lt;a class="footnote-backref" href="#fnref:protected" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 14</title><link href="https://jackdewinter.github.io/2020/12/28/markdown-linter-delving-into-the-issues-14/" rel="alternate"></link><published>2020-12-28T00:00:00-08:00</published><updated>2020-12-28T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-12-28:/2020/12/28/markdown-linter-delving-into-the-issues-14/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/21/markdown-linter-delving-into-the-issues-13/"&gt;last article&lt;/a&gt;,
I started the transition to working on Block Quote issues.  Having made good progress
with those issues, this week I continued with those issues, sometimes blurring the
line between Block Quote issues and Block Quote/List Block interactions.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now firmly in the mode of …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/21/markdown-linter-delving-into-the-issues-13/"&gt;last article&lt;/a&gt;,
I started the transition to working on Block Quote issues.  Having made good progress
with those issues, this week I continued with those issues, sometimes blurring the
line between Block Quote issues and Block Quote/List Block interactions.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now firmly in the mode of dealing with Block Quote block issues, I was looking forward
to making more progress in this area.  With each week that passed, I was becoming
more aware of how close I was to be able to at least do an initial release of the
project.  Block Quotes, and possibly Block Quote/List Block interactions are
the last big thing that I need to do before taking that leap, so I just needed to
buckle down and work through those issues, wherever they would lead.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/b5482d50d053d38a5635c07ba7455e9aaedf1fcb"&gt;16 Dec 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/04b9be38529fc8d75a81401aa63002b61b21c741"&gt;20 Dec 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="fixing-things-up-before-proceeding"&gt;Fixing Things Up Before Proceeding&lt;a class="headerlink" href="#fixing-things-up-before-proceeding" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before I started doing a lot of work for the week, I decided I needed to get one of
the disabled functions working: &lt;code&gt;test_list_items_282&lt;/code&gt;. While it was not a tremendously
important issue, it was one that I had put off for a while, and I just wanted it out of
the way.  Following the GFM Specification exactly, it can be argued that the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;should either be parsed as a list with 2 items or two lists.  The crux of the issue
is whether the third line is considered a continuation of the second line or
if it is an entirely separate list.  Basically, it all comes down to how your parser
implements paragraphs and paragraph continuations.&lt;/p&gt;
&lt;p&gt;Luckily, one of the primary authors of the specification (@jgm) chimed in with this
following bit of information:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The intent was to have language that applies to the starting of list items in the middle of a paragraph that isn’t a direct child of a list item at the same level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While some of the other help was not as useful, that one sentence was.  I did agree
with the other author that Paragraph elements in Markdown are the default element,
however I was not as sure that his interpretation of paragraph continuations was
correct. But this information helped me out a lot.  Using that information, I was able
to quickly put together these lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;is_sub_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indent_level&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Following the suggestion of @jgm, I changed the exclusion code at the end of the
&lt;code&gt;is_olist_start&lt;/code&gt; function to include a reference to &lt;code&gt;is_sub_list&lt;/code&gt;.  Following my
usual process, I was quick to find that everything just fell into place, and the
test was passing.  But I was not confident that I had properly fixed the issue,
so I created four variants of the test data, each just a little different from each
other.  It was only when all five tests had passed that I considered the issue resolved
and dealt with.&lt;/p&gt;
&lt;h2 id="an-easy-set-of-tests"&gt;An Easy Set of Tests&lt;a class="headerlink" href="#an-easy-set-of-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Some of these items take days to complete and some take hours.  Until I start working
on them, I never know which bucket they will end up in.  Therefore, when I started
working on this item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;634&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;bq&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I had no clue what was going to happen.  Starting with the basics, I looked at the
Markdown for function &lt;code&gt;test_raw_html_634&lt;/code&gt; which was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;  &lt;span class="o"&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;b2&lt;/span&gt;
&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="ss"&gt;"foo"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the start of the Markdown does not have a single HTML tag, or a HTML tag from one
of the special groups, an HTML block is ruled out.  But when the processing happens
for a Paragraph element, the inside of that paragraph is then filled with Raw HTML
elements, only slightly altering the Markdown when rendered as HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;  &lt;span class="p"&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;b2&lt;/span&gt;
&lt;span class="na"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the item suggests, placing that same Markdown inside of a List Block or a Block Quote
should result in the same behavior, just inside of that block.  Crossing my fingers for
good luck, I created two variants of that Markdown: one that was prefixed with &lt;code&gt;-&lt;/code&gt; and
the other that was prefixed with &lt;code&gt;&amp;gt;&lt;/code&gt;.  Things flowed quickly through my usual process
and I was happy to find that these scenarios both worked without any additional changes
being needed.&lt;/p&gt;
&lt;h2 id="more-fun-with-block-quotes"&gt;More Fun with Block Quotes&lt;a class="headerlink" href="#more-fun-with-block-quotes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With good luck occurring for my last item, I hoped it would carry on to my next item.
So, when I looked for more work to round out the Block Quotes tests, I came across the
following group of items in the issues list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;different&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;following&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;following&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="n"&gt;levels&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="n"&gt;quotes&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;indented&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;blocks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rather than tackling them separately, I decided to tackle them together as a group.&lt;/p&gt;
&lt;p&gt;The first part of that work was making the requested variations on the data for test
function &lt;code&gt;test_list_items_300&lt;/code&gt;.  That data was somewhat simple, with the Markdown text
of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To address the first item, I added test function &lt;code&gt;test_list_items_300a&lt;/code&gt; that included an
Ordered List element after the Block Quote element, instead of an Unordered List
element.  Test function &lt;code&gt;test_list_items_300b&lt;/code&gt; addressed the second item by keeping that
List Item element as an Unordered List element but adding 2 space characters before it
to make it a sublist.&lt;/p&gt;
&lt;p&gt;Similarly, test function &lt;code&gt;test_list_items_301&lt;/code&gt; has a Markdown text of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
  &lt;span class="k"&gt;c&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The new variation of this Markdown in test function &lt;code&gt;test_list_items_301a&lt;/code&gt; was to change
the second line to start two Block Quote elements instead of one. Test function
&lt;code&gt;test_list_items_301b&lt;/code&gt; modified the test data slightly by indenting each line of the
Fenced Code Block element by one space.  Test function &lt;code&gt;test_list_items_301c&lt;/code&gt; did a more
drastic change by replacing the Fenced Code Block element with the single character &lt;code&gt;c&lt;/code&gt;
indented from the start of the Block Quote element.  Finally, the &lt;code&gt;test_list_items_301d&lt;/code&gt;
function did a more correct version of test function &lt;code&gt;test_list_items_301c&lt;/code&gt; by including
a blank line and a &lt;code&gt;c&lt;/code&gt; character indented by four spaces, but properly enclosing them
within the Block Quote started on line 2.&lt;/p&gt;
&lt;p&gt;With those changes made, it was time to get down to figuring out if there were any
problems and dealing with them!&lt;/p&gt;
&lt;h3 id="working-the-problem"&gt;Working The Problem&lt;a class="headerlink" href="#working-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting with my normal process for working through new test functions, I worked
through the tokens and HTML for each of these functions.  Apart from
the functions &lt;code&gt;test_list_items_301b&lt;/code&gt; and &lt;code&gt;test_list_items_301c&lt;/code&gt;, the other tests
were producing the tokens that I expected them to.  After trying to get those two
functions working properly for an hour or so, I decided to put them on hold while I got
the other functions cleared up.&lt;/p&gt;
&lt;p&gt;Focusing on those other test functions, the HTML output was mostly there, but required
a small amount of fiddling.  Specifically, tests in which there was a Blank Line element
within a Block Quote element within a List Block element, the Blank Line within the
Block Quote was being used to determine whether the list was loose.  As that
Blank Line was within another Block and not within the List Block itself, it should not
have been affecting the calculation of List Block looseness. Luckily, the fix for this
was to add nine lines of code to the &lt;code&gt;__calculate_list_looseness&lt;/code&gt; function to properly
increase and decrease the &lt;code&gt;stack_count&lt;/code&gt; variable to account for the Block Quote token.&lt;/p&gt;
&lt;p&gt;With the tokens and HTML output deal with, it was time to deal with the rehydrated
Markdown and the consistency checks.  The fix to the Markdown was an easy one to
see: the whitespace allocated to the Block Quote tokens was not being added back into
the Markdown text that was generated.  Some easy changes to incorporate that information
was almost as easy to add, leaving the consistency checks.&lt;/p&gt;
&lt;p&gt;While the consistency checks took a bit, in retrospect they were somewhat easy to
understand and fix.  At the time though, it took a bit of effort to work through them.
Like the changes in the Markdown generator, changes needed to be introduced to
properly track which part of the Block Quote’s extracted whitespace was applied in the
Markdown generator.  That tracking is done using the Block Quote token’s
&lt;code&gt;leading_text_index&lt;/code&gt; variable, which was not being properly incremented to track the
newlines used within the owning Block Quote token.&lt;/p&gt;
&lt;p&gt;Once that change was done, things were looking a lot better, but there was a single
case where there was an index error getting that whitespace out of the token.  Upon
debugging, it was obvious that the &lt;code&gt;leading_text_index&lt;/code&gt; variable was getting incremented
twice.  Fixing that took a bit of passing information around but was quickly taken
care of.  And with that fix in place, each of the tests that I was working on was
solved and passing properly.&lt;/p&gt;
&lt;h3 id="not-everything-was-solved"&gt;Not Everything Was Solved&lt;a class="headerlink" href="#not-everything-was-solved" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the other tests passing cleanly, I refocused my efforts on test functions
&lt;code&gt;test_list_items_301b&lt;/code&gt; and &lt;code&gt;test_list_items_301c&lt;/code&gt;.  Doing my usual research into the
issues, I started to figure out what the tokens generating by the parser should be,
comparing that answer with what was being generated.  It was then that I
noticed that the tokens for the tests were close to normal, but not correct.  In both
test functions, the tokens mostly differed in where the one element stopped and the
next one started.&lt;/p&gt;
&lt;p&gt;Now, when I say, “I fiddled with the code”, I really mean I tried normal paths and
interesting paths to try and solve the issue.  And it was similar with these issues.
After around two hours of fiddling, I was no closer to having a solution than when
I first looking at the problem.
In the end, after doing a fair amount of research and debugging, I decided that I was
going to commit the code with functions &lt;code&gt;test_list_items_301b&lt;/code&gt; and
&lt;code&gt;test_list_items_301c&lt;/code&gt; disabled.  I just was not getting the right “angle” on solving
those issues.  I just felt it would be better to commit what I had and work on those
two functions in the next couple of days, so that is what I did!&lt;/p&gt;
&lt;h2 id="dealing-with-301b"&gt;Dealing With 301B&lt;a class="headerlink" href="#dealing-with-301b" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During that Saturday, I decided to take another shot at test function
&lt;code&gt;test_list_items_301b&lt;/code&gt;.  I knew the the tokens were just wrong.  To quantify that
wrongness, the Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
   &lt;span class="o"&gt;```&lt;/span&gt;
   &lt;span class="k"&gt;c&lt;/span&gt;
   &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was produced a Block Quote element that tried to include an empty Fenced Code Block
element into the Block Quote, leaving the &lt;code&gt;c&lt;/code&gt; character by itself on
a line outside of the element, followed by another empty Fenced Control Block.  From
prior work on List Blocks, I knew that the Fenced Code Block should terminate the
Block Quote element, as Block Quotes follow similar roads.  It was just a matter of
figuring out how to get there.&lt;/p&gt;
&lt;p&gt;Knowing that I have had tried to solve this problem the day before, I decided to take
the hard-line approach of debugging line-by-line through some of the code.  I don’t
usually do this as it is very time consuming and requires meticulous notes.  While I
am comfortable with doing that work, there are just more efficient ways of getting to
the same target.  But with those ways not working for this problem, it was down to
the nitty-gritty.&lt;/p&gt;
&lt;p&gt;It was a good thing that I used this approach because it told me something interesting.
Usually, at the start of processing, the code separates the line into extracted
whitespace and parseable line.  In this case, the debugger was showing me that the
separation that I had expected was not done.  As such, when the parser looked at the
raw data for the line, the spaces at the start of the line prevented that line from
being recognized as the start of a Fenced Code Block.&lt;/p&gt;
&lt;p&gt;The good news here was that adding these four lines to the &lt;code&gt;__process_lazy_lines&lt;/code&gt;
function made everything work:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;after_ws_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ex_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extract_whitespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;remaining_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;after_ws_index&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, I just took the same code that split the original &lt;code&gt;line_to_parse&lt;/code&gt; variable
in the main-line processor and added it here.  With that code in place, the
&lt;code&gt;is_fenced_code_block&lt;/code&gt; function did the rest, properly noticing the Fenced Code Block
start sequence, and properly starting the code block within the Block Quote.&lt;/p&gt;
&lt;h2 id="dealing-with-301c"&gt;Dealing With 301C&lt;a class="headerlink" href="#dealing-with-301c" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It was just after 6pm PST when I committed the changes for &lt;code&gt;test_list_items_301b&lt;/code&gt;, and
I decided to start working on &lt;code&gt;test_list_items_301c&lt;/code&gt;.  In this case, it was not the
tokens that were wrong, but the spacing included from one of the lines within a
Block Quote element.  Doing research into the night, I still was unable to figure out
what the magic sequence was to get this working properly.  Rather than press on, I
decided to take a break and spend some time with my family, relaxing myself and my
brain.&lt;/p&gt;
&lt;p&gt;This worked well.  Starting again in the morning, I was able to quickly see that there
were two problems that I needed to address.  The first of those problems was that
the function &lt;code&gt;__adjust_paragraph_for_block_quotes&lt;/code&gt; was always adding an empty string
to the Block Quote token, which was the problem I was trying to solve.  The second
problem was that it was a great solution for most of the time, this specific test being
one of the few times where it was not.&lt;/p&gt;
&lt;p&gt;With that fresh information, I started experimenting and I was able to isolate code in
the &lt;code&gt;parse_line_for_container_blocks&lt;/code&gt; function that affected the outcome of the test.
The fun part was that if I took the indentation used for the list and added it to the
token’s data, test &lt;code&gt;test_list_items_301c&lt;/code&gt; worked, but other tests failed.  Doing some
extra plumbing and experimentation, I narrowed the active scenario down to specifically
only trigger when the &lt;code&gt;parse_line_for_container_blocks&lt;/code&gt; function was triggered within
a paragraph that was within a block quote. [more]&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having felt dread at the prospect of Block Quotes taking as long to complete as
List blocks did, I am happy to report that the feeling is quickly fading.  The
sense I am getting from the issues I am looking at are that there are issues to
deal with, but nothing I have not dealt with already, just variations on it.
On top of that, there are only one type of Block Quotes to worry about with a
very simple start sequence.  I was very solidly feeling that Block Quotes were
going to be a lot easier than List blocks.&lt;/p&gt;
&lt;p&gt;That did not mean things were going to be easy though!  I was starting to come close to
the end of the initial set of issues that I had added to the issues list, but I was
adding more as I looked through the code.  This week, I was able to get rid of
a handful of those issues, and it felt good.  But with approximately 70 lines of
items before hitting those that dealt with Rules, Tabs, and Correctness, it was
a sobering reminder that I just needed to get stuff done and done cleanly.&lt;/p&gt;
&lt;p&gt;And for me, that often poses a problem.  There are things that I want to do and feel
that I should be doing, and there are things that I need to do.  Resolving any issue
that deals with Tab characters?  Now that is a want, and I can live with a
“stupid” translation of Tabs until I can get the time to make them right.  Resolving
any issues that might uncover scenarios that I have not covered yet.  To the best of
my abilities, that is a must.  But there is a grey area between those two.&lt;/p&gt;
&lt;p&gt;Take the item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="n"&gt;handling&lt;/span&gt; &lt;span class="n"&gt;confusing&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;standard&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I would like to get it resolved, but I am not sure that I need to do that.  I must
balance my desire for wanting things done right and delaying any release with my
knowledge that I can live with it for a couple of months while I get the project out.
And those are the types of decisions that I am going to have to make more and more as
this project gets to its closing stages.  Do I really need it, or can it wait?&lt;/p&gt;
&lt;p&gt;At least I know it is going to be fun!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I was just as happy to get some holiday time off in which I could spend more time
with my family as I was to be able to make some solid holiday progress.  This next
week was going to be a good mixture of resolving solid issues, test cleanup, and
code cleanup.  Stay tuned!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 13</title><link href="https://jackdewinter.github.io/2020/12/21/markdown-linter-delving-into-the-issues-13/" rel="alternate"></link><published>2020-12-21T00:00:00-08:00</published><updated>2020-12-21T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-12-21:/2020/12/21/markdown-linter-delving-into-the-issues-13/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/14/markdown-linter-delving-into-the-issues-12/"&gt;last article&lt;/a&gt;,
I worked diligently to resolve all the tests that I had marked as disabled in the
previous week.  After cleaning up those issues, I finished cleaning up the remaining
List Block issues before getting back up to speed on Block Quote issues.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/14/markdown-linter-delving-into-the-issues-12/"&gt;last article&lt;/a&gt;,
I worked diligently to resolve all the tests that I had marked as disabled in the
previous week.  After cleaning up those issues, I finished cleaning up the remaining
List Block issues before getting back up to speed on Block Quote issues.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a week of digging deep to resolve the disabled tests, I checked the issues
list.  With only a handful of items left in the List Blocks section, I figured it was a
good time to make a push to finish with the List Blocks and start with the Block Quotes.&lt;/p&gt;
&lt;p&gt;Knowing that I was about to do that transition made me happy and filled me with dread
at the same
time.  It made me happy as I was more aware of how close I was getting to the end of the
first phase of the project.  It also filled me with a sense of dread because I had not
done any serious work with Block Quotes in a while.  As such, I am not sure if the
effort to get the Block Quotes to the same level as List Blocks will be the same.  I
hope it is significantly less, but we will see.&lt;/p&gt;
&lt;p&gt;If I think about it, I believe that
sense of dread is from not knowing how long it will take to address any issues that
arise.
I do know, that unless I finish up the List Blocks and start the Block Quotes, that
feeling will be stuck at dread.  So, time to buckle down and get stuff done!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/09682fe55c9e7962f18341be3212d3712b6888e8"&gt;10 Dec 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/6db64e26af671e757156652ddcc457595542bc84"&gt;13 Dec 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="closing-out-list-blocks"&gt;Closing Out List Blocks&lt;a class="headerlink" href="#closing-out-list-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having finished cleaning up the disabled scenario tests, there were a few items on the
issues list that I needed to get out of the way.  While not high-profile items,
those items were standing between myself and a list with no list block related items
on it.  That was motivation enough to put these items at the top of my list.&lt;/p&gt;
&lt;h3 id="adding-variations-of-existing-patterns"&gt;Adding Variations of Existing Patterns&lt;a class="headerlink" href="#adding-variations-of-existing-patterns" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;During the previous three weeks, I had taken the Series M scenario tests and
filled them out a lot.  As I filled them out, I did find parsing and transformation
issues, all which got fixed.  But in creating that series, I needed to take some
alternate path to properly exercise the specific patterns that I was trying to make sure
were covered by the tests.  In doing so, I often veered away from the correct variation
to faithfully create the right pattern in the group of scenario tests that I was
working on.&lt;/p&gt;
&lt;p&gt;Confused?  Hopefully, a concrete example will explain.  I started going through the
tests in each group, starting with Fenced Code Blocks and the scenario test function
&lt;code&gt;test_paragraph_series_m_ol_nl_fb&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The purpose of that specific test was to make sure that a Fenced Code Block following an
empty Order List start element was parsed properly.  However, from my point of view,
there was another variation of that test that was possible.  Creating the new scenario
test function &lt;code&gt;test_paragraph_series_m_ol_nl_all_i3_fb&lt;/code&gt;, I altered the Markdown
slightly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
   &lt;span class="o"&gt;```&lt;/span&gt;
   &lt;span class="n"&gt;foo&lt;/span&gt;
   &lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Technically that was not a big change, but it was a significant one to me.  Instead of
testing
a variation where the Fenced Code Block terminates the List Block, it instead tests
the inclusion of that Fenced Code Block into the List Block. I consider that
the most correct form of that test.  At its base, that reason
for that classification is that if I said I wanted “an empty list with a fenced code
block”, that is what I would expect.  Nothing more, nothing less, just a simple example
that had that Markdown in its simplest form.&lt;/p&gt;
&lt;p&gt;I could have repeated that exercise with a lot of the scenario tests, but I
stayed with four tests from each group: two tests with a single list and two tests with
a sublist.  Starting with Fenced Control Blocks, I then proceded to HTML Blocks,
Indented Code Blocks, and SetExt Headings.  I hoped that the new scenario tests were
covering old scenarios, but I was not 100% confident that they were.  But as I executed
those tests, one by one I was convinced they were old scenarios, just being covered by
the Series M tests as a group.  Not one of the scenario tests failed!  After my
usual process of adopting the scenario tests, each test passed on its first try,
requiring no changes to the parser, the transformers, or the consistency checks.&lt;/p&gt;
&lt;p&gt;In the end, I was able to mark all these items from the issues list as resolved:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;variations&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nv"&gt;fenced&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;proper&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;actual&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;variations&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nv"&gt;html&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;proper&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;actual&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;variations&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;proper&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;actual&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;variations&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;ext&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;proper&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;actual&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="lazy-continuations-and-nested-list-blocks"&gt;Lazy Continuations and Nested List Blocks&lt;a class="headerlink" href="#lazy-continuations-and-nested-list-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Another easy issue to get off the list was this one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;levels&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;lists&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;lazy&lt;/span&gt; &lt;span class="n"&gt;continuation&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on the work I had just completed to round out the Series M tests, I had confidence
that these would also not require any changes.  It was a bit of an educated guess, but
I believe that
all I wanted to do here is to provide different levels of List Blocks, ensuring that
the principle of
&lt;a href="https://github.github.com/gfm/#lazy-continuation-line"&gt;lazy continuation lines in lists&lt;/a&gt;
was being adhered to.&lt;/p&gt;
&lt;p&gt;Starting with test function &lt;code&gt;test_list_blocks_extra_5a&lt;/code&gt;, I added the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
&lt;span class="n"&gt;def&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ensuring that text &lt;code&gt;def&lt;/code&gt; continued the paragraph started in the level 1 List Block.
Three tests later, the test function &lt;code&gt;test_list_blocks_extra_5d&lt;/code&gt; was testing the level 4
List Block with the Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
      &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
         &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
&lt;span class="n"&gt;def&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This was a simple set of scenarioes that passed right away, but I had expected them to.
However, with some of the issues that I have had with List Blocks and lazy continuation
lines, it was good to have some tests explicitly covering these cases.&lt;/p&gt;
&lt;h3 id="simple-cleanup"&gt;Simple Cleanup&lt;a class="headerlink" href="#simple-cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having done some rewriting of code lately, I was debugging and found a couple of lines
in the &lt;code&gt;__handle_blank_line&lt;/code&gt; function that were not being used anymore.  With the
breadth of scenario tests and summaries of the code coverage of those tests also in
place, it was easy to determine and test to make sure this code was no longer being
used.  With that observation verified, that code was removed.&lt;/p&gt;
&lt;h3 id="getting-clarity"&gt;Getting Clarity&lt;a class="headerlink" href="#getting-clarity" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For a while, I have been convinced that I coded something wrong, but have not been able
to prove whether it was correct or not correct.  The only thing that I was convinced
of was that I needed to deal with this at some point.  With this being the last
issue in the List Block section, it was time to deal with it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;blank&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;ending&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;parsed&lt;/span&gt; &lt;span class="nv"&gt;wrong&lt;/span&gt; &lt;span class="nv"&gt;into&lt;/span&gt; &lt;span class="nv"&gt;tokens&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;stack_count&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="sc"&gt;#9&lt;/span&gt;:[&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;ulist&lt;/span&gt;]
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;should&lt;/span&gt; &lt;span class="nv"&gt;be&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="nv"&gt;blank&lt;/span&gt;, &lt;span class="nv"&gt;as&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;blank&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;outside&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;233&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;235&lt;/span&gt;, &lt;span class="nv"&gt;should&lt;/span&gt; &lt;span class="nv"&gt;blank&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;tokens&lt;/span&gt; &lt;span class="nv"&gt;be&lt;/span&gt; &lt;span class="nv"&gt;reversed&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The prototypical example of this was test function &lt;code&gt;test_list_blocks_233&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;

 &lt;span class="n"&gt;two&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the HTML output for that Markdown was correct, I had questions about whether I
was emitting the following tokens in the correct order:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;"[ulist(1,1):-::2:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[para(1,3):]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,3):one:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para:::True]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[BLANK(2,1):]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-ulist:::True]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[para(3,2): ]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(3,2):two:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para:::True]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Specifically, my question was around the Blank token and the end Unordered List token.
Should the tokens be in Blank/Unordered order, or Unordered/Blank order?  Over the weeks
that I have looked at this case, I had never taken the time to sit down and work through
it.  As it was the last item for List Blocks in the Issue List, it was time.&lt;/p&gt;
&lt;h4 id="doing-the-dirty-work"&gt;Doing the Dirty Work&lt;a class="headerlink" href="#doing-the-dirty-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;This may appear to be an easy case to some people, but I had issues with it.  Thinking
about it at length, it felt that my understanding of this problem was influenced by
which part of the GFM
Specification I had last dealt with.  So, to deal with that influence head-on, I re-read
the parts of the specification dealing with List Blocks, Paragraph Blocks, Blank
Lines, and lazy continuation lines.  With that information in my head, I started to work
through the problem logically.&lt;/p&gt;
&lt;p&gt;Starting at the beginning, line 1 starts the tokens off with the first three tokens of
the document, leaving an
Unordered List item active and a Paragraph element open.  When the Blank Line element
in line 2 is encountered, it closes the Paragraph element but leaves the Unordered List
and Unordered List item open.  Therefore, the fourth and fifth tokens are generated and
added to the document.&lt;/p&gt;
&lt;p&gt;It was at this point in working the problem that the clarity surrounded this problem
crystalized and became clear in my mind.  I am not sure why, but I had wrongly believed
that the Blank Line
element on line 2 not only closed the Paragraph Block but closed the List Block and
List Block item as well.  The Markdown for
&lt;a href="https://github.github.com/gfm/#example-240"&gt;example 240&lt;/a&gt;
clearly shows this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;


  &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as the Markdown is trnslated into a single Unordered List Block with a single item
that contains two paragraphs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ul&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ul&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This meant that when line 3 is interpreted, the List Block and List Block item are
still open, but the previous Paragraph element was closed by the Blank Line.  As
such, line 3 is not eligible for consideration as a lazy continuation line.  With
that option removed, the single leading space character is not enough leading space
to keep line 3 in the List Block, so that block is closed, and a new Paragraph element
is opened with the contents of line 3.&lt;/p&gt;
&lt;p&gt;It took a bit of work and a straight head to work through, but I had my answer!  To
make sure I did not forget about it, I added a comment to function
&lt;code&gt;test_list_blocks_232&lt;/code&gt;
to make sure I can look back at it when I need to.  While this was not something that
required a code solution, knowing that this issue was finally (and definitively)
resolved brought a smile to my face!&lt;/p&gt;
&lt;h2 id="starting-with-block-quotes"&gt;Starting with Block Quotes&lt;a class="headerlink" href="#starting-with-block-quotes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With that last issue, all the specifically List Block related items were crossed off
the issues list.  It was now time to ease myself into work on Block Quotes and getting
them up to a comparable level as I had reached with List Blocks.&lt;/p&gt;
&lt;h3 id="starting-out-easy"&gt;Starting Out Easy&lt;a class="headerlink" href="#starting-out-easy" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I decided to start with an easy item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;# TODO add case with &amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the beginning, each of the scenario functions in the range &lt;code&gt;test_block_quotes_212&lt;/code&gt;
to &lt;code&gt;test_block_quotes_216&lt;/code&gt; were simple tests that showed how lazy continuation lines
work with Block Quote elements.  One of the observations that I made when adding those
tests was that, to properly test lazy continuation lines, the removed &lt;code&gt;&amp;gt;&lt;/code&gt;
character that makes the line “lazy” should be able to be inserted without changing
the HTML output.  Basically, according to the GFM Specification:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a string of lines Ls constitute a block quote with contents Bs, then the result of deleting the initial block quote marker from one or more lines in which the next non-whitespace character after the block quote marker is paragraph continuation text is a block quote with Bs as its content.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To properly test this, I created &lt;code&gt;a&lt;/code&gt; variant functions of each of those five scenario
tests, and in
each case I added a variation with the &lt;code&gt;&amp;gt;&lt;/code&gt; character at the start of the line.  As
I worked through the scenarios, all the variant tests were working fine except for
function &lt;code&gt;test_block_quotes_213a&lt;/code&gt;.  Looking at what made that test different, the
answer was obvious: it involved List Blocks.  Even after adding other variants of this
test, I was unable to get any of them working.&lt;/p&gt;
&lt;p&gt;I was not 100% sure it was the right thing to do, but in the name of progress, I
marked the test functions &lt;code&gt;test_block_quotes_213a&lt;/code&gt; to &lt;code&gt;test_block_quotes_213d&lt;/code&gt; as
disabled, knowing I would get back to them when testing Block Quotes and List Blocks
and how they interacted.&lt;/p&gt;
&lt;h3 id="three-quick-reviews"&gt;Three Quick Reviews&lt;a class="headerlink" href="#three-quick-reviews" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The next three items that I resolved were all easy issues to resolve.&lt;/p&gt;
&lt;p&gt;The first item was the removal of a piece of code that was no longer being used:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_in_paragraph&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;at_end_of_line&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;is_first_item_in_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;is_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next item was to remove the poorly worded item from the list and replace it with
one that specified the problem more clearly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;unify&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;separate&lt;/span&gt; &lt;span class="n"&gt;calculations&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="ss"&gt;`__pre_list`&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, the last item was just to review the existing tests and make sure that
agreed with their current state:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;228&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;229&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;what&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;proper&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;col&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;None of these were tough tasks to undertake, but they were all helping me to get back
up to speed on parsing Block Quotes.&lt;/p&gt;
&lt;h3 id="mixed-levels-of-block-quotes-and-serendipity"&gt;Mixed Levels of Block Quotes and Serendipity&lt;a class="headerlink" href="#mixed-levels-of-block-quotes-and-serendipity" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Going through the list looking for other easy items to resolve, this one caught my
attention:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;quotes&lt;/span&gt; &lt;span class="nv"&gt;that&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;stop&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;.&lt;span class="nv"&gt;e&lt;/span&gt;. &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span class="nv"&gt;etc&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To me, this looked like an easy issue to tackle.  The test function
&lt;code&gt;test_block_quotes_229&lt;/code&gt; was a good base to start with.  However, I felt there needed
to be a bit more data, so instead of three lines with varying numbers of Block Quote
start characters, I created test function &lt;code&gt;test_block_quotes_229a&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and test function &lt;code&gt;test_block_quotes_229b&lt;/code&gt; with the same content, just blank lines
between each of the original lines.  Basically, the first test would verify how the
different lines worked together, and the blank lines in the second test would verify
how each line worked isolated from any other lines.&lt;/p&gt;
&lt;h4 id="serendipity"&gt;Serendipity&lt;a class="headerlink" href="#serendipity" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Except for some moving code around to make sure it looked correct, only one real change
needed to be done to get the tests working.  It was an interesting thing to run into,
but it was also a lucky break for me.  If I had selected any other text for each line,
things would have worked fine, and I would be none the wiser.  However, with the given
content for each line, the parser thought that the number for each line was a possible
start for an Ordered List Block.  As such, it consumed the digit and then looked for
the &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;)&lt;/code&gt; character to follow it.  When the end of the line was encountered instead
of one of those characters, an &lt;code&gt;IndexError: string index out of range&lt;/code&gt; error was thrown.
While this was quickly fixed by only setting that variable if the start of the List
Block had been confirmed, it was a good issue to find!&lt;/p&gt;
&lt;h3 id="building-up-test-coverage"&gt;Building Up Test Coverage&lt;a class="headerlink" href="#building-up-test-coverage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;These issues were ones that I used to start the process of building up to the same
level of coverage for various Block Quote scenario groups as I had done with List
Blocks.  This effort was in response to the following issue list items:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;cov2&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;blank&lt;/span&gt; &lt;span class="nv"&gt;before&lt;/span&gt;, &lt;span class="nv"&gt;after&lt;/span&gt;, &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;both&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;html&lt;/span&gt; &lt;span class="nv"&gt;blocks&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;other&lt;/span&gt; &lt;span class="nv"&gt;blocks&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;cov2&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;multiple&lt;/span&gt; &lt;span class="nv"&gt;lines&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;, &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;html&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;all&lt;/span&gt; &lt;span class="nv"&gt;leaf&lt;/span&gt; &lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;all&lt;/span&gt; &lt;span class="nv"&gt;container&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To accomplish this, variations of Paragraph Blocks were added to function
&lt;code&gt;test_block_quotes_211&lt;/code&gt;, Thematic Breaks to function &lt;code&gt;test_block_quotes_212&lt;/code&gt;,
Indented Code Blocks to function &lt;code&gt;test_block_quotes_214&lt;/code&gt;, and Fenced Code Blocks to
function &lt;code&gt;test_block_quotes_215&lt;/code&gt;.  After adding 10 new scenario tests to address
these issues, I felt that this was a good start to addressing the issue of coverage
for Block Quotes.&lt;/p&gt;
&lt;p&gt;With all those changes completed, I followed my usual process of verifying each
scenario test.  Except for one issue with the Markdown transformer, the tests all
passed without incident.  That one issue was that the Markdown rehydration for
test function &lt;code&gt;test_block_quotes_214d&lt;/code&gt; included an extra &lt;code&gt;\x03&lt;/code&gt; character in the
output.  As I have mentioned in
&lt;a href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/#moving-special-character-support"&gt;previous articles&lt;/a&gt;,
that character is a NOOP character, and is used to essentially place a “Blank” in
the tokens that can be removed if not needed.  In this case, that NOOP character was
added to the content of the Text token to indicate that a Blank Line was part of that
content.&lt;/p&gt;
&lt;p&gt;As that information was not needed for the translation back to Markdown, I eventually
added a call to the function &lt;code&gt;ParserHelper.resolve_noops_from_text&lt;/code&gt; at the end of the
&lt;code&gt;__perform_container_post_processing_lists&lt;/code&gt; function to remove that extra character.
While I knew that I needed to add a call to that function at some point in the
processing chain, it took an hour or so of experimentation to find the right place
to insert that call at.  Until I found and tested that location, I found lots of
locations where test function &lt;code&gt;test_block_quotes_214d&lt;/code&gt; was passing, but other test
functions started failing.  It was frustrating, but I was able to work through all
that noise and find the right place, which was satisfying!&lt;/p&gt;
&lt;h3 id="sunday-morning-relaxing"&gt;Sunday Morning Relaxing&lt;a class="headerlink" href="#sunday-morning-relaxing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With a solid amount of work completed during the week, I found myself sitting in
front of my computer on another Sunday morning, wanting to get another issue resolved.
I do not want anyone thinking that I am workaholic, as I am not.  Sunday mornings in
our household are mostly for whatever personal projects we are working on.  As such,
I choose to get up early on Sundays and try and get a couple more issues resolved from
one of the projects that I am working on, before the family projects start taking
control of my day.&lt;/p&gt;
&lt;p&gt;Knowing that it was going to take a couple of hours, and having a couple of hours of
peace and quiet available, I started looking at the following item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;blank&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;bquote&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;compare&lt;/span&gt; &lt;span class="n"&gt;test_block_quotes_218&lt;/span&gt; &lt;span class="n"&gt;vs&lt;/span&gt; &lt;span class="n"&gt;test_blank_lines_197a&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;already&lt;/span&gt; &lt;span class="n"&gt;fixed&lt;/span&gt; &lt;span class="n"&gt;test_list_blocks_260&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;257&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it may not seem like much, the positioning and whitespace of those blank lines
are just slightly off.  Looking at this back at the end of June 2020, I noticed that
within containers, the column number for blank lines was off.  Specifically, given this
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(where the &lt;code&gt;\a&lt;/code&gt; character is a visual indicator for a space character), the token for
the blank line was being calculated as &lt;code&gt;[BLANK(2,5):]&lt;/code&gt;.  While that is one possible
answer to Blank Line token for that line, it has issues.  Specifically, because it is
within a List Block, the consistency checking had issues with that line because it
did not appear to have the correct indentation.&lt;/p&gt;
&lt;p&gt;After thinking about it, I eventually settled on the correct form of that token being
&lt;code&gt;[BLANK(2,2):   ]&lt;/code&gt;.  As the spaces were all that was on the line, I figured that it was
more correct to say that the column number was 2 followed by three space characters
than a column number of 3 followed by two space characters.  Influenced by
&lt;a href="https://github.github.com/gfm/#example-257"&gt;example 257&lt;/a&gt;,
I have confidence that I made the correct choice, backed up by the commit I made
on
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4b681751cae38ce2007f3b0ada6158ed9a15f353"&gt;28 Jun 2020&lt;/a&gt;
with that choice and the fallout from that choice.&lt;/p&gt;
&lt;p&gt;At that time, I was focusing on List Blocks, and I added the item into the issues
list to fix this for Block Quotes, and it was now time to fix that.  Unlike the
fixes required to resolve this for List Blocks, the fixes required to resolve this
for Block Quotes were relatively small.  The first part of that change was to
set the column number to the length of the text removed by the owning container
blocks.  This firmly set that column number to the first character after the
container processing, removing the determination of the column number from the
leaf block processing.  To balance that out, the calculation for
initial whitespace to allow for a Blank Line token within a Block Quote was set
to the amount of whitespace that was extracted.  Other than that, no other
changes were made.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned earlier, it was a relief to wrap up the verification of the List Blocks
and moving on to Block Quotes.  But with that transition, there was also a sense of
dread that I felt as I started on Block Quotes.  Would getting a solid amount of
coverage for Block Quotes take a couple of months as it had for List Blocks?  Would
it be more? Would it be less?  I just did not know.  I was hoping it would be less,
but that not knowing was just driving me nuts.&lt;/p&gt;
&lt;p&gt;But I also realized that the sense of dread would not disappear until I started doing
something about it.  Even by working on easy Block Quote items, I was getting a
clearer picture of the effort it will take to cover Block Quotes properly.  Instead of
a sense of dread, I believe I am at a place where I am confident that it will be less
than four months, and probably more than two weeks.  Not sure where in that range it
will land, but pretty confident it will be in there.&lt;/p&gt;
&lt;p&gt;And that is okay for now.  The important thing is that I did not let that dread knock
me down.  I took it, channeled it, and got some more information that helped me deal
with it.  Cool!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Still feeling a small amount of
dread, but mostly I am feeling optimism about the progress I am making!
As such, I expect to be working with Block Quotes for a while, possibly dipping into
dealing with Block Quotes and List Blocks every so often.  &lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Autism And How It Affects My View of Christmas</title><link href="https://jackdewinter.github.io/2020/12/20/autism-and-how-it-affects-my-view-of-christmas/" rel="alternate"></link><published>2020-12-20T00:00:00-08:00</published><updated>2020-12-20T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-12-20:/2020/12/20/autism-and-how-it-affects-my-view-of-christmas/</id><summary type="html">&lt;p&gt;Many people in my life have been very understanding, but as always, there are a decent
number of people that have left some lasting negative impacts.  Some of those people I
blame for their actions, and some of those people were just reacting to me and how
my Autism appeared …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Many people in my life have been very understanding, but as always, there are a decent
number of people that have left some lasting negative impacts.  Some of those people I
blame for their actions, and some of those people were just reacting to me and how
my Autism appeared to them.  But equally important to how I appeared to them was my
Autism and how it has affected my view of Christmas throughout my life.&lt;/p&gt;
&lt;p&gt;When I say that I was diagnosed with Autism in my 40s, that does not mean that I did not
have Autism before that.  It just means instead of &amp;ldquo;the weird guy with Autism&amp;rdquo;, I was
just the &amp;ldquo;the weird guy&amp;rdquo;.  And back when I was a kid, I definitely was &amp;ldquo;the weird kid&amp;rdquo;.
Contrary to the modern definition of Autism, the definition of Autism when I was a kid
was someone with below-average intellect who had severe problems interacting with the
world.  I did not have the benefit of any helpful labels and programs to help me
succeed, such as the help that my son was able to get throughout his childhood.  It was
just me trying to figure things out as I went, often feeling alone and alien, wanting
to fit in with my peers, but not knowing how to even start.&lt;/p&gt;
&lt;p&gt;That is where my negative view of Christmas started, based on a strong dislike of what
I perceived to be the over-commercialization of Christmas.  As I have been trying to
understand myself better over the years, it has been hard for me to disentangle two
aspects of this dislike from each other.&lt;/p&gt;
&lt;p&gt;The
original reason that I disliked Christmas was indeed a selfish one: our family did not
have enough growing up.  My mom is one of the most important people in my life, and
each year I saw her struggle throughout the year to make sure we had our basic
necessities and whatever other reasonable things she could get for us.  It pissed me
off that my father was almost never in the picture.  The thought of my mother having
to ask our local church or food bank for help and for presents, either made me feel
embarrassed and mad at the same time.  With the kind heart that I know my mother has,
I am pretty confident
that she felt like she should have been a better mother, even though that was not in
the cards. For me, even though my mom did everything for us out love for us,
Christmas was a time when I always felt more negative emotions that positive ones.&lt;/p&gt;
&lt;p&gt;And there is where the second aspect kicks in: my peers.  I remember the feeling of
dread that preceded going back to school after Christmas break.  Each year, I would go
back to school and everyone in the class
would be bragging about the wonderful things they got for Christmas.  While I tried to
pass off the things I got as equally wonderful, my lack of social skills meant that
I was unsuccessful, while my classmates would seemingly and convincingly go on and on
about the fantastic things that they got.  They all seemed to be bragging about how
wonderful their lives and families were, and it hurt.&lt;/p&gt;
&lt;p&gt;As that stuff was happening at school, there were also issues
I had with how my extended family dealt with Christmas.  I mean, at 11 years old, how
could I explain to them that the music of Tchaikovsky appealed to me because of his use
of harmony and melody?  I just knew that I liked it and could get lost in that music
for hours.  So, when my mother asked what I wanted for Christmas from my extended
family, I asked for a Tchaikovsky cassette tape.  It was simple, it would not cost too
much, and it was something that I would appreciate.  Sounds logical, right?&lt;/p&gt;
&lt;p&gt;I ended up asking for that single cassette tape of Tchaikovsky for three years
straight.
I would never dream of asking my mother for it, because she was having a hard enough
time making sure we were cared for.  But as a request for Christmas from my
extended family, I was sure it was an easy request to fulfil.  Not so.
The first year, one of my older cousins gave me a Bart Simpson poster and a dancing
beer can, because &amp;ldquo;they were sure that is what I meant to ask for&amp;rdquo;.  The second year I
did indeed get a cassette tape, but one with the works of Beethoven.  When I asked
about the cassette tape, I was asked &amp;ldquo;aren&amp;rsquo;t they the same?&amp;rdquo;.  The third year, a year
in which I remember one of my younger cousins being responsible for me in the gift
exchange, I finally received a cassette tape of some of Tchaikovsky&amp;rsquo;s symphonies.  I
did not find out who that cousin was, but I wish I did so I could have thanked them&amp;hellip; I
played that tape until it wore out.&lt;/p&gt;
&lt;p&gt;But those experiences left a bitter mark on my mind regarding Christmas.
Finding out more information about the gifts, I was able to figure out that the dancing
beer can was supposed to be a gag gift or a good joke.  The Beethoven tape? It was
bought two months before my mother gave them my Christmas list.  While it may not be
the right information to gleam from those events, my Autistic mind analyzed the facts
that I had gathered and came to a couple of conclusions.&lt;/p&gt;
&lt;p&gt;The first conclusion was that my extended family did not care about each other.  It was
about a good joke with the whole family there, or something that was bought at a sale
that they could pass off as good enough.  It was not about love or understanding, it
was about fulfilling a contract to present a gift.  The second conclusion was that even
though we were all good Catholics and went to mass in and around the holidays, most of
that was all for show.  One of the tenets that I learned growing up was:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do unto others as you would have them do unto you.&lt;/p&gt;
&lt;p&gt;Gospel of Luke, 6:31.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When my aunts and uncles asked each other for something for Christmas, I believe they
almost always received what they asked for.  How would they have felt if it took one
of their siblings three years to get it right?  I do not think they would have been
happy.  Furthermore, how would they have felt if they asked for something they really
did need, and instead got a joke gift and had everyone laughing at them.  How would
they feel then?&lt;/p&gt;
&lt;p&gt;To my recollection, none of my extended family asked me or my mother what was so
important about Tchaikovsky that I would ask for it over a toy.  I just know that it
was not until I was in my 30s that one of my younger cousins asked.  The reason? In a
life where my Autistic mind was going the speed of thought, listening to those melodies
and harmonies helped me find peace and calmness for a brief amount of time.  I could
lose myself in them and forget about how difficult that the world was for me to
process.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;As I grew older, I was able to start figuring out how these things impacted my life
and how it colored my view of Christmas.  My loving wife has asked me for the last
ten years why I do not share her love of Christmas, and it is only recently that I have
been able to sort out parts of it.  It has been difficult to try and pull on all these
threads to try and figure it out but undertaking that task has helped me find some
peace with the subject. From those old threads of my Christmas experiences, I was able
to gather some things that I would like to share.&lt;/p&gt;
&lt;p&gt;As the years have passed, I have heard little bits of information here and there from
my trips back home that lead me to believe that a lot of my classmates were not always
as lucky as I was.  It was with a lot of sadness that I found out what a lot of
those classmates had to go through their own versions of hell in their own lives.  For
quite a few of them, those Christmas presents that they received were the only symbols
of love that they received from their parents.
For others, they felt a constant need to prove that they were better than others because
their families never made them feel like they were good enough.  I could go on with
other things I have heard about classmates over the years, but the picture is pretty
much the same.  Every one of those people had different forces impacting them in their
lives, and often, enough of them were negative and colored their perceptions.&lt;/p&gt;
&lt;p&gt;Using the analytical part of my Autistic brain, I came to understand that
their bragging about Christmas gifts were mostly cries for help, not joyous refrains.
While I was upset with them growing up, regardless of their station in life I now hope
that each and every one of them finds peace in their own way. I came to the realization
that I was, and continue to be, lucky that I have always had a kind and caring mother
in my life. She has always been there for me and never left me feeling that having
only one parent in your life was not enough.  While it should be more common, it is not,
and that is sad.&lt;/p&gt;
&lt;p&gt;To that extent, I believe that Christmas should not be based on a calendar, but on a
state of mind.  We should
be helping people and making sure our children and each other are comfortable, loved,
and respected.  It should not be about making a special effort during Christmas to make
time for each other and be patient with each other, it should be a normal occurrence
in our daily lives.  I am not sure if this makes me seem naïve or if it just the way
that my Autistic mind works, but it is how I feel.  I do not care if it is kind
of mushy or idealistic.  Can anyone really argue with me that showing each other a
little more patience and respect would not be a positive thing in our chaotic world?&lt;/p&gt;
&lt;p&gt;Another observation is that people are quick to point to the physical gifts that they
received at Christmas, but do not always pay attention to the other gifts throughout
the year.  Even though we did not have enough growing up, I have the utmost confidence
that I would not have made it to where I am today without my mother&amp;rsquo;s unconditional
love.  While she knew I was different from a young age, I never felt like I was a
&amp;ldquo;weird kid&amp;rdquo; to her, just her oldest son, who needed love just as much as her other
two kids.&lt;/p&gt;
&lt;p&gt;Finally, different people experience things differently, and we must make
our own efforts to understand people on their turf, not ours.  As someone with Autism,
I should not be expected to offer to explain myself and my Autism to people.  But if
someone were to ask me a question about how I perceive things and how they can help, I
would definitely be open to that.  I would like to think that if my relatives had asked
me that question about Tchaikovsky and I answered honestly that they would either
respect myself or my mother and help me find that 45 minutes of peace located on a
well-worn cassette tape.  I know I would gladly offer that gift to someone.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Even after finding peace with the subject, I am not sure that a &amp;ldquo;love&amp;rdquo; of Christmas
is in the cards for me.  I do know that in my own life, either inspired by my mother&amp;rsquo;s
love or her teaching of &amp;ldquo;the Christmas spirit&amp;rdquo; to me, Christmas is just another day
to me as I simply try and apply those &amp;ldquo;Christmastime&amp;rdquo; principles to my life daily.  To
be honest, I have no clue on whether it is my Autism or my upbringing that
has got me to this place in my life, I just know that it is the path that I chose.  And
I feel good about that choice.&lt;/p&gt;
&lt;p&gt;I guess you could say that it is my gift to those around me.  My gift to myself?
Letting go of some of those negative Christmas experiences each year.  Allowing myself
to forgive those people and hope that they find peace with their own person daemons.
I am not a religious person by nature, but I do know that the many holy books, the
Bible included, have some great verses.  Here is one I try and live by:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A new commandment I give to you, that you love one another: just as I have loved you, you also are to love one another.&lt;/p&gt;
&lt;p&gt;Gospel of John, 13:34&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="Autism"></category><category term="Autism"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 12</title><link href="https://jackdewinter.github.io/2020/12/14/markdown-linter-delving-into-the-issues-12/" rel="alternate"></link><published>2020-12-14T00:00:00-08:00</published><updated>2020-12-14T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-12-14:/2020/12/14/markdown-linter-delving-into-the-issues-12/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/07/markdown-linter-delving-into-the-issues-11/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
worked hard to deal with the 33 scenario tests that I skipped in the last set of commits
due to time constraints.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Pure and simple, this week …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/12/07/markdown-linter-delving-into-the-issues-11/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
worked hard to deal with the 33 scenario tests that I skipped in the last set of commits
due to time constraints.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Pure and simple, this week was all about resolving the 33 scenario tests that I marked
as disabled from last week.  I was mostly confident at the time that the right decision
was to mark these tests as disabled and commit the changes I had already made.  The
question was whether I could fix this issues in five minutes, five hours, or five days.
If the answer was anything except five minutes, then disabling the tests was the right
thing to do.  Otherwise, it would not be the wrong thing to do, I would just feel
foolish that it could have been dealt with quickly instead of disabling the tests.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/b9b0e9707355c5e174e89588b4085eac912ada5f"&gt;03 Dec 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7137522b730ee7875020e495a39b45f9de2b2866"&gt;06 Dec 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="cleaning-up-from-last-week"&gt;Cleaning Up from Last Week&lt;a class="headerlink" href="#cleaning-up-from-last-week" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the end of the work that I covered in the last article, I marked 33 scenario test
functions as disabled.  While I felt comfortable in disabling them for a bit, I did
not feel comfortable leaving them disabled for too long.  It was time to tackle them and
get them resolved!&lt;/p&gt;
&lt;h3 id="starting-with-html-blocks"&gt;Starting with Html Blocks&lt;a class="headerlink" href="#starting-with-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I needed to start somewhere, and HTML Block elements just seemed like the best place
to start.  There was no real good reason to choose them other than, in my mind, they
were a simple block type.  The text in HTML Block is translated
to HTML with no changes or interpretation, and the start and the stop sequences for
HTML Block are very constrained, but also very simple.  It just seemed like the
simplest place to start for something that I was concerned about.  My concerns?
That solving the problems with all 33 failures were going to be a very difficult task
to accomplish.&lt;/p&gt;
&lt;p&gt;It was during my usual task of research though debugging that I was able to make a
quick breakthrough in diagnosing the problem.  As a lucky observation, I noticed that
when one of the Series M test functions was executed, the test’s Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1. 1.
&lt;span class="nt"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
foo
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resulted in an HTML Block element that started between the end of the sublist and
the end of the list.  When the end of that list occurred, it caused the HTML Block
element to be closed, leaving the last two lines to be interpreted as a Paragraph
containing the text &lt;code&gt;foo&lt;/code&gt; and a Raw HTML element of &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;.  By looking at the
Markdown text above, I believed that both lists should have been closed.  The
HTML Block start element should have closed both Ordered List blocks as the HTML
Block was not indented enough to keep either List block open.  But how was the code
interpreting that Markdown, that was the real question.&lt;/p&gt;
&lt;p&gt;Digging into the code a bit, adding extra debug as I went, I was able to soon figure
out that the parser was trying to close the list, but the right type of close was not
occurring.
As I dug into that code, I noticed that I had found a similar problem with the
Thematic Break element and list closures at some point in the past.  To solve the
problem with Thematic Breaks, I added Thematic Break specific code in the
&lt;code&gt;__check_for_list_closures&lt;/code&gt; function that properly closes the right amount of List
elements if a Thematic Break element occurred within a List element.  After going
through this code and the data from the scenario test’s log, I had a theory that
I had another instance where I needed to follow this pattern.&lt;/p&gt;
&lt;p&gt;To test that theory, I quickly changed the code in the &lt;code&gt;HtmlHelper&lt;/code&gt; class that
checks for the type of HTML block to break out the “is it a HTML start” code from the
“what kind of HTML start is it”.  By creating this new &lt;code&gt;is_html_block&lt;/code&gt; function,
it allowed me to change the &lt;code&gt;__check_for_list_closures&lt;/code&gt; function in the
&lt;code&gt;ListBlockProcessor&lt;/code&gt; class to calculate whether the current line was indeed the
start of a HTML Block, storing that value in the &lt;code&gt;is_html_block&lt;/code&gt; variable.
With that completed, I changed code that specified &lt;code&gt;is_theme_break&lt;/code&gt; as part
of two &lt;code&gt;if&lt;/code&gt; conditions to &lt;code&gt;is_theme_break or is_html_block&lt;/code&gt; and I was ready to go.&lt;/p&gt;
&lt;p&gt;Following my usual pattern of validation scenario tests, I was able to get the
new and changed tokens validated quickly, producing the HTML output that I
expected.  With no other changes, I was able to get all four disabled scenario
tests that dealt with HTML Blocks working again.&lt;/p&gt;
&lt;p&gt;With those four tests no longer being disabled, the total count of scenario tests
to fix was down 4 scenario tests from 33 to 29.  It was a good start, but I still
had a long way to go.  But with momentum on my side, I carried on!&lt;/p&gt;
&lt;h3 id="maintaining-the-momentum-with-fenced-code-blocks"&gt;Maintaining the Momentum with Fenced Code Blocks&lt;a class="headerlink" href="#maintaining-the-momentum-with-fenced-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I had a pattern that worked for one type of block, I decided to try that same pattern
out on the next type of blocks: Fenced Code Blocks. When I did that, I was
pleasantly surprised that following the same pattern led to the same results, with
one exception.  In this case, the “is this a Fenced Code Block start” function
already existed as &lt;code&gt;LeafBlockProcessor.is_fenced_code_block&lt;/code&gt;, so it was easy to
wire it into the &lt;code&gt;__check_for_list_closures&lt;/code&gt; function after assigning it to the
&lt;code&gt;is_fenced_block&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;The one exception was that there was a small failure in the rendering of the Fenced
Code Block tokens to HTML.
In cases where an empty Fenced Code Block element was present, any extra whitespace
in the Blank Line was being added to the HTML output after the newline character,
instead of just adding the newline character.  As this was the only failure, and
(at least to me) it was obvious that this was the issue, I was able to fix it
by adding the &lt;code&gt;exclusion_condition&lt;/code&gt; variable and keying off of that variable.  The
testing for that change happened almost as quickly as the coding did, and I was
able to resolve that group of four failing scenario tests.&lt;/p&gt;
&lt;p&gt;With another 4 tests that were no longer disabled, the disabled test count was now
down to 25.&lt;/p&gt;
&lt;h3 id="atx-headings-for-the-three-peat"&gt;Atx Headings for The Three-peat?&lt;a class="headerlink" href="#atx-headings-for-the-three-peat" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Deciding to work on Atx Headings next, I applied the same pattern and got a very good
result.  Other than that changes required to isolate the “is this an Atx Heading start”
code into its own function (and its inclusion into the &lt;code&gt;__check_for_list_closures&lt;/code&gt;
function), no other Atx Heading code required changes.  After validating and modifying
the tokens for the scenarios, all the tests just passed.  It was so weird to have
that happen, that I ran the scenario tests again just to be sure, and they were
indeed passing.&lt;/p&gt;
&lt;p&gt;To be clear, it was not that I was doubting myself, I just expected a lot more
difficulty in resolving these issues.  But, with a little bit of work, another 3 tests
were removed from the disabled list, bringing the disabled test count down to 22 tests.&lt;/p&gt;
&lt;h3 id="cleaning-up-the-html-indented-code-blocks"&gt;Cleaning Up The HTML: Indented Code Blocks&lt;a class="headerlink" href="#cleaning-up-the-html-indented-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After looking at the disabled tests dealing with Indented Code Block elements,
it was almost immediately obvious the same pattern would not work with these tests.
As far as I
could tell from my initial look, the problem was not with the tokens, but in
the determination of the looseness of the Lists.  In each of the failures, the
only difference was whether the items in the List blocks were surrounded
by HTML’s Paragraph tags or not.  The problem definitely had something to do with
looseness.&lt;/p&gt;
&lt;p&gt;The GFM Specification’s
&lt;a href="https://github.github.com/gfm/#loose"&gt;definition of looseness&lt;/a&gt; states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A list is loose if any of its constituent list items are separated by blank lines, or if any of its constituent list items directly contain two block-level elements with a blank line between them. Otherwise a list is tight. (The difference in HTML output is that paragraphs in a loose list are wrapped in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags, while paragraphs in a tight list are not.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And whether I liked it or not, the HTML output was just a &lt;em&gt;little&lt;/em&gt; bit off.  Not much,
but enough.  Specifically, it was cases in which the Blank Line token was appearing
right after an end List Block token, a case that I felt should not be marked as loose.&lt;/p&gt;
&lt;p&gt;Adding a lot of debug and scanning through the log files, I decided to take an approach
of removing the one set of cases that were producing bad results, rather than redesign
the &lt;code&gt;__calculate_list_looseness&lt;/code&gt; function from the ground up.  As far as I could tell,
everything else was working, just this one case was failing.  Therefore, I created the
new &lt;code&gt;__correct_for_me&lt;/code&gt; function where I looked for Blank Line tokens, looked for the
end List Block tokens directly before it.  At that point, being within the proper list,
the code was then able to make the right determination on the looseness of the list.&lt;/p&gt;
&lt;p&gt;Testing that theory took a while to code up, but the testing went by quickly.  It
was during that testing when I noticed that the whitespace in the Paragraph Block
tokens was off by one.  As the HTML output is checked before the Markdown rehydration
is checked, the issues with the HTML output prevented this issue from being seen.
However, due to the extensive logging I have in place, I was able to quickly deduce
that I had mixed up the passing of the &lt;code&gt;leading_space_length&lt;/code&gt; variable to the
&lt;code&gt;__adjust_line_for_list_in_process&lt;/code&gt; function with the &lt;code&gt;before_ws_length&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;After a quick fix and some retesting, everything was now working, and the count of
failing tests had fallen by another 2 tests down to 20 failing tests.&lt;/p&gt;
&lt;h3 id="the-long-slog-setext-headings"&gt;The Long Slog: SetExt Headings&lt;a class="headerlink" href="#the-long-slog-setext-headings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Working through the previous scenario tests, I was confident looking at the two
tests that deal with SetExt Heading elements that I would be able to deal with
them quickly.  If someone is right with their confidence on something like this, they
are told they are right.  If they are not right, they are usually told that they had
too much hubris.  That day, hubris was having a fun time laughing at me.&lt;/p&gt;
&lt;p&gt;As it was a Saturday, I was doing things around the house and getting them off our
house’s to-do list.  In between each of these tasks, I would sit down and work on trying
to figure out what the issue was with these tests and how to properly identify them.
I was fairly convinced that I needed to be able to detect the start of a SetExt Heading
element.  I was failing miserably on trying to figure out how to perform that
detection. I tried to be smart about the detection, and it failed.  I tried to be
simple about the detection, and that too failed.  And with each attempt, I was just
getting more frustrated.&lt;/p&gt;
&lt;p&gt;It was mainly as a joke that I decided to add &lt;code&gt;or True&lt;/code&gt; to the end of one of the
&lt;code&gt;if&lt;/code&gt; statements.  At the very most, I thought I might possibly find some information
related to the “detecting the start of a SetExt Heading” issue that I was working on.
I was flabbergasted when the scenario tests I was debugging just started working.&lt;/p&gt;
&lt;p&gt;In retrospect, it somewhat makes sense, though I want to dig into that function some
more in the future to verify it.  I believe that it worked because SetExt Heading
elements and Paragraph elements are related.  To get a SetExt Heading, you start with
a Paragraph element, and you transform it into the SetExt Heading element once the
SetExt Heading sequence is seen after that paragraph on its own line.  As such, I
didn’t need to add any extra processing above that of the Paragraph processing to
the first &lt;code&gt;if&lt;/code&gt; statement in the &lt;code&gt;__check_for_list_closures&lt;/code&gt; function, as the Paragraph
element processing was already sufficient.  &lt;/p&gt;
&lt;p&gt;In the case of the second &lt;code&gt;if&lt;/code&gt; statement, all the other types of Leaf Block element had
already been added, so adding &lt;code&gt;or True&lt;/code&gt; just included the one or two remaining types
of leaf blocks that had been missed.  As far as I can tell, it was nothing more than
a shortcut.&lt;/p&gt;
&lt;p&gt;Regardless of whether my guess is correct or not, the count was now down from 20
disabled scenario tests to 18 scenario tests… and these ones were going to take
some time to figure out.&lt;/p&gt;
&lt;h2 id="the-last-18"&gt;The Last 18&lt;a class="headerlink" href="#the-last-18" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I was then down to the last eighteen scenario tests that I needed to get working, and
I knew some serious work was going to be involved.  I had already been thinking about
this for a while, even going as far to contact the
&lt;a href="https://talk.commonmark.org/"&gt;CommonMark Discussion List&lt;/a&gt;
to help understand some of the thorny issues.&lt;/p&gt;
&lt;h3 id="understanding-the-scope-of-the-problem"&gt;Understanding the Scope Of The Problem&lt;a class="headerlink" href="#understanding-the-scope-of-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When all was said and done, these last
scenario tests were failing due to my lack of understanding and implementation of the
following section of the GFM specification:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exceptions:
1. When the first list item in a list interrupts a paragraph—that is, when it starts on a line that would otherwise count as paragraph continuation text—then
(a) the lines Ls must not begin with a blank line, and
(b) if the list item is ordered, the start number must be 1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It took me a bit to work through it, but here is how I think about it.  Take the
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first line clearly starts a list, but it also opens a paragraph block with the text
&lt;code&gt;abc&lt;/code&gt; in it.  Because of that open paragraph, the text in line 2 needs to be handled
carefully, as the previously noted exceptions come into play.  In this case, because of
section (a) of the exceptions, this Markdown will be interpreted as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc
1.&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If there is even 1 non-whitespace character on that second line after the list start
identifier, say the Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then that section of the exceptions is no longer in play, allowing the second line to
be a valid list start:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;a&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, the harder one for me to understand was section (b) of the exceptions.  The
impact of that exception is that while the above example works as I would expect, the
following Markdown did not:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
   &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;producing the following HTML&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc
2. a&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But why?&lt;/p&gt;
&lt;h3 id="everything-is-not-perfect"&gt;Everything Is Not Perfect&lt;a class="headerlink" href="#everything-is-not-perfect" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I could give many different examples of what is and is not a proper
translation, but the example from the discussion forum that sticks in my head a lot is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt; &lt;span class="n"&gt;risked&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt;
   &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;deadline&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;March&lt;/span&gt;
   &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;meeting&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="k"&gt;called&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;architect&lt;/span&gt; &lt;span class="n"&gt;would&lt;/span&gt; &lt;span class="n"&gt;take&lt;/span&gt; &lt;span class="n"&gt;flight&lt;/span&gt;
   &lt;span class="mi"&gt;457&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;It&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="n"&gt;eye&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;She&lt;/span&gt; &lt;span class="n"&gt;would&lt;/span&gt; &lt;span class="n"&gt;stay&lt;/span&gt; &lt;span class="k"&gt;at&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;Hilton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;room&lt;/span&gt;
   &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;It&lt;/span&gt; &lt;span class="n"&gt;had&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;ocean&lt;/span&gt; &lt;span class="k"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First off, this example is plainly an example based in the English language, and I
assumed that equally valid examples could be constructed for any language.  Given that
assumption, when I read that Markdown for the first item in the list, it is obvious to
me that the end of the first item in the list refers to &lt;code&gt;March 13.&lt;/code&gt;, not a sublist
starting at &lt;code&gt;13&lt;/code&gt; with the contents of &lt;code&gt;A meeting was called.&lt;/code&gt;.  The context of the rest
of the sentence leaves me with little doubt that the sentence was written that way.
And each of the other two list items left me with the same confidence.  Those numbers
were part of the sentences, and thus the paragraphs that the sentences were in, not
the starts of new lists.&lt;/p&gt;
&lt;p&gt;But how should the specification handle the codification of this?  The concepts of
“sentence context” and “looks right” do not apply to the specification.  For something
to apply to the specification, there needs to be a solid rule that can be followed
without fail.  In this case, the second exception comes into play:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(b) if the list item is ordered, the start number must be 1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While it is not perfect, this exception allows the specification to handle the above
cases in a way that it has a solid rule to follow, and hence predictable results. No
guesswork or “sentence context” involved.  I believe that &lt;code&gt;@jgm&lt;/code&gt; from the discussion
board put it best:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If we were inventing a light markup language from scratch, I’d want to require a blank line before a list or sublist (see Beyond Markdown), for this and many other reasons.&lt;/p&gt;
&lt;p&gt;But we’re not, so we need to find a compromise that works.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that indeed is a viable solution for starting sublists with any number as the
list’s start number.  Therefore, if you the previous example with a non-one sublist
start of &lt;code&gt;2.&lt;/code&gt; to be rendered properly, you need to add a newline:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;

   &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;producing the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;abc&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt; &lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"2"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;a&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As &lt;code&gt;@jgm&lt;/code&gt; said, and as I agree with, it is a solid compromise.&lt;/p&gt;
&lt;h3 id="attacking-the-problem"&gt;Attacking the Problem&lt;a class="headerlink" href="#attacking-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first thing that I did was to validate that this issue applied to both Ordered Lists
and Unordered Lists, which was quickly accomplished.  To me, this indicated that I was
going to be making near identical changes to the &lt;code&gt;is_olist_start&lt;/code&gt; function and the
&lt;code&gt;is_ulist_start&lt;/code&gt; function.  As the Order List changes were the most complicated, I
decided to start with those.&lt;/p&gt;
&lt;p&gt;The first part of detecting the condition described above was deciding that the current
line being parsed was already marked for a list start.  This was already being
performed in the function, so it was an easy change to do some extra processing if the
&lt;code&gt;is_start&lt;/code&gt; variable was set.  In that case, to narrow down the things that need to be
checked, the first two changes were to set the &lt;code&gt;is_in_paragraph&lt;/code&gt; variable to indicate
whether a paragraph block was open, and the &lt;code&gt;at_end_of_line&lt;/code&gt; variable to indicate
that there was no more data to process on the line (hence, a blank line).&lt;/p&gt;
&lt;p&gt;With those easy changes out of the way, the variable &lt;code&gt;is_first_item_in_list&lt;/code&gt; needed to
be set to indicate whether or not the proposed Ordered List start sequence actually
indicated a new List item or a brand-new List block.  While lengthy in its description,
the next part of
the algorithm checked, in order, to see if a parent List block contained the Paragraph
element, if it was the same type of List element, if it had the same List character,
and if the start index for the proposed List element was greater than that of a matching
List element already in progress.  If any one of those checks failed, the proposed List
start was stored as &lt;code&gt;True&lt;/code&gt; in the &lt;code&gt;is_first_item_in_list&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;From there, the check was relatively easy.  After an additional change to set the
&lt;code&gt;is_not_one&lt;/code&gt; variable to indicate whether the &lt;code&gt;olist_index_number&lt;/code&gt; variable was not
the string &lt;code&gt;1&lt;/code&gt;, the calculation was easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;is_in_paragraph&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;at_end_of_line&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_not_one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;is_first_item_in_list&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;is_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Following the exceptions detailed earlier, when a new list start occurs within an
ongoing paragraph (&lt;code&gt;is_first_item_in_list&lt;/code&gt; and &lt;code&gt;is_in_paragraph&lt;/code&gt;), a further check
is done to to see if the List element would begin with a blank line (&lt;code&gt;at_end_of_line&lt;/code&gt;)
or is an Order List start sequence where the start number is not &lt;code&gt;1&lt;/code&gt; (&lt;code&gt;is_not_one&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id="how-well-did-this-work"&gt;How Well Did This Work?&lt;a class="headerlink" href="#how-well-did-this-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The changes documented in the last section were the bulk of the work, and after that
the remaining changes were easy to figure out and work on.  With the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_theme_break&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_html_block&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_fenced_block&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;is_atx_heading&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resolving to True in all cases, I removed that line to make things clearer.  While
it makes a mess of any displayed differences, it really is only removing that line and
shifting all text text that was under that &lt;code&gt;if&lt;/code&gt; statement to the left by four spaces.
After running through some tests, there were some failures with the translation to
HTML.  Those failures were all fixed with two lines of code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newline_character&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;output_html&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newline_character&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that completed, all the scenarios were running except scenario test function
&lt;code&gt;test_list_items_282&lt;/code&gt;.  After working on that for a while, I marked that scenario test
as disabled, to research it and work on it later.  Along the way, I also added two
variations of test function &lt;code&gt;test_list_blocks_263&lt;/code&gt; to test specific cases that I thought
would be a problem, both working without any problems.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first thing that came to mind is that I did have an answer to my question from
the Introduction section.  It took me five days to resolve those disabled tests.  More
than anything else, that really cemented my feeling that I made the right decision in
committing that block of work I had from the previous week, with tests disabled.&lt;/p&gt;
&lt;p&gt;While I was still a bit tired after my sinus cold from the previous two weeks,
it felt good to get some real solid debugging work done and out of the way.  The
contrast between this one week’s work and the previous two week’s work was just
staggering.  It was a real good feeling to get back up to a speed that I know I
can easily achieve.&lt;/p&gt;
&lt;p&gt;And given that non-cold increase in momentum, along with the recent reduction of
items in the issues list, it was nice to see that the finish line is getting visibly
closer.  While I don’t want to jinx myself by setting a date, and then missing it,
I am guessing that I am going to be ready sometime in early 2021, and that is good with
me. Believe it or not, I am very much looking forward to it!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With some of the hard issues out of the way, I wanted to finish up all the List Block
issues and get started on the Block Quotes issues.  Here is hoping that I would be able
to do that!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 11</title><link href="https://jackdewinter.github.io/2020/12/07/markdown-linter-delving-into-the-issues-11/" rel="alternate"></link><published>2020-12-07T00:00:00-08:00</published><updated>2020-12-07T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-12-07:/2020/12/07/markdown-linter-delving-into-the-issues-11/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/30/markdown-linter-delving-into-the-issues-10/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I jokingly referred to this week as the week …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/30/markdown-linter-delving-into-the-issues-10/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I jokingly referred to this week as the week from hell.  It was hellish in
nature because of a bad cold that got into my sinuses and would not leave, no matter
what I tried to get rid of it.  As such, I felt that I got approximately half the work
done that I had wanted to.  Therefore, I felt that it was appropriate to talk about the
work done during the two-week period that I had the sinus cold instead of just my usual
one week period.  Even though my brain was fogging with the sinus cold for a good
solid two weeks, I was able to get some good work done, even if it was not at the
pace that I am used to having.&lt;/p&gt;
&lt;p&gt;The big focus at this point in the project was on reducing the number of items on the
issues list that dealt with List elements.  Having taken a significant amount of time
working on
the leaf block elements and getting those items resolved, I was hoping to get a good
chunk of the list issues dealt with.  But I also knew that the impending American
Thanksgiving holiday and a nasty sinus cold were going to slow me down.  It was just
a matter of being honest with myself about what I could accomplish during this period.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/57ba5d7777602b3d67cbea901cc289db539cf0d2"&gt;17 Nov 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/307bbc4ebf6b6f764a88731a1739a2ec895f5fbf"&gt;29 Nov 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="indented-code-blocks-and-list-blocks"&gt;Indented Code Blocks and List Blocks&lt;a class="headerlink" href="#indented-code-blocks-and-list-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Up to that point, I had a good variety of cases for each leaf block type in Markdown
save for one: Indented Code Blocks.  Hence, I had logged this issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt;, &lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;computing&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="nv"&gt;properly&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;empty&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;indented&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I gave a good solid first try at getting them working, but in my mind, Indented Code
Blocks were different enough that they posed additional difficulty.  As such, I left
them for last.  The example that gave me the trouble was an additional test that I
added, function &lt;code&gt;test_list_blocks_256i&lt;/code&gt; or function &lt;code&gt;test_list_blocks_256ix&lt;/code&gt; as I
renamed it.  The Markdown for the example was simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the list start indented to the maximum with three leading spaces, the indentation
of the text &lt;code&gt;foo&lt;/code&gt; should have been enough to make it eligible for an Indented Code Block
with four leading spaces.   Instead, it was just getting captured as part of the text
for the List Item element.&lt;/p&gt;
&lt;h3 id="working-through-it"&gt;Working Through It&lt;a class="headerlink" href="#working-through-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Granted, my cold was raging in my head, and I was not thinking clearly, but eventually I
looked at the tokens long enough and something stuck out at me.   The start List Block
token for line 1 was &lt;code&gt;[olist(1,3):.:1:3:  :   ]&lt;/code&gt; which did not look weird to me at
first.  Looking at the end of the token, where I usually look, everything was fine.
There were three leading spaces before the start List element, and there were three
spaces registered for that token.  Exactly as it should be!  And it was an start
Ordered List token with a single digit start number, so the &lt;code&gt;indent_level&lt;/code&gt; for that
list should be 3: 1 for the single digit, 1 for the list character &lt;code&gt;.&lt;/code&gt;, and one for the
whitespace after it.  Check!  &lt;/p&gt;
&lt;p&gt;Then it dawned on me.  While the three leading spaces were appearing in the token
itself, they were not being accounted for in the &lt;code&gt;indent_level&lt;/code&gt;.  As such, when the
parser got to the second line, the &lt;code&gt;indent_level&lt;/code&gt; was set to &lt;code&gt;3&lt;/code&gt;, and it looked like the
that line was only indented by one character, not enough to start an Indented Code
Block.  After making some changes to pass through the &lt;code&gt;extracted_whitespace&lt;/code&gt; variable
from the first line, the &lt;code&gt;indent_level&lt;/code&gt; was adjusted by the length of the
&lt;code&gt;extracted_whitespace&lt;/code&gt; variable, resulting in an &lt;code&gt;indent_level&lt;/code&gt; of 6.  As the four
leading spaces on the second line was less than that value, it was properly interpreted
as an Indented Code Block element.&lt;/p&gt;
&lt;p&gt;After adding some additional variations to test and make sure that the change was the
right change, I was happy to resolve this issue, and get some rest.&lt;/p&gt;
&lt;h2 id="the-birth-of-series-m"&gt;The Birth of Series M&lt;a class="headerlink" href="#the-birth-of-series-m" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having documented this process before for the other series, I will not take the time to
go through all the steps performed to move these scenario tests over.  I will point out
that for me, with a sinus cold that was not letting up, it was the perfect thing for me
to work on.  It was a lot of moving tests over two days, but it was slow, and it was
methodical.  More importantly, it had built in error checking.  A good thing to have
when you are not 100% sure of how clearly you are thinking.&lt;/p&gt;
&lt;p&gt;As this series was genuinely moving scenario tests over from their origin module
&lt;code&gt;test_markdown_list_blocks.py&lt;/code&gt;, I did not expect any issues and there were none.  Due
to some clarity in thinking when setting up this work, any errors that I did make during
that process were caught and recovered from right away.  Other than that, the entire
process was a blur.&lt;/p&gt;
&lt;h2 id="weird-list-contents"&gt;“Weird” List Contents&lt;a class="headerlink" href="#weird-list-contents" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Mostly due to the sinus cold, which was finally starting to ease up, it took me another
couple of days to get the next issue resolved.  Mentally, I realized that I could either
push myself hard and perhaps prolong the cold, or I could take more breaks and have that
energy go towards resolving the cold.  Whether it was the positive thinking or the
natural course of the cold, I will never be sure which one helped more.  But by noon on
Saturday, I was starting to feel better, and I started to tackle these issues:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;span&lt;/span&gt; &lt;span class="n"&gt;inside&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;multi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="n"&gt;inside&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first issue was easy.  I started with something simple, adding the function
&lt;code&gt;test_list_blocks_extra_2a&lt;/code&gt; to test split paragraphs with the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
&lt;span class="n"&gt;def&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;ghi&lt;/span&gt;
&lt;span class="n"&gt;jkl&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there, I made a small modification to test for Code Spans by using the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;`one`&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;``&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="ss"&gt;``&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;`two`&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="ss"&gt;``&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="ss"&gt;``&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the Code Spans dealt with, I moved on to links, using Inline Link elements and
splitting them between two lines are various points in the link itself.  While not
that interesting, it was a good solid scenario that I wanted to make sure was working:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;me&lt;/span&gt;
&lt;span class="s"&gt;"out"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;really&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;me&lt;/span&gt;
&lt;span class="s"&gt;"out"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="tracking-down-the-issues"&gt;Tracking Down the Issues&lt;a class="headerlink" href="#tracking-down-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After coding those new tests, I started executing the tests and everything within the
changing parts of the lists looked fine.  However, on the third line of each example,
when the next item of the base list was defined, some of the tests emitted their text
surrounded by a Paragraph tag.  As this relates to
&lt;a href="https://github.github.com/gfm/#loose"&gt;whether a List is considered loose&lt;/a&gt;,
I took some time to poke around and debug through it.&lt;/p&gt;
&lt;p&gt;Looking at the debug, I realized that I had some issues with the function
&lt;code&gt;__reset_list_looseness&lt;/code&gt; in the &lt;code&gt;transform_to_gfm.py&lt;/code&gt; module.  In trying to be smart
about locating the end of the relevant tokens belonging to a given list, I was going
forward from the start List token looking for the matching end List token.  The problem
was that I was not being selective about which end List token I found, just that I found
a token.&lt;/p&gt;
&lt;p&gt;A short while later, I had some changes coded up that kept track of the &lt;code&gt;stack_count&lt;/code&gt;
associated with the start List tokens and end List tokens that were seen.  The start
List tokens bumped the count by one and the end List tokens reduced the count by one.
If the &lt;code&gt;stack_count&lt;/code&gt; variable was ever zero, it meant that the algorithm had found
the matching end List token, and it broke out of the loop.&lt;/p&gt;
&lt;p&gt;After I finished executing the tests and verifying the results, it was clear to me that
I had found and remedied the issue.  While it was not a big issue to fix, it
was a sneaky one to find, and I was happy to resolve it.&lt;/p&gt;
&lt;h2 id="sometimes-it-is-not-obvious"&gt;Sometimes It Is Not Obvious&lt;a class="headerlink" href="#sometimes-it-is-not-obvious" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Feeling good from my success and solving the last issue, and with the sinus cold
allowing, I started to work on another issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;242&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;variations&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;blank&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="k"&gt;are&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While I remembered adding this item to the issues list, I could not remember anything
around the reason that made me add this to the list.  As I was not aware of the
reasoning
behind the inclusion of this item into the list, and I could not figure out from the
item, I decided to make copies of function &lt;code&gt;test_list_blocks_242&lt;/code&gt; and experiment with
the positioning and number of blank lines within the document.  What I found was
interesting.&lt;/p&gt;
&lt;p&gt;It was a time where I was very happy that I had taken the time to add consistency
checks, as they caught this problem right away, where the output HTML comparison tests
did not.  The problem?  In cases where the &lt;code&gt;__remove_top_element_from_stack&lt;/code&gt; function
in the blank line handling of the &lt;code&gt;tokenized_markdown.py&lt;/code&gt; module were removing
blank lines to be added to the document, it was doing so in reverse order.  That reverse
order meant that in cases with multiple blank lines, the latest blank line would be
added first, messing up the ordering in the document.  &lt;/p&gt;
&lt;p&gt;Once again, a quick fix, and with a couple of iterations of testing to make sure other
functions were not impacted by that side effect (and mitigating those), things were
taken care of.  Another issue solved and resolved.&lt;/p&gt;
&lt;h2 id="variation-on-example-297"&gt;Variation on Example 297&lt;a class="headerlink" href="#variation-on-example-297" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I had some energy left from fighting my cold, and some time left before the American
Thanksgiving holiday started, so I figured I could work on something light.  Hopefully
picking something easy, I picked this task off the list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;296&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;297&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;added&lt;/span&gt; &lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;case&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;LRD&lt;/span&gt;, &lt;span class="nv"&gt;but&lt;/span&gt; &lt;span class="nv"&gt;need&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt;:
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;other&lt;/span&gt; &lt;span class="nv"&gt;types&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;blocks&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt;, &lt;span class="nv"&gt;blank&lt;/span&gt;, &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="nv"&gt;multiple&lt;/span&gt; &lt;span class="nv"&gt;blocks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After a quick look at the Markdown for
&lt;a href="https://github.github.com/gfm/#example-297"&gt;example 297&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I had a good feeling that I would be able to deal with this issue in a couple of hours
or less. To deal with this issue properly, I quickly created variations on function
&lt;code&gt;test_list_items_297&lt;/code&gt; to
test those different scenarios.  Instead of a Link Reference Definition in each
variation, I used an Atx Heading element, a SetExt Heading element, a HTML Block
element, an Indented Code Block element, and a Fenced Code Block element.  Just for
good measure, I added an extra scenario test that had a Fenced Code Block element
followed by a HTML Block element.&lt;/p&gt;
&lt;p&gt;After adding those scenario test and executing them, I was greeted by
the good news which was that the tokens and the output HTML matched what was expected
of each test.  The only issue was in the Markdown generator where the original Markdown
was being reconstructed from the tokens.  After a quick bit of debugging was done
around the processing of the Html Block token, a small change was needed in the function
&lt;code&gt;__merge_with_container_data&lt;/code&gt; to allow the &lt;code&gt;remove_trailing_newline&lt;/code&gt; variable to be set
if the block ends with a newline character.  With those small changes in place, the
newly added scenarios worked fine, generating the correct Markdown to match the
original Markdown.&lt;/p&gt;
&lt;h2 id="fun-with-list-elements"&gt;Fun with List Elements&lt;a class="headerlink" href="#fun-with-list-elements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I do not have any notes on why I picked this task:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;test_link_reference_definitions_185f&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;test_link_reference_definitions_183f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;but it was a fairly interesting task to pick.  Previously, I had disabled both
tests as I was not able to get them working previously.  And it was not
much, but I somewhat remembered working on both these items for at least a couple
of hours each, and not making much progress.  As I said, this was going to be
interesting.&lt;/p&gt;
&lt;p&gt;The good news was that, after a small amount of debugging, I was convinced that I
was looking at two separate issues.   While I did not have any concrete information,
I had a strong feeling that the &lt;code&gt;test_link_reference_definitions_183f&lt;/code&gt; function
failures were due to the Block Quote element in the Markdown, while the
&lt;code&gt;test_link_reference_definitions_185f&lt;/code&gt; function was simply an issue of getting
the Markdown generator adjusted properly.&lt;/p&gt;
&lt;h3 id="debugging-the-issues"&gt;Debugging the Issues&lt;a class="headerlink" href="#debugging-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Picking what I thought was the easy issue to solve, I decided to start working on
the problem with the handling of the Block Quote element.  This happened to be a good
choice as some simple debugging showed me that the issue was a simple one of
not closing off an active List before starting off the Block Quote element.  I
quickly fixed that by adding a simple loop in the &lt;code&gt;__ensure_stack_at_level&lt;/code&gt; function of
the &lt;code&gt;BlockQuoteProcessor&lt;/code&gt; class to ensure that occurs before the Block Quote itself
is started.&lt;/p&gt;
&lt;p&gt;With that part of the issue fixed, my focus shifted to dealing with ensuring that
the Markdown was being properly generated.  After a couple of hours of debugging,
I finally figured out that the failures were being caused when the already transformed
data ends with a newline character, and the next token to transform is either a normal
text token, or one of the &lt;code&gt;SpecialTextToken&lt;/code&gt; related tokens:  Links, Images, and
Emphasis tokens.  In each case, these tokens somehow interrupted the accumulated text,
leaving it ending with a newline character.  To properly add any more text to that
accumulated text, the new data to be added needs to be processed differently to
accommodate that break.&lt;/p&gt;
&lt;p&gt;Like one of the previous sections, the first issue was relatively quick to fix,
while the second issue took hours.  Working through the debugging with a sinus cold
was a bit of a slog, but it was a good issue to take off the list.&lt;/p&gt;
&lt;h2 id="bulking-up-the-series-m-tests"&gt;Bulking Up the Series M Tests&lt;a class="headerlink" href="#bulking-up-the-series-m-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It was Saturday afternoon and I had finished doing some work around my house.  While
I was a bit fatigued, I felt that the
sinus cold was letting up enough that I could spend some weekend time making some
progress on getting more depth to the Series M scenarios.  To do that, I basically
started by placing each of the tests in Series M of the scenario tests into their own
tables.  Having over 45 tests at that point, that separation was equal parts necessity
for my sanity to keep each table separate and readability for anyone looking at them.&lt;/p&gt;
&lt;p&gt;Adding 60 scenario tests to the series, I added 10 scenario tests in each of the six
groups within the series.  While there were small variations to each group of tests,
the underlying tests were essentially the same 10 tests added each time.  And just
as I have mentioned before, the process was a long one: adding the rough form of
the specific test to the table, adding a scenario test to match that rough form,
and then dialing in the example, the token list, and cleaning up the final form of the
entry in the table.  And as usually, it was a long, grueling process.&lt;/p&gt;
&lt;h3 id="powering-through-the-scenarios"&gt;Powering Through the Scenarios&lt;a class="headerlink" href="#powering-through-the-scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The bad news was that I did not get everything done.  After working hard to
get all tests passing, there were 35 tests that for one reason or another were not
passing.  Between the scope of the changes and the last vestiges of my sinus cold,
I did not think twice of marking those failed tests with &lt;code&gt;@pytest.mark.skip&lt;/code&gt;, to be
handled in the following week.  I had a feeling that this task was more than I
could handle in the time allotted with the energy I had, and I was right. Regardless,
I had 25 new scenario tests passing where I did not have them before.&lt;/p&gt;
&lt;p&gt;The good news was that in those 25 new scenario tests, I only found two issues that
I needed to fix and was able to fix.  The most obvious one was in the case of two
empty start List elements, nested together on the same line.  Following through the
code and the log files for that scenario test, it was immediately obvious to me that
assigning the first element of the result from the function
&lt;code&gt;parse_line_for_container_blocks&lt;/code&gt; to &lt;code&gt;_&lt;/code&gt; (in essence, throwing it away), was the
wrong thing to do.   Assigning that first element to the &lt;code&gt;produced_inner_tokens&lt;/code&gt;
variable and adding the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;produced_inner_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fixed that problem. One down, one to go.&lt;/p&gt;
&lt;h3 id="digging-deep-into-the-issue"&gt;Digging Deep into The Issue&lt;a class="headerlink" href="#digging-deep-into-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The other issue that I found was in dealing with empty
list starts in the &lt;code&gt;__pre_list&lt;/code&gt; function.  In one of the first iterations of this
function, I added code in the &lt;code&gt;True&lt;/code&gt; evaluation of
&lt;code&gt;if after_marker_ws_index == len(line_to_parse):&lt;/code&gt; to handle those empty list items.
After a lot of work to come up with the correct formula, I had settled on the code
in that function, part of it for empty list items, and the other part of it for the
non-empty list items.  And that worked well.&lt;/p&gt;
&lt;p&gt;That is until I started looking at it considering the new examples added during these
tasks.  Looking at why scenario tests with empty list items were failing, I kept on
looking at this &lt;code&gt;__pre_list&lt;/code&gt; function.  And with each debugging session that I came
back to that function, the surer I was that I missed something pivotal.  And that
feeling was getting stronger each time.&lt;/p&gt;
&lt;p&gt;Given that feeling, I spent a couple of hours taking that &lt;code&gt;if&lt;/code&gt; statement apart and
putting it back together.  Ultimately, I left the &lt;code&gt;True&lt;/code&gt; case of the &lt;code&gt;if&lt;/code&gt; statement
as it was, but I changed the condition to
&lt;code&gt;after_marker_ws_index == len(line_to_parse) and ws_after_marker&lt;/code&gt;.  As for the cases
where &lt;code&gt;ws_after_marker&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, I added the following code to the &lt;code&gt;False&lt;/code&gt; case to
handle that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;after_marker_ws_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ws_after_marker&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ws_after_marker&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After my experimentation, it just seemed like the right thing to do.  I did find other
solutions that were way more complicated than this one, but those solutions were a lot
more convoluted.  This one was simple.  Instead of doing a complicated calculation and
having lots of &lt;code&gt;if&lt;/code&gt; statements, this just added a slight adjustment to the variable
&lt;code&gt;ws_after_marker&lt;/code&gt;, after which the rest of the &lt;code&gt;False&lt;/code&gt; part of the &lt;code&gt;if&lt;/code&gt; statement was
executed without change.&lt;/p&gt;
&lt;p&gt;While the first solution with the tokens took less than a half an hour to code and
test, when all was said and done, more than five hours had been spent on the task.
But even though it took a while, I was pleased with the result, and I am confident
that the time was well spent in upgrading those solutions.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the beginning of this project, having those 35 scenario tests marked as skipped
would have hung heavily over me.  But at this stage of the project, I recognized that
it was a necessary tool at my disposal.  Instead of waiting until all 60 new scenario
tests were working 100%, it was better to chip away at those tests, committing those
changes to the repository as I went.  Having worked on this project for almost a
year at this point, I knew there were going to be things that ended up running away
from me.  I also knew that while I try and break bigger issues into smaller issues,
there are times that is not possible, for one reason or another.  In this case, I
was concerned that if I did not add all 60 scenarios at once, I would miss one and
it would be hard to detect.  It just meant I would have to adjust.&lt;/p&gt;
&lt;p&gt;And for me, both in my professional life and with this project, is the big takeaway
that I have learned in the last couple of years.  It is extremely important to
set expectations at a healthy level that can be sustained.  Too little, and you can
be viewed as taking it easy.  Too much, and you may be expected to sustain that level
of output for months or years.  I have found great success in clearly stating my
goals and how I plan to achieve them, and resetting expectations on a weekly or
daily basis.  It just makes sense to me.  Well, it does now.  That was not always the
case.&lt;/p&gt;
&lt;p&gt;From my point of view, I could not see a clear way to break up that big issue without
sacrificing the quality in the Series M group changes.  So, I reset my own expectations
for resolving that issue, promising myself that I would address each of those skipped
tests in the next week.  And I was at peace with my decision to do that.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Leaving 35 scenario tests marked as skipped because I could not figure them out
did not sit well with me, so I made them the priority for the following week.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 10</title><link href="https://jackdewinter.github.io/2020/11/30/markdown-linter-delving-into-the-issues-10/" rel="alternate"></link><published>2020-11-30T00:00:00-08:00</published><updated>2020-11-30T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-30:/2020/11/30/markdown-linter-delving-into-the-issues-10/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/23/markdown-linter-delving-into-the-issues-9/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a specific focus on getting list issues resolved …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/23/markdown-linter-delving-into-the-issues-9/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a specific focus on getting list issues resolved this week, I was hoping to
make some decent headway with the issues list.  From my reading of the list at the
start of the week, there were a fair number of List element related issues, Block Quote
element related issues, and cross-over issues between the two.  It just made sense to
me to pick one and focus on it.  And I picked List elements related issues.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4335e2dea51cafd20b96c54832e2cfc50abd1f01"&gt;11 Nov 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/09fe53af190cf566d6476aa4a382f87e92b5cc76"&gt;15 Nov 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-off-with-an-easy-task"&gt;Starting Off with An Easy Task&lt;a class="headerlink" href="#starting-off-with-an-easy-task" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While not a big task, the task:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;292&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;ordered&lt;/span&gt; &lt;span class="n"&gt;lists&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was a nice easy one to start with.  This task was simply to take the functions
&lt;code&gt;test_list_items_292a&lt;/code&gt; to &lt;code&gt;test_list_items_292c&lt;/code&gt;, copy them to &lt;code&gt;test_list_items_292d&lt;/code&gt;
to &lt;code&gt;test_list_items_292e&lt;/code&gt;, changing them from an Unordered List elements to Ordered
List elements.  Nothing more, nothing less.&lt;/p&gt;
&lt;p&gt;And this was very simple, and similarly, the tests passed without any issues.  A
simple, but a good, solid start.&lt;/p&gt;
&lt;h2 id="double-checking"&gt;Double Checking&lt;a class="headerlink" href="#double-checking" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For these tasks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;269&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;305&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;variations&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;whitespace&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;correct&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;weird&lt;/span&gt; &lt;span class="n"&gt;cases&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;list_in_process&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nothing was changed, but some research was done.&lt;/p&gt;
&lt;p&gt;To start, I went to those
two scenario tests and their variations and looked at the whitespace in the
tests.  While it took me a second to remember why the whitespace looks that way in
the list tokens, there
was nothing wrong with the way it was being stored there.  However, it did take
me a second or two to remember that a paragraph within a list stores part of its leading
whitespace in the List token and the remaining leading whitespace in the paragraph
token.  Maybe that is what caused me to add the item to the issues list?&lt;/p&gt;
&lt;p&gt;I then looked at the code for the &lt;code&gt;list_in_process&lt;/code&gt; function with a similar
exploratory effort, but nothing seemed out
of place.  I even enabled debug for a few of the &lt;code&gt;test_list_items_292&lt;/code&gt; functions,
tracing through the code to look for any issues.  While I did not find anything wrong,
I was happy to take a second look at these areas to put any perceived issues that I
might have had to rest.&lt;/p&gt;
&lt;h2 id="ordered-list-blocks-and-start-numbers"&gt;Ordered List Blocks and Start Numbers&lt;a class="headerlink" href="#ordered-list-blocks-and-start-numbers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once again, I found a small task to get out of the way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;CommonMark&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;how&lt;/span&gt; &lt;span class="nv"&gt;handles&lt;/span&gt; &lt;span class="nv"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;initial&lt;/span&gt; &lt;span class="nv"&gt;cases&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;starts&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To examine this issue, I created two new functions, &lt;code&gt;test_list_blocks_extra_1&lt;/code&gt; and
&lt;code&gt;test_list_blocks_extra_2&lt;/code&gt;.  In the first of these functions, I added a couple of lists
with sub-lists, all starting with the the integer &lt;code&gt;1&lt;/code&gt;.  In the second of these
functions, I changed one of the sub-lists to start with the integer &lt;code&gt;2&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;Checking the PyMarkdown parser HTML output against the BabelMark, everything was fine
for the first function, but there was a slight difference for the second function.
Instead of acknowledging the &lt;code&gt;2.&lt;/code&gt; signifying the start of a sub-list, that &lt;code&gt;2.&lt;/code&gt; text
was combined with the paragraph element from the previous line.  That was curious.&lt;/p&gt;
&lt;p&gt;After combing through the specification for about an hour, I posted a question to
the
&lt;a href="https://talk.commonmark.org/"&gt;CommonMark Discussion Boards&lt;/a&gt;, and waited for a response.
More on that in a later article.&lt;/p&gt;
&lt;h2 id="variations-on-existing-lists"&gt;Variations on Existing Lists&lt;a class="headerlink" href="#variations-on-existing-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Graduating from the simpler tasks, I decided to tackle a task that had a bit more
substance to it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;276&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ulist&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;olist&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ulist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Starting with the scenario test for
&lt;a href="https://github.github.com/gfm/#example-276"&gt;example 276&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I started generating variations based along different themes. For each of
the main variations, I simply ran through a simple list of combinations of the Ordered
List element and the Unordered List element: Unordered/Ordered, Ordered/Unordered,
Ordered/Ordered, and Unordered/Unordered.  After those combinations were taken care of,
the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; variations of those variations were created by adding an Unordered List
element (for &lt;code&gt;a&lt;/code&gt;) or an Ordered List element (for &lt;code&gt;b&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;While I expected something to happen, it was nice to be proven wrong.  The tests all
passed without any issues.  The reason for my initial doubt on this issue?  I have
had problems with “empty” lists before.  While I do not use them myself, the Markdown
specification allows for a List element that only contains a start List Element text
sequence, say &lt;code&gt;1.&lt;/code&gt;, with no other text on that line.  And from my knowledge of the
GFM Specification, empty list items are covered, but not as completely as the list
item starts followed by text.  Based on that background, it was good to see that so
far, those empty list items were not going to be an issue.&lt;/p&gt;
&lt;h2 id="variations-on-a-theme"&gt;Variations on A Theme&lt;a class="headerlink" href="#variations-on-a-theme" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;On a bit of a roll with some easy wins in the completed task column, I decided to
do a couple of tasks together as a single task:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;extra&lt;/span&gt; &lt;span class="nv"&gt;spaces&lt;/span&gt; &lt;span class="nv"&gt;on&lt;/span&gt; &lt;span class="nv"&gt;blanks&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;other&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;types&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;instead&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;just&lt;/span&gt; &lt;span class="nv"&gt;li&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on previous tasks, it seemed like a good idea to come up with variations to
deal with these tasks.  To do this, I started with the example for
&lt;a href="https://github.github.com/gfm/#example-256"&gt;example 256&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;
  &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
  &lt;span class="n"&gt;bar&lt;/span&gt;
  &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;
      &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the first two variations on &lt;code&gt;test_list_blocks_256&lt;/code&gt;, I modified the example Markdown
to include extra trailing whitespace as part of the empty list items.  From there,
I added a variation which replaced the unordered list item elements with ordered list
item elements.  In addition, I further modified that variation by adding extra blank
lines and by reducing the indent on the Fenced Code Block element from 3 to 2, making
it ineligible for inclusion into the list. Basically, I looked at Example 256
and experimented with what I thought would be good variations to test.&lt;/p&gt;
&lt;p&gt;While a lot of those variations did not result in the discovery of any expected issues,
there was one interesting new issue.  In cases where there is a blank line inside
of a list, there was a weird ordering where the processing of the blank line and the
processing of the blank line to close the list were in the wrong order.  As such,
a small fix was required to make sure that the information is available to make a
proper decision on how to handle that blank line with the correct data.&lt;/p&gt;
&lt;p&gt;That one took a bit of effort to figure out, but it was a good warm up for what I knew
was going to be a bear of a task to follow.&lt;/p&gt;
&lt;h2 id="this-weeks-big-issue"&gt;This Week’s Big Issue&lt;a class="headerlink" href="#this-weeks-big-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there was not an explicit entry in the issues list for this issue, it was an
issue that I had long been concerned about.  As the commit message stated, that issue
was to “add better support for lists that are aborted due to missing leading space in
front of a new block”.  I knew I was opening a can of worms by exploring this issue,
but for me to have confidence in the project, I felt that I needed to explore this, and
explore it now.&lt;/p&gt;
&lt;h3 id="aborted-due-to-missing-leading-space"&gt;Aborted Due to Missing Leading Space?&lt;a class="headerlink" href="#aborted-due-to-missing-leading-space" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Basically, in its simplest form, this issue breaks down into the following scenario:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="c1"&gt;---&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this scenario, the Markdown specifies a simple List element that is created without
any content on that line, an empty list item.  In starting to parse the second line,
the parser must first determine if that newly parsed text will be part of that list or
not.  To ensure that text is added to that List element, the text on the next line must
be indented 3 spaces, matching the indent level
of that List element.  Therefore, when the Thematic Break element on that next line
fails to maintain that level of indentation, the original list is then aborted, and the
Thematic Break element is processed after the list has been closed.&lt;/p&gt;
&lt;p&gt;This reading of the specification is backed by the HTML output generated by
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;BabelMark&lt;/a&gt;
for this scenario:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;li&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;ol&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;hr&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="what-is-the-issue-then"&gt;What Is the Issue Then?&lt;a class="headerlink" href="#what-is-the-issue-then" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I had a specific answer to a specific question regarding how the List element
and the Thematic Break element interacted, I wanted a more generic answer that I
could work with.  As usual, I opened up the
&lt;a href="https://github.github.com/gfm"&gt;GFM Specification&lt;/a&gt;
in my browser and started looking for that generic answer.  Unfortunately, I
did not get an answer that I was satisfied with.&lt;/p&gt;
&lt;p&gt;The first thing that I looked for
was some variation on the previous example, of which I kind of found a related test
with &lt;a href="https://github.github.com/gfm/#example-27"&gt;example 27&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;***&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it was not exactly what I was looking for, it was something.  When I went to look
for a similar example including an Atx Heading element, I did not find any comparable
example.&lt;/p&gt;
&lt;p&gt;To be clear, I do not believe this is the fault of the GFM Specification. To
be honest, I think the specification has done a great job and specifying the main cases
that people are going to encounter.  But there is always room for improvement, and I am
hoping to contribute to that improvement with the PyMarkdown project’s testing suite.
That is part of the process, and how the specification gets better.&lt;/p&gt;
&lt;p&gt;With that newfound information in mind, I was left with a slightly modified issue.
As I did not have a good set of examples detailing how lists and other leaf blocks
interacted, I therefore did not have a good comprehensive
scenario test suite that I had confidence in.  I was confident that the GFM
Specification was getting me a good 90% of the way there, but I wanted more than that
90%.  Therefore, the newly modified issue that I needed to solve was that I needed to
specifically add more specific tests in this area.&lt;/p&gt;
&lt;h3 id="getting-a-good-view-on-the-issue"&gt;Getting A Good View on The Issue&lt;a class="headerlink" href="#getting-a-good-view-on-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first thing I did to address this issue was to stop and think clearly about what
needed to be done.  From the last bit of work, I knew that the scenario functions
&lt;code&gt;test_list_blocks_256*&lt;/code&gt; were a good start, so I decided to add functions with similar
names more from that point.&lt;/p&gt;
&lt;p&gt;Starting with the example I outlined the function &lt;code&gt;test_list_blocks_256f&lt;/code&gt; with the
following markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="c1"&gt;---&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then I added a variation on that, making test function &lt;code&gt;test_list_blocks_256fa&lt;/code&gt; be the
same thing, just with text after the List Item element.  Once that was done, I basically
copied those scenario tests, replacing the Thematic Break element with an Atx Heading
element, a SetExt Heading element, an Ordered Code Block element, a Fenced Code Block
element, and an HTML Block element.  With scenario test titles going from &lt;code&gt;256f&lt;/code&gt; to
&lt;code&gt;256k&lt;/code&gt;, I went back and used BabelMark to replace the output HTML in each of the
scenario tests.&lt;/p&gt;
&lt;p&gt;Running the newly created scenario tests, I discovered a solid number of issues that
needed to be looked at.  I knew at this point that there was not going to be an easy
solution here.  I rolled up my sleeves and got to work.&lt;/p&gt;
&lt;h3 id="html-blocks"&gt;HTML blocks&lt;a class="headerlink" href="#html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Picking one of the elements to start with, that night I decided to start working with
the HTML Block element and regretted it within hours.  Looking at the failures
from those tests, it was obvious that there was more than one problem with these tests.
The most immediate problem was that the tokens produced by the parser just looked
wrong.&lt;/p&gt;
&lt;p&gt;Taking the time to look at the problem in depth, I quickly discovered that the
HTML Block element was not causing the list to close like it should.  As that was
a major issue to find, everything else after that token was affected in some way.
To address this issue, I created the &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt; function
to allow the parser to clean up in situations like this.  More specifically, it was
for cases where a paragraph had just been closed while in an active list.  In those
cases, the parser thought the lists had been closed, but the proper tokens were not
being emitted.&lt;/p&gt;
&lt;p&gt;But even with those observations in place, there still was something about the tokens
that looked “off”.  However, I know that there was currently too much noise in the
way for me to see that other issue clearly, so I just decided to get it out of the
way first.&lt;/p&gt;
&lt;h3 id="cleaning-up-html-blocks-in-lists"&gt;Cleaning Up HTML Blocks in Lists&lt;a class="headerlink" href="#cleaning-up-html-blocks-in-lists" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To take care of those concerns, I experimented with eight other variations on that list
scenario, including some variations with sub-lists.  While I was mostly pleased with the
results, there were three tests that were failing due to issues in generating the
correct HTML and rehydrated Markdown text.  After some quick investigation, it became
obvious that there was whitespace missing at the start of the HTML blocks.&lt;/p&gt;
&lt;p&gt;Double checking with the other failing tests, the pattern that emerged was that the
spacing between the end of the previous paragraph and the new HTML block needed to
be altered a bit.  To make sure that information could get from the parser to the
HTML generator, I added a new member variable &lt;code&gt;fill_count&lt;/code&gt; to the HTML Block token,
using the &lt;code&gt;add_fill&lt;/code&gt; function to adjust its value.  Once that was added, I was then
able to make small alterations to the &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt; function
to adjust that &lt;code&gt;fill_count&lt;/code&gt; member variable with the difference between the number of
whitespace characters removed and the indentation level of the currently active list.&lt;/p&gt;
&lt;p&gt;With that information now present in the token, the HTML generator was easily changed to
add those extra characters between the start of the HTML Block and the processing of
the text within that block.  With those changes generating HTML properly, the focus
shifted to applying similar changes to the the Markdown generator and the consistency
checks.  While the first part of this issue had taken days to complete and fix, this
part took only half an hour.  At that point, the HTML blocks and all their variations
were working properly.&lt;/p&gt;
&lt;h3 id="moving-on-to-the-other-blocks"&gt;Moving on To The Other Blocks&lt;a class="headerlink" href="#moving-on-to-the-other-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After fixing the HTML Block elements, I took a closer look at the other failing tests
and started to notice similar problems.  While the &lt;code&gt;fill_count&lt;/code&gt; solution was only useful
for the HTML blocks, the &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt; function was useful
in fixing issues with the handling of Fenced Code Block elements and Atx Heading
elements.  In both of those instances, the new element was supposed to abort the
previous list but was not doing so.  The &lt;code&gt;correct_for_leaf_block_start_in_list&lt;/code&gt;
function needed a couple of tweaks to make sure it was handling things consistently
across all three scenarios, but they were all easy fixes.&lt;/p&gt;
&lt;p&gt;With the parser generating the tokens properly, the tests were making more progress but
still failed on the output HTML.  While not a big difference, the output HTML was
missing a newline between the end of the previous list and new Fenced Code Block
elements,
Atx Heading elements, and SetExt Heading elements.  That difference was quickly
eliminated by adding two small lines of code to the handle of those elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;lt;/ol&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;output_html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;lt;/ul&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;output_html&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After crossing my fingers for good luck, and fixing a couple of typing mistakes,
the new tests passed without much fanfare.  It was just a relief.  I knew it would
take a while, but I did not think it would take three days to complete the
implementation and verification of these new scenario tests.&lt;/p&gt;
&lt;h3 id="it-was-a-slog"&gt;It Was A Slog…&lt;a class="headerlink" href="#it-was-a-slog" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Over that three days, I was able to get 18 new scenario tests coded and passing
properly.  To be honest, I was doubtful at certain points that I would get done, as
progress was hard to come by.  While I cannot remember how “on my game” I felt during
that time, I do remember that I felt burdened by the knowledge that this work was
only the starting point, and I would have to repeat it multiple times in the future.&lt;/p&gt;
&lt;p&gt;And to that end, I had my next task already lined up.&lt;/p&gt;
&lt;h2 id="lather-rinse-repeat"&gt;Lather, Rinse, Repeat&lt;a class="headerlink" href="#lather-rinse-repeat" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While it was a tough couple of days getting through that block of work, I felt that it
was a good task to complete, but that it was not yet 100% complete.  With some extra
time left in the evening, I decided to take a shot at replicating the width of tests
that I added for HTML Block elements to the other Leaf Block elements as well.&lt;/p&gt;
&lt;p&gt;Taking a bit of time to setup (copy, paste, alter, repeat… many times), I was
pleasantly surprised with the low number of failures.  For those tests that did fail,
patterns that I was familiar with from the previous issues with HTML Block elements
began to resurface.  As these issues arose in the Atx Heading elements and the Fenced
Code Block elements, the first set of changes I made were to add a &lt;code&gt;fill_count&lt;/code&gt;
member variable to those token class, similar to how I had added them to the Html Block
token class.  As some of those classes were in a bit more of a “raw” state than the
HTML Block class was, I needed to do a bit of extra work to make sure that I could
adjust the &lt;code&gt;fill_count&lt;/code&gt; variable and have it be persisted.  But it was nothing I had
not done multiple times before, so it was quickly accommodated.&lt;/p&gt;
&lt;p&gt;Other than a couple of small changes, the only big change was to the function
&lt;code&gt;__check_for_list_closures&lt;/code&gt;.  Taking a while to get right, I needed to alter
a few of the functions that feed that function to pass the right parameters
around.  While it was not too difficult, I was hoping that I would find time in
the near future to revisit parts of this code and refactor it to make it cleaner.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Getting a fair number of items related to lists taken off the issues list was a
good feeling.  While there were a couple of draining issues in the middle, it was
still good to make that progress forward.  While it was a bit disheartening finding
issues in the parser after a spell without any major issues with the parser, it
was par for the course.  Better for me to discover them now, than to have a consumer
discover them later.  But as long as I was finding these issues, I would have to make
sure to examine the existing tests and identify any potential areas where I can
add extra tests to validate that I had found most of the issues with lists.&lt;/p&gt;
&lt;p&gt;At this point, I thought it would be useful for me to reiterate a point from previous
articles.
I am not trying to make this project perfect.  After years of software development and
years of software automation, I know that eliminating all issues is not possible.  It
always boils down to when the next issue is going to happen, not if.  But for me, it is
very important to make my best effort in getting the quality to a point that I feel
comfortable with.&lt;/p&gt;
&lt;p&gt;Following that, while I know there is a bit left to go before releasing this project,
I know that it is getting nearer with each item I resolve from the issues lists.  And
that is the point.  It is getting closer, and I just need to keep my focus on the prize:
that project release.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Continuing with my efforts to get better scenario tests around lists, I knew
that I had to be more structured about that testing.  As that meant creating
a new test series, it forbade that the next week’s work would be moving this
week’s work into a new series and cleaning it up.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 9</title><link href="https://jackdewinter.github.io/2020/11/23/markdown-linter-delving-into-the-issues-9/" rel="alternate"></link><published>2020-11-23T00:00:00-08:00</published><updated>2020-11-23T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-23:/2020/11/23/markdown-linter-delving-into-the-issues-9/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/16/markdown-linter-delving-into-the-issues-8/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not much of an introduction here, just my usual …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/16/markdown-linter-delving-into-the-issues-8/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
split my time between adding to the scenario cases tables and dealing with items from
the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not much of an introduction here, just my usual plodding forward.  Having spent time
in the last couple of weeks working on either the scenario cases tables or resolving
items from the issues list, I tried this week to split my time evenly between those two
tasks.  Without further ado, on to the work!&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/3ff576dcdbac37f42e176a0db6dd6b3d1933188e"&gt;03 Nov 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fe184f8a312033c2998f76b983b83a74a61a96ee"&gt;08 Nov 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="dismissing-an-easy-issue"&gt;Dismissing an Easy Issue&lt;a class="headerlink" href="#dismissing-an-easy-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Initially, looking at  the following item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;553&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I thought I would have some work to do.  However, when I started looking at this
item, it did not take longer than a couple of minutes before I was able to resolve
this issue.&lt;/p&gt;
&lt;p&gt;Along the way, there are times where I have good ideas on things to check, and then
other times where I just have ideas.  While I think I meant well with this item,
it ended up falling into neither of those two buckets.  Taking a look at the Markdown
for
&lt;a href="https://github.github.com/gfm/#example-553"&gt;example 553&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[bar][foo\\!]&lt;/span&gt;

&lt;span class="na"&gt;[foo!]: /url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I believe I wanted to make sure that I tested other concepts to make sure the lookup
worked properly.  The most obvious of those concepts would usually be inline elements,
so I think it might have made sense from that point of view.  However,
I had missed one little thing.  As function &lt;code&gt;test_reference_links_553&lt;/code&gt; centers around
subtle variations with the link reference, any inline element would be treated as
plain text, without any interpretation.&lt;/p&gt;
&lt;p&gt;Based on that quick research and the fact that I already had tests for inline elements
in the link label, I just resolved it without any changes.  I think while I might have
had something else on my mind when I added that issue to the list, I was unsure of a
good way to honor it in any reasonable form.  It was good to check out though, just
nothing to do to enhance the project with.&lt;/p&gt;
&lt;h2 id="empty-link-labels"&gt;Empty Link Labels&lt;a class="headerlink" href="#empty-link-labels" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Added a long time ago, I spotted two issues that I knew that I could resolve
quickly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="mi"&gt;560&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;full&lt;/span&gt; &lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="mi"&gt;560&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously added at a time when I was not as complete in my knowledge of the
GFM Specification as I am now, both items were indicating confusion as to why an
empty link label wasn’t valid.&lt;/p&gt;
&lt;p&gt;With the experience gained since those items were added, it was easy for me to
reference the GFM Specification on
&lt;a href="https://github.github.com/gfm/#link-reference-definitions"&gt;Link Reference Definitions&lt;/a&gt;,
select the
&lt;a href="https://github.github.com/gfm/#link-label"&gt;link label&lt;/a&gt;
reference in the first line of the first paragraph, and extract the following bit
of text from the definition of a link label:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Between these brackets there must be at least one non-whitespace character.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While that one line escaped me early in the development of the project, I was now
familiar enough with it to be able to locate it in 30 seconds or less.  As I
acknowledge it is a boundary case, I can see why the specification writers added that
text in there to deal with that case.  From my point of view, an empty link label is
just an empty string that needs to be parsed.  But I also understand that there is
plenty of precedence to also look on an empty string as having no value.  I am not
sure if that is the way I would have gone with this, but I was happy to follow along
with the specification with this one.&lt;/p&gt;
&lt;h2 id="bolstering-up-the-scenario-cases"&gt;Bolstering Up the Scenario Cases&lt;a class="headerlink" href="#bolstering-up-the-scenario-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The more I used the new &lt;code&gt;scenario-cases.md&lt;/code&gt; document, the more I was enjoying it and
the confidence it brings to the project.  While it is still early in the document’s
life, I am starting to rely on that document at the same level that I rely on the GFM
Specification examples.  Basically,
if a parser can properly handle either one of those groups of tests, it is a good thing.
If it can properly handle both groups of tests, it is a wonderful thing.&lt;/p&gt;
&lt;p&gt;As such, a certain amount of this week was spent beefing up that important document.&lt;/p&gt;
&lt;h3 id="moving-simple-inline-links"&gt;Moving Simple Inline Links&lt;a class="headerlink" href="#moving-simple-inline-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At the start of this block of work, one of the things that I wanted to do was to move
the non-base &lt;code&gt;test_inline_links_518&lt;/code&gt; functions into the Series F group by moving them
into the &lt;code&gt;test_paragraph_extra_&lt;/code&gt; group.  While this was not a big move, it filled a
hole that I had perceived in the Series F group tests.  And since it was just
moving the tests from one module to the other, the tests were already passing.
That made the duration task seem to fly by.&lt;/p&gt;
&lt;h3 id="adding-links-as-the-last-element-in-the-document"&gt;Adding Links as The Last Element in the Document&lt;a class="headerlink" href="#adding-links-as-the-last-element-in-the-document" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having just moved that small group of tests into the Series F group, I noticed that
all the test cases in that group ended with a Text token, and not a Link element.
As that affects what is checked at the end of a leaf block, I thought it was
prudent to go through the Series F group and add a variation for each case that
tested the base document without any elements after the document.&lt;/p&gt;
&lt;p&gt;That was not a difficult task but was a task that was both tedious and lengthy.  I went
through each of the 16 base tests registered in the Series F group and created a
new variant of that base test.  Once created, I removed any trailing non-link
characters from each test document, double checking that I had not disturbed the Link
element itself.  As usual, I verified the HTML document against
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;Babelmark&lt;/a&gt;,
then running the tests to see if there were any issues.&lt;/p&gt;
&lt;p&gt;When I ran the tests, I was greeted with the good news that the parser itself was
working properly and the consistency checks only required minor changes.  Those changes
were in the &lt;code&gt;__handle_last_token_end_link&lt;/code&gt; function, each of them small adjustments to
handle the various parts of the Link token in its various forms, but nothing that
wasn’t immediately resolvable.&lt;/p&gt;
&lt;h3 id="following-up-with-image-elements"&gt;Following Up with Image Elements&lt;a class="headerlink" href="#following-up-with-image-elements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It should be no surprise that after completing the work documented in the previous two
sections that I decided to follow that work up with ensuring parity for the Image
elements in the Series F group. In total, 29 new scenarios were added to the group,
mirroring the existing Link element tests.&lt;/p&gt;
&lt;p&gt;Due to previous hard work and a bit of luck, there
was only one change required in the &lt;code&gt;__handle_last_token_image&lt;/code&gt; function.  In the
case where the last token is a full Image token, I just needed to add a single line
to properly increase the &lt;code&gt;inline_height&lt;/code&gt; variable by one for each newline in the
&lt;code&gt;text_from_blocks&lt;/code&gt; field of the Image token.  While the verification phase of each
test took a while, the testing phase of these additions went by very successfully and
very quickly.&lt;/p&gt;
&lt;h3 id="moving-scenario-tests-into-their-own-modules"&gt;Moving Scenario Tests into Their Own Modules&lt;a class="headerlink" href="#moving-scenario-tests-into-their-own-modules" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Over the course of the next three commits, I took on the immense chore of moving and
renaming tests belonging to seven of the identified scenario case groups.  Those seven
groups were Series A to Series E, Series H and Series J.  For each group, I created a
new file, such as &lt;code&gt;test_markdown_paragraph_series_a.py&lt;/code&gt; and moved tests in from their
original modules, renaming them as I went.&lt;/p&gt;
&lt;p&gt;As I renamed those functions, I started to come up with a solution for how to identify
each test uniquely.  What I quickly settled on was to start the test name with
the series that it belonged to, followed by a descriptive name based on the contents
of the test document.  In this way, I could easily tell if I repeated a test within
a given group by looking at the name of the function.&lt;/p&gt;
&lt;p&gt;While this work was primarily copying and renaming scenario tests, it was exhausting.
For each test, I needed to make sure that the name of the function matched the
Markdown document contained within the test.  Then I needed to take that Markdown
document and run in through Babelmark to make sure the HTML output was correct.
Repeated on over 100 scenario tests, it took a lot of time and a lot of patience to
get correct.  But in the end, it was satisfying to be able to see the groups
come together, painting a cohesive picture of a group of passing tests along a given
theme.&lt;/p&gt;
&lt;h2 id="better-tests-for-link-reference-definitions"&gt;Better Tests for Link Reference Definitions&lt;a class="headerlink" href="#better-tests-for-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Switching back to resolving items from the issues list, the first thing that caught
my eye was an issue dealing with Link Reference Definitions.
Of all the leaf blocks elements that I have had to design and code for this project,
the Link Reference
Definition element was by far the most difficult to get right.  It was no surprise to
me to find the following item in the issues list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;what&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;bad&lt;/span&gt; &lt;span class="nv"&gt;link&lt;/span&gt; &lt;span class="nv"&gt;definition&lt;/span&gt; &lt;span class="nv"&gt;discovered&lt;/span&gt; &lt;span class="nv"&gt;multiple&lt;/span&gt; &lt;span class="nv"&gt;lines&lt;/span&gt; &lt;span class="nv"&gt;down&lt;/span&gt;, &lt;span class="nv"&gt;how&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;back&lt;/span&gt; &lt;span class="nv"&gt;track&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Starting back in April 2020 when I added support for
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/"&gt;Link Reference Definitions&lt;/a&gt;,
I felt that while the feature was implemented, I knew that there was always going to be
a possibility of a gap in the feature implementation.  Because of the unique multiline
nature of this feature, it is impossible to determine if the element itself is valid
without reading the next line.  As such, I had to implement a “requeue” functionality
to allow the parsing of a possible Link Reference Definition element to be rewound and
attempted again as a different element.  While that has worked well, the bulk of my
concerns over this feature centered around whether that rewinding functionality
dealt with all possible side effects, not just the most common set of them.&lt;/p&gt;
&lt;p&gt;Given that history, I decided to add functions &lt;code&gt;test_link_reference_definitions_166a&lt;/code&gt;
and &lt;code&gt;test_link_reference_definitions_166b&lt;/code&gt; to test for two more cases where an element
was only discovered to be invalid.  In the case of function
&lt;code&gt;test_link_reference_definitions_166a&lt;/code&gt;, I made sure that the title portion starts on
the same line but was not properly terminated.  This was to make sure that the entire
element would be discarded as there was no solution where the Link Reference Definition
could be considered complete under any circumstances.  When I added function
&lt;code&gt;test_link_reference_definitions_166b&lt;/code&gt;, I took the opposite approach, starting the title
on the next line.  As I started it on the next line, the Link Reference Definition could
be completed, just without the title.&lt;/p&gt;
&lt;p&gt;When I ran the tests for these two tests, it was no surprise to me that there was a
failure.  In looking at the tests, the failure was with function
&lt;code&gt;test_link_reference_definitions_166b&lt;/code&gt; which fails due to an extra Blank Line token
being generated before the rewind is reprocessed.  It took me a bit of time to realize
that I needed to add the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;force_ignore_first_as_lrd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lines_to_requeue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;at the end part of the &lt;code&gt;__stop_lrd_continuation&lt;/code&gt; function that dealt with continuations
that were partially successful.  I just had to try different combinations before
figuring out what the correct one was before proceeding.&lt;/p&gt;
&lt;h2 id="dont-judge-a-book"&gt;Don’t Judge A Book…&lt;a class="headerlink" href="#dont-judge-a-book" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Indeed, when I came across this item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;603&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;doesn&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;look&lt;/span&gt; &lt;span class="k"&gt;right&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I agreed that it did not look right.  The Markdown for
&lt;a href="ex-603"&gt;example 603&lt;/a&gt; is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;boolean&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;producing the HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"http://foo.bar.baz/test?q=hello&amp;amp;amp;id=22&amp;amp;amp;boolean"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;http://foo.bar.baz/test?q=hello&lt;span class="ni"&gt;&amp;amp;amp;&lt;/span&gt;id=22&lt;span class="ni"&gt;&amp;amp;amp;&lt;/span&gt;boolean&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I was able to verify it quickly against Babelmark, but it took me a bit to figure out
what the parser did to get to that result.  The big thing that I had to remember for
this case was that it was interpreted as an Autolink, which is meant as a quick way to
provide references.  As such, it makes sense that instead of a literal interpretation
of the
specified link, the processing leans more towards what the user probably intended.  To
that end, it makes sense that the ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;) character in the link is translated
into the named character entity &lt;code&gt;&amp;amp;amp;&lt;/code&gt; for use in both the reference and the text.&lt;/p&gt;
&lt;p&gt;So, after thinking it through and checking it out, the function &lt;code&gt;test_autolinks_603&lt;/code&gt; is
100% correct.  For extra points though, to produce the correct link, I determined that
the following HTML block would be needed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://foo.bar.baz/test?q=hello&amp;amp;id=22&amp;amp;boolean"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;http://foo.bar.baz/test?q=hello&lt;span class="err"&gt;&amp;amp;&lt;/span&gt;id=22&lt;span class="err"&gt;&amp;amp;&lt;/span&gt;boolean&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yeah, I like puzzles, and this was a good one.&lt;/p&gt;
&lt;h2 id="i-really-need-to-be-more-specific"&gt;I Really Need to Be More Specific&lt;a class="headerlink" href="#i-really-need-to-be-more-specific" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I am usually good at adding items to the issues list, this one was cryptic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;620&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;more&lt;/span&gt; &lt;span class="n"&gt;bad&lt;/span&gt; &lt;span class="n"&gt;cases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Huh?  That really was not a lot to go on, but I gave it a shot.  Without more
information in the item, I just got a bit creative.&lt;/p&gt;
&lt;p&gt;Taking a look at function &lt;code&gt;test_autolinks_604&lt;/code&gt;, I took the initial URI autolink of
&lt;code&gt;&amp;lt;irc://foo.bar:2233/baz&amp;gt;&lt;/code&gt;, stripping it down to &lt;code&gt;&amp;lt;irc:foo.bar&amp;gt;&lt;/code&gt; for
function &lt;code&gt;test_autolinks_604a&lt;/code&gt; and expanding the theme to
&lt;code&gt;&amp;lt;my+weird-custom.scheme1:foo.bar&amp;gt;&lt;/code&gt; for function &lt;code&gt;test_autolinks_604b&lt;/code&gt;. Similarly,
I took the email Autolink of &lt;code&gt;&amp;lt;foo+special@Bar.baz-bar0.com&amp;gt;&lt;/code&gt; from function
&lt;code&gt;test_autolinks_613&lt;/code&gt; and reduced it down to &lt;code&gt;&amp;lt;l@f&amp;gt;&lt;/code&gt; for function &lt;code&gt;test_autolinks_613a&lt;/code&gt;.
Having added some good positive tests, I then decided to add negative tests.  For
function &lt;code&gt;test_autolinks_620a&lt;/code&gt; I specified a theme with too few characters, while
function &lt;code&gt;test_autolinks_620b&lt;/code&gt; specified a theme with too many characters. Test
function &lt;code&gt;test_autolinks_613c&lt;/code&gt; specified a scheme with an invalid character in the
theme, while function &lt;code&gt;test_autolinks_613d&lt;/code&gt; had no domain part and function
&lt;code&gt;test_autolinks_613e&lt;/code&gt; had no name part.&lt;/p&gt;
&lt;p&gt;These tests all passed without incident, but it felt good to increase the scenarios
and increase my confidence in the project.  While I was pretty sure that these would
all pass, as they are all based on regular expressions with specific character counts,
it just felt right to explicitly test those limits and make sure they were consistent.&lt;/p&gt;
&lt;h2 id="verifying-link-reference-definitions-with-other-blocks"&gt;Verifying Link Reference Definitions with Other Blocks&lt;a class="headerlink" href="#verifying-link-reference-definitions-with-other-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the same manner as other tests, this one started from the issues list item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;test_link_reference_definitions_183&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;partial&lt;/span&gt; &lt;span class="n"&gt;lrd&lt;/span&gt; &lt;span class="n"&gt;followed&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;bq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;add&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt; &lt;span class="n"&gt;blocks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In test function &lt;code&gt;test_link_reference_definitions_183&lt;/code&gt;, the Link Reference Definition
(or its acronym LRD as used in the item) follows an Atx Heading element.  In the
GFM Specification for this example, it explicitly states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, it can directly follow other block elements, such as headings and thematic breaks, and it need not be followed by a blank line.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While it states that it can follow other block elements, it only gave three examples:
one after an Atx Heading element, one before a Thematic Break element, and one before a
SetExt Heading element.  Those three tests cases, spread out in the three functions
between &lt;code&gt;test_link_reference_definitions_183&lt;/code&gt; and &lt;code&gt;test_link_reference_definitions_185&lt;/code&gt;
were a good start, I felt that better coverage was warranted.  Therefore, I created
functions &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt; for function &lt;code&gt;test_link_reference_definitions_183&lt;/code&gt; and functions
&lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for function &lt;code&gt;test_link_reference_definitions_185&lt;/code&gt; to cover the before and
after cases.&lt;/p&gt;
&lt;p&gt;Except for two of the tests, they all passed without incident.  The two
that did not pass were tests that involved a Link Reference Definition occurring both
before and after a list. As I knew I was going to be finishing up with leaf blocks
and heading to container blocks in the next week or two, I marked those test as
disabled, added an item to the issues list, and kept on going.&lt;/p&gt;
&lt;h2 id="cleaning-up-character-entity-tests"&gt;Cleaning Up Character Entity Tests&lt;a class="headerlink" href="#cleaning-up-character-entity-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At first, when I saw the issues list item:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;test_markdown_entity&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;various&lt;/span&gt; &lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="n"&gt;tests&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I thought that I had missed a couple of cases and looked for some missing cases.  It
was during that search that I came across the following text at the end of the
&lt;code&gt;test_markdown_entity_and_numeric_character_references.py&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# TODO&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;amp; and various forms at end of line&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# 327 special parsing for html blocks?&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;lt;a href="&amp;amp;ouml;&amp;amp;ouml;.html" x="&amp;amp;ouml;"&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;lt;x-me foo="&amp;amp;ouml;"&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;# &amp;lt;script&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;amp;ouml; bar="&amp;amp;ouml;" bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Comparing the items in the Python list, I determined that all those cases had already
been covered by other tests, but there were some tests that I thought it was worth
adding.&lt;/p&gt;
&lt;p&gt;While the example for function &lt;code&gt;test_character_references_321&lt;/code&gt; specified that the text
must match that of an entity in the named entities table, I added function
&lt;code&gt;test_character_references_321a&lt;/code&gt; to make it explicit that it was a case-sensitive
lookup.  Similarly, functions &lt;code&gt;test_character_references_322&lt;/code&gt; and
&lt;code&gt;test_character_references_323&lt;/code&gt; mention turning numeric entities into characters, but
only included the special &lt;code&gt;NUL&lt;/code&gt; character &lt;code&gt;0&lt;/code&gt; as a byproduct of the text in an example.
As such, I created the &lt;code&gt;test_character_references_323a&lt;/code&gt; function to call attention to
this special character, also showing that any number of leading zeroes does not matter
for numeric entities.&lt;/p&gt;
&lt;p&gt;In a similar pattern, but at a higher level, I added the &lt;code&gt;test_character_references_336&lt;/code&gt;
series of functions, named &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt;.  While I was okay with the examples showing the
usage of entities in paragraphs, I felt that having explicit cases of entities in each
of the other leaf blocks was useful.  In order, the tests added named entities in each
of an Atx Heading element, a SetExt Heading element, and Indented Code Block element,
a Fenced Code Block element, and a Html Block element.  I also verified that the entity
was interpreted in the first two elements, and not interpreted in the last three
elements, as per the GFM Specification.&lt;/p&gt;
&lt;p&gt;Finally, as a simple set of comprehensive tests, I wanted to have a good example of
specifying
a named entity using all three forms: named, decimal, and hexadecimal.  As such, I
created the &lt;code&gt;test_character_references_extra_&lt;/code&gt; functions with &lt;code&gt;01&lt;/code&gt; using &lt;code&gt;&amp;amp;quot;&lt;/code&gt;,
&lt;code&gt;02&lt;/code&gt; using &lt;code&gt;&amp;amp;#34;&lt;/code&gt;, and &lt;code&gt;03&lt;/code&gt; using &lt;code&gt;&amp;amp;#x22;&lt;/code&gt;.  I know that these functions were going
to pass ahead of time, but it gave me confidence knowing that I had a concrete set of
three tests showing that the form of the entity didn’t matter, as they all produced
the same HTML results.&lt;/p&gt;
&lt;h2 id="closing-things-up"&gt;Closing Things Up&lt;a class="headerlink" href="#closing-things-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Even though I was getting close to writing time on Sunday morning, I wanted to try and
clear one more easy issue from the list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;HTML&lt;/span&gt; &lt;span class="n"&gt;transformer&lt;/span&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;text_from_chars&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;instead&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;field&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;see&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jackdewinter&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;pymarkdown&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a506ddd3bda08a8ca1d97a7b0d68c114325b545e&lt;/span&gt; &lt;span class="ss"&gt;`extra_74`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This was more of a bookkeeping issue than anything else, or at least I hoped it was.
During a previous change on 02 Oct 2020, I thought I had noticed that the HTML
transformer was using the &lt;code&gt;text_from_blocks&lt;/code&gt; field to create the text for the links.
Thankfully, resolving this took a quick look at the &lt;code&gt;__handle_image_token&lt;/code&gt; function
in the &lt;code&gt;transform__to_gfm.py&lt;/code&gt; module to verify it was not using that field.&lt;/p&gt;
&lt;p&gt;When I took a second, this should have been more obvious to me.  While it is possible
to derive the &lt;code&gt;image_alt_text&lt;/code&gt; field from the &lt;code&gt;text_from_blocks&lt;/code&gt; field, it is the last
thing I would have thought about when generating HTML.  But I still felt good that I
verified this and dispelled any doubts about the HTML output being based on the wrong
part of the token out of my mind.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The work went on like it always does, but an interesting milestone was met with
the completion of this work: any outstanding issues clearly identified as being
attributable to a leaf block has been solved.  Short version?  I finished any
issue that was clearly a leaf block issue.&lt;/p&gt;
&lt;p&gt;While the realization of that goal was not a big thing to me, it wasn’t a small one
either.  It still meant that I needed to check how leaf blocks interacted with the two
container blocks, but it reduced the number of things to check to just interactions
with and between container blocks.  That was a good feeling, knowing I had hit that
mark.  It increased my confidence that things were going in the right direction.&lt;/p&gt;
&lt;p&gt;It is still too early to tell, but I am now starting to hope for an initial release
of PyMarkdown as a linter in the early parts of 2021.  That felt good typing that.
Real good.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the work done to verify the leaf blocks, the next week was going to be full of
me trying to reduce the issues specific to list blocks. Closer to the line I get!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 8</title><link href="https://jackdewinter.github.io/2020/11/16/markdown-linter-delving-into-the-issues-8/" rel="alternate"></link><published>2020-11-16T00:00:00-08:00</published><updated>2020-11-16T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-16:/2020/11/16/markdown-linter-delving-into-the-issues-8/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/09/markdown-linter-delving-into-the-issues-7/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
take a bit of time to focus on adding some depth to the scenario cases table.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I get closer to the end of this initial phase …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/09/markdown-linter-delving-into-the-issues-7/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
take a bit of time to focus on adding some depth to the scenario cases table.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I get closer to the end of this initial phase of the PyMarkdown project, I find
myself measuring the project’s success differently than I did at various points in the
past. Initially the success criteria statement was “does it work at all”.
Then it moved on to “is it implemented for most circumstances”.  Finally, in the last
couple of weeks, it has moved on to the “what did I miss” stage.  And wow, does it
seem like it has taken both a couple of weeks and almost a year at the same time.&lt;/p&gt;
&lt;p&gt;While this phase might seem boring to other people, people that are Testers or
Automation Developers&lt;sup id="fnref:SDET"&gt;&lt;a class="footnote-ref" href="#fn:SDET"&gt;1&lt;/a&gt;&lt;/sup&gt; often enjoy times like these because of two words:
exploratory
testing.  Our job is to make sure the thing we are testing is working properly. To
a lot of us, exploratory testing is basically like leaving a kid in a room filled with
hundreds of opened
&lt;a href="https://www.lego.com/"&gt;LEGO&lt;/a&gt;
sets and saying to them “show me what you can build!”  It is in those times that we
get to “play around” and experiment.  We use that time to try and understand where the
issues are, and which scenarios give us the most benefit to test for the least cost.
And as this phase is closing, this type of testing is pivotal in being able to close
out the phase cleanly and with confidence.&lt;/p&gt;
&lt;p&gt;And as I have mentioned before, testing and test automation is not about trying to break
something, it is about reducing the risk that the user of the product will experience
that thing breaking.  That is where my recording of the bulk testing in the scenario
cases tables comes into play.  Instead of looking for one issue at a time, those tables
take a group of concepts and test them as a single group.&lt;/p&gt;
&lt;p&gt;I have found that the benefits of that approach are twofold.  The first benefit that
I have experienced is an increase in confidence.  This is an easy one to
explain, as I can concretely point to a collection of tests along a theme and know that
any scenario along that theme is working properly.  The second benefit is one of
economy.  The cost
of finding an individual issue is expensive.  It takes exploration or debugging to find
the issue in the first place, with the extra debugging and logging to try and figure
out what the issue really is, followed by the extra work required to fix the issue. That
ends up being a lot of time.  By amortizing the work over an entire group of tests,
that cost is drastically reduced.&lt;/p&gt;
&lt;p&gt;Having experienced these benefits on this project, I decided to dedicate a weeks’ worth
of work to adding to the table, to increase my confidence and to accelerate my journey
to having a shippable project.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c467c617da4ca9e03457b18c9795d6fff7dceb65"&gt;27 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/e1d9b9e016b799f5bc11670f21d8008e1c0cd967"&gt;31 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="linksimages-and-other-inline-tokens"&gt;Links/Images and Other Inline Tokens&lt;a class="headerlink" href="#linksimages-and-other-inline-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The easy part about coming up with a theme is the title of the theme itself.  For the
Series J theme, it was easy an easy theme to identify: Link/image elements followed by
various other inline tokens.  In the
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/main/scenario-cases.md"&gt;scenario-cases.md&lt;/a&gt;
file, that description is right there after the name of the series.  But the hard part
of a theme is the act of trying to make sure that each scenario that you want in that
theme is present.  And often, I miss the mark.&lt;/p&gt;
&lt;p&gt;When I originally added Series J to the document, I thought that I had added each of
the qualifying inline elements to the group.  Going through the list in my head, I
thought I had each of those newlines added when I created the group.  But in retrospect,
I did not have the right viewpoint as I missed a large part of that group: internal
versions of the scenarios I had already added.&lt;/p&gt;
&lt;p&gt;I came about this when looking at the J8 test and experimenting by creating two
new tests:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;J9&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="n"&gt;emphasis&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;nnk&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;ndef&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test_paragraph_extra_e1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;J9i&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="n"&gt;emphasis&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;nnk&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;ndef&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test_paragraph_extra_e2&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whereas the other tests in the Series J group focus on the inline elements after the
Link elements and Image elements, I wanted to experiment with performing the same
process on those token’s link labels, inside of the tokens.  And that experimentation
bore fruit.  The J9 test failed in the consistency check with an overcount on the
line number.  After a quick debugging session, I discovered that the &lt;code&gt;rehydration_index&lt;/code&gt;
that I have mentioned in previous articles was being added to, both in the link label
and in the Link’s encapsulated tokens.  It was just a simple fix from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;link_stack&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After that quick fix, the issue was addressed.  But it outlined something to me that I
wanted to get back to before the end of the week: inline elements within the link label.
More on that near the end of this article!&lt;/p&gt;
&lt;h2 id="adding-the-series-l-theme"&gt;Adding the Series L Theme&lt;a class="headerlink" href="#adding-the-series-l-theme" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This work was the major focus of the week, focusing on links or images contained within
the link label section of another link or image.&lt;/p&gt;
&lt;h3 id="origin-story"&gt;Origin Story&lt;a class="headerlink" href="#origin-story" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I came up with the idea for this
group recently, I have been thinking about this topic since at least
31 July 2020.  It was at that time that I did the research that I would document in
a section labelled
&lt;a href="https://jackdewinter.github.io/2020/08/10/markdown-linter-adding-links-to-the-markdown-transformer/#example-528"&gt;Example 528&lt;/a&gt;,
followed by the work undertaken to fix that issue, documented in the section
“creatively” labelled
&lt;a href="https://jackdewinter.github.io/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/#fixing-example-528"&gt;“Fixing” Example 528&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That scenario test, encapsulating the GFM Specification’s
&lt;a href="https://github.github.com/gfm/#example-528"&gt;example 528&lt;/a&gt;,
is a bit contrived but a good example nonetheless.  Given the Markdown document:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;[[foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the expected output is the HTML document:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"uri3"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"[foo](uri2)"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The reason I say that this example is contrived is that I can visualize useful cases of
a Link element within an Image element, I have a hard time coming up with a similar
example for a Link element within a Link element.&lt;/p&gt;
&lt;p&gt;A practical instance of this example is the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;![moon&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;nssdc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gsfc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nasa&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gov&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;imgcat&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;midres&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gal_p37329&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gif&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wikipedia&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;wiki&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Moon&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is rendered as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"https://en.wikipedia.org/wiki/Moon"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"https://nssdc.gsfc.nasa.gov/imgcat/midres/gal_p37329.gif"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"moon"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At the visual level, this HTML provides for a picture of a moon from the NASA
archives.  When
that image is clicked on, the browser goes to the Wikipedia article on the moon.&lt;/p&gt;
&lt;p&gt;Useful
element compositions like this is probably why there are multiple examples of a
Link element within an Image element in the GFM Specification.  However, in that same
specification, only the above example provides for a Link element within a Link element
within an Image element.  As the GFM Specification provides a unified interpretation of
Markdown, Example 528 is presented as a recipe on how to handle cases like that.  My
guess was that if that example was anything other than an outside case, there would be
more examples outlining that pattern.&lt;/p&gt;
&lt;h3 id="formulating-the-test-group"&gt;Formulating the Test Group&lt;a class="headerlink" href="#formulating-the-test-group" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the help of
&lt;a href="https://johnmacfarlane.net/"&gt;John McFarlane&lt;/a&gt;,
I was able to figure out the part of the algorithm that I had misunderstood and fixed
the error.  Having invested all that research and work to fix that one issue, I
wondered if there was a better way to handle issues with examples like that.  That was
when I really started thinking about how to cover all the cases that would lead to
having a good group of tests around Example 528.&lt;/p&gt;
&lt;p&gt;The downside about that exercise was that as soon as I thought about how to cover all
those scenario cases, a couple of negative things got in the way.  The first big one was
&lt;a href="https://github.github.com/gfm/#example-583"&gt;example 583&lt;/a&gt;
and the paragraph that follows it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Though this spec is concerned with parsing, not rendering, it is recommended that in rendering to HTML, only the plain string content of the image description be used. Note that in the above example, the alt attribute’s value is &lt;code&gt;foo bar&lt;/code&gt;, not &lt;code&gt;foo [bar](/url)&lt;/code&gt; or &lt;code&gt;foo &amp;lt;a href="/url"&amp;gt;bar&amp;lt;/a&amp;gt;&lt;/code&gt;. Only the plain string content is rendered, without formatting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, given the Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo [bar&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the specification suggests that the only content that should be used is the &lt;code&gt;foo&lt;/code&gt; text
contained at the start of the Image element’s link label, and the &lt;code&gt;bar&lt;/code&gt; from the link
label of inner Link element.  Therefore, after processing, the resultant HTML is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url2"&lt;/span&gt; &lt;span class="na"&gt;alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"foo bar"&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The downside of this information is that there are at least 64 “simple” combinations of
links inside of links, images inside of images, links inside of images, and images
inside of links.  Those simple combinations are 4 types of links inside of 4 types of
links inside of 4 combinations of link and image elements.  That lays the groundwork
for determining which combinations should be tested to address scenarios like example
528 but does not address example 528-like scenarios.&lt;/p&gt;
&lt;p&gt;Already taking the work required to create a single test for each combination into
account, the bigger downside was going to be the verification of each of those tests.
Increasing the cost of this downside was the possibility of finding issues that needed
to be addressed while the verification phase of the tests was ongoing.&lt;/p&gt;
&lt;p&gt;It was daunting, but I felt strongly that it needed to be done. So, I started working
on identifying the combinations that were needed, and added them to the
&lt;code&gt;scenario-cases.md&lt;/code&gt; file.  It was then that the hard work for this issue would start.&lt;/p&gt;
&lt;h3 id="working-the-issue"&gt;Working the Issue&lt;a class="headerlink" href="#working-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The bulk of the work on resolving this issue was done over 4 days of lengthy
sessions.  To reduce the cost of completing this work, I decided early on to come up
with a simple strategy to hopefully allow me to copy-and-paste tests where possible,
hopefully avoiding extra work.  To that end, I figured that the combination of Link
elements inside of Link elements was the best combination to start with.  I just hoped
that I could reuse a lot of the test code.&lt;/p&gt;
&lt;p&gt;The table that I created in the &lt;code&gt;scenario-cases.md&lt;/code&gt; file was a good tool to create
the tests from, but it lacked any Markdown that I could use as a template.  Keeping
it simple, I started with the Markdown &lt;code&gt;a[foo [bar](/uri)](/uri)a&lt;/code&gt;, and transformed
the Markdown for each scenario from there.  Once I started working with non-inline
Link elements, I added in a simple Link Reference Definition, including link
referenced to that Link Reference Definition and to a non-existent Link Reference
Definition.&lt;/p&gt;
&lt;p&gt;Following my usual pattern, I executed that new test and manually verified the
tokens, before copying them into the test.  After that, I executed the test again
and copied the HTML output into the test, after once again manually verifying that it
looked right.  Even after that step, I used
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;BabelMark&lt;/a&gt;
against the Markdown for each test, comparing my parser’s output against the
&lt;code&gt;commonmark.js&lt;/code&gt; output.  This process was long, drawn out, and tedious… but it
worked.&lt;/p&gt;
&lt;p&gt;The hard part about mentally processing a lot of these combinations is that because
of the rule that Link elements cannot contain Link elements, I needed to do a lot
of tedious parsing of each combination.  It was not as simple as just looking at
the Markdown and quickly knowing what the answer was.  I kept a copy of the GFM
Specifications
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;implementation guide&lt;/a&gt;
open in another window, just to make sure I was doing things in the right order.
Even then, I double checked, and triple checked each transformation being running the
tests, just to make sure I had things done correctly.&lt;/p&gt;
&lt;p&gt;After a couple of days of work in the evenings, I had finished this first
part.  For the other three parts, I was hoping I could leverage the work heavily
to allow me to shave some time off the process.&lt;/p&gt;
&lt;h3 id="completing-work-on-the-issue"&gt;Completing Work On The Issue&lt;a class="headerlink" href="#completing-work-on-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With Link elements inside of Link elements out of the way and committed to the
repository, I started to work on Image elements inside of Link elements.  The big
change here was that while nested Link elements need to be parsed carefully,
the parsing of Image elements inside of Link elements was more natural to me. The
Link token’s link label field contained the “raw” form of the link label, while the
tokens between that token and the end Link token contained a processed version.
With a decent amount of experience in reading Markdown due to this project, I was able
to gain proficiency at those required changes quickly.  It therefore followed
that the verification part of the process went a lot smoother than with nested Link
elements.&lt;/p&gt;
&lt;p&gt;Moving on to nested Image elements was a relatively easy step to take from there.
As the Image elements create their &lt;code&gt;alt&lt;/code&gt; attribute values by processing the link label
instead of encapsulating it (as with Link elements), the two big changes were
easy to consistently apply across each of the new tests.  The first change was to remove
any tokens that were being encapsulated between the start Link token and the end Link
token, replacing them with a single Image token.  The second change was to look at an
example nested Image element and determine what the &lt;code&gt;alt&lt;/code&gt; attribute was going to be.
After the first two or three tests, I started to get pretty good at doing that before
I started verifying the tokens, saving a lot of time.&lt;/p&gt;
&lt;p&gt;Finally, completing the group with the Link element inside of an Image element was
almost trivial.  As the different between a Link element inside of an Image element
and an Image element inside of an Image element is one character (&lt;code&gt;!&lt;/code&gt;), the link
labels remained constant between the tests.  As such, only minor changes were
required to these tests after copying them from the previous group.&lt;/p&gt;
&lt;h3 id="dealing-with-relatively-minor-issues"&gt;Dealing with Relatively Minor Issues&lt;a class="headerlink" href="#dealing-with-relatively-minor-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To get all the test passing and verified was a chore, but the good news was that most
of the work was contained within the scenario test process that I have already defined.
Considering the scope of the group of tests, the number of issues found in the non-test
parts of the project were very small.&lt;/p&gt;
&lt;p&gt;To be specific, there was only one change required.  When adding the tests for Image
elements within a Link element, the only change that I needed to do was to change the
expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To be blunt, it was both confirming and unsettling at the same time.  The confirming
part of the process was that I had done the work on the project properly, with only
a very slight change required.  And hopefully it does not sound like I lack confidence,
but it was also unsettling.  After working on scenario tests across an entire theme,
taking three to four days in the process, I somewhat expected the new scenario tests
to find something that I missed.&lt;/p&gt;
&lt;p&gt;I was happy that it did not find anything, do not get me wrong.  It just took a bit of
getting used to.  And it was still a validation of the parser code itself, as the change
was only required in the consistency checks.  After some thought, it sank in that
at this late stage of the project’s initial push, I wanted the results to be exactly
this: the parser was being proved as validly constructed, again and again.&lt;/p&gt;
&lt;h2 id="rounding-out-series-j"&gt;Rounding Out Series J&lt;a class="headerlink" href="#rounding-out-series-j" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Based on the research that I did at the start of the week, I wanted to close out
the week by responding to that research by rounding out the Series J group. As
with my recent work in adding the Series L group of tests, I started out by
scribbling down the combinations that I thought needed to be covered, looking for
gaps that I had missed.  While not a big gap, I added tests &lt;code&gt;J2a&lt;/code&gt; and &lt;code&gt;J2ai&lt;/code&gt; to
fix a small gap where I did not have a newline in the Raw Html element.&lt;/p&gt;
&lt;p&gt;With that initial fix made, the rest of the changes were fairly in scope with the
new test that I documented at the start of this article.  Starting with emphasized
text, I added scenario descriptions and scenario tests encompassing a wide range
of inline tokens, including Hard Line Break elements.  I double checked everything
and then began my usual process of executing and verifying the tests.  And boy was
I glad that I did!&lt;/p&gt;
&lt;p&gt;While it was not a lot of code, I made changes to the &lt;code&gt;__collect_text_from_blocks&lt;/code&gt;
function and the &lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function to properly handle
these new cases.  In the case of both functions, most of the inline tokens were
handled, but the two Autolink inline tokens and the Hard Line Break tokens were not
handled.  While the extra code to remedy these issues was relatively small, it was
a good find.  It felt good that these issues were found directly because of this new
group of scenario tests.  It felt like validation of the approach I had taken.&lt;/p&gt;
&lt;p&gt;From a consistency check point of view, there were only a couple of issues that were
found.  Mirroring the change made for split emphasis at the start of this article,
the &lt;code&gt;__verify_next_inline_hard_break&lt;/code&gt; function was changed to only increase
the &lt;code&gt;rehydrate_index&lt;/code&gt; if the token was not inside of an active Link token.  The
other issue was a small, nitpicky thing: adding the text &lt;code&gt;+ 1&lt;/code&gt; to the output
for the main assert in the &lt;code&gt;__verify_next_inline_code_span&lt;/code&gt; function.  Other than
those two changes, the consistency checks had a clean bill of health.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have to admit that I wondered (out loud, to my dog, who did not help in the discussion
one way or the other) whether this was a good investment of time once the week had
ended.  The broad sweeping groups that I added confirmed that the parser code
was in good shape, as were the consistency checks that watched over that code.  Maybe
it was me still thinking I was in the middle part of the “game” of creating the project,
and not the end game where I believe I am currently at.  But as I mentioned above,
I had both positive and negative emotions about the results.  Happy that things were
going well, but not as trusting of those results as the tests had proved out.&lt;/p&gt;
&lt;p&gt;Taking some time to think about it as I am writing this article, I do think my
descriptions of “middle game” and “end game” are appropriate metaphors to where I
am on the project.  After a long time spent in the middle of the project, I
believe it is just taking me some time for me to switch into the mode where I am
wrapping things up to complete this first phase of the project.  As such, I when I
start that week’s work, I believe that I am going to find more issues than I find,
and then I turn out to be happy when I do not find many issues.  I truly
believe that when I properly switch my mentality to an end game mentality, I will
be expecting the tests to verify the work already done.&lt;/p&gt;
&lt;p&gt;Does that mean the project will be properly tested?  Nope.  If you ask any person
experienced with testing a project that question, they will not give you a solid
answer.  That is not due to lack of confidence, but because there is not one to give.
There will always been edge cases that are not thought of and weird things that can
show up.  It is my belief that you can find most of the issues with any given project,
but it is always a question of when that next issue will show up, and who will find
that issue.&lt;/p&gt;
&lt;p&gt;In both professional life and for this project, my goal is the same.  If not to find
that issue before the customer does, then to make sure I have a solid assessment of
the risk outlined and evaluated.  And with these latest changes in the past week,
I see that measure of risk going down, which is a good thing.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a solid weeks’ worth of “big ticket item” issues resolved, I decided to try
and tackle a lot of the smaller issues.  I just started with a couple of easy ones
and kept on going until I stopped.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:SDET"&gt;
&lt;p&gt;Nomenclature can be everything, and changes from job to job.  From my viewpoint, Testers are people that are very methodical and document what they did, in what order, and what the results are.  Automation Developers like me, a SDET or Software Development Engineer in Test, take documented patterns and results, writing test code and test frameworks to make sure that those scenarios can be written as code which can be used to automatically validate the results.  There are exceptions, but the general rule is that most Testers only have a small amount of the skills required for an Automation Developer, while most Automation Developers are very adept at most of the skills required for a Tester.  Both skill sets are very useful on projects from a quality point of view. &lt;a class="footnote-backref" href="#fnref:SDET" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Autism, Stress, and Anxiety</title><link href="https://jackdewinter.github.io/2020/11/11/autism-stress-and-anxiety/" rel="alternate"></link><published>2020-11-11T00:00:00-08:00</published><updated>2020-11-11T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-11:/2020/11/11/autism-stress-and-anxiety/</id><summary type="html">&lt;p&gt;&amp;ldquo;I don&amp;rsquo;t know.  I really don&amp;rsquo;t know.&amp;rdquo;  Those were the last words I said before a
solid minute&amp;rsquo;s worth of silence.  After being married for seven years, my wife and I
had a &amp;ldquo;heated discussion&amp;rdquo; that was almost an argument.   That was unusual in itself.
But even …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&amp;ldquo;I don&amp;rsquo;t know.  I really don&amp;rsquo;t know.&amp;rdquo;  Those were the last words I said before a
solid minute&amp;rsquo;s worth of silence.  After being married for seven years, my wife and I
had a &amp;ldquo;heated discussion&amp;rdquo; that was almost an argument.   That was unusual in itself.
But even more unusual was that I was at a loss of words.  Her question?  &amp;ldquo;How can I
help?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Now, our marriage is an interesting one already.  I am a software guy with a diagnosed
case of Autism, with an anxiety disorder and sensory overload disorder to boot.  My
diagnosis is such that unless I tell people I have Autism or they know what to look
for, I can often hide under the radar. But even so, it does have significant impacts on
my day-to-day life.  In contrast, my wife is a lawyer that has a heart of gold,
preferring that people play together nicely.  When they don&amp;rsquo;t, she is the one that is
not afraid to step in and do or say what needs to resolve the situation.  But uniting
us together is the fact that we both have big hearts and open minds.  The combination
of that with humor and laughter has always been a major component to our success in
marriage.&lt;/p&gt;
&lt;p&gt;But in this case, I was stumped.  Earlier in the day she had told me that she wanted
to go on a vacation to Florida with her family.  During a pandemic.  On an airplane.
With people she doesn&amp;rsquo;t know around her.  I really didn&amp;rsquo;t know what to say.  I remember
ranting and raving about it, but as to what I said at that moment, I don&amp;rsquo;t
remember too much of that.  It was all a blur.  My logic and my emotions were all over
the place.&lt;/p&gt;
&lt;p&gt;Here is where things get interesting:  I know we have two different points of view
on things like this.  While my wife is weird (heck, she married me!), she is solidly
neurotypical with only a middling amount of introvert.  Even with her being cooped up
in our house since April, she has been going into her workplace once or twice a week
since our state allowed it during the summer.  Even with this, I can tell that not
being able to get out and stretch her legs among people is chewing away at her
sanity.  I know that her going on vacation with her family is a good thing for her. It
is what she needs.&lt;/p&gt;
&lt;p&gt;For me, it is a completely different equation.  Starting with the little things,
going on a vacation with crowds of other people around is just not a lot of fun for
someone with sensory overload disorder.  Trying to mitigate the effects of that disorder
is many times more exhausting than dealing with anything else. Adding to that, my
anxiety disorder and my Autism are acting the part of tag team wrestlers. My Autism
takes the first shot with an elbow, keeping me isolated from groups of people
that I know care about me.  Then my anxiety disorder takes control with an
&lt;a href="https://prowrestling.fandom.com/wiki/Wrestling_throws#Irish_whip"&gt;Irish Whip&lt;/a&gt;,
either complaining that I am getting too little information about the current state
of the pandemic and economy, or too much information.  Then my Autism tags in with a
high-five, hyper-focusing on one little thing that I think I heard or didn&amp;rsquo;t hear.
Finally, my anxiety tags in with a
&lt;a href="https://prowrestling.fandom.com/wiki/Wrestling_throws#Hurricanrana"&gt;hurricanrana&lt;/a&gt;,
trying to figure out all the possible situations that can happen and ways to deal
with each of them. &lt;sup id="fnref:wrestling"&gt;&lt;a class="footnote-ref" href="#fn:wrestling"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;I struggled to figure out what metaphor to use to explain the vicious cycle that
escalates in my head.  While I haven&amp;rsquo;t watched professional wrestling in years, I
believe it is the best metaphor by far.  At its heart, professional wrestling is a
show.  For me to communicate with people every day, I must act a bit to communicate
clearly. Professional wrestling contains the good guys, or
&lt;a href="https://en.wikipedia.org/wiki/Face_(professional_wrestling)"&gt;faces&lt;/a&gt;, and the
bad guys, or
&lt;a href="https://en.wikipedia.org/wiki/Heel_(professional_wrestling)"&gt;heels&lt;/a&gt;.  Just like
in the shows, sometimes my positivity and clarity win, and sometimes my anxiety and
lack of connection with others wins.  And as anyone who has followed wrestling will
tell you, behind the bright white smiles, coifed hair, and shiny outfits are people
that are often hurting doing the thing they love to do.&lt;/p&gt;
&lt;p&gt;Thinking about how to answer that question as I write this article, where am I now? I
still don&amp;rsquo;t know.  I do know that in terms of where I am, I am currently fighting
my own personal wrestling match day-by-day.  There are some days where the good guys
win and some days where the bad guys win.  Some of the days I am acting for my
audience, and some of the days I am trying to be my honest self with them.  Just like a
wrestler needs to understand where they are in the ring relative to the others, I need
to understand where my wife is relative to where she needs to be.  And yes, somedays
I am controlling my anxiety and Autism, and somedays it controls me.&lt;/p&gt;
&lt;p&gt;And forgive me if I it seems like I am singling myself out from the people around me
and the stress they are experiencing.  But there are two things that I feel make a
big difference.  My Autism and anxiety do amplify each other, sometimes out of control.
Also, I don&amp;rsquo;t have the option of resorting to things like alcohol or other things to
help me forget for a while.  Quite the opposite, those things tend to amplify
how I feel even more.  I don&amp;rsquo;t get a break&amp;hellip; but I am okay with that.  This is
something I have dealt with every day of my life, this tug-of-war going on inside of
my head.  Yeah, it is exhausting.  It is so unbearably exhausting at times.  But the
flip side of that is: I know I can handle it.&lt;/p&gt;
&lt;p&gt;While I still don&amp;rsquo;t have a good answer for her question, I am working on it.  What I do
know is that our solutions to how to deal with the stress of this pandemic are
going to be on opposite sides of the spectrum.  As much as it would be a terrible idea
for me to think about, I believe that her flying down to Florida with her family is one
of the better things she can do for herself.  In contrast to her approach, I do know
that a lot of the things that I need to do are small and personal.  More mental
breaks.  Increased exercise.  Making better choices when eating.  No big silver
bullets, just little things that add up over time.&lt;/p&gt;
&lt;p&gt;And I guess that is okay.  The important thing I realized in all this is that we are
asking ourselves the right questions.  &amp;ldquo;How are you?&amp;rdquo;, &amp;ldquo;What are you feeling?&amp;rdquo;, and the
important one: &amp;ldquo;How can I help?&amp;rdquo;  I know I don&amp;rsquo;t have that answer for her on that last
one, I am working on it.  I do know that part of my answer is this article.  It&amp;rsquo;s
making sure others, people with Autism or not, ask themselves, their friends, and their
loved ones those questions.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:wrestling"&gt;
&lt;p&gt;I grew up in Southern Ontario in the 80s.  Yes, I watched wrestling.  Everyone I knew did.&amp;#160;&lt;a class="footnote-backref" href="#fnref:wrestling" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Autism"></category><category term="Autism"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 7</title><link href="https://jackdewinter.github.io/2020/11/09/markdown-linter-delving-into-the-issues-7/" rel="alternate"></link><published>2020-11-09T00:00:00-08:00</published><updated>2020-11-09T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-09:/2020/11/09/markdown-linter-delving-into-the-issues-7/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/02/markdown-linter-delving-into-the-issues-6/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This article is probably going to be a lot shorter than the others in this series.  It …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/11/02/markdown-linter-delving-into-the-issues-6/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This article is probably going to be a lot shorter than the others in this series.  It
is not the case that I did a lot less work, just that there is just a lot less of that
work to talk about.  The bulk of that work was an effort by me to get the extra
groups of scenario tests more organized.  Sometimes the work I do on the project is
easy to describe and takes a lot of words to explain, as usual.  But in this case,
it is just a lot of work that has a short description.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ef7e569ca0710982fe5c4639c055251875bed5b3"&gt;23 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fa955668b6e2e91a0c9a40efab35bf71769223dc"&gt;25 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="keeping-things-organized"&gt;Keeping Things Organized&lt;a class="headerlink" href="#keeping-things-organized" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For most of the time that I have spent on this project, I have maintained a very good
grasp of where things are and what needs
to be done.  Sure, I use the issues list to keep track of all the little things that
I need to fix or check, but I rarely forget about items on the list.  Usually, within
seconds of reading one of the items on the issues list, I remember a good amount of
information about what the problem is and why I added it.  But since the project has
been going on for a while now, I sometimes forget when I added the item to the list.&lt;/p&gt;
&lt;p&gt;When it comes to the scenario tests, it used to be the case that I had an equally solid
hold on the tests and what they covered.  At first it was easy, one example from the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
equals one scenario test.  Then, as I was working through the validation of the parser,
I added some extra scenarios by adding a letter to the end of the parent scenario and
documenting the change.  At that point, there was still a good link between the example
that spawned the new scenario test and the parent of that test.&lt;/p&gt;
&lt;p&gt;And then came the “extras” scenario tests.  Most of them were added to provide
additional testing for the line/column numbers needed for the linter than for the
parser itself.  As the example provided for in the GFM specification are targeted for
parsers, I felt it was totally reasonable to add extra scenario tests to ensure that
the different in testing between the needs of a parser and the needs of a linter were
covered.&lt;/p&gt;
&lt;p&gt;But what started out as a few scenario tests, rapidly grew to a set of tests that
numbered over 140.  The tests are their contents started to get jumbled up in my head
on a frequent basis.  What group of tests was the
test I was just looking at a part of?  Did I cover all the cases within in the group?
Did I miss one?  If I missed one, how could I tell?  It just got more difficult to
keep things clear with each case I added.&lt;/p&gt;
&lt;h3 id="finding-a-solution"&gt;Finding A Solution&lt;a class="headerlink" href="#finding-a-solution" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently, I had added an item to the issues list to start looking at this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;need&lt;/span&gt; &lt;span class="nv"&gt;comprehensive&lt;/span&gt; &lt;span class="nv"&gt;table&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt; &lt;span class="nv"&gt;that&lt;/span&gt; &lt;span class="nv"&gt;qualify&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;each&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt; &lt;span class="nv"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;.&lt;span class="nv"&gt;e&lt;/span&gt;. &lt;span class="nv"&gt;para_extra&lt;/span&gt;
  &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;different&lt;/span&gt; &lt;span class="nv"&gt;groups&lt;/span&gt;, &lt;span class="nv"&gt;links&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;images&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that I had a few weeks to think about it, I believed a solution was in order.  The
first big decision I need to make was to figure out the medium for this table, with
Markdown being the natural selection.&lt;/p&gt;
&lt;p&gt;Creating the Markdown document &lt;code&gt;scenario-case.md&lt;/code&gt; in the root folder, I tried four
or five formats before settling down on the final format. The first column contains a
unique identifier for that test.  Starting with the letter id for the group of tests,
I made sure that the rest of the identifier clearly described what the scenario test
contained using a common id schema.  Following that identifier column are the columns
that contain a short description of the scenario test, the relevant Markdown from the
test, and the actual function name of the scenario test.  Starting by enumerating the
scenario tests for the
&lt;code&gt;test_markdown_paragraph_extra.py&lt;/code&gt; module, I left space for a trailing column that
would also include the function name of the scenario test for the
&lt;code&gt;test_markdown_setext_headings_extra.py&lt;/code&gt; module.&lt;/p&gt;
&lt;h3 id="i-really-needed-this"&gt;I Really Needed This&lt;a class="headerlink" href="#i-really-needed-this" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I finished creating this document as the result of this multi-day task, it
was extremely obvious why I needed it:  there was a lot of information to process.
There were a solid core of groups in the initial document, and by documenting each
group, I easily
found things that I had missed or not completed.  By clearly delineating each group of
tests, it also became a lot easier to see the patterns in the groups and why they were
important.&lt;/p&gt;
&lt;p&gt;First, there were the basic groups, Series A to Series E.  These were simple
foundational tests for the complete set of inline elements.
Series A tested the inline element at the start of a line, followed by text.
Series B and Series C followed those tests by testing the same inline elements with
text around the inline element and text followed by the inline element.  While they
would not be seen that way naturally, Series D provided tests for each inline element
alone in a document by itself.  Finally, Series E extended the Series D tests by
testing those inline elements that can contain a newline character, rounding out the
foundational tests.&lt;/p&gt;
&lt;p&gt;From there there were 4 groups of tests that I had added that all dealt with link
elements and image elements.  The Series F tests provided for a newline character
in each part of all 4 link types.  The Series G tests provided for the same type of
tests but tested for the inclusion of a backslash escape sequence and character
reference sequences.  Due to some issues I encountered with Code Span elements and
Raw Html elements inside of Link Labels, the Series H tests were added to provide
a thorough testing of those combinations.  Rounding out those tests, the Series J
tests provided for various combinations of Inline elements with Link elements and
Image elements, once again added due to some issues that I ran into.&lt;/p&gt;
&lt;h3 id="the-proof-is-in-the-pudding"&gt;The Proof Is In The Pudding&lt;a class="headerlink" href="#the-proof-is-in-the-pudding" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As they used to say
“&lt;a href="https://idioms.thefreedictionary.com/proof+is+in+the+pudding"&gt;the proof is in the pudding&lt;/a&gt;”.
Basically, the only way that I am going to find out if this works or not is by using
it and judging the results.  However, I can say that this initial task
of putting the table together has already yielded positive results.  There were
tests that were duplicated, and there were new distinct tests that were child
tests of existing tests.  Putting that table together helped me clean up the extra
tests by
fixing up those cases.  In addition, it found a missing scenario that dealt with an
inline link type that did not have a title but had whitespace after the URI.  That
scenario is one that I would not have found otherwise.&lt;/p&gt;
&lt;p&gt;I feel the balance point of this work needs to be mentioned, as the cost of putting
this table together was a couple of days’ worth of work.  That cost would have be
spread out over numerous issues
if it was started at the beginning, but at that point, I am not sure if the benefit of
putting this table together is something that I thought would justify the cost.  As a
matter of personal sanity, I try not to do the “what ifs” too often.  From my point of
view, while it might have been better to do this earlier, it was at this point that
I started seeing that it needed to be done.  After I made that observation, it was only
a couple of weeks before I took the time to create the table.  And that time was spent
thinking about how I wanted to organize the table, so it was not wasted time.&lt;/p&gt;
&lt;p&gt;I guess the thing I am trying to say is this: do not kick yourself and do not rush
things. If you can see something ahead of time, and the benefit is worth the cost to
mitigate the issue, then mitigate.  Otherwise, wait until the benefit becomes worth the
cost, plan it out to make sure you can do it cleanly and clearly, and then work on it.&lt;/p&gt;
&lt;h2 id="is-a-character-entity-the-same-as-a-character"&gt;Is A Character Entity the Same As A Character?&lt;a class="headerlink" href="#is-a-character-entity-the-same-as-a-character" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the section of the GFM on
&lt;a href="https://github.github.com/gfm/#entity-and-numeric-character-references"&gt;Entity References&lt;/a&gt;,
the specification is very clear about how Character Entities are to be used:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Entity and character references cannot stand in place of special characters that define structural elements in [Markdown]. For example, although * can be used in place of a literal * character, * cannot replace * in emphasis delimiters, bullet list markers, or thematic breaks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To be blunt, you cannot get clearer than that.  If you want the Markdown document to
be interpreted properly, your document must use the actual character used to invoke the
behavior you want, not a character reference.&lt;/p&gt;
&lt;p&gt;For the most part, I was very comfortable with that, and I was sure that I had adhered
to that rule throughout the parser.  When it came to the newline character, I
was not as confident.  I was pretty sure that if I tested all the inline elements with
the character entity newline, that the HTML output would look correct.  However, while
I was sure that I properly handled most of the cases, I was not as sure that I had
properly handled all those cases.  Therefore, enter Series K.&lt;/p&gt;
&lt;p&gt;To get this series started, I began with the Link elements.  Starting with the inline
Link element, I enumerated the 7 places where the character entity &lt;code&gt;&amp;amp;#xa;&lt;/code&gt; could be
inserted, followed by the 2 places for the full Link element and 1 a piece for the
shortcut Link element and the Collapsed Link element.  Once that was in place, I
duplicated those scenarios, transforming the Link elements into their equivalent
Image elements.  Finally, I added cases for the Emphasis element, the Code Span element,
the Raw Html element, and both Autolink elements.&lt;/p&gt;
&lt;p&gt;With a total of 27 new scenarios to cover, I started to work on creating these scenario
tests, one at a time.  As with other tests I have documented in previous articles, I
was very precise and meticulous with the creation of those tests.  When each test was
created, I gave it a manual check before testing it against the parser’s HTML output,
but only after running the Markdown against
&lt;a href="https://johnmacfarlane.net/babelmark2"&gt;BabelMark&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the end, 11 of those new scenario tests resulted in failures, with 16 of them passing
right away.  But at that point, it had taken me most of the day to add and verify the
tests, along with all the things that life threw at me that Saturday.  A bit
reluctantly, I committed those tests as-is, after adding 11 new items to the issue list
to track those tests I needed to finish.  Then I went to sleep.&lt;/p&gt;
&lt;h2 id="finishing-up-the-series-k-tests"&gt;Finishing Up the Series K Tests&lt;a class="headerlink" href="#finishing-up-the-series-k-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a good night’s sleep, I took a look at that week’s article notes.  I figured
that the article notes were in a good enough state for me to look at those 11 new items
I added
the night before.  Planning out my work to address those issues, a couple of things
leapt out at me.&lt;/p&gt;
&lt;p&gt;The first thing that I noticed was that while I had added some good tests for the link
types, I had
not varied the type of character entity or numeric entity that I used in place of
the newline character.  While I was confident it had been covered in the base GFM
Specification, I believed that for completeness it would be good if I also added it
in this group of tests.  When I was done fixing that, there were 14 new tests in
the table, 7 new tests for Link elements and 7 new tests for Image elements.  In
addition, there was 3 extra scenario tests that I added to complete the coverage
for the other inline elements.  When that work was done, the Series K group contained
42 tests.&lt;/p&gt;
&lt;p&gt;The other thing that I did not realize the day before was that the failures were nicely
bucketed into three groups: one that failed in the &lt;code&gt;InlineProcessor&lt;/code&gt; class, ones that
failed in the &lt;code&gt;__verify_next_inline_handle_previous_end&lt;/code&gt; function, and ones that failed
in the &lt;code&gt;__verify_next_inline_text&lt;/code&gt; function.  While it would have been nice if they
all had the same root cause, three different causes to examine was still better than
eleven!&lt;/p&gt;
&lt;h3 id="attacking-the-parse-failure-cases"&gt;Attacking the Parse Failure Cases&lt;a class="headerlink" href="#attacking-the-parse-failure-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As luck would have it, this was the easiest problem to fix.  In the code for the
&lt;code&gt;__calculate_inline_deltas&lt;/code&gt; function, there was an assert statement as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;link_part_index&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Newline in link token not accounted for."&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When I originally added this code, I was being defensive, thinking that I had not
properly
handled a newline character occurring in the link label part of the Link element and
the Image element.  It took me a bit of time and some extra debug scenarios, but
I was able to conclusively prove that newline character in link labels were already
been handled by another part of the code.  As such, I was able to comment out that
assert and resolve two out of the eleven failures.  On the the next one!&lt;/p&gt;
&lt;h3 id="properly-handling-split-lines"&gt;Properly Handling Split Lines&lt;a class="headerlink" href="#properly-handling-split-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After a bit of looking at the remaining tests, one pattern leapt out at me.
Immediately, it looked like the line/column numbers being calculated by the parser were
correct, but the same calculation for the consistency checks was off.  With only
a small amount of looking at the problem, the cause for that result became obvious
to me almost immediately.&lt;/p&gt;
&lt;p&gt;When any of the character entities or numeric entities are used in a normally
processed part of the document, a replacement sequence is placed within the token
to represent that sequence.  For the Markdown generator, the original entity is
persisted, and for the HTML generator, the replacement text is persisted.  This
is performed by using a replacement sequence such as &lt;code&gt;\a&amp;amp;#xa;\a\n\a&lt;/code&gt;, making it
clear which part is “what is replaced” and which part is “what it is replaced with”.&lt;/p&gt;
&lt;p&gt;And therein lied the problem.  In the &lt;code&gt;__verify_next_inline_text&lt;/code&gt; function, the
&lt;code&gt;current_line&lt;/code&gt; variable is split as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;split_current_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there, each part of that split line is processed.  But due to the above
replacement sequence,
each entity sequence like &lt;code&gt;&amp;amp;#xa;&lt;/code&gt; generates another entry in that list.  Now, if the
HTML output were being verified, that would work well.  But as the consistency checks
are used to verify the line/column numbers in the Markdown document, those newline
characters confuse the issue.&lt;/p&gt;
&lt;p&gt;I realize that this may seem confusing, so consider a small Markdown document like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;#&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When this document is parsed, the above Python code will generate an array with two
values in it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"a&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;&amp;amp;#xa;&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;b"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If that does look right, it is because it is not right.  It is a faithful interpretation
of the request made to split the string &lt;code&gt;a\a&amp;amp;#xa;\a\n\ab&lt;/code&gt; at its newlines, but it
does not understand that it should only consider the first part of the replacement
sequence, not both the first and the second parts.&lt;/p&gt;
&lt;p&gt;I needed to come up with a way to deal with this issue.&lt;/p&gt;
&lt;h3 id="fixing-the-issue-with-split-lines"&gt;Fixing the Issue With Split Lines&lt;a class="headerlink" href="#fixing-the-issue-with-split-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;That is when I started putting together the &lt;code&gt;__handle_newline_character_entity_split&lt;/code&gt;
function.  Given that array of split lines, this function specifically looks for
any entries that start with the replacement character (&lt;code&gt;\a&lt;/code&gt;), and the previous entry
ends with the first part of the replacement sequence.  Basically, as the data is split
on the newline character (&lt;code&gt;\n&lt;/code&gt;), we want to look for cases where one entry ends with
the &lt;code&gt;\a&amp;amp;#xa;\a&lt;/code&gt; part of the sequence and the following entry starts with the &lt;code&gt;\a&lt;/code&gt; at
the end of that sequence.&lt;/p&gt;
&lt;p&gt;When it was all said and done, the function looked like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__handle_newline_character_entity_split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;try_again&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;try_again&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;try_again&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
                &lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__create_newline_tuple&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
                &lt;span class="n"&gt;combined_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;combined_line&lt;/span&gt;
                &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;search_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="n"&gt;try_again&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;split_current_line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After testing this new function with a single scenario test, I execute all the failed
tests again, and was rewarded with only four failing tests.  Time to buckle down
and get the last ones taken care of.&lt;/p&gt;
&lt;h3 id="cleaning-up"&gt;Cleaning Up&lt;a class="headerlink" href="#cleaning-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With four tests remaining, I was ready to put in a lot of work to figure out what
the problem was.  I made sure I had a good snack and a big glass of water, turned
on the debug logging output for some of the tests, and
proceeded to look at the failed scenario tests and the scenario tests that were
around them and were passing. &lt;/p&gt;
&lt;p&gt;The first issues I noticed in the failed tests were in the
&lt;code&gt;__verify_next_inline_handle_current_end&lt;/code&gt; function, where the number of newlines
characters are counted.  Looking at the difference between the reported line numbers
and the calculated line numbers, there was a direct correlation between the number
of entity sequences used and how much the reported difference in line numbers.  Having
seen this pattern many times before,
it was easy for me to see that instead of using fields in this manner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;newline_count4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I needed to change that to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;pre_link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;pre_link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;

        &lt;span class="o"&gt;...&lt;/span&gt;

        &lt;span class="n"&gt;newline_count4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After a quick check against the tests, it was obvious that there were also some
issues with the &lt;code&gt;__verify_next_inline_handle_previous_end&lt;/code&gt; function, of the same
type.  Looking at that function, I needed to do the same with the &lt;code&gt;link_uri&lt;/code&gt; field
and the &lt;code&gt;pre_link_uri&lt;/code&gt; field that I did in the above example with the &lt;code&gt;link_title&lt;/code&gt;
field and the &lt;code&gt;pre_link_title&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;While verifying those changes, I did notice that there was an omission that was not
tested.  In cases where an inline link contains an URI that is inside of “angle
brackets” (&lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;), I was not adjusting the counts to accommodate for that.
After adding an extra test or two, the solution to this was easy, adding
the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;did_use_angle_start&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;part_3&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the &lt;code&gt;__verify_next_inline_handle_previous_end&lt;/code&gt; function.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There were a couple of times during the creation and validation of the scenarios
table that I wanted to give up.  It was a large body of work with no immediate
validation of its correctness.  It was also a body of work that could easily fall
out of sync with the actual scenario tests themselves, so there was the future work
to maintain and revalidate the table to consider.&lt;/p&gt;
&lt;p&gt;But still, that table was, and still is worth it!  I emphatically believe this with
few reservations, if any.  I do agree that I need to be careful in concluding about
whether to add a scenario test or two versus adding a new scenario
test group.  That is a no-brainer.  But this is another tool that I have in my toolbelt
to help me make sure the quality of the PyMarkdown project is where I want it to be.&lt;/p&gt;
&lt;p&gt;Take the case with the group for the newline character entity sequence.  If I had added
only a couple of tests, I would have wondered if I had captured all the cases.  By
adding the tests as a group of cases, I carefully documented and tested the cases that
I could come up with, but left the door open for more cases to be added at a future
date.  For me, that is a winning proposition for the right kind of scenario tests.&lt;/p&gt;
&lt;p&gt;And as I mentioned above, the proof is in the pudding.  I have already cleaned
up an old assert statement in the Inline Processor, something I would have overlooked
without that group of tests.  In addition, it found at least three issues with the
consistency checks for the line/column numbers, making that watchdog code more complete.
That small step towards completeness of the consistency checks means that I have more
confidence that it will detect any issues that arise when something is changed.&lt;/p&gt;
&lt;p&gt;I know I am getting close to the end of the project, and my goal is to add both
single tests and groups of tests with no changes to either the parser itself or the
consistency checks.  And this work brought me one step closer to that goal!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that I had the master table of scenario tests and their groups together, it
was time to leverage that information and add to it.  That was the focus of
the next week’s work, work that was indeed satisfying.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 6</title><link href="https://jackdewinter.github.io/2020/11/02/markdown-linter-delving-into-the-issues-6/" rel="alternate"></link><published>2020-11-02T00:00:00-08:00</published><updated>2020-11-02T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-11-02:/2020/11/02/markdown-linter-delving-into-the-issues-6/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/26/markdown-linter-delving-into-the-issues-5/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After having a week where I felt like I barely made any progress, it was nice to …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/26/markdown-linter-delving-into-the-issues-5/"&gt;last article&lt;/a&gt;,
I continued in my quest to reduce the size of the issues list.  In this article, I
make good progress in removing items from the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After having a week where I felt like I barely made any progress, it was nice to get
a week where I was able to get some work done while keeping balance with my personal
life.  For some reason, the stop-and-go nature of last week was not repeated this
week, and I was grateful for it.  But this week was not really about any one of
those issues, just getting some good, solid work in to reduce the size of the
issues list.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ea62ec32ce232668df57c232a94d5311cc6107f9"&gt;14 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7ac7e655e3aabe6b220e9ba179f59620284ac9e1"&gt;18 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="finishing-up-the-work"&gt;Finishing Up the Work&lt;a class="headerlink" href="#finishing-up-the-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a day’s rest from writing that week’s article, I looked at my notes and noticed
there was one little issue that was left over from the last weeks’ worth of work:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- test_paragraph_extra_b5 - adding extra newline somewhere, possibly not clearing after previous image?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, I was not able to get the &lt;code&gt;test_paragraph_extra_b5&lt;/code&gt; function to pass before
the end of the previous week, so I marked it with &lt;code&gt;@pytest.mark.skip&lt;/code&gt; to disable the
test until I could look at it.  Not wanting to leave things undone, this was the number
one thing on my list for this week.&lt;/p&gt;
&lt;p&gt;Looking at the Markdown document and the HTML output, everything looked fine.  It was
when I looked at the tokens and saw the issue that it came flooding back to me: there
was a problem with the newlines.  Specifically, there was a problem with the Text token
following the test document’s Image token:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="s2"&gt;"[text(3,19):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;def::&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s2"&gt;]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If things are working properly, the number of newline characters in the text field is
equal to the number of new characters in the extracted field.  In this case, the text
field contains one newline character, but the extracted whitespace contains two newline
characters.  And once I saw that pattern, I was able to see it in other similar tests.
In total, there were 16 Paragraph token tests and 12 SetExt Heading token tests that
exhibited this behavior.  The key was that in each case, the Text token followed an
Image token and preceded the end of block token.&lt;/p&gt;
&lt;h3 id="digging-in"&gt;Digging In&lt;a class="headerlink" href="#digging-in" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now I had a pattern, so it was time to fix it. I started by turning the debug log on and
working my way through the data for the test.  There was a substantial amount of data,
but using my experience on the project, I was able to quickly narrow the search to
something
in the inline processing section.  Taking a look at the tokens produced right before
the inline processing started, everything looked right.  I then decided to focus on the
inline processing based on that information.&lt;/p&gt;
&lt;p&gt;Digging into the Inline Processor, I followed the processing along token by token,
right up to and including the Image token and everything looked fine.  Even the
processing for the Text token itself looked fine if it was not for that extra newline
character in the extracted whitespace field.  To narrow down where that character was
being added,
I started with some debug to log the tokens at various stages of the processing,
and the data confirmed my previous statement.  From a token point of view, everything
looked perfect.&lt;/p&gt;
&lt;p&gt;To me, that just left the tidying up after the tokens.  Because of the way the parser
is designed, the inline text is accumulated until an inline token is required.  Once
that token is created, the parser then grabs all the characters up to the start of that
token, creates a Text token with that information, and adds it before adding the new
token.  I stared at the code that created the token, and wondered what the problem
could be.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;inline_blocks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;TextMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;current_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;starting_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;end_whitespace&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;end_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;last_line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;last_column_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was on a hunch more than anything else that I decided to look at the &lt;code&gt;end_string&lt;/code&gt;
variable. This variable is where the extra whitespace stripped from the end of the line
is stored. Looking at this variable’s impact on the logs, I noticed a couple of “holes”
that I filled with extra debug log statements.  It was with that information that I was
able to pinpoint that along the way to the creation of that Text token, the extra
newline character was appearing.  Tracking backwards, it soon became clear that the
issue was that the &lt;code&gt;end_string&lt;/code&gt; was being assigned that newline character, but it was
not been cleared properly.&lt;/p&gt;
&lt;h3 id="fixing-the-issue"&gt;Fixing the Issue&lt;a class="headerlink" href="#fixing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After about 45 minutes of additional debugging and fiddling, the answer final came to
me.  When the &lt;code&gt;inline_response.consume_rest_of_line&lt;/code&gt; field was set, four different
fields and variables were being reset.  The thinking here was that if the different
handlers indicated that they had consumed the rest of the data on the line, there
was not anything else to do.  But one thing was forgotten: the resetting of the
&lt;code&gt;end_string&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Sometimes a fix is rewriting some logic, and sometimes a fix is adding some new logic to
handle a missed case. This time, the fix was just about completing the reset action.
Adding a single line in the &lt;code&gt;if inline_response.consume_rest_of_line:&lt;/code&gt; block was
all that was needed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;end_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Anticlimactic that it was only resetting one variable on one line, but that is the way
it sometimes is.  Lots of looking only to find out something small was missed.  With
the research I completed, it did make sense though.  Without that variable being reset
to &lt;code&gt;None&lt;/code&gt;, the newline character from a previous line was being carried through to
the Text token after the Image token.&lt;/p&gt;
&lt;p&gt;Once I verified that the fix worked with that one test, I ran the entire suite of tests
with the new code in place.  Comparing the test failures to the set of 16 Paragraph
token tests and 12 SetExt Heading token tests, there was a 100% match!  After
approximately 3 hours of work, I had found that small but required change!&lt;/p&gt;
&lt;h2 id="being-more-precise"&gt;Being More Precise&lt;a class="headerlink" href="#being-more-precise" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first part of this task was to perform some catch-up work on code coverage.  Having
forgotten to check the coverage with recent changes, I was happy that there were only
two small areas that
I needed to improve on.  Even better, both were cases where I had added defensive
code that was not being utilized.  As such, removing that code from the
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function and the
&lt;code&gt;__complete_inline_block_processing&lt;/code&gt; function returned the code coverage numbers to
their normal levels.&lt;/p&gt;
&lt;p&gt;With that task under my belt, I decided to address an issue that has been bugging me
for a couple of weeks: the &lt;code&gt;rehydrate_index&lt;/code&gt; assert.  Located in the
&lt;code&gt;__handle_last_token_text&lt;/code&gt; function, I have improved this assert over the last few
weeks.  While it started off as a simple “less than” expression, it was now down
to a comparison between the count of newlines in the tokens and the &lt;code&gt;rehydrate_index&lt;/code&gt;
field.  My problem with it?  As improved as it was, it was still checking to see if
the &lt;code&gt;rehydrate_index&lt;/code&gt; field was either equal to &lt;code&gt;num_newlines&lt;/code&gt; or &lt;code&gt;num_newlines + 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As documented in past articles, I have incrementally improved this check to the
point where it was when I started this work.  But the real target was always to get
that assert statement down to a one-part expression.  Specifically, based on its usage,
the goal was to get the statement down to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="debugging"&gt;Debugging&lt;a class="headerlink" href="#debugging" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting the work on this task, the first thing I did was to figure out the amount of
work I needed to do.  In this case, the best way to do this was to make the change
detailed at the end of the last section and look for failures.  While it was not
research in the typical way that I do it, it was useful.  It pointed out that all the
scenario test expect for approximately 15 scenario tests were passing.  This was
useful for both marking a starting point and for my confidence.&lt;/p&gt;
&lt;p&gt;As I started digging into the failures, those tests started to separate themselves
into two distinct groups: those with code spans including newline characters and
Text tokens occurring at the end of Paragraph blocks.  While the work took a long
time, in both cases the process was the same.  I started by isolating one test in the
group I was looking at, then looked at the consistency check output to find a pattern
that made sense.  Then I just kept on drilling and adding debug where needed until
the pattern became visible to me.  Now, as I have been working on this project for
a while, the “until a pattern became visible” to me is guided by experience and
enhanced by luck, and both just take time.&lt;/p&gt;
&lt;p&gt;After a while, the pattern that leapt out at me for the code span tests was simple:
the line number was being updated properly, but the &lt;code&gt;rehydrate_index&lt;/code&gt; field was not
being updated.  Adding some extra debug, I was able to validate that quickly, then
adding the follow code to remedy that problem:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;link_stack&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;num_columns&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having found and fixed that issue, the second group was then easier to see.  Seeing
as a not updated &lt;code&gt;rehydrate_index&lt;/code&gt; field was the issue with the problem, I gave it
a short with this one, and it worked here as well!  Once again, a quick fix solved
the issue.  Executing the tests with the new changes in place, the consistency checks
were now testing against my intended target of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="paragraphs-ending-with-multiline-non-text-inlines"&gt;Paragraphs Ending with Multiline Non-text Inlines&lt;a class="headerlink" href="#paragraphs-ending-with-multiline-non-text-inlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;That title is a mouthful, but accurate.  The next issue that I tackled was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; - repeat __handle_last_token_text with paragraphs ending with other inlines
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I was not sure if this was going to be a problem, but I can see why I added this to
the issues list.  Most of the existing tests were focused on a specific Markdown
element and either ended with that element or text following that element.  Even
harder to find were tests where the element at the end of the block contained a
newline character in the middle of it.  So, while I found an isolated scenario test
here and there that tackled some of these combinations, there was not a good solid
“here it is” block of tests.&lt;/p&gt;
&lt;p&gt;Time to change that!  To address this, I added test functions &lt;code&gt;test_paragraph_extra_c7&lt;/code&gt;
to &lt;code&gt;test_paragraph_extra_d4&lt;/code&gt;.  Quite simply, I added 8 tests, 4 tests for links and
4 tests for images.  Within each group of 4 tests, I added a split Text element,
a split Code Span element, a split Raw Html element, and a split Emphasis element.
It was not rocket science, but it was good to have all those tests in one place,
ensuring that I was addressing that concern.  Even better?  They all worked on the
first try.&lt;/p&gt;
&lt;h2 id="expanding-paragraph-tests-to-setext-heading-tests"&gt;Expanding Paragraph Tests to SetExt Heading Tests&lt;a class="headerlink" href="#expanding-paragraph-tests-to-setext-heading-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a metaphorical bounce in my step after addressing the last issue,  I decided to
tackle the copying and transformation of Paragraph tests to SetExt Heading tests.
While not officially on the issues list, my goal was to keep the extra Paragraph tests
synced up with their cousins, the extra SetExt Heading tests.  I am not sure if the
right term is cousins, but that is how I thought of them, as the only difference between
the two groups of tests was their
parent blocks.  The contents of the tests remaining the same, except for the addition
of a SetExt Heading block terminator.&lt;/p&gt;
&lt;p&gt;As I knew that these tests were based off existing Paragraph tests, it was pretty
simple to go through the new tests and adjust them to use a SetExt Heading token instead
of a Paragraph heading token.  While simple, even the creation of copied test
functions &lt;code&gt;test_setext_headings_extra_a3&lt;/code&gt; to &lt;code&gt;test_setext_headings_extra_d4&lt;/code&gt; took some
time to get right.  But once again, I was rewarded for my hard work with tests that all
passed, with no failures.&lt;/p&gt;
&lt;h2 id="are-links-being-verified-properly"&gt;Are Links Being Verified Properly?&lt;a class="headerlink" href="#are-links-being-verified-properly" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This task was not to solve the following issue, but to research it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- are links getting verified properly in checks? images are, cannot find link code for same
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on previous tasks, I have done extensive work on making sure that any image
links were verified properly.  However, I have previously noticed that the same
rigor had not been applied to the Link token.  While I did not want to solve the
issue right away, I wanted to make sure I had the right information to resolve it
later.&lt;/p&gt;
&lt;p&gt;And it did not take me long to finally figure out why this issue that had been bothering
me for a while.  The big issue here was that I was missing validation in cases where
an end token was present.  Specifically, while the end Emphasis token has a line/column
number attached to it, the end Link token does not.  That meant that when the previous
token validation was occurring, the existing code was doing the equivalent of a digital
shrug and letting it go.  That was the real crux of the problem.&lt;/p&gt;
&lt;p&gt;Additionally, the Image token was of interest.  Doing a double check of my findings, it
became
immediately obvious why it escaped the same fate: it is a whole token.  Whereas the
Link token has a start token, the inner text, and then an end token, the Image token is
entirely self-contained.  As such, everything is processed at one time, and no end token
handling is required, thus the processing for an empty line/column number was avoided.&lt;/p&gt;
&lt;p&gt;It was clear to me that solving this would require some serious planning and thinking.&lt;/p&gt;
&lt;h2 id="adding-proper-link-verification"&gt;Adding Proper Link Verification&lt;a class="headerlink" href="#adding-proper-link-verification" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given the research from the last section, I decided to take the time needed to tackle
that issue properly.  Dedicating a minimum of 4 hours to this task, I sat down and
started to work the problem.&lt;/p&gt;
&lt;p&gt;To keep things simple, I am going to keep track of the pseudo-code for this solution
instead of the actual code.  While it is true that the code needs some major refactoring
to occur, the more important reason is that it is just very verbose.  The big reason
for me to relay this information is that I found this useful during my development
of the solution.  While the algorithm at its base components is simple, I just found
keeping it in my head in a clear and concise form was too much.&lt;/p&gt;
&lt;h3 id="step-1"&gt;Step 1&lt;a class="headerlink" href="#step-1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first issue was that I needed to have an anchor to base the consistency check’s
line/column numbers from.  As the end Link token does not have a line/column
number associated with it, I first needed to add some code to look backwards in the
token stream for the first valid line/column number.   While I was initially worried
about possible interactions between the end Emphasis token and the end Link token,
I eventually determined that exploring that path was a dead end.  Because the end
Emphasis token has a line/column number, it can serve as an anchor token just as
well as any other token.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;search&lt;/span&gt; &lt;span class="nv"&gt;backwards&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;have&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;valid&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="step-2"&gt;Step 2&lt;a class="headerlink" href="#step-2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that anchor in place, it was then possible to apply the translations to the
line/column number.  This was mostly due to how the link is constructed.  In the
case of a simple inline link such as &lt;code&gt;[link](/url)&lt;/code&gt;, the &lt;code&gt;[&lt;/code&gt; is processed,
then the link label text &lt;code&gt;link&lt;/code&gt;, and then the rest of the link text.  When the
end Link token is encountered, the remaining text &lt;code&gt;](/url)&lt;/code&gt; needs to be accounted
for.&lt;/p&gt;
&lt;p&gt;Starting with the code for the handling of the Image token, I was able to quickly
build up a similar block of code that provided the translations for the line/column
number.  As I had a pattern to work off of, this work went by fairly quickly.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;search&lt;/span&gt; &lt;span class="nv"&gt;backwards&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;have&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;valid&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;apply&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;translations&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;due&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;rest&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;Link&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="step-3"&gt;Step 3&lt;a class="headerlink" href="#step-3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that work in place, I then went to handle the previous token in the normal
case and hit an issue.  The anchor line/column number did not seem to be correctly
calculated. I double checked my code, and everything looked fine.  Doing some
deep digging, I started to understand why.  When I figured out which token to use as
the anchor, I did not take into account any changes introduced
to the line/column number by the anchor token itself.  Basically, if I was
using a Text token containing &lt;code&gt;text&lt;/code&gt; at &lt;code&gt;(2,7)&lt;/code&gt; as an anchor, I was using that
&lt;code&gt;(2,7)&lt;/code&gt; as the starting point, ignoring any changes introduced by its contents.
Instead, I needed to use &lt;code&gt;(2,11)&lt;/code&gt; as the starting point, taking the length of
the token’s original Markdown into account.&lt;/p&gt;
&lt;p&gt;The saving grace here was that immediate calculations were okay, so I just added the
code following the previously added code.  While it does not affect the results, in
hindsight I might want to move the translation code for the anchor token up to make sure
that the code logically flows better.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;search&lt;/span&gt; &lt;span class="nv"&gt;backwards&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;last&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;have&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;valid&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;anchor&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;apply&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;translations&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;due&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;rest&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;Link&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;apply&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;translations&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;column&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;due&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;anchor&lt;/span&gt; &lt;span class="nv"&gt;token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="testing-the-changes-and-further-adjustments"&gt;Testing the Changes and Further Adjustments&lt;a class="headerlink" href="#testing-the-changes-and-further-adjustments" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having executed an isolated scenario test or two during these changes, I then went to
execute those tests again, and the results were hopeful.  From what I could see, the
line/column number calculations
were working properly, but another assert was getting fired.  After a quick check,
I came to an interesting observation: while looking at the line/column numbers and
making sure they were being adjusted properly, I totally forgot about the
&lt;code&gt;rehydrate_index&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;Most of the adjusting went off without a hitch, but a couple of outlying tests
were still failing with the assert for the &lt;code&gt;rehydrate_index&lt;/code&gt; field.  It took me
a good couple of hours of adding debug statements and scanning the consistency
check output before I found the pattern.  While I had just added code to adjust
the &lt;code&gt;rehydrate_index&lt;/code&gt; field to account for the Link token, I had failed to adjust
the field to account for the anchor token.  As such, if the token before the end
Link token (the anchor token) contained one or more newline characters, those
newline characters were missed.&lt;/p&gt;
&lt;p&gt;Fixing that problem took a bit of creativity.  I already had the code to properly
calculate the proper values, but they were in the &lt;code&gt;__process_previous_token&lt;/code&gt; function.
The problem with reusing that function was that it modifies the &lt;code&gt;rehydrate_index&lt;/code&gt; field
as a side effect, something I was not sure that I wanted to happen.  In the end, I
worked around this problem by doing a sample call to the &lt;code&gt;__process_previous_token&lt;/code&gt;
function and getting the change in the line number, then invoking that function
again on the anchor token, applying the proper change and restoring the
&lt;code&gt;rehydrate_index&lt;/code&gt; field.  It took a while to figure that out and get it working, but
it was worth it.&lt;/p&gt;
&lt;p&gt;With that code in place, I ran those tests again, and the consistency checks for
the small sample of tests I was using passed.  Crossing my fingers, I ran it for
the entire set of scenario tests and was happy to see that they all had passed.
While it took quite the while to accomplish, it was good to finally put that issue
to rest.&lt;/p&gt;
&lt;h2 id="needing-some-extra-emphasis"&gt;Needing Some Extra Emphasis&lt;a class="headerlink" href="#needing-some-extra-emphasis" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the description for this issue was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- add verification for links with the endlink as the last element
- add verification for links+emphasis as the last 2 inline elements
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I felt that it really did not describe the problem properly.  Added when addressing
the previous issue, what I believe I was trying to note is that I wanted more
testing with the interaction with the end Link token and the end Emphasis token.  At
the time when I added that note, I remember thinking that there might be some weird
interaction between the two end tokens.  It was only later that I remembered that the
end Emphasis token was the rare end token that has a line/column number attached to it.&lt;/p&gt;
&lt;p&gt;Still, it made sense to add some extra tests for emphasis and interactions with the
link tokens, as I did not believe I had good coverage of that so far.  To remedy that,
I added test functions &lt;code&gt;test_paragraph_extra_d7&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_e0&lt;/code&gt;, with
emphasis around the the link and image elements followed by emphasis within the link
label of the link and image elements.  These tests were not at all complicated to add
and I am also not sure they are actually needed.  However, as I perceived testing in
that area to be a bit thin, adding those tests just seems to me to be a good idea.
And luckily, after running those new tests, everything passed without incident.&lt;/p&gt;
&lt;h2 id="just-before-the-end"&gt;Just Before the End&lt;a class="headerlink" href="#just-before-the-end" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I remember looking at the clock and noticing that I had around 20 minutes left before I
started writing that week’s article at noon.  While I used to start writing first thing
Sunday morning, as
of recently I have tried to keep my notes in a way that I could more easily mine them
for the articles.  Still in the proving stage, it has helped me out with the writing
process, allowing me to find my flow more easily on Sunday at noon when I now start
writing.&lt;/p&gt;
&lt;p&gt;Anyhow, with somewhere near 20 minutes left before noon on a Sunday and me wanting to
milk the clock for every minute that I could, I quickly looked at the issues list.
I was hopeful that I could find some
&lt;a href="https://www.merriam-webster.com/dictionary/low-hanging%20fruit"&gt;low-hanging-fruit&lt;/a&gt;
to work on in the time remaining, and quickly came across this little gem:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- code span
  - multiple lengths of ticks, whitespace
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I felt that this was a good candidate, but I still needed to investigate it.  At the
very least, I could get the research done and have it ready for next week.&lt;/p&gt;
&lt;h3 id="the-research"&gt;The Research&lt;a class="headerlink" href="#the-research" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After some quick research, I found out that while the scenario tests between (and
including) the &lt;code&gt;test_code_spans_338&lt;/code&gt; function and the &lt;code&gt;test_code_spans_359&lt;/code&gt;
function has some interesting variations, I felt that they were missing some basic
coverage.  Looking at those tests, it was pretty evident that tests with variations
on the number of backticks and the amount of whitespace were in the minority.  Doing
some quick scans for the number of backticks in the tests, my suspicions were confirmed
with only 4 tests dealing with double backticks and no tests dealing with more than two
backticks.  As for whitespace, the tally was similar: 5 tests with one whitespace
character and 1 test with 2 whitespace characters.&lt;/p&gt;
&lt;h3 id="fixing-the-issue_1"&gt;Fixing the Issue&lt;a class="headerlink" href="#fixing-the-issue_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that research in hand, I could either document the issue more thoroughly, or fix
the issue.  Looking back at the description of the issue, I inferred that what I was
really looking for was a centralized place where those tests kept, not having to look
for them all over the place.  If that were the case, I figured I could solve the issue
by adding 3 new tests, so I decided to fix the issue.&lt;/p&gt;
&lt;p&gt;The 3 new tests?  I started with the text &lt;code&gt;aa`aa`aa&lt;/code&gt;, adding one backtick and
one whitespace in critical areas to get &lt;code&gt;aa `` aa `` aa&lt;/code&gt; and then finally
&lt;code&gt;aa  ```  aa  ```  aa&lt;/code&gt;.  I just kept it simple and created 3 new tests, each
one clearly handling an increasing number of backticks and whitespace.   A quick
execution of the new scenario tests, and… no issues.  Assuming my inference was
correct, problem solved!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there were only a couple of issues that made me really think about how
to solve them, this was a good week for just getting some issues taken care of.
At this point in the project, I am confident that I have 95 percent of the
code working properly.  My hope is that by adding new tests and making sure
that existing tests are grouped properly, I can find those outlier scenarios
that I have not thought of.  Whether those scenarios end up working or failing
is something I cannot control.  But I can strive to find as many of those
scenarios as possible.&lt;/p&gt;
&lt;p&gt;And I have noticed that this hope is being largely reflected in the work I am
doing.  Less and less work is in the project’s parser itself, with more
changes being attributed to improving the verification of the parser.  From where
I sit, that is a good place to be in.  The other observation?  In times when I do
need to change the parser, those changes are usually small changes of five lines or
less.  That statistic alone fills me with confidence.&lt;/p&gt;
&lt;p&gt;Now, while I do want to find as many scenarios as possible, I need to balance that
with trying to wrap up the initial phase of this project so I can use it and get the
project out there.  For me, that means I need to start buckling down and shifting
my focus away from issues in the “Nice to Have” category and work on the other
issues.  Here’s hoping I can action on that!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From my viewpoint, next week’s article will be interesting as I talk about my
efforts to group the tests together more concisely, with documentation to back
up the reasons for those tests.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 5</title><link href="https://jackdewinter.github.io/2020/10/26/markdown-linter-delving-into-the-issues-5/" rel="alternate"></link><published>2020-10-26T00:00:00-07:00</published><updated>2020-10-26T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-26:/2020/10/26/markdown-linter-delving-into-the-issues-5/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/19/markdown-linter-delving-into-the-issues-4/"&gt;last article&lt;/a&gt;,
I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To be totally honest with any readers, the work …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/19/markdown-linter-delving-into-the-issues-4/"&gt;last article&lt;/a&gt;,
I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To be totally honest with any readers, the work that I did for this article was just
more of the same stuff.  Basically, look at the
&lt;a href="https://github.com/jackdewinter/pymarkdown/blob/main/readme.md"&gt;issues list&lt;/a&gt;,
find something to work on, and work on it.  However, as of late, I have been trying to
find groups of issues to work on, instead of one-off items.  As such, I was looking
for issues that could help me resolve questions about a group of behavior for the
project, not just a very specific behavior.&lt;/p&gt;
&lt;p&gt;And to continue to be honest, this work was done during a difficult week for me.
With things to do around the house, I did not seem to get any really good stretches
of time to work on the project until later at night when I was tired.  It was just
one of those weeks.&lt;/p&gt;
&lt;p&gt;But even though I was tired, I wanted to continue.  While I would have been ecstatic
to continue working with great velocity, what I needed to do was to maintain forward
momentum.  That meant picking items from the issues list that I could work on in
phases, keeping that momentum up from phase to phase.  That is why I wanted to focus
on items I could deal with as a group.  It was a good way to keep working, while not
feeling I was forever stopping.  For me, it was not about doing the work as much as
maintaining the feeling that the work was progressing.  That is what was important to
me.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/98e691cc253e03769acecf087e546f0b90507e23"&gt;07 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/59c624c08a7fe6f9f3072123c5ec9beac8e5c6ad"&gt;11 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-with-some-cleanup"&gt;Starting With Some Cleanup&lt;a class="headerlink" href="#starting-with-some-cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As usual, there were some issues left over from the previous week that I needed to
take care of.  While not pivotal to my efforts going forward, I spent a brief amount of
time going through the &lt;code&gt;Bugs - General - Uncategorized&lt;/code&gt; section of the issues list,
making sure to remove anything that had already been done. This effort was mostly
done for reasons of cleanliness and accuracy, though I will admit that getting rid of
a handful of items that had been completed was good for my confidence.&lt;/p&gt;
&lt;p&gt;In addition, during the prior week’s testing, I had added functions
&lt;code&gt;test_fenced_code_blocks_099k&lt;/code&gt; and &lt;code&gt;`test_fenced_code_blocks_099l&lt;/code&gt; to test out
different counts of multiple blank lines within a fenced code block.  As those tests
passed and seemed useful, I decided to keep them in the test suite, but did not have an
issue to tag them with.  It just made sense to add them at this point, before taking
them any further.&lt;/p&gt;
&lt;h2 id="ensuring-consistent-paragraphs"&gt;Ensuring Consistent Paragraphs&lt;a class="headerlink" href="#ensuring-consistent-paragraphs" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The work in this section all came from one line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- make sure line/column is tracking text indenting on each line
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not a fantastically descriptive line, but it was there.  And it was enough for me to
understand what it is that I wanted to look at.&lt;/p&gt;
&lt;p&gt;In previous articles, I have talked about how paragraphs are the base building block of
any Markdown document.  Being the default block container for the default inline
element, I would guess that an average of 75% of existing Markdown document blocks are
Paragraph elements.  I have no hard facts to back it up, but as I look at a
representative sample of the articles I have worked on, a
&lt;a href="https://en.wikipedia.org/wiki/Scientific_Wild-Ass_Guess"&gt;SWAG&lt;/a&gt; leads me to think that
75% is a fairly good estimate.&lt;/p&gt;
&lt;p&gt;This perceived predominance of Paragraph elements in Markdown documents influenced
my perception when I was designing the token system used by the PyMarkdown project.
To accommodate this perception, I decided to place any
newline handling elements in the Paragraph token instead of the encapsulated inline
tokens.  At the time, my thoughts were that the Paragraph element
had rules that were different enough from the 2 header elements, the 2 container
elements, and the 2 code block elements, that I needed to capture the element’s
information differently.  As Paragraph elements largely ignore leading space on a given
line, the Paragraph token seemed to be the right place to store that information.  While
it has caused a couple of issues in the past, I still believe that it is still the right
decision.&lt;/p&gt;
&lt;h3 id="the-issue"&gt;The Issue&lt;a class="headerlink" href="#the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I do believe it was the right decision to make, that decision has added extra
headaches to the project.  The big headache is confirming that the newlines in the
inline token correspond to newlines in the whitespace that is extracted and stored
in the Paragraph token.  That is where the &lt;code&gt;rehydrate_index&lt;/code&gt; field comes in.&lt;/p&gt;
&lt;p&gt;I have talked about it in passing, especially in a previous post in the section
titled
&lt;a href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/#verifying-the-rehydration-index"&gt;Verifying the Rehydration Index&lt;/a&gt;.
In that article, I talk about how I was not sure if there were any errors because
I was not sure that the field was named correctly.  While I concluded that
the field was named correctly, that name can still be confusing at times.  The
&lt;code&gt;rehydrate_index&lt;/code&gt; field
indicates the index of the next newline that will need processing.  As such, once the
processing of any text at the start of a line is done within the bound of a Paragraph
token, that field is updated to &lt;code&gt;1&lt;/code&gt;.  This offset also means that when all processing
for the text within the Paragraph token has been completed, the index should be set to
the number of newline characters plus &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To move towards consistency of this field’s value, I added the following code to the
end of the processing of the end of a Paragraph block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;num_newlines&lt;/span&gt;
            &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"rehydrate_index ("&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;") != num_newlines("&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_newlines&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;")"&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, if the algorithm is at the end of a Paragraph block, any inline elements
contained within the paragraph should have moved the &lt;code&gt;rehydrate_index&lt;/code&gt; field to its
proper value.
However, I needed to add an alternate conditional to handle the case where it was
1 count short.  While that was concerning, it was more concerning that there were some
cases where the &lt;code&gt;rehydrate_index&lt;/code&gt; field even fell short of that adjusted mark.  I felt
it was imperative to get those outliers addressed first.&lt;/p&gt;
&lt;h3 id="addressing-the-failures"&gt;Addressing the Failures&lt;a class="headerlink" href="#addressing-the-failures" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In debugging, it is not often that an answer almost literally jumps out and screams
“Here I am, please fix me!”  In this case, when I executed the failing scenario tests
and looked at their failures, it was an easy observation to make.  For some
reason, the Text token after a Hard-Line Break token included a newline character in
its text section, but did not include a newline character in its whitespace section.
As a result of that mismatch, the tests failed as the Paragraph token’s
&lt;code&gt;rehydrate_index&lt;/code&gt; field was not set to the correct value when verifying the tokens.&lt;/p&gt;
&lt;p&gt;It took me a while of careful tracing through the logs, but I finally found that in
the handling of the end of the line for a Hard-Line Break token, it was not clearing
the &lt;code&gt;whitespace_to_add&lt;/code&gt; variable in both case.  This code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;whitespace_to_add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was being executed if the Hard-Line Break token was created by multiple space characters
in the Markdown document.  However, if the token was created by the backslash character
at the end of the line, it was not.  Making sure that code was in both branches solved
some of those issues, but every test.  There were still a handful of tests that failed.&lt;/p&gt;
&lt;h3 id="covering-my-bases"&gt;Covering My Bases&lt;a class="headerlink" href="#covering-my-bases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While the tests for the SetExt Headings tokens were all passing, the discovery of
the previous failures inspired me to add some similar tests for the SetExt Heading
tokens.  To do this, I started with the original scenario test,
&lt;code&gt;test_setext_headings_extra_22&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="err"&gt;\\&lt;/span&gt;
&lt;span class="c1"&gt;---&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From there,
I added functions &lt;code&gt;test_setext_headings_extra_22a&lt;/code&gt; to &lt;code&gt;test_setext_headings_extra_22d&lt;/code&gt;
to test the creation of a Hard-Line Break token followed with a Text token.  To start,
I added the first two functions that simply had both forms of creating a Hard-Line
Break token with some simple text following it.  In addition, to make sure that I was
handling the next line’s leading whitespace properly, I added two more variations that
included a single space character at the start of the following line.&lt;/p&gt;
&lt;p&gt;While I am not sure how useful these four tests will be in the future, at the time they
were important.  As I had just fixed some issues with Paragraph tokens and extracted
whitespace, I wanted to make sure that a similar format with SetExt Heading embedded
text did not suffer from a similar problem.&lt;/p&gt;
&lt;h3 id="continuing-forward"&gt;Continuing Forward&lt;a class="headerlink" href="#continuing-forward" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the experience from the last section in hand, I continued to look for the root
cause of the remaining failed tests.  As in the previous section, the tests were
failing with a common theme: newlines that occurred within a Link token.  &lt;/p&gt;
&lt;p&gt;While the solution to this issue was not as easy to arrive at as the solution for
the last section, it was fairly simple to see that the problem had two parts:
the tokens derived from the link’s label, and the main body of the link itself.
Almost as soon as I started looking at the logs, I noticed that the numbers were
off, and I had to dig in a bit deeper.&lt;/p&gt;
&lt;h3 id="digging-deeper"&gt;Digging Deeper&lt;a class="headerlink" href="#digging-deeper" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The way inline links are constructed is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, the token generation algorithms follow the way that the tokens are used to
generate the HTML output, which for that Markdown is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the link label (the text &lt;code&gt;link&lt;/code&gt; in the above sample) may contain any form of inline
text except for another link, that information cannot be contained in its processed
form within the Link token.  Instead, there is a start Link token, followed by the
processed version of the link label, followed up by the end Link token.  From
PyMarkdown’s point of view, the token stream for the above Markdown document is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "[para(1,1):]",
        '[link(1,1):inline:/uri:title::::link:False:":: :]',
        "[text(1,2):link:]",
        "[end-link:::False]",
        "[end-para:::True]",
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unless the Link token contained a newline character somewhere within its bounds,
everything was working properly, and the consistency checks were properly verifying the
tokens.  But when the Link tokens contained a newline character, those properly working
algorithms were not working so well.&lt;/p&gt;
&lt;h3 id="finding-a-solution"&gt;Finding A Solution&lt;a class="headerlink" href="#finding-a-solution" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I knew that this problem had two parts, I figured that the solution needed to have
two parts are well.  I believe that my realization of that conclusion is what enabled
me to shortcut other solutions that did not work in favor of a split
solution that did work.&lt;/p&gt;
&lt;p&gt;The first half of the solution needed to deal with the text contained within the link
label.  While this text is handled in the tokens between the start end end Link tokens,
from a Markdown point of view, it occurs right after the opening &lt;code&gt;[&lt;/code&gt; character of the
link.  The good news here is that adjusting the &lt;code&gt;rehydrate_index&lt;/code&gt; field for each
enclosed token was easily done by adding some simple code at the end of the processing
loop in the &lt;code&gt;__verify_inline&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;The second half of the solution was in the handling the Link token itself.  As the
inside inline tokens come first in the Markdown document, it made sense to handle
the Link part of the solution when the end Link token is processed.  This meant
adding some extra code to the &lt;code&gt;__verify_next_inline&lt;/code&gt; function, processing the
end Link token at the top of the function if the &lt;code&gt;current_line_token&lt;/code&gt; line/column
numbers are both &lt;code&gt;0&lt;/code&gt;.  If the &lt;code&gt;current_line_token&lt;/code&gt; variable is a end Link token
and the code is processing within a Paragraph token, I added new functionality
to calculate the number of newline characters encountered within the Link token
itself.&lt;/p&gt;
&lt;p&gt;Running through this code in my head, and solving some simple issues, I executed
the failing tests again, and was pleased to find that they were all passing.  In
that version of the code, I had four different sections, one for each type of
link.  However, after a quick examination of the code, I believed that the code could
easily be parsed down to one block of code that just gathered the newline counts
from each part.  Eliminating all the other blocks except for the inline block,
I was happy to find out that my guess was correct.  The way I had set up the values
for the other types of links allowed for a more simplified version of the code.&lt;/p&gt;
&lt;p&gt;After a quick check of that guess locally, a full scenario test run confirmed that
there were no ill effects of these changes, I cleaned the code up and checked in
that work for the first part of the week.&lt;/p&gt;
&lt;h2 id="interlude"&gt;Interlude&lt;a class="headerlink" href="#interlude" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It was after this point in the week where it became more difficult to find numerous
good blocks of time to work on the project.  The first day it happened it was not so
bad, but the struggle to find good time to work on the project was draining.  I
knew I had to keep my priorities focused on the other tasks in my life, as they
had priority.  But even so, it was just hard not to get a good block of work done
on the project.&lt;/p&gt;
&lt;p&gt;But I persevered.&lt;/p&gt;
&lt;h2 id="inlines-and-new-lines"&gt;Inlines and New Lines&lt;a class="headerlink" href="#inlines-and-new-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The second half of the week was spent working on clearing up a related item from
the issues list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- need other multiline elements in label and verify
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Piggybacking off the previous item, this seemed like a really good choice to pick off
the issues list.  While the previous work dealt with plain text inside of the link
label, this issue took that work and improved on it.  Instead of just simple text
elements, this work adds testing support for Raw Html tokens and Code Span tokens that
span multiple lines.&lt;/p&gt;
&lt;h3 id="starting-with-tests"&gt;Starting with Tests&lt;a class="headerlink" href="#starting-with-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The start of this work was easy.  I added scenario
test functions &lt;code&gt;test_paragraph_extra_a3&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_c6&lt;/code&gt; to cover all
the new scenarios.  Starting with simple tests, the first three tests that I specified
were a normal link label &lt;code&gt;[li\nnk]&lt;/code&gt;, a code span &lt;code&gt;[li`de\nfg`nk]&lt;/code&gt;, and a raw
html &lt;code&gt;[li&amp;lt;de\nfg&amp;gt;nk]&lt;/code&gt;.  Moving on to variations of those tests, having completed
those tests for the inline link type, I transitioning to examples for the full link
type, the collapsed link type, and the shortcut link type.  Once those variations were
done, I copied each of those tests, replacing the start Link element character &lt;code&gt;[&lt;/code&gt; with
the Image element character &lt;code&gt;![&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Work to setup the tests was also easy, but pedantic.  After a quick survey of the
inline element types, I was shocked to find out that only the three inline tokens
named above allow for newlines with their elements.  It did make the creation of
the tests easier though, so I was happy to find that out.&lt;/p&gt;
&lt;p&gt;And maybe it was just my experience on the project, but the test setup went
smoothly.  I did the research, I figured out what I needed to test, and then cycled
through the variations with speed and accuracy.  Just felt good to have a solid grasp
on the problems.&lt;/p&gt;
&lt;h3 id="starting-with-the-inline-processor"&gt;Starting with the Inline Processor&lt;a class="headerlink" href="#starting-with-the-inline-processor" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From a link point of view, the tests were generating their tokens
successfully.  The Text tokens and Code Span tokens were being handled properly,
passing all their tests.  However,
when the Raw Html token tests were executed, the text &lt;code&gt;text&lt;/code&gt; was being added
to the token stream instead of the Raw Html token.  Having fixed an issue in this area
before, I had a feeling
it was in the &lt;code&gt;__collect_text_from_blocks&lt;/code&gt; function, where link tokens are
translated back into their source text.  After taking a quick look there, it
was somewhat funny to see that I had handled the Code Span token case, but not
the Raw Html token case.  A quick fix, followed by another run over those tests,
and the Link token tests that were failing started working again.&lt;/p&gt;
&lt;p&gt;That left the failing tests that dealt with Image tokens.  While this took a bit
more work, it was roughly the same process as with the Link token.  In this case,
the text for the &lt;code&gt;alt&lt;/code&gt; parameter of the &lt;code&gt;image&lt;/code&gt; tag is created by consuming
the elements generated from the Image token’s label field.  This work is done
by the &lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function, consuming the tokens as the
processing is done.&lt;/p&gt;
&lt;p&gt;The main difference with this process from the link process is that, according to
the GFM specification, this text is preserved largely without any of the special
characters.  As such, I had to check the proper translation of each of the
inline tokens against BabelMark to make sure that I had the right translation.
But other than that extra bump in the process, it went smoothly.  The
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function filled out quickly with each
coded translation.&lt;/p&gt;
&lt;p&gt;With that task completed, the scenario tests were generating the HTML output
that I expected.  Onwards!&lt;/p&gt;
&lt;h3 id="rehydrating-the-markdown-text"&gt;Rehydrating the Markdown Text&lt;a class="headerlink" href="#rehydrating-the-markdown-text" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After I was sure that the tokens being generated correctly, I quickly ran each of the
Markdown documents from the new tests through
&lt;a href="https://johnmacfarlane.net/babelmark2/"&gt;Babel Mark&lt;/a&gt;,
verifying that the output
HTML was correct.  Encountering no problems, I moved on to the rehydration of those
tokens into Markdown and was happy with the results.  With only a couple of tests
failing, I took a quick look at the failures and noticed the problem right away:
rehydrating Link tokens and Image tokens that contained newlines was not working.&lt;/p&gt;
&lt;p&gt;Following the log files, I was able to quickly figure out that the problem was
that the backslash escape sequences and replacement markers were not being resolved
from the text before doing the final rehydration of the elements.  In the end,
the following lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;text_to_modify&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove_backspaces_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_modify&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;text_to_modify&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resolve_replacement_markers_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;text_to_modify&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;were added to the &lt;code&gt;__insert_leading_whitespace_at_newlines&lt;/code&gt; function to resolve
those elements.&lt;/p&gt;
&lt;p&gt;With that code added, every scenario test was passing to the point of being able
to regenerate its original Markdown.  On to the consistency checks!&lt;/p&gt;
&lt;h3 id="cleaning-up-the-consistency-checks"&gt;Cleaning Up the Consistency Checks&lt;a class="headerlink" href="#cleaning-up-the-consistency-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It was in this area that I spent a lot of time making sure things were correct.
Due to the shortened time blocks in which I could work on the project, the solutions
that I initially came up with were just not solid enough solutions to use.  These
solutions were either too complicated or failed to meet the criteria, leading me to
throw each approach out.  In the end, I just reset to use a simple approach, after
which things started to work out fine.&lt;/p&gt;
&lt;p&gt;Learning from my previous work, I was pretty sure these changes were going to involve
handling replacement markers and backslash escapes better.  Specifically focusing
on the link label and image label, I was able to quickly determine that the link
labels and link text from the different link types in the
&lt;code&gt;__verify_next_inline_inline_image&lt;/code&gt; function needed to call the
&lt;code&gt;resolve_replacement_markers_from_text&lt;/code&gt; function to remove the replacement markers.&lt;/p&gt;
&lt;p&gt;After making that change, I followed a hunch to see if the other changes I made needed
to be copied in some form to the consistency checks.  I was rewarded to find positive
benefit to extending the code under the &lt;code&gt;if "\n" in str(current_inline_token):&lt;/code&gt;
condition of the &lt;code&gt;__verify_inline&lt;/code&gt; function in a manner similar to the changes made to
the &lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function.  It just made sense.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This was just a brutal week project-wise.  The stop-and-go (but mostly stop) nature
of this week reminded me of a time home when I worked in a cubicle farm for a year.
Instead of people just looking over at you or emailing you, they would have to walk
over to your cubicle and stand by your “door” to have a conversation with you.  At
least for me, it often seemed like I was just getting into a good work flow when
someone else showed up to talk, causing another interruption.&lt;/p&gt;
&lt;p&gt;While I definitely had my priorities straight in dealing with the issues around my
house, the stop-and-go nature of this week made it hard to get into a good flow.
Even thinking about how I felt that week made the task of writing this article more
difficult.  It was just that jarring at times.&lt;/p&gt;
&lt;p&gt;That also made my current predicament that much more painful.  I can see the issues
list getting smaller and smaller, closer to a point where I know I will feel comfortable
in releasing the project.  And I want to get there, but I want to get there with what
I consider to be solid quality.  But I also want to get there soon.  And I know that
if I had more quality time during the week, I would have been able to resolve at least
a couple more issues.&lt;/p&gt;
&lt;p&gt;But I am still happy with the momentum on the project, and where I am with it.  And
one of the promises that I made to myself at the start of the project is that I must
have balance between this project and other priorities in my life.  And this was
just a week where I had to put my money where my mouth was.&lt;/p&gt;
&lt;p&gt;Hopefully next week will be better.&lt;sup id="fnref:ofCourse"&gt;&lt;a class="footnote-ref" href="#fn:ofCourse"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next week’s article will be more interesting, as I was able to address my time
allotments on the project, submitting 9 commits during that week.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:ofCourse"&gt;
&lt;p&gt;It was better.  These articles track roughly 2-3 weeks behind the actual work, I know for a fact it got better. &lt;a class="footnote-backref" href="#fnref:ofCourse" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 4</title><link href="https://jackdewinter.github.io/2020/10/19/markdown-linter-delving-into-the-issues-4/" rel="alternate"></link><published>2020-10-19T00:00:00-07:00</published><updated>2020-10-19T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-19:/2020/10/19/markdown-linter-delving-into-the-issues-4/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/12/markdown-linter-delving-into-the-issues-3/"&gt;last article&lt;/a&gt;, I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are times during the development of a project …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/12/markdown-linter-delving-into-the-issues-3/"&gt;last article&lt;/a&gt;, I started to add extra
scenario tests that tested newline characters in various groups or themes.  In this
article, I continue working towards having a good level of group coverage for each of
those groups.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are times during the development of a project where the tasks are all feature
related, and then there are times where the tasks are all issue related.  Instead of
waiting for that second era to arrive, I instead elected to proactively invest extra
time in trying to improve the scenario tests.  While I know I will not find every
issue, I want to make sure I do my best to throw as many combinations of elements
against the wall, hoping none of those combinations will stick.&lt;sup id="fnref:spaghetti"&gt;&lt;a class="footnote-ref" href="#fn:spaghetti"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;From my viewpoint, I am aware that this focus on quality is taking time and effort
away from adding new rules to PyMarkdown.  However, in my eyes, every minute spent on
making sure the project is stable is worth it.  Even with the knowledge that I will
not catch every issue before it happens, I am confident that by being proactive and
adding groups of tests, I will put the project in a great position to be a stable
platform for linting Markdown documents.  Even better, by focusing on groups of
combinations instead of individual tests, I believe I can discover a large group
of issues at the current stage, instead of in a bug report later.  At the very least,
that is my hope, and my confidence is increasing with each group I add.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/a506ddd3bda08a8ca1d97a7b0d68c114325b545e"&gt;02 Oct 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/953ed1b4afdc40353995dd7b1dcd41e7a306effc"&gt;04 Oct 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="cleaning-up-after-last-week"&gt;Cleaning Up After Last Week&lt;a class="headerlink" href="#cleaning-up-after-last-week" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As the work I documented last week ran into the overtime territory, I decided at that
time to disable those tests, with promises to work on them next week.  As this is the
next article, this is the next week.  Time to get to work!&lt;/p&gt;
&lt;p&gt;With very few exceptions, the results of each scenario test have been checked at
least three times.  As such, I was very confident that I needed to update the
consistency checks to deal with these changes, and not the results. As an ancillary
task, since the code to calculate the line/column number was just introduced, I knew
that there was a decent chance that I might find an issue or two that would need to be
fixed.  As the consistency checks were not passing, I was hoping that it was the
checks that needed updating but prepared for changes in the parser itself.  Only
research would tell, so it was on to more research!&lt;/p&gt;
&lt;h3 id="doing-the-research"&gt;Doing the Research&lt;a class="headerlink" href="#doing-the-research" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Digging into the code for links, it seemed obvious that the issue was with the links
and their column numbers was something simple.  As I scanned more code, my confidence
that it was something simple just increased.  All the big pieces of code looked
fine, but one thing was sticking out: replacements.  Back when I was adding the
Markdown transformer, I made sure that both the HTML-friendly and Markdown-friendly
versions of the token’s text were included in the Link Token.  However, when I added
the code to handle this into the consistency checks, I got confused.&lt;/p&gt;
&lt;p&gt;Part of this is my own fault, but the reason I was confused was due to the duality
that exists in the tokens and the project.  In inline text situations, replacement
sequences are used to show both the &lt;em&gt;before&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; parts of the replacement.
In link situations, a similar pattern is used, including both parts of the replacement
in the token.  However, in the link case, there are a couple of added wrinkles.&lt;/p&gt;
&lt;p&gt;The first wrinkle is that there are usually 2 different fields of the Link token
that contain this information. Using the &lt;code&gt;link_title&lt;/code&gt; field as an example, the processed
version is stored in that field, while the raw text used to generate that field is
kept in the &lt;code&gt;pre_link_title&lt;/code&gt; field.  To avoid useless duplication of fields, the
&lt;code&gt;pre_&lt;/code&gt; version of the field is only used if they have a different value that their
processed field.  That is the second wrinkle.  In processing that Link token
information, it is common to see code likeL&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent_cur_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pre_link_title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, set the &lt;code&gt;link_title&lt;/code&gt; variable to the token’s &lt;code&gt;link_title&lt;/code&gt; field by default.
But if the &lt;code&gt;pre_link_title&lt;/code&gt; field is set, use that instead.&lt;/p&gt;
&lt;p&gt;Given that there are two different access patterns, sometimes I can get confused and
use a process for dealing with the other access pattern.  And that is where the third
wrinkle shows up: dealing with link labels.  In the case of link labels, the processed
version of the text exists between the start Link token and the end Link token, with
the raw version being kept in the start Link token’s &lt;code&gt;text_from_blocks&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;And to be honest, while it does make sense in how each of the 3 use cases are used in
practice, remembering which one is in play when I am writing code on a given field
can be difficult.&lt;/p&gt;
&lt;h3 id="fixing-the-issues"&gt;Fixing the Issues&lt;a class="headerlink" href="#fixing-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Hopefully there is enough information in the previous section to allow for this
revelation
to be easy to see in advance: I used the wrong pattern in one place and the wrong
field in another place.  While the fix was just a couple of lines of code in the
newly refactored &lt;code&gt;__verify_next_inline_inline_image_inline&lt;/code&gt; function, it took some
debugging to properly address the issue by using the correct patterns.  With both
patterns adjusted, most of the tests were passing.&lt;/p&gt;
&lt;p&gt;It was in those remaining failures that I noticed that another problem that was hiding
behind that problem:
character references were not updating the column number.  With all the confusion
of the other problem out of the way, there were a couple of outlier tests dealing
with character entities that were not adding any space for the Code Span tokens.
That was fixed by adding the following code to the end of the
&lt;code&gt;handle_character_reference&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_index&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, it was obvious that something needed to be done once I started looking
at the function itself, but without something causing me to look there, it was
overlooked.  I was just grateful that the extra scenario tests pointed this out!&lt;/p&gt;
&lt;h2 id="rounding-out-image-support"&gt;Rounding Out Image Support&lt;a class="headerlink" href="#rounding-out-image-support" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the support for images and their line/column numbers was added a long time ago,
the proper validation support in the consistency checks was only recently added.  In
addition, while previous work tested the inline image support, there was very little
testing of the shortcut and compressed image types, and no testing of the full image
type.&lt;/p&gt;
&lt;h3 id="adding-the-tests"&gt;Adding The Tests&lt;a class="headerlink" href="#adding-the-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The testing part of this support was easy to address.  As part of finishing the work
from the previous
week, I copied over tests &lt;code&gt;test_paragraph_extra_78&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_89&lt;/code&gt;, renaming them &lt;code&gt;test_paragraph_extra_90&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_a2&lt;/code&gt;.  Once that was
done, I changed the example text from the link start sequence &lt;code&gt;[&lt;/code&gt; to the image start
sequence &lt;code&gt;![&lt;/code&gt;.  Temporarily disabling the consistency checks, I then ran through
each of the scenario tests, adjusting the token output and the HTML output for the
change from a Link token to an Image token.  From the token point of view, I was
primarily looking for the Image token to take the place of the start Link token.  In
addition, I was checking to ensure that any tokens after the start Link token but before
(and including) the end Link token were removed.  Finally, I adjusted the HTML for the
scenario from an HTML anchor tag to an HTML image tag, along with any tag attribute
changes that were required.&lt;/p&gt;
&lt;p&gt;At this point, it should go without saying that as I was making those changes, I ran
through the token output and the HTML output multiple times.  I did these checks both
mentally and my tried and true method of “counting out loud”, verifying that both values
were the same. As I knew the next task was to properly implement the consistency checks
for the other image types, I also knew that an extra count or two would take less time
than trying to debug any off-by-one issues with any of the line/column numbers.  It just
made sense to take an extra minute per test and do that extra level of verification.&lt;/p&gt;
&lt;h3 id="reviewing-collapsed-and-shortcut-images"&gt;Reviewing Collapsed and Shortcut Images&lt;a class="headerlink" href="#reviewing-collapsed-and-shortcut-images" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Containing only a link label, the shortcut and collapsed image types had already been
coded into the consistency check.  From a quick visual inspection, they both made
sense and looked great:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"collapsed"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;image_alt_text&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_from_blocks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text_from_blocks&lt;/span&gt;

        &lt;span class="n"&gt;token_prefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;newline_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image_alt_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;
            &lt;span class="n"&gt;para_owner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;
            &lt;span class="n"&gt;estimated_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

            &lt;span class="n"&gt;split_label_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_alt_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;image_alt_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split_label_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;token_prefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="n"&gt;estimated_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="n"&gt;estimated_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;token_prefix&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image_alt_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the collapsed link type as an example, the algorithm was really easy to code up.
A Markdown collapsed link type looks like this: &lt;code&gt;[reference][]&lt;/code&gt;.  To start with, the
code to determine the content of the link label is used, as was mentioned in the
previous sections.  With that information in hand, the &lt;code&gt;token_prefix&lt;/code&gt; was set to &lt;code&gt;1&lt;/code&gt; to
account for the opening &lt;code&gt;[&lt;/code&gt;, before proceeding to deal with any newlines.  Dealing
with the newlines used the same pattern that I used for each part of the inline image
type.  However, the big change here is that the &lt;code&gt;token_prefix&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; if a
newline character is found.  The rationale behind this is that if there any newlines
in the link label, the length of the opening &lt;code&gt;[&lt;/code&gt; is no longer useful in determining
the column number, as it comes before the part that has a newline character in it.&lt;/p&gt;
&lt;p&gt;With all that preparation in place, it is then time to compute the change in the
column number.  The initial &lt;code&gt;estimated_column_number += 2&lt;/code&gt; takes care of the
&lt;code&gt;[]&lt;/code&gt; characters at the end of the image text.  The &lt;code&gt;2&lt;/code&gt; from the first part of the
following statement combines a &lt;code&gt;+1&lt;/code&gt; for the translation from an index into a position
and a &lt;code&gt;+1&lt;/code&gt; for the &lt;code&gt;]&lt;/code&gt; character after the link label.  The &lt;code&gt;token_prefix&lt;/code&gt; variable
is then added to account for the length of the opening &lt;code&gt;[&lt;/code&gt; label, as described above,
followed by adding the length of the raw version of the link label text.&lt;/p&gt;
&lt;h3 id="why-review-this"&gt;Why Review This?&lt;a class="headerlink" href="#why-review-this" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It may seem weird that I reviewed this before going forward but let me explain.
I reviewed both because I knew that I had plans to use either the shortcut
code or the collapsed code as a template for the full image type.  I knew that the
only difference in the code between those two types was the addition of a link
reference.  To me, it just made sense to start with the code for either of those image
types and just add the extra code to handle the link reference.&lt;/p&gt;
&lt;p&gt;Following that plan to reuse that code, the support for the full image types was
added within a couple of hours.  After making sure the consistency checks were enabled,
I started running the newly added scenario tests against the newly added consistency
check code.  It was then that I started noticing some weird failures.&lt;/p&gt;
&lt;h2 id="debugging-the-alt-attribute"&gt;Debugging The Alt Attribute&lt;a class="headerlink" href="#debugging-the-alt-attribute" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Digging into those failures, it was initially hard for me to figure out what the issue
was.  Everything looked fine until I started doing a character by character mental
reconstruction of the tokens from the Markdown.  It was then that I saw it:  the &lt;code&gt;alt&lt;/code&gt;
attributes on a handful of the image tags were wrong.&lt;/p&gt;
&lt;p&gt;The scenario test function &lt;code&gt;test_paragraph_extra_73&lt;/code&gt; is a great example of that.  With
the Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Fo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;beta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="ss"&gt;"testing"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and a simple knowledge of Markdown, the text assigned to the &lt;code&gt;alt&lt;/code&gt; attribute of the
HTML image tag was obvious to me.  It should be &lt;code&gt;Foβo&lt;/code&gt;.  But when I looked at the
token itself, that token was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[image(1,2):inline:/uri:testing:Foo::::Foo:False:":: :]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That was close, but I was expecting a token that was more like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[image(1,2):inline:/uri:testing:Foβo::::Fo&amp;amp;beta;o:False:":: :]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which contained both the processed version of the text &lt;code&gt;Foβo&lt;/code&gt; and the unprocessed
version of the text &lt;code&gt;Fo&amp;amp;beta;o&lt;/code&gt;.  This was not like some previous issues that I had
already resolved where one of the other inline tokens was not being represented
properly.  This was a case of some very simple replacements needing to take place
but being missed.&lt;/p&gt;
&lt;p&gt;In addition, after looking at some other cases, backslash escape sequences
were also causing issues, though usually hidden.  Function &lt;code&gt;test_paragraph_extra_74&lt;/code&gt;
is a good example where the output HTML was correct, but the tokenization contained an
&lt;code&gt;o&lt;/code&gt; for the processed text instead of &lt;code&gt;Fo]o&lt;/code&gt;.  &lt;/p&gt;
&lt;h3 id="fixing-the-issue"&gt;Fixing The Issue&lt;a class="headerlink" href="#fixing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To get around this issue, I was faced with three different choices.  The first choice
was to code something up specific to this issue.  I immediately rejected that approach
as I felt that one of the extensions that I will need to support in the future may have
to introduce some base level of character manipulation like the character entities.  As
such, I wanted to leave my options open.&lt;/p&gt;
&lt;p&gt;That left the other two options, or rather one option with two variations.  In
either case, I already had a mechanism for registering inline handling and using those
handlers.  As such, my second choice was to use the existing inline processor code for
text blocks.  The issue that I had with that approach was that I would need to pass an
additional flag into that function that would limit its use to only the backslash
escapes and the character entities.  While that may have been possible with a smaller
function, the size and complexity of the &lt;code&gt;__process_inline_text_block&lt;/code&gt; function gave me
have concerns about possible side effects.&lt;/p&gt;
&lt;p&gt;From three choices down to one, I went with a simplified processor approach to the
&lt;code&gt;__process_inline_text_block&lt;/code&gt; function.  When
the handlers register themselves, I added a new flag to denote whether the
handler was for
one of the two simple inline sequences.  If it was, I added the text sequence to
the &lt;code&gt;__valid_inline_simple_text_block_sequence_starts&lt;/code&gt;.  Then, in the imaginatively
named &lt;code&gt;process_simple_inline&lt;/code&gt; function, I added the code for a very pared down
version of the &lt;code&gt;__process_inline_text_block&lt;/code&gt; function.  This function was purposefully
crafted to
only handle those simple inline sequences and the newline character, nothing else.&lt;/p&gt;
&lt;p&gt;It was when I went to wire the function up that I found another interesting surprise
waiting for me.&lt;/p&gt;
&lt;h3 id="circular-references-suck"&gt;Circular References Suck!&lt;a class="headerlink" href="#circular-references-suck" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With a decent first attempt at a simplified inline processor in place, I did as I
normally do and went to the place where I needed the function, the
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function in the &lt;code&gt;LinkHelper&lt;/code&gt; module, and added
the reference and the import to go along with it.  After starting the test executing,
there was a long pause, and I was then greeted with a simple error telling me:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E   ImportError: cannot import name 'LinkHelper' from 'pymarkdown.link_helper'
    (C:\old\enlistments\pymarkdown\pymarkdown\link_helper.py)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having hit these a number of times, I was sure it was a circular import reference,
but where was it?  It was then that I thought about it.  The &lt;code&gt;LinkHelper&lt;/code&gt; module
was already imported from the &lt;code&gt;InlineProcessor&lt;/code&gt; module, as I used it to handle
all the heavy lifting with the links.  As Python does not have any concept of
forward references, all referenced classes or functions must be loaded before
a reference is made to that item.  In this case, with the relationship already
established, I could not add the reference in the other direction.  I needed to find
another solution.&lt;/p&gt;
&lt;p&gt;I was sure that I would be able to come up with a more elegant solution at a later
time, but I wanted to finish this task up, so I took the &lt;em&gt;lazy&lt;/em&gt; approach of passing
the function as an object.  As it was passed as an argument to each function, there
was no restriction imposed and I was able to use that method at the target
&lt;code&gt;__consume_text_for_image_alt_text&lt;/code&gt; function.  I may want to look at a better way
to do that in the future, but at the time, it worked.&lt;/p&gt;
&lt;h3 id="rounding-the-corner"&gt;Rounding The Corner&lt;a class="headerlink" href="#rounding-the-corner" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At that point, all the scenario tests were passing.  I was sure that there were
other scenarios that I could find and test, but I was confident that I had a good
collection of paragraph tests added to the project.  I knew in future weeks I would
need to expand that collection in size and cover the SetExt Headings, but that could
come later.&lt;/p&gt;
&lt;h2 id="duplicating-tests-without-duplicating-effort"&gt;Duplicating Tests Without Duplicating Effort&lt;a class="headerlink" href="#duplicating-tests-without-duplicating-effort" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With those scenario tests completed for links and images contained within paragraphs,
it was time to extend those tests to including inline processing within SetExt Heading
tokens.  To that extent, I copied over &lt;code&gt;test_paragraph_extra_43&lt;/code&gt; to
&lt;code&gt;test_paragraph_extra_a2&lt;/code&gt;, creating tests &lt;code&gt;test_setext_headings_extra_43&lt;/code&gt; to
&lt;code&gt;test_setext_headings_extra_a2&lt;/code&gt;.  In terms of the Markdown documents for each test,
the only change I made was to add &lt;code&gt;---&lt;/code&gt; after the Markdown being tested, transforming
it from a Paragraph token test to a SetExt Heading token test.&lt;/p&gt;
&lt;p&gt;As I expected, there were some issues that I needed to resolve to get those tests
working.  As the original versions of the tests used Paragraph Tokens, and the handling
of those Paragraph tokens relied on the &lt;code&gt;rehydrate_index&lt;/code&gt; field of the Paragraph
token, that was an obvious change that needed to be made.  To be specific, I needed
to add code to each reference of the &lt;code&gt;rehydrate_index&lt;/code&gt; field to only reference that
field if the Paragraph token was the container for the inline text.  For the consistency
check and the Inline Processor, this meant protecting any use of the &lt;code&gt;para_owner&lt;/code&gt;
variable, and the &lt;code&gt;owning_paragraph_token&lt;/code&gt; variable for the Markdown transformer.&lt;/p&gt;
&lt;p&gt;With that change made, the only other thing that needed to be dealt with is the change
in how the leading whitespaces are handled within a Paragraph token and within a
SetExt Heading token.  To allow better processing of paragraphs, the Paragraph token
collects any leading whitespace in the Paragraph token, whereas the processing of
inline tokens within the SetExt Heading token stores that information with the inline
tokens themselves.  That handling was changed to ensure the information was properly
being mined from each inline token.&lt;/p&gt;
&lt;p&gt;And while it probably took a couple of hours to resolve, it felt like these changes
only took a couple of minutes.  Compared to some of the other changes I have done
in the last couple of weeks, these changes were completed quickly.  I am sure that
there were a couple of issues in the code that I needed to fix, but as I said, the
time just flew by.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the introduction, I mentioned my increase in confidence for the project, mostly due
to my switch from individual scenario tests to scenario test groups.  From a work
point of view, instead of many small issues, I am lucky if I can get 2 to 3 medium
or large sized issues done in a week.  But as I am covering many combinations in one
task, I feel that the benefit easily outweighs the cost.  And
that benefit is what helps me drive forward.&lt;/p&gt;
&lt;p&gt;And especially with today’s climate, I find that I sometimes need some help in
maintaining focus on this project and driving it forward.  At times like that, when
I need some extra focus, I find it is good to think about the positive parts of the
project.  Instead of focusing on what is left to do, I focus on the progress I have
made in getting to this point.  Instead of focusing on the quantity of tasks I can
get done in a week, I focus on the quality that those tasks being to the project.
And most importantly, instead of focusing on what I cannot change around me, I choose
to focus on this PyMarkdown project, and the benefits I can provide to Markdown
authors with this project.&lt;/p&gt;
&lt;p&gt;So, as I move forward with the project, focusing on quality, I choose these areas
to focus on.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Staying with the theme of testing blocks, I tackle another couple of testing blocks
in the next article.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:spaghetti"&gt;
&lt;p&gt;&lt;a href="http://www.english-for-students.com/Spaghetti.html#:~:text=Alternative%3A%20Throwing%20spaghetti%20on%20the%20wall%20is%20how,to%20the%20walls%20too%21%20Thanks%20to%20Tarean%20West"&gt;Throwing Spaghetti&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:spaghetti" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 3</title><link href="https://jackdewinter.github.io/2020/10/12/markdown-linter-delving-into-the-issues-3/" rel="alternate"></link><published>2020-10-12T00:00:00-07:00</published><updated>2020-10-12T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-12:/2020/10/12/markdown-linter-delving-into-the-issues-3/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/"&gt;last article&lt;/a&gt;,
I continued the long journey to remove items from the project’s issues list.  Still
without a better title than the equivalent of “chapter 3”, this article details more
pruning of that list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this process feels like just one of many stops on …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/"&gt;last article&lt;/a&gt;,
I continued the long journey to remove items from the project’s issues list.  Still
without a better title than the equivalent of “chapter 3”, this article details more
pruning of that list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this process feels like just one of many stops on a long journey, I do find
that I am finding this part of the project particularly satisfying.  Sure, I am fixing
issues that I have found along the
way, but that is a good thing.  I am not finding a lot of “I need to redesign this from
scratch” issues, just a lot of “wow, did I forget to…” or “wow, I didn’t think to
test the combination where…” issues.  And I find that observation both calming and a
boost to my confidence.&lt;/p&gt;
&lt;p&gt;Is it taking up time? Sure.  Would I like to get back to implementing and adding rules?
Yup.  But, with each
issue that I resolve, my confidence that this is the right course of action increases.
The project’s collection of different Markdown documents and test data just keeps on
growing.  As I manually check each scenario test out against what is expected,
verify the output HTML against the reference implementation, and have consistency checks
in place, any new issues just give me that much more information that the project is
working properly.&lt;/p&gt;
&lt;p&gt;Mind you, properly does not mean it is perfect, just that it is headed in the right
direction.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/d3780447b4b71153a6a2a259f2512483d8c153a0"&gt;21 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f3cc298745e56b435f4962965502a00d281eb2dc"&gt;27 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="small-cleanups-and-large-aspirations"&gt;Small Cleanups and Large Aspirations&lt;a class="headerlink" href="#small-cleanups-and-large-aspirations" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first commit in this week’s work was an easy one.  During the writing of the
article on that week’s
work, I realized two things: I wasn’t taking &lt;code&gt;show_debug&lt;/code&gt; arguments out of tests
after debugging,
and test &lt;code&gt;test_raw_html_632&lt;/code&gt; needed a child test with a bit of change, creating
&lt;code&gt;test_raw_html_632a&lt;/code&gt;.  Both changes were accomplished within 15 minutes, so
they were good cleanup issues. But after that, I was left with an interesting problem
to deal with:  Newlines and various inline elements.&lt;/p&gt;
&lt;p&gt;There were a couple of issues that I wanted to deal with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- HTML and Fenced Blocks and better handling of capturing newlines to avoid counting token height
- verify which inlines cannot contain newlines and verify with line/col
  - autolinks
  - raw_html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To break these issues out a bit more, I want to make sure I convey the difference
between the PyMarkdown project and a normal Markdown parser.  As the project’s
focus is to be a Markdown linter, there are additional requirements imposed that are tested with every commit.  Those requirements are that
any element of interest, once translated into a token to represent it, must include the
line number and column number of the original Markdown.  While the examples provided
by the GFM specification are great for testing a parser, they fall a bit short for
testing a linter.&lt;/p&gt;
&lt;p&gt;To be clear, that is not a problem with the GFM specification.  The section called
&lt;a href="https://github.github.com/gfm/#about-this-document"&gt;About this document&lt;/a&gt;
specifically starts with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This document attempts to specify Markdown syntax unambiguously. It contains many examples with side-by-side Markdown and HTML.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The specification specifically deals with syntax and how a given Markdown document
should be represented by HTML.  Full stop.  It is this project’s additional requirement
of being able to examine the tokens that are then translated to HTML that add that
extra level of complexity.  And that extra complexity comes with a cost.&lt;/p&gt;
&lt;h2 id="changing-that-cost-benefit-ratio"&gt;Changing That Cost-Benefit Ratio&lt;a class="headerlink" href="#changing-that-cost-benefit-ratio" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The cost of this complexity has not been large until this point.  Hitting an issue
where I thought needed
some extra testing, I created a child test by adding a letter to the end of the parent
scenario test and made the required variations to the child test for that situation.
In cases where there were more variations, I introduced multiple child scenarios,
each one testing something specific.  This approach did not significantly increase
the complexity of the tests, due to its focused nature.&lt;/p&gt;
&lt;p&gt;But with this week’s work, it was different.  Instead of having one test here to verify
and one test there to verify, I wanted to make sure that all inline tokens that
followed a given pattern were being handled properly.  I wanted to have one central
location where I could look to make sure inline tokens and newline characters were
being handled properly.  This was different in that its scope was going to make it
complex.&lt;/p&gt;
&lt;h2 id="new-tests-first-batch"&gt;New Tests - First Batch&lt;a class="headerlink" href="#new-tests-first-batch" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first batch of these new scenario tests were the group from
&lt;code&gt;test_paragraph_extra_43&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_46&lt;/code&gt;.
To reiterate the message from the previous section, the purpose of these tests was not
to provide one off tests for each type of inline element, but to provide a group of
tests along a given theme.  In this case, that theme was an inline element
surrounded by simple text on either side, with a newline in the middle of the element.&lt;/p&gt;
&lt;p&gt;Far from being tricky, adding these tests was simple.  I started with test
&lt;code&gt;test_paragraph_extra_43&lt;/code&gt; and support for the Code Span token, adding support for the
Raw Html token,
the URI Autolink token, and the email Autolink token, ending at
&lt;code&gt;test_paragraph_extra_46&lt;/code&gt;  Those were easy
tests to add.  In each case, it was just a simple Markdown document like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;
&lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was when I started looking at the links and images that I realized that I was in
for a world of hurt.  Well, maybe not hurt, but it was going to be a lot of work.&lt;/p&gt;
&lt;h3 id="new-tests-links-and-newlines"&gt;New Tests - Links and Newlines&lt;a class="headerlink" href="#new-tests-links-and-newlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting off with the links, I began with inline links, as they are what I mostly
use in my documents.  In terms of changeable parts, the inline
links have 6 elements: the link label, the whitespace before the URI, the URI,
the whitespace before the title, the title, and the whitespace after the title.
To test these parts, I added tests &lt;code&gt;test_paragraph_extra_47&lt;/code&gt; to
&lt;code&gt;test_paragraph_extra_52&lt;/code&gt;, one for each of the parts.  In addition,
for each whitespace test, I added variations on the tests that included whitespace
before the newline, whitespace after the newline, and whitespace before and after
the newline.  &lt;/p&gt;
&lt;p&gt;Once those tests were added, it was time to focus on the other 3 link types.  The
full link type was tested by adding a test for newlines in the label
(&lt;code&gt;test_paragraph_extra_53&lt;/code&gt;) and
newlines in the link reference (&lt;code&gt;test_paragraph_extra_54&lt;/code&gt;).  A new test was added
for a shortcut
link with a newline in the link reference (&lt;code&gt;test_paragraph_extra_55&lt;/code&gt;) and a
collapsed link with a newline
in the link reference (&lt;code&gt;test_paragraph_extra_56&lt;/code&gt;).  Finally, to address some
concerns I had about a newline
at the start of those elements, I added test &lt;code&gt;test_paragraph_extra_57&lt;/code&gt; that includes
a collapsed link with
a newline at the start of the link label, and test &lt;code&gt;test_paragraph_extra_58&lt;/code&gt;
that includes a full link with
a newline at the start of the link reference.&lt;/p&gt;
&lt;p&gt;With that group of tests added, it was time to shift to the next group of tests: images.
After adding test &lt;code&gt;test_paragraph_extra_59&lt;/code&gt; to place a newline between the &lt;code&gt;!&lt;/code&gt;
character and the &lt;code&gt;[&lt;/code&gt; character of the image link, tests &lt;code&gt;test_paragraph_extra_60&lt;/code&gt; to
&lt;code&gt;test_paragraph_extra_67&lt;/code&gt; were added as versions of tests
&lt;code&gt;test_paragraph_extra_47&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_52&lt;/code&gt;, modified for an image instead
of a normal link.  In addition, tests &lt;code&gt;test_paragraph_extra_60&lt;/code&gt; and
&lt;code&gt;test_paragraph_extra_65&lt;/code&gt; were added to test an image link without any link title
being provided.&lt;/p&gt;
&lt;p&gt;To me, this was a good start to some solid tests.  I was focusing on a particular
group of tests, and make sure that pattern was cleanly covered.&lt;/p&gt;
&lt;h3 id="adding-in-replacements-and-backslashes"&gt;Adding in Replacements and Backslashes&lt;a class="headerlink" href="#adding-in-replacements-and-backslashes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finding that the pattern of adding new tests in the previous section was working well
as a template,
the next group of tests followed a similar pattern.  In this group of tests, I wanted
to focus on newlines as part of replacement sequences and backslash sequences within
different parts of the inline links.  My concern was that the special character
handling would play havoc with the determination of the column number for the token
following the token with the special character.  It just seemed to be a good idea to
test these thoroughly.&lt;/p&gt;
&lt;p&gt;Tests &lt;code&gt;test_paragraph_extra_68&lt;/code&gt; and &lt;code&gt;test_paragraph_extra_69&lt;/code&gt; provide for testing in
the inline link label, with a newline around
a replacement sequence and a newline near a backslash sequence.  Then test
&lt;code&gt;test_paragraph_extra_70&lt;/code&gt;
tests a inline URI containing a space, followed by tests &lt;code&gt;test_paragraph_extra_71&lt;/code&gt;
and &lt;code&gt;test_paragraph_extra_72&lt;/code&gt; testing for
newlines within a replacement sequence and a backslash sequence.  Then tests
&lt;code&gt;test_paragraph_extra_73&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_77&lt;/code&gt; repeat those tests, but with
image links instead of normal links.  To round out
this testing tests &lt;code&gt;test_paragraph_extra_78&lt;/code&gt; to &lt;code&gt;test_paragraph_extra_89&lt;/code&gt; repeat
the link testing with the variations
based on the other 3 link types.&lt;/p&gt;
&lt;p&gt;As I was compiling the list of tests for this article, I did notice that it appears
that I have some tests that are done more than once.  To combat this, I added
a new item to the issues list to create a table or spreadsheet to more
accurately track these variations.&lt;/p&gt;
&lt;h2 id="addressing-the-issues"&gt;Addressing the Issues&lt;a class="headerlink" href="#addressing-the-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;All in all, things went well with adding the new tests.  For the initial group
of 4 tests, the only thing that the tests uncovered was that the Code Span token was
not handling the newline properly.
That was quickly resolved with a couple of small changes in the &lt;code&gt;handle_inline_backtick&lt;/code&gt;
function.  The bigger issues arose in the handling of the links.&lt;/p&gt;
&lt;p&gt;While not a design change, most of that section either needed to be added or enhanced
to properly handle links with newlines.
The way the code was implemented before that week’s work, if there was a newline
character in the current token, the logic was invoked to properly determine what the
line/column number should be.  There were two problems with that code.  The first is
that it was only setup to handle newline characters in an inline link.  This meant that
the code to handle full links, collapsed links, and shortcut links needed to be added.&lt;/p&gt;
&lt;p&gt;The second issue was that the initial code added to handle the inline links was only
partially complete.  In trying to figure out why that was for this article, my notes
refer to an extreme lack of examples in the GFM specification that have newline
characters in any parts of the Link elements themselves.  Part of the push to add this
current series of tests was to try and shore up that deficiency, adding those tests
myself.&lt;/p&gt;
&lt;h3 id="breaking-things-down"&gt;Breaking Things Down&lt;a class="headerlink" href="#breaking-things-down" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As it is the link type that I use most often, I started
with the inline links and their component length arrays.  This array, in a variable
named &lt;code&gt;link_part_lengths&lt;/code&gt;, contained all 5 lengths of the variable parts of the
inline links: pre-URI whitespace, URI, pre-title whitespace, title, and post-title
whitespace.  The link labels were already handled before reaching that point in the
code, so there were no issues there.&lt;/p&gt;
&lt;p&gt;That code started off with some initialization of the array and its values:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;link_part_lengths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;active_link_uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;before_title_whitespace&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inline_title_bounding_character&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;active_link_title&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;after_title_whitespace&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These values were not always going to be the right values, but they proved to be
a good place to start for each link part.  Basically, I started with an array of 5
integer values, each set to reflect a certain section of the inline link.  While those
values are not a direct 1-to-1 mapping of inline link part to length of that part,
they are keyed to handle a newline character showing up in any of those inline link
parts.&lt;/p&gt;
&lt;p&gt;A good example for this is handling a newline character in the inline link title part.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;newline_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;active_link_title&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;delta_line&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;
    &lt;span class="n"&gt;para_owner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newline_count&lt;/span&gt;

    &lt;span class="n"&gt;split_active_link_title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;active_link_title&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_active_link_title&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;link_part_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the title part, if there are any newlines discovered, the count of newlines found
is added to the relevant variables.  Once that is done, the title is split on newline
characters, and the length of the entire part is set to the length of the last part of
that split.  Finally, the &lt;code&gt;link_part_index&lt;/code&gt; variable is set to the part itself.&lt;/p&gt;
&lt;p&gt;Finally, once all the parts are examined in this manner, the following code is
executed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;link_part_index&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;split_paragraph_lines&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;para_owner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rehydrate_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;link_part_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;link_part_index&lt;/span&gt;
    &lt;span class="n"&gt;repeat_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;link_part_lengths&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Essentially, this is the magic part of the algorithm that pulls everything together.
At the start of the final processing, the last element in the array is set to include
any whitespace prefix from the last line that was added.  Once that is done, the
elements before the last element containing a newline are set to 0.  Basically, if we
have a title part that has a newline, anything before that title is not useful in
determining the column number.  Finally, the algorithm then calculates the column
number (in the &lt;code&gt;repeat_count&lt;/code&gt; variable) by summing up each of the values in the
&lt;code&gt;link_part_lengths&lt;/code&gt; array.&lt;/p&gt;
&lt;h3 id="show-me-this-in-practice"&gt;Show Me This in Practice&lt;a class="headerlink" href="#show-me-this-in-practice" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Applying that algorithm to the following Markdown&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"test&lt;/span&gt;
&lt;span class="ss"&gt;ing"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given this information, the array was initialized as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;link_part_lengths[0] = 4 + 1
link_part_lengths[1] = 1
link_part_lengths[2] = 8 + 1
link_part_lengths[3] = 0
link_part_lengths[4] = 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the newline in the title is detected, the &lt;code&gt;link_part_index&lt;/code&gt; variable is set to
&lt;code&gt;2&lt;/code&gt; and the 2nd element is reset to &lt;code&gt;4&lt;/code&gt;: &lt;code&gt;3&lt;/code&gt; for the length of &lt;code&gt;ing&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as per
the rest of the adjustment equation.&lt;/p&gt;
&lt;p&gt;Without any more newlines, when the final part of the algorithm is executed, no
adjustments are made to the 4th element, any element before the 2nd element is
zeroed out, and the sum of the remaining elements is then &lt;code&gt;4&lt;/code&gt;.  Following the
final part of the algorithm, &lt;code&gt;2&lt;/code&gt; is added to that value, ending with a value of
&lt;code&gt;6&lt;/code&gt;.  In double checking the above text, the letter &lt;code&gt;a&lt;/code&gt; on the second line does indeed
start at column 6.&lt;/p&gt;
&lt;h3 id="summary_1"&gt;Summary&lt;a class="headerlink" href="#summary_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For me, this algorithm is very effective. It starts with good defaults, updating
those values as each part is evaluated.  As the column number cannot be determined
until after the last part is evaluated, that evaluation is only done at the very
end.  And by using an array, the algorithm can use the &lt;code&gt;sum&lt;/code&gt; function to add those
elements up, instead of manual summation.&lt;/p&gt;
&lt;p&gt;It took me a while to get to it, but it is and accurate algorithm and an efficient
one.&lt;/p&gt;
&lt;h3 id="adjusting-the-consistency-checks"&gt;Adjusting the Consistency Checks&lt;a class="headerlink" href="#adjusting-the-consistency-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like the changes that needed to be made to the Markdown parser, its consistency checks
needed to change to test the new criteria.  I initially wanted to just copy over the
work I had done in setting the new line/column numbers with newlines, but after 15
milliseconds, I realized the fallacy of that approach.  The problem was that because
I knew of the approach I already used; it was hard to come up with another way to do
it.&lt;/p&gt;
&lt;p&gt;In the end, I just started the code with a less optimal starting point for the inline
links, growing it from
there.  Instead of a nice array that I could easily sum, I used a series of 5 boolean
variables and 5 string variables that contained the content of each part of the link.
While I knew this was almost the same approach, I had confidence that I was picking a
path that was enough different that I wouldn’t be tempted to look at the previous
code base to figure things out.  The approach did not have to be optimal, it just had
to be independent from the original algorithm, at least for this phase of the project.&lt;/p&gt;
&lt;p&gt;After all that work, adding the shortcut links and collapsed links were simple,
being simple sums of the component parts, both constant and variable.  But that brought
up things that I knew I was going to have to work on soon.&lt;/p&gt;
&lt;p&gt;First off, all this verification was happening in the
&lt;code&gt;__verify_next_inline_inline_image&lt;/code&gt; function.  I made a note in the issues list to
check out why, but there was not any verification present for the link tokens.
Secondly, any support for validating the full link type was missing.  After checking
the entire list of tests, there were no image tests that were specified using a full
link format.  Noted, and continued.  Finally, there were the existing calculations for
the collapsed and shortcut tests.  While there was something there, I was sure
that those checks wouldn’t handle any newline characters in any of their components.
Once again, I noted an item in the issues list, and moved forward.&lt;/p&gt;
&lt;p&gt;Besides those missing test areas that I discovered, there were a handful of tests
that I could not get working by the end of the week.  While it may seem like the tests
were only small variations on each other, it did take quite a bit of work to get them
working to the extent I did.  Not include child tests, there were 47 scenario tests that
I added.  While some of them worked right away, most of them required research and small
changes to get them working.  Any even with a good push to get all the work done,
I needed to leave some of the tests unfinished.&lt;/p&gt;
&lt;h3 id="leaving-something-undone"&gt;Leaving Something Undone&lt;a class="headerlink" href="#leaving-something-undone" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It was a hard decision to document the cases that I had missed and leave them for
later, but I thought it was an important thing to do.  As it was, the commit was done
on Sunday morning, already digging into my article writing time for that week.  I had
no clue if the remaining tests were going to take 5 minutes to resolve or 5 days.  I
needed to draw a line somewhere and put those tests into the bank for the following
week.&lt;/p&gt;
&lt;p&gt;While I was not 100% sure about the groupings, I had a bit of information that I used
to group them together into 4 groups.  The first group was a set of 7 tests that
contained a character entity and seemed to have their column number off by 6.  The
second group was a set of 2 tests that contained a backslash and seemed to have their
column number off by 2.  I was not sure about the 3 tests in the third group, but they
seemed to fit together.  Finally, I recognized that I had started work on image versions
of some of the links, but I needed to make sure that each of the tests at &lt;code&gt;78&lt;/code&gt; and over
needed image versions.&lt;/p&gt;
&lt;p&gt;With that information added to the issues list for the following weeks’ work, I ended
the week with a good amount of work done.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One thing that I am learning about in this phase of the project is that I have wells
of patience that I can tap into if need be.  To be honest, it is surprising me that
I have this ability.  I usually want to forge ahead with things and make sure they
get done to the 90 percent mark, and struggle with that last 10 percent.  But this
project is different.&lt;/p&gt;
&lt;p&gt;I am not sure if it is my self-imposed strictness on the project requirements or my
personal investment into this project, but I just find I am a lot more focused on
making this project a solid, well-tested application.  I know I am not going to be
able to catch every issue at the beginning, but I also know the cost of catching those
issues once I release the application to the community.  For that, I am prepared to
make a good-faith effort to do a thorough job in testing, even if it delays the
release of the project by a couple of months.&lt;/p&gt;
&lt;p&gt;In writing this article though, I am realizing how boring it may appear to others.
That possible appearance was made clear to me as I worked on parts of this article.
Yes, I added over 40 new scenario tests, debugged them, and got most of them working.
And because they are in themes, it was harder to write something interesting about
them.  No more “hey I caught this, and here is the interesting part”.  It was just
one or two themes, and then numerous variations on that theme.&lt;/p&gt;
&lt;p&gt;But boring as it may be, I believe it is important.  Going forward, I want to have
a cohesive collection of tests that I can use as a foundation to improve on.  I
firmly believe that this work, and the work that follows in the next couple of weeks,
builds that testing foundation.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;No surprise here, more issues to address, and still focusing on newline and links.
Stay tuned!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 2</title><link href="https://jackdewinter.github.io/2020/10/05/markdown-linter-delving-into-the-issues-2/" rel="alternate"></link><published>2020-10-05T00:00:00-07:00</published><updated>2020-10-05T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-10-05:/2020/10/05/markdown-linter-delving-into-the-issues-2/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/28/markdown-linter-delving-into-the-issues-1/"&gt;last article&lt;/a&gt;,
I started to tackle a few of the items on the project’s issues list.  As the imaginative
title for this article suggests, this article details more of the effort to reduce the
items on the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/28/markdown-linter-delving-into-the-issues-1/"&gt;last article&lt;/a&gt;,
I started to tackle a few of the items on the project’s issues list.  As the imaginative
title for this article suggests, this article details more of the effort to reduce the
items on the issues list.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last article, this part of the project is not about anything
stellar, just going through the issues list and removing one item at a time.  Far from
moving a mountain by itself, it is all about moving that mountain one pebble at a time.
The work for this week was no different.  It was just about dealing with 6 items from
the issues list and either proving they are not an issue or fixing the item if it
really is an issue.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/57d7add2a3b51b0cfb9df9446f9c13b61f100ea4"&gt;15 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/663191ae12e13fe058507b8c0f85dfc69ae38af5"&gt;20 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="rounding-out-coverage"&gt;Rounding Out Coverage&lt;a class="headerlink" href="#rounding-out-coverage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the entry for this issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;each&lt;/span&gt; &lt;span class="n"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="n"&gt;surrounded&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;was short, I knew that this issue was all about completing the code coverage on
recently changed code.  I was already aware that more than half of the cases in the
consistency check
&lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function had the default &lt;code&gt;assert False&lt;/code&gt; code put there as
a placeholder.  In addition, as soon as I looked the rest of the code, it was obvious
that I had not tested a lot of the inline sequences within an Atx Heading element or a
SetExt Heading element.  That entry was a reminder for me to circle back around 
and fix it!&lt;/p&gt;
&lt;p&gt;To accomplish that, I started by working with each inline element and its relevant
position in a line of the Markdown document.  Tests 1 to 11 dealt with each inline
element at the
start of the line with text after it, tests 12 to 20 dealt with each element with text
on either side of it, and tests 21 to 31 dealt with each element at the end of the line
with text before it.  For good measure, I added tests 32 to 42 which were each inline
element by itself on a line.  Once that was accomplished for the simple case, the
Paragraph element, I cloned those tests into 2 other sets of tests, one for Atx Heading
elements and one for SetExt Heading elements. Once cloned, I introduce a small change
for both elements, the Atx Heading tests starting
with the sequence &lt;code&gt;#{space}&lt;/code&gt; at the start of each line and the SetExt Heading tests
having the sequence &lt;code&gt;---&lt;/code&gt; follow the test text on the next line.&lt;/p&gt;
&lt;h3 id="what-did-i-find"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Running the tests after completing those changes, I found two expected results and one
unexpected result.  The first expected result was that the new tests rounded out
the &lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function by providing good examples for each of
the inline elements, except for the Hard Line Break element.  The Hard Line Break element
has some special rules, so in most cases the setup caused the text to not be interpreted
into a Hard Line Break token, and just placed in a normal Text token.&lt;/p&gt;
&lt;p&gt;The second expected result was that several of the &lt;code&gt;__handle_last_token_&lt;/code&gt; functions
needed adjustment when evaluated within the bounds of a SetExt Heading element. During
the creation of those functions, as evidenced by the work required in the
&lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function, testing within a SetExt Heading element was
almost entirely missed.  While it was not difficult to address, the testing clearly
showed that I needed to add the following code to each &lt;code&gt;__handle_last_token_&lt;/code&gt; function
to compensate:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_block_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_setext_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;inline_height&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, the unexpected result was that the normal Paragraph processing and the Atx
Heading processing were fine, requiring no fine tuning.  While I had hoped for that
outcome, it was nice for it to happen.  I had expected at least one or two small issues
to show up, but none appeared.&lt;/p&gt;
&lt;h2 id="fixing-a-simple-yet-wincing-issue"&gt;Fixing A Simple, Yet Wincing Issue&lt;a class="headerlink" href="#fixing-a-simple-yet-wincing-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Yes, I said a “wincing” issue.  While there are more colorful names for these issues,
I prefer the name “wincing” as I believe it is clear, descriptive, and obvious.  Quite
simply, these are a class of issues that are so simple that when I see them, I cannot
help but wince that the error made it through any of my commit processes without being
detected.  In this case, it was a typo where I typed &lt;code&gt;estiated_column_number&lt;/code&gt; instead of
&lt;code&gt;estimated_column_number&lt;/code&gt;, before I copied it into many places.  Yeah, I winced.&lt;/p&gt;
&lt;p&gt;While I was at it, I also decided to also tackle the issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;make&lt;/span&gt; &lt;span class="nv"&gt;new&lt;/span&gt; &lt;span class="nv"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;different&lt;/span&gt; &lt;span class="nv"&gt;indent&lt;/span&gt; &lt;span class="nv"&gt;levels&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;each&lt;/span&gt;`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like my reasons for doing the work in the previous section on
&lt;code&gt;Rounding Out Coverage&lt;/code&gt;, I just had doubts about whether I had missed anything
with the scenario test 52e.  With previous issues, I had seen a handful of false
positives occur from a test having a constant number of indent spaces. I believe my
feeling was that to truly test this scenario, I needed to add a test where the number of
ident spaces varied from line to line.  As such, I cloned scenario test 52e into 52f,
altering the indents on the second and third line to 3 spaces and 1 space, respectively.&lt;/p&gt;
&lt;h3 id="what-did-i-find_1"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One of the amusing things that I found out is that I get really embarrassed by simple
typos. Other than that, while I was right to question the indents from scenario test 52e,
the newly added scenario test 52f confirmed that the code was handling the indents
properly.&lt;/p&gt;
&lt;h2 id="verifying-the-rehydration-index"&gt;Verifying the Rehydration Index&lt;a class="headerlink" href="#verifying-the-rehydration-index" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In looking at this issue, I could easily tell beforehand that it was going to be
a research issue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;why&lt;/span&gt;?  &lt;span class="nv"&gt;shouldn&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;t each one be of the proper length?&lt;/span&gt;
```
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;split_extracted_whitespace&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;last_token&lt;/span&gt;.&lt;span class="nv"&gt;rehydrate_index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;len&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;
            &lt;span class="nv"&gt;split_extracted_whitespace&lt;/span&gt;
        &lt;span class="ss"&gt;)&lt;/span&gt;:
```
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Introduced when I was working on the Markdown transformer, the &lt;code&gt;rehydrate_index&lt;/code&gt; field
of the Paragraph token is not serialized with the other fields in the token.  It is used
exclusively for tracking the index into the Paragraph token’s &lt;code&gt;extracted_whitespace&lt;/code&gt;
field.  When I reviewed this code for another issue, I believe that I saw something
about this statement that made me question why it was needed or what it was used for.&lt;/p&gt;
&lt;h3 id="what-did-i-find_2"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After adding extra debug statements and running through the tests, I started
to understand why I might have had issues with this code.  Normally, when software
developers talk about an index, they are referring to a number that is 0 based instead
of a position which is 1 based.  Basically, the difference is whether the counting
starts with 0, as with an index, or the counting starts with 1, as with a position.
From a purist point of view, this field
is named properly: if the field has a value of 0, it is referring to the set of
characters before the first newline character in the &lt;code&gt;extracted_whitespace&lt;/code&gt; field.
Another way to look at this is that when the line is split on the newline character into
an array, as I often do for processing, the 0th element is the first element.&lt;/p&gt;
&lt;p&gt;However, when this field is used, it has the appearance of being a position.  The
&lt;code&gt;extracted_whitespace&lt;/code&gt; field holds any leading whitespace for a Paragraph token.
Accordingly, any whitespace
before the first newline in that field is applied as leading whitespace to that text
string as soon as that string’s processing starts.  As such, if there are multiple lines
in the paragraph, the &lt;code&gt;rehydrate_index&lt;/code&gt; field is set to 1 almost from the very
beginning of processing.  So, while
it is properly called an index, it can appear to look like a position based on its usage.&lt;/p&gt;
&lt;p&gt;Following that information back to the code sample above, my question now made sense.
However, while the naming could perhaps be better, it is indeed an index that somewhat
behaves like a position, with that duality causing the confusion.  In the end, after a
decent amount of review, I resolved this issue without any changes except for an extra
assert statement and some debug.  I felt that the name of the variable and the
variable’s use were both exactly what they should be.&lt;/p&gt;
&lt;h2 id="fenced-code-blocks-and-blank-lines"&gt;Fenced Code Blocks and Blank Lines&lt;a class="headerlink" href="#fenced-code-blocks-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This issue was an interesting one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;verify&lt;/span&gt; &lt;span class="nv"&gt;that&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;blank&lt;/span&gt; &lt;span class="nv"&gt;lines&lt;/span&gt; &lt;span class="nv"&gt;solution&lt;/span&gt;
`&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;previous_inline_token&lt;/span&gt;.&lt;span class="nv"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nv"&gt;MarkdownToken&lt;/span&gt;.&lt;span class="nv"&gt;token_blank_line&lt;/span&gt;`
&lt;span class="nv"&gt;does&lt;/span&gt; &lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;affect&lt;/span&gt; &lt;span class="nv"&gt;single&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;solutions&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;why&lt;/span&gt; &lt;span class="nv"&gt;needed&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From the start of the work on this issue, I knew it was going to either be
very simple or very complex.  The easy part of working on this issue was adding 4 new
scenario tests, 99f to 99i, to check for any abnormalities.  Based on the information
contained in the issue’s text, those new tests included multiple blank lines as well as
mixing blank lines and text lines within the Fenced Code Block element.&lt;/p&gt;
&lt;h3 id="what-did-i-find_3"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first thing I did after running the tests was to adjust the produced tokens to the
new values, after manually verifying each one individually.  Considering how the
coalescing processor merged the Text tokens together, the text and the line/column
numbers for each token seemed fine.  What
was immediately different was the HTML that was produced.  Instead of being a direct
interpretation of the Markdown, the resultant HTML had a few newlines missing.&lt;/p&gt;
&lt;p&gt;Far from being easy to find, this issue took me 2 days of research to find and diagnose,
revealing problems with both the HTML transformer and the Markdown transformer. This
issue just proved to be very difficult to isolate and identify.&lt;/p&gt;
&lt;h3 id="addressing-the-issue"&gt;Addressing the Issue&lt;a class="headerlink" href="#addressing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For
the HTML transformer, additional logic needed to be added to track past characters.
For whatever reason, when there are 2 blank lines in a Fenced Code Block element,
one of the newline characters is not emitted.  &lt;/p&gt;
&lt;p&gt;To properly address this issue, newlines needed to be added in 3 areas.  The first
area was in the handling of the text token, where a Text token preceded by 2 Blank
Line tokens, requiring a newline to be added.  The second area was in the handling
of a Blank Line token to make sure that the newline was only added in the right cases.
Finally, at the end of a Fenced Code Block element, another check needed to be added
for the multiple Blank Line tokens, adding a newline if they were found.&lt;/p&gt;
&lt;p&gt;After completing that grueling episode of debugging, my focus turned to the Markdown
transformer and consistency checks.  While I was dreading another 2 days of research
into the issue and how it affected the Markdown transformer, the results there was
very easy to see and diagnose.  When a switch is made from rehydrating a Text token
to rehydrating a Blank Line token, a newline is omitted in the process.  As such, it
was easy to identify this case and add an extra newline before focusing on the
rehydration of the Blank Line token.&lt;/p&gt;
&lt;p&gt;Having fixed that issue, I reran the scenario tests and got a series of weird
errors complaining about &lt;code&gt;current_token&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt;.  That was quickly tracked down
to working code for handling the last token in a consistency check, and checking
to see if the &lt;code&gt;inline_height&lt;/code&gt; variable needed to be increased by 1 to take care of
the end Fenced Code Block token.  After adding a quick check to make sure that it was
not &lt;code&gt;None&lt;/code&gt;, all the tests ran without issue.&lt;/p&gt;
&lt;p&gt;I had mixed emotions about this issue as I worked through it.  On one hand, it was
not
a simple issue, so it was good to get it out of the way.  Whether it was pride or
confidence, I was pretty sure that most of the simple issues had been cleaned
up, and this easily was not a simple issue.  On the other hand, to find an issue
like this near the end of the first phase of the project was a bit disheartening.&lt;/p&gt;
&lt;p&gt;In the end, I felt that the positives of finding and fixing this issue outweighed
the negatives.  It took a while to clean up, but that scenario was now running
properly.&lt;/p&gt;
&lt;h2 id="testing-backslashes"&gt;Testing Backslashes&lt;a class="headerlink" href="#testing-backslashes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The item for this one was simple, yet descriptive:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;backslashes&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;600&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;verify&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="k"&gt;before&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;after&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="k"&gt;all&lt;/span&gt; &lt;span class="k"&gt;valid&lt;/span&gt; &lt;span class="n"&gt;inline&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;During the various passes I have made through the code, one thing that I worried about
was whether each of the inline sequences properly handled the backslash character.
While I was confident that the start sequences of inline elements were decently
tested, I still retained a shred of doubt that I had missed something.  As for the
end of the inline elements, the confidence level was somewhere between a shred of doubt
and a hunch that I missed something.  Regardless, it was a good thing to check out
and then check off the list.&lt;/p&gt;
&lt;p&gt;To complete this task, the first part was simple:  I needed to come up with a series
of scenario tests to cover all the cases for backslashes and inline character
sequences.  So, starting with the Code Span element, I started working my way through
the inline elements.  In each case, the main test was to make sure that a backslash
character before the start inline sequence prevented the inline element from starting.
Then, if there was an end inline sequence, I added an additional test to make sure that
a backslash used right before the end of the sequence had the intended result.&lt;/p&gt;
&lt;p&gt;Finally, to make sure all inline sequences were covered properly, I replicated each of
the tests for all three inline blocks: Paragraph elements, Atx Heading elements, and
SetExt Heading elements.  Tests 1 to 13 were for Paragraph elements, tests 14 to 26 were
for SetExtHeading elements, and tests 27 to 39 were for the Atx Heading elements.&lt;/p&gt;
&lt;h3 id="what-did-i-find_4"&gt;What Did I Find?&lt;a class="headerlink" href="#what-did-i-find_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For this issue, I lucked out.  Each of the tests passed, without any issues.  But
far from being a disappointment, researching this issue and adding the additional
tests helped me put to rest any doubts that I had about backslash handling.&lt;/p&gt;
&lt;h2 id="properly-escaping-special-characters"&gt;Properly Escaping Special Characters&lt;a class="headerlink" href="#properly-escaping-special-characters" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unlike a lot of the other issues in this block of work, this item was clearly a task:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;verify that any special characters used can be recognized and specially escaped&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To get to this point in the development of the project, I had to &lt;em&gt;enable&lt;/em&gt; certain
characters to have additional meanings.  From the backspace character (\b) meaning
“do not consider the previous character” to the replacement character (\a) allowing
for a substitution to be documented, there were in all 5 characters that fit into
this group.&lt;/p&gt;
&lt;p&gt;According to the Github Flavored Markdown (GFM) specification,
&lt;a href="https://github.github.com/gfm/#character"&gt;a character is&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a Unicode code point. Although some code points (for example, combining accents) do not correspond to characters in an intuitive sense, all code points count as characters for purposes of this spec.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Following this logically, any character that is a classic ASCII control character, that
is a character between 0 and 31, is considered part of the Unicode control characters
group.  As all the special characters are classic control characters, they also exist
as valid Unicode code points.  Therefore, if I wanted to use them as special characters,
I had to make sure to escape them if they appeared in input.&lt;/p&gt;
&lt;p&gt;So now, to complete this task, I just needed to figure out how to do that.&lt;/p&gt;
&lt;h3 id="walking-on-the-shoulders-of-giants"&gt;Walking on The Shoulders of Giants&lt;a class="headerlink" href="#walking-on-the-shoulders-of-giants" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Many languages face the same problem that I was then facing: how do we represent a
control character in various formats while keeping the string readable?  In
the case of strings in languages such as Python, the backslash character is the go-to
choice.&lt;/p&gt;
&lt;p&gt;A good example of this is the definition of the various special characters themselves.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;__backspace_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\b&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;__alert_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;whitespace_split_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x02&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;replace_noop_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x03&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="n"&gt;blech_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x04&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the first two cases, the backslash precedes a character which is a stand-in for the
control character.  In the two first cases, the &lt;code&gt;\b&lt;/code&gt; character is standing in for the
backspace character (ASCII 08) and the &lt;code&gt;\a&lt;/code&gt; character is standing in for the bell or
alert character (ASCII 07).  In the remaining cases, the &lt;code&gt;\x&lt;/code&gt; informs the Python
interpreter that a 2-digit hexadecimal number will follow that is the actual character to
insert into the string.  In all cases, there is a clear understanding of what the
character is, due to the backslash character escaping the readable form of the character
to insert.&lt;/p&gt;
&lt;p&gt;For the processing of Markdown documents, the backslash was not a good character to use.
The biggest advocate against its use was that it was already being used as an escape
character
for Markdown’s special characters.  To efficiently escape the desired character
sequences, the
chosen sequence would have to be one that rarely showed up in the normal Markdown
document.  Unimaginatively, I ended up choosing the character &lt;code&gt;\x05&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I could try and explain why it was the best choice, giving lots of made up reasons, but
in this case, the reason was simple: 5 follows after 4.  It made a lot of sense to
pick another control character for the escaping character, as the other characters were
all in that group.  At that point, after eliminating any control characters that were
commonly used, there were roughly 25 characters left.  Any character would have been
just as good as the others, so I just picked the next one in the sequence.  Sometimes
you need to solidly think something through, and sometimes you just need to pick
something that just works.  This was definitely a “just works” moment.&lt;/p&gt;
&lt;h3 id="making-the-change"&gt;Making The Change&lt;a class="headerlink" href="#making-the-change" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From the outset, I knew that if I did this change properly, the bulk of the work would
be contained within the &lt;code&gt;ParserHelper&lt;/code&gt; class and the &lt;code&gt;InlineProcessor&lt;/code&gt; class.  The
changes to the &lt;code&gt;InlineProcessor&lt;/code&gt; class were easy to define. When parsing inline blocks
of text, I would need to specifically look for any of the special characters, escaping
them before moving forward with the rest of the string.  For any processing after that
change had been made, I knew that is where the &lt;code&gt;ParserHelper&lt;/code&gt; class came in.&lt;/p&gt;
&lt;p&gt;Adding the following declaration to the top of the class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;escape_character&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\x05&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the next function was easy.  To avoid a cycle in the module dependencies,
the &lt;code&gt;valid_characters_to_escape&lt;/code&gt; function was added to allow the &lt;code&gt;InlineProcessor&lt;/code&gt; class
query the &lt;code&gt;ParserHelper&lt;/code&gt; class for the characters to escape.  After that, to make sure
that I had coded things properly, I added a series of 24 scenario tests prefixed with
&lt;code&gt;test_textual_content_extra_&lt;/code&gt; to perform special character tests.  Starting with a
simple test with an example that contained each special character, those tests quickly
moved to testing various combinations of each character and normal text.  Each section
picked a specific type of escaped character, including it in a simple string and
interspersed with examples that produced the unescaped versions of those same characters.&lt;/p&gt;
&lt;p&gt;A good example of this is the function &lt;code&gt;test_textual_content_extra_4&lt;/code&gt;.  Used to test
the replacement character &lt;code&gt;\a&lt;/code&gt;, the Markdown document is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To prove that the code is working properly, an escaped replacement character must appear
on either side of an actual replacement sequence, also using the &lt;code&gt;\a&lt;/code&gt; character.  This
results in a Text token containing the text &lt;code&gt;\x05\a\a&amp;amp;\a&amp;amp;amp;\a\x05\a\a&amp;amp;\a&amp;amp;amp;\a\x05\a&lt;/code&gt;,
as predicted.  It starts with the sequence &lt;code&gt;\x05\a&lt;/code&gt; to provide for an actual &lt;code&gt;\a&lt;/code&gt;
character to be output.  The following sequence, &lt;code&gt;\a&amp;amp;\a&amp;amp;amp;\a&lt;/code&gt; then documents that the
&lt;code&gt;&amp;amp;&lt;/code&gt; character was replaced with the text &lt;code&gt;&amp;amp;amp;&lt;/code&gt;.  From there, it just repeats enough
times to make sure it works well.&lt;/p&gt;
&lt;p&gt;Once that simple sequence and others like it with the &lt;code&gt;\a&lt;/code&gt; character were verified,
this pattern was then repeated with the other inline containers: Atx Heading elements
and SetExt Heading elements.&lt;/p&gt;
&lt;h3 id="cleaning-up"&gt;Cleaning Up&lt;a class="headerlink" href="#cleaning-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While these changes sound good in theory, in practice there were some issues that needed
to be addressed.  The major change was the inclusion of the function
&lt;code&gt;remove_escapes_from_text&lt;/code&gt;.  To ensure that those character were properly represented,
I needed to be able to present a text string and have any instances of the escape
character removed from them.  Basically, if I supplied a Markdown document of &lt;code&gt;\aa&lt;/code&gt;,
that &lt;code&gt;\a&lt;/code&gt; character is then escaped, producing a token with the text &lt;code&gt;\x05\aa&lt;/code&gt;  When
I go to use that text, I need to remove the “protection” of the escape character before
rendering that text.&lt;/p&gt;
&lt;p&gt;That was easy to do, and as I started adding calls to the &lt;code&gt;remove_escapes_from_text&lt;/code&gt;
function, there were some previously working tests that started failing.  After doing a
bit of research, the cases that were failing were a portion of the tests that relied
on the &lt;code&gt;remove_x_from_text&lt;/code&gt; and &lt;code&gt;resolve_x_from_text&lt;/code&gt; functions.  In each of those
functions, something like the following was being done:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove_backspaces_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__backspace_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While that was acceptable before this change, there was one glaring error with it after
this change: it was removing all backspace characters, including escaped ones.  Thought
it took a bit more code, that one function was transformed into the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove_backspaces_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
        &lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__find_with_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__backspace_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;next_backspace_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;:]&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_backspace_index&lt;/span&gt;
            &lt;span class="n"&gt;next_backspace_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__find_with_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__backspace_character&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;adjusted_text_token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it was not as simple, it was correct.  Create a copy of the string, and then look
for the first occurrence of the backspace character that is not escaped.  When that
is done, adjust that copy to remove that backspace, and then continue searching from
there until there are no more backspaces to remove.&lt;/p&gt;
&lt;p&gt;Finally, after all that work, there was only one set of cases left, special characters
within a code span.  This was a special case because the characters needed to be
preserved exactly, with no substitutions.  In the case of the code span, once the code
span start character sequence is found, a scan is made to locate a matching end character
sequence.  If it is found, the handler simply grabs and characters between the end of
the start sequence and the start of the end sequence.  To properly escape these
characters, the &lt;code&gt;escape_special_characters&lt;/code&gt; function was added.&lt;/p&gt;
&lt;p&gt;After a lot of work, and a fair number of changes, the parser was cleanly handling the
escaped characters.  From my point of view, that was a good, solid issue to end the work
for the week on!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While there were many little things to learn, the big thing that I am learning with
this phase of the project is that the bulk of this work is in the research.  If I
am having a good day, the research will take anywhere from 5 minutes to an hour,
followed by at least an hour of retesting, or adding a slew of new tests and then
retesting.  When that happens, I am grateful that it goes by so quickly.&lt;/p&gt;
&lt;p&gt;And those positive experiences prepared me for experiences like the one that I had with
Fenced Code Blocks this week.  They are frustrating and can make me want to pull my
hair out.  I actually prefer the complex issues over these types of issues.  With those
issues, I can more clearly see the issue by breaking down that complex systems into
simpler systems that can then be analyzed individually.  For the Fenced Code Block
issue, it was just a small nitpicky issue that I had to calmly analyze, looking within a
small and complex set of variables to figure out.&lt;/p&gt;
&lt;p&gt;It is at moments like that, when I am faced with tough issues, that I take the time
to step back and try and get a better perspective.  While there are some issues that
are more difficult like the Fenced Code Block issue, the bulk of the issues are
relatively easy to diagnose given the right debug statements.  And fortunately, the
bulk of the project’s design has held up nicely, so only a couple of small redesigns
needed to be done.  All in all, it is not a bad place to be in.  Stepping back and
really appreciating those parts of the project is what I believe keeps me sane.
In the end, the severity of the issues and features evens out, even reducing in scope
the further I get to the end of the project’s first phase.&lt;/p&gt;
&lt;p&gt;Looking ahead, I know that I have a good handful of tough issues to deal with.
Knowing that I was still able to keep a good perspective and keep my wits around me,
I have confidence that I will be able to solve those issues.  Some of them may take
an hour to solve, some may take a couple of days to solve, but I will solve them!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not to sound like I am repeating myself, but this part of the project is all about
keeping the momentum going and solving another handful of issues.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Delving Into the Issues - 1</title><link href="https://jackdewinter.github.io/2020/09/28/markdown-linter-delving-into-the-issues-1/" rel="alternate"></link><published>2020-09-28T00:00:00-07:00</published><updated>2020-09-28T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-28:/2020/09/28/markdown-linter-delving-into-the-issues-1/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/21/markdown-linter-adding-remaining-inline-tokens/"&gt;last article&lt;/a&gt;,
I completed the last bit of work needed to complete the consistency checks.  However,
as I accumulated some items in my issues list, I decided to take some time and make a
sizable dent in that list.  This article details those issues that I investigated …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/21/markdown-linter-adding-remaining-inline-tokens/"&gt;last article&lt;/a&gt;,
I completed the last bit of work needed to complete the consistency checks.  However,
as I accumulated some items in my issues list, I decided to take some time and make a
sizable dent in that list.  This article details those issues that I investigated and
their results.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I am teaching archery at the camps in my local area, I must
constantly keep a level head and strive to find ways keep the kids motivated.  Faced
with children possessing various levels of archery skill, not only do I have to tailor
any assistance to each individual child, but I also try to figure out how to get that
child to retain some part of that assistance. Luckily, I have a couple of tricks up my
sleeve that helps me in this area.&lt;/p&gt;
&lt;p&gt;The most useful trick involves the difference between moving a mountain and moving
a mountain’s worth of pebbles.  When I ask the camper how easy it is to move a mountain,
they usually look at me like I am the most stupid parent on the planet and then proceed
to express how impossible it is in various colorful forms.   As a follow up, when I then
ask them if they can move that mountain one pebble as a time, they state that it would
take a long time, but eventually they would be able
to move that mountain.  Granted, the description of how long that effort would take
differs from camper to camper, some more colorful than others, but they all convey that
it is ultimately doable.&lt;/p&gt;
&lt;p&gt;At that point, I calmly talk to the camper and explain that we are going to start working
on each pebble of their archery skills, one pebble at a time.  At open range events, I
let each group of kids know that me and the other coaches will be there
all day, and will be as helpful at the end of the day as we are at the beginning.
Admittedly, a bit crazier near the end, but we try our best to remain helpful in
the middle of that craziness.&lt;/p&gt;
&lt;p&gt;The reason I mention this story is that when it comes to the items on the project’s
issues list, the list definitely
looks more like a mountain than a pebble to me.  But by taking the same approach with
the items that I do when teaching archery, I can approach that list calmly and not be hit
with a large wall of anxiety.  Instead of seeing the list as a large mountain, I can
choose to see it as a large group of pebbles, moving them one at a time.  My goal at
this point is not to get rid of all those items at once, but to make steady progress
in reducing the size of the issues list, once pebble at a time.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/d56857b8839b2651724935d7b2145b62fb0d20cf"&gt;09 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/573cdf32570611cbc61273cef9c6808fe44137ba"&gt;12 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="starting-with-an-easy-one"&gt;Starting with An Easy One&lt;a class="headerlink" href="#starting-with-an-easy-one" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that I have the consistency checks in place, when I am faced with a problem with a
line number being off or a column number being off, it is a question of whether the
parser’s calculation is wrong or the check’s calculation is wrong.  While I hope that it
is not an error with the consistency checks, I feel that it is a valid question to ask
myself with each issue.&lt;/p&gt;
&lt;p&gt;That is the mindset that I had when I started looking at this issue.  Leftover from my
previous work on
consistency checks, this was an issue where 15-20 minutes of digging into it with
little success caused me to sideline it for later.  The Markdown sample in question was
a modified
&lt;a href="https://github.github.com/gfm/#example-143"&gt;example 143&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;

&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At issue was the tokenization of the Blank Line element at the end of the Block Quote
element.  According to the parser, that Blank Line element was tokenized to
&lt;code&gt;[BLANK(4,1):]&lt;/code&gt;.  However, the consistency checks were stating that the proper
tokenization should be &lt;code&gt;[BLANK(4,3):]&lt;/code&gt;.  Which one was correct?  What was the
miscalculation that was causing one of the two to be off?&lt;/p&gt;
&lt;h3 id="digging-in"&gt;Digging In&lt;a class="headerlink" href="#digging-in" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Performing a quick visual check of the tokenization, things seemed to be valid on
the parser side. The Blank Line element was enough to terminate the HTML element,
but not to also terminate the Block Quote element before the Blank Line element itself.
That part of the test looked good. In addition, the Markdown text does not contain any
other text on that Blank Line, so the position of &lt;code&gt;(4,1)&lt;/code&gt; looked to be an accurate
position for the token.  This meant shifting my focus to the consistency checks.&lt;/p&gt;
&lt;p&gt;Looking at the debug information for the consistency checks, something immediately leapt
out at me.  The debug output read:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;blank_line&amp;gt;&amp;gt;split&amp;gt;['&amp;gt; ', '&amp;gt; ', '&amp;gt; ', '', '']
&amp;gt;&amp;gt;blank_line&amp;gt;&amp;gt;index&amp;gt;1
&amp;gt;&amp;gt;current_position.index_number&amp;gt;&amp;gt;1
&amp;gt;&amp;gt;current_position.index_indent&amp;gt;&amp;gt;0
&amp;gt;&amp;gt;1 + init_ws(2)&amp;gt;&amp;gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Matching that up against the code that produced the debug, it stated that the
&lt;code&gt;index_number&lt;/code&gt; variable was set to &lt;code&gt;1&lt;/code&gt; while the consistency check calculated the number
&lt;code&gt;3&lt;/code&gt; for that same value.  That matched up with the previous information, so looking at
that last line, I saw that the calculation was determining that there was an initial
whitespace of 2 applied to get to the value of &lt;code&gt;3&lt;/code&gt;.  That did not seem right.&lt;/p&gt;
&lt;p&gt;Adding some temporary debug statements, I was able to quickly determine that the reason
that the
check was adding that indent of 2 characters was due to a bad index on the Block Quote
token.  With every newline that occurs within a given Block Quote, the
&lt;code&gt;leading_text_index&lt;/code&gt; field must be updated to point to the current line.  In this case,
the HTML Block had a number of newline characters within its data but had not updated
the index.  As a result, instead of the index being set to 3, it was set to 0.  This
meant that it was picking up the 0th element of the array&lt;sup id="fnref:zeroBased"&gt;&lt;a class="footnote-ref" href="#fn:zeroBased"&gt;1&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;&amp;gt;{space}&lt;/code&gt;,
with its length of 2 instead of the 3rd element in the array, an empty string with its
length of 0.&lt;/p&gt;
&lt;h3 id="fixing-the-problem"&gt;Fixing the Problem&lt;a class="headerlink" href="#fixing-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having learned a decent amount of information from my research, fixing the issue was
relatively
simple.  To increase the index by the right amount, I had to count the number of
newlines in the text and apply that number to the &lt;code&gt;leading_text_index&lt;/code&gt; field.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;newlines_in_text_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;gt;&amp;gt;newlines_in_text_token&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newlines_in_text_token&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;container_block_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leading_text_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;newlines_in_text_token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To err on the side of caution, I also decided to add a couple of extra scenario tests
with further variations on the example.  Just to make sure that the right thing would
happen with an extra line of text, I added an extra line of text and created test
&lt;code&gt;test_html_blocks_143b&lt;/code&gt;.  This addressed my concern that there may be something special
with 2 lines of text, and a third line of text would either highlight or eliminate that
concern.  Then, to make sure that Block Quote lines and their indents were working
properly, I added test &lt;code&gt;test_html_blocks_143c&lt;/code&gt;.  This test alternated the indents for the
Block Quote element between 0 spaces and 1 space, stressing that part of the fix.&lt;/p&gt;
&lt;h2 id="the-start-of-a-series"&gt;The Start of A Series&lt;a class="headerlink" href="#the-start-of-a-series" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This next issue was the start of what I would later refer to as the 518 series of tests.
The process started when I looked at
&lt;a href="https://github.github.com/gfm/#example-518"&gt;example 518&lt;/a&gt;
and I wrote down a note check if all the combinations were covered.  To give more
context, I scribbled down “518, are we sure?” which I interpreted as “Am I sure that I
have all the combinations covered?”.  While it may sound like a weird logically jump
to make from a couple of scribbles, in my own way, I wrote down what was needed to make
sure that I followed it up.&lt;/p&gt;
&lt;p&gt;My thinking was simple.  A standard link, such as the following Markdown from example
518:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;has 6 parts: the link label, the whitespace before the URI, the URI, the whitespace
before the title, the title, and the whitespace after the title.  All other parts of
that link are single characters in nature and required elements.  So, what I did with
this series of tests
is to start changing where the newline(s) were, seeing if I could break anything.  To
add some extra flavor to the tests, I also added a couple of tests that included
backslash characters.&lt;/p&gt;
&lt;h3 id="what-did-i-find-out"&gt;What Did I Find Out?&lt;a class="headerlink" href="#what-did-i-find-out" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The primary thing that I found out was that the parser itself was not handling the
newline characters within links properly.  Specifically, the line numbers and column
numbers were not reflective of the Markdown document that was parsed.  To address
this, the &lt;code&gt;__handle_inline_special&lt;/code&gt; function was modified to handle an alternate
calculation of the line/column number if a Link end token was found.  While the
initial calculation of &lt;code&gt;new_index - next_index&lt;/code&gt; works for any Link tokens that do not
contain a newline character, the calculation for those that included a newline
character was going to be a bit more complicated.&lt;/p&gt;
&lt;p&gt;After trying out a couple of solutions in my head, the only one that gained the
most traction with me
was a staggered approach.  In this approach, I preset an array with the lengths of
various parts of the link, as outlined above.  The function then goes through each of
the parts of the link in their order, checking for newlines for each part as it goes.
If at least one newline character is found, the line variables are updated and the
&lt;code&gt;link_part_index&lt;/code&gt; is set to that part’s index number.  At the end, all values before
that index are reset to 0 and the column number is adjusted by the sum of each value
in the array.&lt;/p&gt;
&lt;p&gt;While there are small fixes along the way to make the algorithm work properly, this
algorithm works well as it keeps things simple.  As each part is checked in turn for
newline characters, the change to the line number variable is accurate.  By setting
and resetting the &lt;code&gt;link_part_index&lt;/code&gt; variable to the last element that had a newline,
only the elements after that index get added to the total, accurately reflecting
the number of characters after the last newline character.&lt;/p&gt;
&lt;p&gt;After that was done, the only extra adjustment that needed to be added was accounting
for whitespace at the start of lines within Paragraph elements, making sure that it
gets applied properly.  That entailed tracking whether or not the parser was currently
processing a paragraph token and using the &lt;code&gt;rehydrate_index&lt;/code&gt; field of the Paragraph
token.  With that in place, manual verification of the newly added case confirmed
that the algorithm was calculating things properly.&lt;/p&gt;
&lt;h3 id="but-what-about"&gt;But What About…?&lt;a class="headerlink" href="#but-what-about" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finishing up the work, there were two things that I knew I needed to work on:
consistency checks and other types of links.  Strangely, the only changes I needed to
the checks were to change Link Reference Definition checks to ensure that it accounted
for the newlines in various components.  Other than that, the everything seemed to
line up.&lt;/p&gt;
&lt;p&gt;As for other types of links, that answer was clear.  Based on the parser code
and the consistency check code, the only type of link that was being tested for newlines
inside of the link were plain inline links.  To combat this, I added extra items to the
issues list, as well as made a mental note to revisit this later.&lt;/p&gt;
&lt;h2 id="fenced-code-blocks-and-blank-lines"&gt;Fenced Code Blocks and Blank Lines&lt;a class="headerlink" href="#fenced-code-blocks-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this did not take a long time to solve, it was a good issue to get out of the
way.  At issue was the Markdown for
&lt;a href="https://github.github.com/gfm/#example-99"&gt;example 99&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;

&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;{space}&lt;/code&gt; stands for an actual space character.  While the actual item reads
&lt;code&gt;fenced, 99 with more blanks&lt;/code&gt;, I knew that I was concerned about not having more
examples with different types of blanks inside of the fenced code block.  To fully
test this, I created many variations on this one test, differing the
number of blank lines and the amount of whitespace on each blank line.&lt;/p&gt;
&lt;p&gt;I was happy to find out that the work on the parser stood up to this extended testing,
and the consistency checks only required a small change.  To be precise, the only
change that it needed was to reset the column number to &lt;code&gt;0&lt;/code&gt; if the
first inline token inside of a Fenced Code block was a Blank Line token.&lt;/p&gt;
&lt;p&gt;I did discover something somewhat puzzling though.  In a Fenced Code block, if the
first token is a Text token, the rest of the body of the block is coalesced. If the
first token is a Blank Line token, then the tokens are not coalesced at all.  Rather
than focus on that at the time, I just noted it down in the issues list, and hoped
to find time soon to figure out if that is the correct solution.&lt;/p&gt;
&lt;h2 id="the-first-inline-token-after-an-atx-heading-token"&gt;The First Inline Token After an Atx Heading Token&lt;a class="headerlink" href="#the-first-inline-token-after-an-atx-heading-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having noticed this one a while ago, it was always something that I wondered about:
why does the parser sometimes insert a whitespace character right after an Atx Heading
token?  I knew I must have a good reason for it, but I could not recall why.  I did find
a couple of scribbles in old notes about Atx Headings, but that was it.  I needed
something more to go on for me to understand this and wrap it up.&lt;/p&gt;
&lt;h3 id="doing-the-research"&gt;Doing the Research&lt;a class="headerlink" href="#doing-the-research" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Going way back in the project’s commit log, I noticed two things:  The first thing was
that this project has been going on for a long while, and the second was that in that
long while, very few of the commits refer to Atx Headings in their commit messages.  To
me, this means that Atx Headings are very stable, something that I felt proud of.
That stability helps me to understand why I did not make any notes around what I was
doing: quite probably they just were not needed.&lt;/p&gt;
&lt;p&gt;There are only 4 times where Atx Headings have
been mentioned in the commit logs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f66221957d761c930728bb8c462576ac951e3552#diff-99f7c38bdec0a4060beb648f08162098"&gt;Adding atx and setext headings.&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;initial addition for Atx Heading support&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/fa7ff7223fd614758b95bf8cde76052671680c7d#diff-99f7c38bdec0a4060beb648f08162098"&gt;Fixing Atx headers to allow better inline processing.&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;moved most text out of the token to allow normal inline processing to take place&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/0565ed9db906873b88d224c829c2acbf9bdb6370#diff-99f7c38bdec0a4060beb648f08162098"&gt;Adding line/column support for tax headings.&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;adding line numbers and column numbers to the tokens&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/573cdf32570611cbc61273cef9c6808fe44137ba#diff-99f7c38bdec0a4060beb648f08162098"&gt;Added testing of every inline at the start of a Atx heading…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;this issue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This summary made it really easy for me to come to the observation that when the change
was made to
allow better inline parsing, the initial whitespace between the Atx Heading and its
enclosed text was placed in the whitespace section of the text token.
By looking at the consistency checks, I also observed that there are zero instances
where an Atx Heading is not immediately followed by a Text token.  After looking at
those two observations and commit history, I do not feel it is a leap to say that
this was a design decision that I made but never recorded.  Further, I feel that the
worst case is that it is a pattern that has a lot going for it and could easily be
adopted as a new design decision.  Either way, it seems to be a winning design.&lt;/p&gt;
&lt;h3 id="backing-up-the-design-decision"&gt;Backing Up the Design Decision&lt;a class="headerlink" href="#backing-up-the-design-decision" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Another thing that I learned from my research was that there was only one case of a
non-Text element following the Atx Heading characters in any of the Markdown examples.
The Markdown for
&lt;a href="https://github.github.com/gfm/#example-183"&gt;example 183&lt;/a&gt; is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;""&lt;/span&gt;&lt;span class="err"&gt;"#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which produces an Atx Heading element with a Link element right after it.  Based on
the previous research, I expected the tokenization to include that whitespace character,
and it did not disappoint:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;"[atx(1,1):1:0:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,3)::&lt;/span&gt;&lt;span class="se"&gt;\a&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="se"&gt;\a\x03\a&lt;/span&gt;&lt;span class="s2"&gt;]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[link(1,3):shortcut:/url:::::Foo:::::]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,4):Foo:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-link:::False]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-atx:::False]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For readers that have not been following along, the &lt;code&gt;\a&lt;/code&gt; character in an inline text
string represents a replacement of one character for another character.  In this case,
the &lt;code&gt;{space}&lt;/code&gt; character between the first two &lt;code&gt;\a&lt;/code&gt; characters is being replaced by
the character &lt;code&gt;\x03&lt;/code&gt; used as a NOOP character.  To me, this means that when the parser
tokenized that part of the line, it purposefully replaced a space character with an empty
string.  Based on the research, this was the right thing to do.&lt;/p&gt;
&lt;p&gt;The rest of addressing this issue was just replicating various forms of this example for
each inline sequence.  Starting with function &lt;code&gt;test_atx_headings_extra_2&lt;/code&gt; and ending with
function &lt;code&gt;test_atx_headings_extra_12&lt;/code&gt;, I just cycled through each of the newline
sequences, include Hard Line breaks.  And with two exceptions, each of the new test
functions passed.&lt;/p&gt;
&lt;p&gt;The first case where I needed to fix something came even before I added the extra
functions: example 183.  To make sure this was working properly, I needed to add an extra
line to the &lt;code&gt;__process_inline_text_block&lt;/code&gt; function of the &lt;code&gt;InlineProcessor&lt;/code&gt; class.  In
the specific case where I was adding that special replacement, I determined that I was
not clearing the &lt;code&gt;starting_whitespace&lt;/code&gt; variable, and that caused the extra text to occur
within the link instead of before the link.  That caused the rehydration to fail as the
space character was in the wrong position.&lt;/p&gt;
&lt;p&gt;The second case was in the &lt;code&gt;__verify_first_inline_atx&lt;/code&gt; function of the consistency
checks.  The function was first cleaned up removing all the extra &lt;code&gt;assert False&lt;/code&gt;
statements and replacing them with an assert that the first token processed within
the Atx Heading was a Text token.  Once that was done, I just reordered the remaining
lines in the function to keep functionality together, and it was done.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I went into this work knowing that at best, I would be able to knock a handful of issues
of the list in one week.  Meeting that goal, it also started to sink in
that the research for each issue was going to take the lion’s share of resolving
each issue.&lt;/p&gt;
&lt;p&gt;If I was lucky, I figured I would stumble upon what I needed to do early in the
research.  But I prepared myself for the probability that, most often, I would need to
add debug statement, add some extra scenario tests, execute all relevant scenario tests,
examine the results of those tests, and iterate.  Sometimes it would only take 1 or 2
iterations, but I figured that most often it would take upwards of 5 to 10 iterations.
Based on my experience with this week’s work, that set of expectations was a healthy
set to start with.&lt;/p&gt;
&lt;p&gt;At this point, I was feeling decently okay.  Not to sound too vague, but what I went
through was right down the middle of what I expected to happen.  As such, I was not
feeling over positive or overly negative, just… well… okay.  If anything, I was
hoping that this “down the middle” result would apply most of the time.  Having too
many quick issues would get my hopes up for the remaining issues and having too many
long running issues would stop any momentum I was gaining.&lt;/p&gt;
&lt;p&gt;But more importantly, I just wanted to keep on working through the issues list.  I was
okay with moving issues to the “nice to have” section that I had created.  But I was
only okay with that if I honestly though it was not required.  If I kept myself
honest, it was a good way to move forward without jeopardizing the project.&lt;/p&gt;
&lt;p&gt;And with that, I ended the work for the week, on a mostly positive note.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed resolving a small number of issues, I was hoping to keep up some
momentum by continuing to solve more issues in the next week.  Simple as that!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:zeroBased"&gt;
&lt;p&gt;A simple reminder that when most people talk about arrays, they refer to an index into that array.  As such, the first element of the array in the zeroth (0th) element of the array. &lt;a class="footnote-backref" href="#fnref:zeroBased" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Remaining Inline Tokens</title><link href="https://jackdewinter.github.io/2020/09/21/markdown-linter-adding-remaining-inline-tokens/" rel="alternate"></link><published>2020-09-21T00:00:00-07:00</published><updated>2020-09-21T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-21:/2020/09/21/markdown-linter-adding-remaining-inline-tokens/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/"&gt;last article&lt;/a&gt;,
I completed the addition of proper support for line and column numbers for the
text token and emphasis tokens by finishing the consistency checks.  In this article,
I talk about the efforts and issues required to finish implementing the line and
column numbers for the …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/"&gt;last article&lt;/a&gt;,
I completed the addition of proper support for line and column numbers for the
text token and emphasis tokens by finishing the consistency checks.  In this article,
I talk about the efforts and issues required to finish implementing the line and
column numbers for the remaining inline tokens, including their consistency checks.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From a wholistic point of view, I felt that the accuracy and consistency of the tokens
were getting more solid with each change.  While I expected a fair number of tests to fail
when I started to add the consistency checks, I was now at a point where a failing test
would be a novel thing. And that was good!  But even with that positive outlook on the
project and the consistency checks, I knew I still had a way to go to finish
things up properly with respect to the tokens.&lt;/p&gt;
&lt;p&gt;After having finished adding the line/column numbers for the Emphasis tokens and the
Text token, the remaining inline tokens were the only things left in the way of
finishing that work.  After the work
I had done on that group of tokens, I was hoping that this would be an easy batch of
work to complete.  But only time would tell.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f518085e03979439ea20f48a787213f1f145eb3a"&gt;04 Sep 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/0d7be8514f459102853974a88810ce6842618e58"&gt;09 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="remaining-inline-tokens"&gt;Remaining Inline Tokens&lt;a class="headerlink" href="#remaining-inline-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having taken care of the Emphasis tokens and the Text token, all the other inline tokens
remained: Raw-HTML, Links, Images, Autolinks, Code Spans and Hard Line Breaks.
Before starting work on each of these tokens, I was not sure if the effort required
to implement each one would be more like the Emphasis tokens or more like the Text
token.  I hoped it would be a simple case and easy to work on, but there were no
guarantees.&lt;/p&gt;
&lt;p&gt;With some optimism in mind, and my fingers crossed, I started my work.&lt;/p&gt;
&lt;h3 id="raw-html-and-links"&gt;Raw HTML and Links&lt;a class="headerlink" href="#raw-html-and-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I write this article and look back at my notes, I fully admit that I am a bit
stumped.  Picking one of these two inline tokens to work on makes sense to me.  I have
no notes to myself saying, “two for the price of one” or “these will be simple”.&lt;br/&gt;
I am left scratching my head as to why I decided to work on both at the same time.
Regardless of why I decided to do both, they were both completed.&lt;/p&gt;
&lt;p&gt;I believed that working on both items at the same time would just be asking for
something to go wrong, so I chose to focus first on the Raw HTML token.  The initial
change was easy, changing the creation of the token from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;RawHtmlMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_raw_html&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;RawHtmlMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_raw_html&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;thereby passing the line number and the column number to the constructor for the
&lt;code&gt;RawHtmlMarkdownToken&lt;/code&gt; class.  Once that was done, another simple change was made
to the &lt;code&gt;handle_angle_brackets&lt;/code&gt; function to pass the current line number and column
number as arguments, as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;after_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HtmlHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_raw_html&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;between_brackets&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;remaining_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="testing-and-iterating"&gt;Testing and Iterating&lt;a class="headerlink" href="#testing-and-iterating" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Running the tests for the Raw HTML token, it was immediately obvious to me that in
certain cases, the column number was off by a bit.  After a bit of research, I noticed
that in cases where there was a Text token before the Raw HTML token, the new Raw HTML
token had the same line/column number as the Text token.  Digging a bit deeper, it
appeared that in those cases, the &lt;code&gt;remaining_line&lt;/code&gt; field of the &lt;code&gt;inline_request&lt;/code&gt; object
had the correct number of characters to make up the difference, but they were not being
applied.&lt;/p&gt;
&lt;p&gt;To address that inadequacy, I made a small change to the above example.  Following the
logic of the inline algorithm, once a new token is created to be inserted, the text
leading up to that token is determined, largely based off the &lt;code&gt;remaining_line&lt;/code&gt;
variable.  While this seems slightly out of order, it ensures that the proper Text token
with the proper line/column number is inserted in the correct order.  However, because
the new token is created before that Text token is inserted, it does not have the
right column number.  By simply adding the length of the &lt;code&gt;remaining_line&lt;/code&gt; variable to
the column number, the difference is accounted for.  This was accomplished by first
calculating that new column number:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;new_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
            &lt;span class="n"&gt;new_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remaining_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and then passing that new &lt;code&gt;new_column_number&lt;/code&gt; value into the call to the
&lt;code&gt;HtmlHelper.parse_raw_html&lt;/code&gt; function in the previous example instead of the
&lt;code&gt;inline_request.column_number&lt;/code&gt; argument.&lt;/p&gt;
&lt;h4 id="new-lines-inside-of-the-token"&gt;New Lines Inside of the Token&lt;a class="headerlink" href="#new-lines-inside-of-the-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;After running through the tests again, almost all the tests were passing, except for
the test for
&lt;a href="https://github.github.com/gfm/#example-500"&gt;example 500&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This case may look weird, but everything is computed properly as a series of Text
tokens and a Raw HTML token.  Because of
the newline in the URI, the text is not eligible to be a link, but since the URI part
is enclosed in “angle brackets”, it is eligible to be a Raw HTML token.  But even with
the Raw HTML token being parsed, the Text token containing the trailing &lt;code&gt;)&lt;/code&gt; character was
off.  Instead of being reported as &lt;code&gt;(2,5)&lt;/code&gt;, it was being reported as &lt;code&gt;(1,17)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To investigate this further, I created the new scenario test &lt;code&gt;test_raw_html_634a&lt;/code&gt;.  This
new test was a more isolated
case of example 500, a copy of the test function &lt;code&gt;test_raw_html_634&lt;/code&gt; with a newline
character inserted inside of the &lt;code&gt;b2&lt;/code&gt; HTML tag, as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;  &lt;span class="o"&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;b2&lt;/span&gt;
&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="ss"&gt;"foo"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I started to look at this issue and
it turned out to be an easy issue to overcome.&lt;/p&gt;
&lt;h4 id="fixing-newlines"&gt;Fixing Newlines&lt;a class="headerlink" href="#fixing-newlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;With this isolated scenario test, it was very easy to see that the issue was with the
&lt;code&gt;raw_tag&lt;/code&gt;
field of the Raw HTML token.  When the token contained a newline character, that newline
was treated as a normal character and added to the character count.  What I needed to
do was to make sure that the algorithm understood that the newline character was special
and to handle it differently.  So, to address that
behavior, I introduced some extra code to the &lt;code&gt;handle_angle_brackets&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;new_token&lt;/span&gt;
    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_raw_html&lt;/span&gt;
    &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_tag&lt;/span&gt;
&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;split_raw_tag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_tag&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_line_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_raw_tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;length_of_last_elements&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_raw_tag&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length_of_last_elements&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;inline_request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_index&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inline_response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, since the existing code already handled the case with zero newlines perfectly,
I did not need to change that aspect of the function.  However, in the case of a Raw HTML
token that contained a newline in its &lt;code&gt;raw_tag&lt;/code&gt; field, I needed special processing to
kick in.  The first thing I
needed was a clear picture of the &lt;code&gt;raw_tag&lt;/code&gt; field and its newline characters, so I
split the string on newline characters into the &lt;code&gt;split_raw_tag&lt;/code&gt; variable.  Then I
addressed the line number calculation first, correcting the line number calculation by
adding the number of newline characters found to the &lt;code&gt;inline_response.delta_line_number&lt;/code&gt;
variable.&lt;sup id="fnref:splitLine"&gt;&lt;a class="footnote-ref" href="#fn:splitLine"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;After I was sure that the line number was being correctly calculated, it was time for me
to focus on the column number.  While each of the lines in the &lt;code&gt;raw_tag&lt;/code&gt; field were
important, their content was already mostly covered by the calculation for the change to
the line number.  Each line except the last line that is.  That last line was the new
information that would lead the text after the Raw HTML token.  As such, the column
number was at least as many characters along as the length of any text past that last
newline character, as calculated for the &lt;code&gt;length_of_last_elements&lt;/code&gt; variable.  With
that calculation completed, all that was required was to add 2 to that value for
constant element overhead: 1 for
the length of the closing angle brackets (&lt;code&gt;&amp;gt;&lt;/code&gt;) and 1 to translate the value from an
index to a position.&lt;sup id="fnref:indexPosition"&gt;&lt;a class="footnote-ref" href="#fn:indexPosition"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h4 id="conveying-that-information-back-to-the-caller"&gt;Conveying That Information Back to The Caller&lt;a class="headerlink" href="#conveying-that-information-back-to-the-caller" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;With everything else completed, I then had to decide how I was going to get the newly
calculated column number back to the calling function.  According to the debug
statements that I had added, the value was being calculated properly.  While there were
a couple of options on the table, I decided to go for a simple approach: a negative
number.&lt;/p&gt;
&lt;p&gt;I am not sure if this choice is
&lt;a href="https://blog.startifact.com/posts/older/what-is-pythonic.html"&gt;pythonic&lt;/a&gt;
or not, I believe that it conveys the right information in an efficient manner.
If the column number is zero or positive, it represents a simple change or delta to the
column
number, a simple value to be added to the current column number to arrive at the new
column number.  However, if the column number is negative, it represents an absolute
number that should be used for the column number.  For example, if the token contains
a newline character, it makes sense that the returned value would indicate a value
from the start of the new line, not from the last know position.&lt;/p&gt;
&lt;p&gt;Why a negative number?  While I could have returned an extra value that determined
whether the number was referential or absolute, that seemed too bulky.  For me, this
was keeping it lean within its limited scope.&lt;/p&gt;
&lt;h4 id="adding-validation"&gt;Adding Validation&lt;a class="headerlink" href="#adding-validation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;After all that work, the validation was very anti-climactic.  It may appear that I
cheated and copied the calculation from above as-is into the new
&lt;code&gt;__verify_next_inline_raw_html&lt;/code&gt; function.  Rather than being a cheat, I worked
through the calculations again on paper, making sure that I did not miss any weird
boundary conditions.  After generating the algorithm in the
&lt;code&gt;__verify_next_inline_raw_html&lt;/code&gt; function from scratch, I compared the two algorithms
together and the algorithms themselves were the same.  Rather than cheating,
I considered it a validation that I had derived the right algorithm twice.&lt;/p&gt;
&lt;h4 id="what-about-the-links"&gt;What About the Links?&lt;a class="headerlink" href="#what-about-the-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;As I mentioned at the start of this section, I am not sure why I decided to work on
these two tokens together.  I can only guess that perhaps
I thought that adding line/column numbers to the Link tokens would uncover something
important that adding line/column numbers to the Raw HTML tokens would not.
The reality was that after completing the Raw HTML token work, the changes needed
to implement the line/column numbers for Link tokens was trivially easy.&lt;/p&gt;
&lt;p&gt;Unexpectantly, this would foreshadow the following work on the other inline tokens.&lt;/p&gt;
&lt;h2 id="autolinks-code-spans-images-and-hard-line-breaks"&gt;Autolinks, Code Spans, Images and Hard Line Breaks&lt;a class="headerlink" href="#autolinks-code-spans-images-and-hard-line-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I expected some manner of difficulty in implementing the line/column numbers
for these tokens, however the previous work made the implementation of the new code easy.
There were issues that needed to be properly addressed for each specific type of
token, but the hard work had already been done.  As such, the work was more akin
to copy-and-paste-and-adjust than anything else.&lt;/p&gt;
&lt;p&gt;In the implementation of each of the tokens, the initial calculation for each of the
tokens included values for the length of the constant part of the element and the
variable part of
the element.  Once that was complete and the easy tests were passing, any multiline
parts were addressed, with progress being made to get closer to having the remaining
scenario tests passing.  To finish that work, consistency checks were added that were
simply verifying the algorithms used previous and verifying the work.&lt;/p&gt;
&lt;p&gt;This process was a simple rehash of the work that I did for the Raw HTML token, and
then again for the Link token.  But it was working and working well.  While a part
of me was saying “this is too easy, what’s wrong?”, I double checked all my work
to quiet that voice and assure myself that I had not missed anything.&lt;/p&gt;
&lt;p&gt;While it was simple work, it did take a couple of days to complete.  But at the end
of that work, each relevant token had a line number and a column number, and they
had been verified.  Even more interesting, while some extra scenarios were added to
deal with missing cases (mostly to deal with multiline element parts), no new issues
had been found.  Things were looking good.  Almost.&lt;/p&gt;
&lt;h2 id="last-inline-vs-next-block"&gt;Last Inline vs Next Block&lt;a class="headerlink" href="#last-inline-vs-next-block" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With all the inline tokens supporting line/column numbers, I felt as if a bit of
a load was taken off of my shoulders.  I was not really worried that there was something
wrong, but as I mentioned
&lt;a href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/#introduction"&gt;in the last article&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I know that I am fallible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There was no proof that I could see that I had missed something, but I just had a
nagging feeling that I had left something out.  Trying to get rid of that feeling, I went
through the work that I had just completed and checked it again, finding nothing out
of the ordinary.  On top of that, I had automation in place to catch any miscalculations
that I made, something that was welcome.&lt;/p&gt;
&lt;p&gt;After that extra checking was completed, I could not find anything wrong and I was ready
to move on.  But as I was getting ready to start working on some of the items
in the issue list, I noticed something.  Reading my previous article to gain some
extra perspective on where I was in the project, I noticed the part where I stated:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So, whether I liked the idea or not, validation of the first element in the list was mandatory.  The last element is a different story.  While it would be nice to tie the last inline token to the following block token, I felt that it was not as important as the verification of the first element.  However, I added in a placeholder to the code to make sure that I would follow up on it later.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I remembered!&lt;/p&gt;
&lt;h3 id="the-other-anchor-for-the-inline-tokens"&gt;The Other Anchor for the Inline Tokens&lt;a class="headerlink" href="#the-other-anchor-for-the-inline-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I mentioned before, I started with the outer token and the first token because
I wanted to ensure that was able to anchor the list, and the anchoring the first token
was the easiest solution at the time.  Having finished that task off and
also having finished validation of the inline tokens within the list, it was now time to
work on anchoring the other side of the list: the last inline token and the following
block token.  That is what the nagging feeling was! That is what I was trying to
remember.&lt;/p&gt;
&lt;p&gt;Starting to research what I needed to do to resolve this anchor issue, I came to an
interesting
observation.  While all groups of inline tokens start after a block token, not all
groups of inline tokens end with a block token.  Because of the way tokenization is
performed, I decided not to expose line/column numbers for any of the end tokens that
did not add something to the data stream.  This means that except for the
Emphasis end token, none of the other end tokens have a line/column associated with
them.&lt;/p&gt;
&lt;p&gt;Why is that observation on tokenization important?  A good example is the Markdown
document for
&lt;a href="https://github.github.com/gfm/#example-364"&gt;example 364&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From that Markdown,
I can surmise that the tokens for that document will start with a Paragraph
start token and end with a Paragraph end token.  Inside of the paragraph, there will be
a Text token containing &lt;code&gt;foo&lt;/code&gt;, an Emphasis start token, a Text token containing &lt;code&gt;bar&lt;/code&gt;,
and an Emphasis end token.  This is backed up by the realized tokens for the example,
which are:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;"[para(1,1):]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,1):foo:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[emphasis(1,4):1:*]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text(1,5):bar:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-emphasis(1,8)::1:*:False]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para:::True]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From looking at this tokenization, the last token with a line/column number attached
to it is the Emphasis end token, an inline token.  Getting an actual block token to
appear after those tokens is as simple as changing the Markdown to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This adds a new Blank Line token to the end of the array, adding the tokenization
&lt;code&gt;'[BLANK(2,1):]'&lt;/code&gt;.  However, I knew the real trick would be to determine that value
without having to add that extra token.&lt;/p&gt;
&lt;h3 id="focusing-on-that-line-number"&gt;Focusing on That Line Number&lt;a class="headerlink" href="#focusing-on-that-line-number" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Working through the issue from the previous section helped me understand something
else about the relationship with the last inline token and the possible following
block token: only the line number was important.  Because the inline tokens
are always contained within a container block element or a leaf block element, the
last token in an inline token group is guaranteed to be either an end token for a
previously started block element or a start token for a new block element.&lt;/p&gt;
&lt;p&gt;If the next block token after the inline tokens is a block start token, because of
the work up to this point, a line/column number is guaranteed.  If the next block
token is a block end token, one of two things happens.  Either a block start token
follows with the start of a new block element, or the end of the document is reached.
If a block start token follows, the line/column number is guaranteed as above.
In the case of the end of the document, as no token with a valid line/column number
follows, some other calculation is needed to determine the line number to compare
to.&lt;/p&gt;
&lt;p&gt;The good news is that only the line number is important.  Because only the line number
is important, there is another available number that we can use: the number of lines
in the Markdown document.  As such, if there is a block start token after the inline
block, I used the line number from that token as the line number to compare against.
If no such token existed, I used the number of lines in the document.&lt;/p&gt;
&lt;p&gt;I tested this approach with a handful of scenarios, some with eligible following block
tokens and some with an absence of eligible following block tokens.  On paper it seemed
to work without fail.  The only thing that was left was to test that approach with
actual code.&lt;/p&gt;
&lt;h3 id="completing-the-checks"&gt;Completing the Checks&lt;a class="headerlink" href="#completing-the-checks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To calculate the line number to compare to, I added the &lt;code&gt;__verify_last_inline&lt;/code&gt;
function with my usual development pattern.  Following that pattern, I started
adding handlers for each of the inline tokens it encountered, just trying to
get to a steady state where all the handlers were present.  Once that was achieved,
I started adding the content to each handler to calculate the height of the inline
token.&lt;/p&gt;
&lt;p&gt;Now I wish I could say it was good planning, but it was just serendipity that I
did this work right after the work on adding the line/column number support to most
of the inline tokens.  Based on that recent work, adding the calculations for the
heights of each of the tokens was exceedingly easy.  While it was easy, it took
a couple of days for me to work through each case and verify each twist and turn
of the token.  But in the end, with only one planned failure&lt;sup id="fnref:IKnew"&gt;&lt;a class="footnote-ref" href="#fn:IKnew"&gt;3&lt;/a&gt;&lt;/sup&gt; to address and
one or two items to look at later, the token validation was complete!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Getting to this point in the PyMarkdown project was a momentous achievement for
me, measured in months rather than days.  Along the way, I had developed a
Markdown parser, ensured that it emitted tokens that include line numbers and
column numbers, verified its output against both expected HTML output and the original
Markdown input, and had a good array of consistency checks on the line numbers and
column numbers.  Phew.  It was a long list, but the project has come a long way.&lt;/p&gt;
&lt;p&gt;I was relieved that I got to this point with my original design mostly intact.  I
was aware that I was going to have to do some refactoring in the future to make the
code more modifiable, but I believe it is in a decent position to make that happen.
Besides, when I start doing that, I have almost 1400 scenario tests that will make
sure any changes are not negatively impacting the code.&lt;/p&gt;
&lt;p&gt;With all that good stuff in mind, I started to look at the issues list, and paged
through it.  At just over 200 lines of text, it was a bit daunting to look at initially.
But as I progressed with the project, any idea or question I had was put into that
list.  There were ideas for better tests, questions on whether something was done right,
and notes on things I wanted to check because they looked weird in some way.  And during
the project’s development to date, I had taken proactive efforts to get any
serious issues out of the way.  Being the optimistic, I hoped that I was left with a
solid set of enhancements.  Regardless
of what remained in the list, I was sure that I could tackle it.  And sure, there
might be some rewrites that I would need to do, but they would make the project stronger,
leaner, faster, and more maintainable.&lt;/p&gt;
&lt;p&gt;So how was I feeling?  Very optimistic.  There were quite the number of items in the
issues list, but if I tackled them one at I time, I could get through them.  And going
through them would either fix an issue or confirm that the project did not have that
particular issue.  And to me, both outcomes were positive.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed all the consistency checks, I now had operating scenario tests with
values and line/column numbers that I was very confident about.  But along the way,
I had accumulated a decent number of items in the issues list.  Before getting back
to filling out the set of rules, it was time to address those items.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:splitLine"&gt;
&lt;p&gt;Python’s &lt;code&gt;split&lt;/code&gt; function works as expected.  If you have a string that does not contain the sequence to split on, it returns an array with one element.  If you have a string that has one or more instances of the sequence to split on, it returns an array with each element being any text between those instances.  As such, if a string has one newline character and is split, it will result in an array with a length of 2.  Therefore, I used &lt;code&gt;len(split_raw_tag) - 1&lt;/code&gt; to figure out the number of newline characters found in the &lt;code&gt;raw_tag&lt;/code&gt; field. &lt;a class="footnote-backref" href="#fnref:splitLine" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:indexPosition"&gt;
&lt;p&gt;By their nature, an index starts at 0 and a position starts at 1.  As a column number is a position on a line but was being computed as an index, I needed to add 1 to the value to transition it into being a position. &lt;a class="footnote-backref" href="#fnref:indexPosition" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:IKnew"&gt;
&lt;p&gt;Ahead of time, I had already determined that the scenario test &lt;code&gt;test_inline_links_518b&lt;/code&gt; was split over multiple lines and would be addressed by this validation. &lt;a class="footnote-backref" href="#fnref:IKnew" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Consistency Checks for Emphasis and Text Tokens</title><link href="https://jackdewinter.github.io/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/" rel="alternate"></link><published>2020-09-14T00:00:00-07:00</published><updated>2020-09-14T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-14:/2020/09/14/markdown-linter-adding-consistency-checks-for-emphasis-and-text-tokens/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/"&gt;last article&lt;/a&gt;,
I started to add the proper support for line and column numbers for both the text
tokens and the emphasis tokens.  In this article, I increase my confidence in the
line and column numbers for those two inline tokens by adding the consistency checks
for …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/"&gt;last article&lt;/a&gt;,
I started to add the proper support for line and column numbers for both the text
tokens and the emphasis tokens.  In this article, I increase my confidence in the
line and column numbers for those two inline tokens by adding the consistency checks
for those tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I know that I am fallible.  It therefore stands to
reason that any code that I write will have some issues with it.  Those issues may be
obvious issues, or they may be issues that only occur under a bizarre set of
circumstances, but they are there.   Rather than fight against them, I embrace
the attitude that good test automation will help me to identify those types of issues
as early as possible.&lt;/p&gt;
&lt;p&gt;For the PyMarkdown project, this test automation takes the form of scenario tests
containing consistency checks.  These consistency checks validate that the Markdown
documents in the scenario tests are properly interpreted by the PyMarkdown project.
But while these consistency checks are beneficial, the consistency checks have
taken a long while to complete.  After 3 calendar months have passed, it can easily be
said that my decision
to add consistency checks to the project removed 3 months of project development time
and replaced it with 3 months of project test time.  Plain and simple, those statements
are facts.&lt;/p&gt;
&lt;p&gt;My confidence about the project and its ability to work correctly is an emotional and
abstract statement.  However, with effort, I have been able to move it in the direction
of being more of a fact than a feeling.  The consistency checks are a form
of test automation that apply a generalized set of rules over a group of tokens,
looking for each group to behave in a predictable manner.  Before this work,
my confidence was expressed as a feeling: “I believe the project is stable”.  With
this work nearing its completion, I can now point to the scenario tests and consistency
checks that run within those scenario tests.  I can state that each of the scenario
tests is passing a rigorous set of criteria before it is marked as passing.  That
confidence can now be expressed as: “Here are the tests that are passing and the
checks that are being performed on each test.”&lt;/p&gt;
&lt;p&gt;From that point of view, it made sense that before I start working on setting the
line/column numbers for the remaining inline tokens that I would implement the
consistency checks for the Text token and the Emphasis tokens.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/c6cc992fa4c5c7c25f2a93038010dfab84a22da8"&gt;02 Sep 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="getting-started-with-inline-token-validation"&gt;Getting Started With Inline Token Validation&lt;a class="headerlink" href="#getting-started-with-inline-token-validation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At the start of the week, the code used to verify the consistency of inline tokens was
extremely simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;gt;&amp;gt;last_token:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_value_visible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;next_token_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;last_token_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;next_token_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"-token:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_value_visible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;next_token_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;next_token_index&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Added in as a placeholder to allow me to see what was going on with the inline tokens,
it served its purpose well.  But as I started to work on the inline tokens
and their line/column numbers, I needed to facilitate better consistency checking of
those inline tokens.&lt;/p&gt;
&lt;p&gt;To start the work off, I removed that placeholder code from two places in the code
and replaced both with a call to a new function &lt;code&gt;verify_inline&lt;/code&gt;.  The only
difference between the two
invocations of the function were the fourth argument, &lt;code&gt;current_token&lt;/code&gt;.  Called for
the first time from the_&lt;code&gt;__verify_token_height&lt;/code&gt; function, the &lt;code&gt;current_token&lt;/code&gt; variable
is set to the block token after a series of inline tokens.  The second time it is
called, it is called at the end of processing to capture any inline tokens that are
within one of the valid text elements, but at the very end of the document.  When it
is invoked from that location, that same argument is set to &lt;code&gt;None&lt;/code&gt;.  In both cases,
the inline tokens to be validated were clearly outlined for the &lt;code&gt;verify_inline&lt;/code&gt;
function.&lt;/p&gt;
&lt;h3 id="clearly-defining-the-problem"&gt;Clearly Defining the Problem&lt;a class="headerlink" href="#clearly-defining-the-problem" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Before doing any real processing with the inline tokens, I needed to create a simple
list containing the actual inline tokens that I wanted to check.  I could have done that
with the main list of tokens and the previously document outlining.  However, I thought
about it and decided that it was clearer to have a separate list that just
contained the tokens that I was concerned about.  Once I had all the inline tokens
between the two block tokens in that new list, there was a small amount of work to do
before the list was usable.  While it was not difficult, the new list had some extra
end tokens at the end of the list that needed to be removed.  Working around
those extra end tokens would have been okay, but I just felt that it was simpler to
remove them from the list before I did any further processing.&lt;/p&gt;
&lt;p&gt;Having a simple list of the inline tokens to work with, the first iteration of the
checking algorithm started with an easy outline to follow:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;token_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;token_index&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;__verify_first_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;__verify_next_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;inline_tokens&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;token_index&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                    &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# verify_last_inline(inline_tokens[-1], current_inline_token)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From my viewpoint, the processing of the inline tokens had 3 distinct phases: the first
element in that list, each element after it, and the last element in that list.  Based
on their locations, the first and last elements are special in that they anchor the
other inline tokens to the block tokens on either side of the middle elements.  Without
those anchors, the middle elements lack a foundation with which they can based their
positions on.&lt;/p&gt;
&lt;p&gt;Based on those observations, I chose to implement the check for the first inline token
against the previous block token, and not the check for the last inline token against
the following block token.  Without validating the first element, validating any of the
elements on the inside of the list would be useless.  So, whether I liked the idea or
not, validation of the first element in the list was mandatory.  The last element
is a different story.  While it would be nice to tie the last inline token to the
following block token, I felt that it was not as important as the verification of the
first element.  However, I added in a placeholder to the code to make sure that I
would follow up on it later.&lt;/p&gt;
&lt;h3 id="validating-the-first-element"&gt;Validating the First Element&lt;a class="headerlink" href="#validating-the-first-element" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Following the pattern that I have used for validation in the past, I created the
&lt;code&gt;__verify_first_inline&lt;/code&gt; function with my standard starting template:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_first_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As this function is comparing the starting position of the first inline token to the
last valid block token, the &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; in the above code sample was quickly replaced
with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_atx_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_setext_heading&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_paragraph&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_fenced_code_block&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_indented_code_block&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_html_block&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and one by one I added the validation functions to replace the &lt;code&gt;assert False&lt;/code&gt;
statements.  Following that same pattern for
resolving these as I have before, I ran the scenario tests over the entire project
using the command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -m gfm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each time, I just picked one of the failing tests, and worked on that tests in that
group until they were all passing.  For each validation function, I repeated the same
pattern with the first inline
token that was observed.  For example, the &lt;code&gt;__verify_first_inline_atx&lt;/code&gt; function quickly
evolved to look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_first_inline_atx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Handle the case where the last non-inline token is an Atx Heading token.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="n"&gt;col_pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hash_count&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;replaced_extracted_whitespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resolve_replacement_markers_from_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;col_pos&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;replaced_extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;col_pos&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_hard_break&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_link&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
            &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EndMarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_name_prefix&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_inline_link&lt;/span&gt;
        &lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="what-did-i-discover"&gt;What Did I Discover?&lt;a class="headerlink" href="#what-did-i-discover" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Predictably, I discovered that there are 2 groups of text within block tokens: ones
that support
inline tokens other than the Text token, and ones that do not.  The ones that do not
support inline tokens are
mostly easy: assert that the inline token is a Text token, and then assert on a simple
calculation of the first line/column number.  The validation of the HTML Block token and
the Indented Code Block token both followed this pattern, with very simple validation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_first_inline_html_block&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;
    &lt;span class="n"&gt;leading_whitespace_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;leading_whitespace_count&lt;/span&gt;
        &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Fenced Code Block tokens required a bit more effort, but not much. As the Fenced
Code Blocks can start with 0-3 space characters that then need to be managed on any
subsequent line in the code block, the owning block token’s &lt;code&gt;leading_spaces&lt;/code&gt; variable
holds the information on what leading spaces were already removed.  As such, when
calculating the proper position of the first Text token inside of a Fenced Code Block,
that removed space needs to be accounted for.  To properly facilitate that, the
&lt;code&gt;last_token_stack&lt;/code&gt; argument needed to be plumbed through so the verification function
could calculate the proper owning blocking token.&lt;/p&gt;
&lt;p&gt;The second group of block tokens were the more interesting group of tokens to deal with.
This group of tokens includes the Atx Heading tokens (as shown in the above example),
SetExt Heading tokens, and Paragraph tokens.  The &lt;code&gt;__verify_first_inline_atx&lt;/code&gt; function
and the &lt;code&gt;__verify_first_inline_setext&lt;/code&gt; function ended up looking similar: the Text
inline token case was populated, but all the other types of inline tokens were handled
with &lt;code&gt;assert False&lt;/code&gt; statements.  The &lt;code&gt;__verify_first_inline_paragraph&lt;/code&gt; function was
similar, but also slightly different.  The same template was used to generate the
function, but each of the conditions in the &lt;code&gt;if-elif-else&lt;/code&gt; block were met at least once.
However, since only the Text token and the Emphasis token have line/column numbers,
allowing this comparison to be performed for them:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last_non_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the other inline tokens, the ones that did not currently have a line/column assigned
to them (yet), used the following comparison:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;first_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was not much, but it gave me two important bits of information.  The first was that
there was at least one case where each available inline token was the first inline
token inside of a Paragraph token.  The second was that both heading tokens, the Atx
Heading token and the SetExt Heading token, only contained scenario tests that started
with Text tokens.  I made a note of that observation in the issue’s list and moved on.&lt;/p&gt;
&lt;h2 id="verifying-the-middle-tokens"&gt;Verifying the Middle Tokens&lt;a class="headerlink" href="#verifying-the-middle-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the validation of the first element out of the way, it was time to start working
on the &lt;code&gt;__verify_next_inline&lt;/code&gt; function.  Now that the middle tokens were anchored at
the beginning, each of the middle inline tokens could be validated against the inline
token that preceded it.  Since I knew that most of the inline tokens had not
been handled yet, I started out that function with a slight change to the template:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__verify_next_inline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pre_previous_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;
&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;

    &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;
    &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt;

    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s2"&gt;"&amp;gt;&amp;gt;est&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;estimated_line_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&amp;gt;act&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s2"&gt;"&amp;gt;&amp;gt;est&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;estiated_column_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&amp;gt;act&amp;gt;"&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first set of &lt;code&gt;if&lt;/code&gt; statements made sure that if either the previous inline token or
the current inline token
was one that I had not worked on yet, it would return right away.  While this assumed
that the line/column numbers were correct to a certain extent, I was okay with that
assumption in the short term.  The second part computed a starting point for the new
line/column numbers, and then went into the usual pattern of dealing with
each of the eligible tokens by name.  Finally, the third part compared the modified
line/column numbers against the actual line/column numbers of the current token,
asserting with meaningful information if there were any issues.&lt;/p&gt;
&lt;h3 id="emphasis-tokens"&gt;Emphasis Tokens&lt;a class="headerlink" href="#emphasis-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I thought it would be quick to get emphasis out of the way, and it was!  As both the
start and end Emphasis tokens contain the &lt;code&gt;emphasis_length&lt;/code&gt;, it was a quick matter of
adjusting the column number by that amount.  As both tokens are confined to
a single line, there was no adjusting of the line number to worry about.&lt;/p&gt;
&lt;h3 id="text-tokens"&gt;Text Tokens&lt;a class="headerlink" href="#text-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As mentioned in a previous section, there are two major groups of block tokens
that contain Text tokens: ones that allow all inline tokens and ones that do not allow
inline tokens except for the Text token.  The ones that do not allow inline tokens are
simple, as all the
information about the Text token is contained within the token itself.  It is the
other group that are interesting to deal with.&lt;/p&gt;
&lt;p&gt;The easy part of dealing with the Text token is determining the new line number.
With the exception of a Text token that occurs right after a Hard Line Break token,
the calculation is simple:  split the text by the newline character, subtract 1,
and that is the number of newlines in the Text token.  If the token before the Text
token was a Hard Line Break token, it already increased the line number, but the
Text token that followed also started with a newline character.  To remedy this,
that pattern is looked for, and the &lt;code&gt;current_line&lt;/code&gt; variable adjusted to remove the
newline character at the start of the line.&lt;sup id="fnref:noted"&gt;&lt;a class="footnote-ref" href="#fn:noted"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Determining the column number is a more interesting task to undertake.  For any
Text tokens occurring within a block that does not allow for extra inline tokens,
the column number information is already in the token itself, and the calculation
is as simple.  The column delta is equal to the number of text characters stored
within the token&lt;sup id="fnref:processing"&gt;&lt;a class="footnote-ref" href="#fn:processing"&gt;2&lt;/a&gt;&lt;/sup&gt;.  If there was a newline in the token’s text, this
count is started after the last newline character.&lt;/p&gt;
&lt;p&gt;The second group of block tokens that can contain text are the Atx Heading token, the
SetExt Heading token, and the Paragraph token.  Since the Atx Heading token can only
contain a single line’s worth of data, no extra calculations are required to handle
multiple line scenarios.  In the case of the other Heading token, the SetExt Heading
token, the starting whitespace is stored in the Text token’s &lt;code&gt;end_whitespace&lt;/code&gt; field.
The processing of this information is a bit tricky in that the starting and ending
whitespace for the Text tokens within the SetExt Heading token is stored in that
field using the &lt;code&gt;\x02&lt;/code&gt; character as a separator.  Still, determining the proper
indent and applying it to the column number is relatively simple.&lt;/p&gt;
&lt;p&gt;Dealing with a Text token within a Paragraph token is a lot more work.  Due to other
design reasons, the whitespace indent for these Text tokens is stored within the
owning Paragraph token.  While that is not difficult by itself, keeping track of which
indent goes with which line is a bit of a chore.  Luckily, when I was working on the
Markdown transformer, I introduced a variable &lt;code&gt;rehydrate_index&lt;/code&gt; to the Text token.
When rehydrating the Text token, I used this variable to keep track of which stripped
indent needed to be added back to which line of any subsequent Text tokens. Given
the prefix whitespace for any line within the Paragraph block, calculating the
column number delta was easy.&lt;/p&gt;
&lt;h3 id="blank-line-tokens"&gt;Blank Line Tokens&lt;a class="headerlink" href="#blank-line-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;That left the Blank Line tokens to deal with, and I hoped that the effort needed to
complete them was more in line with the Emphasis tokens than the Text tokens.  I was
lucky, and the Blank Line tokens were easy, but with a couple of small twists.
Intrinsically, a blank line
increases the line number and resets the column number to 1.  That was the easy part.
The first twist is that if the current token is a Text token, that text token can
provide leading whitespace that needs to be considered.  That was easily dealt
with by adding the following lines to the handler:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The more difficult problem occurred when 2 blank line tokens appear one after the
other within a Fenced Code Block token.  Because of how the numbers added up, I needed
to adjust the &lt;code&gt;estimated_line_number&lt;/code&gt; variable by one.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_blank_line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;previous_inline_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MarkdownToken&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_blank_line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;estimated_line_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;estiated_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that tweak being done, all the tests were then passing, and it was time to
wrap it up.&lt;/p&gt;
&lt;h2 id="was-it-worth-it"&gt;Was It Worth It?&lt;a class="headerlink" href="#was-it-worth-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The interesting part about defensive code is that sometimes you are not aware of how
good that defense is.  Using the analogy of a castle, is a castle better defensible if
it can withstand attack or if it deters others from attacking the castle?  While I
did not have any information about potential attacks that were stopped ahead of time,
there were 2 actual issues that the current round of consistency checks did find.&lt;/p&gt;
&lt;h3 id="issue-1-image-link"&gt;Issue #1: Image Link&lt;a class="headerlink" href="#issue-1-image-link" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first of those issues was an issue with the column number for
&lt;a href="https://github.github.com/gfm/#example-600"&gt;example 600&lt;/a&gt;
as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;!\&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Before these inline consistency checks were added, the text for the &lt;code&gt;]&lt;/code&gt;
character was reported as &lt;code&gt;(1,6)&lt;/code&gt;.  By simply counting the characters, the &lt;code&gt;!&lt;/code&gt;
character starts at position 1 and the second &lt;code&gt;o&lt;/code&gt; character is at position 6.  As
such, the &lt;code&gt;]&lt;/code&gt; character should be reported as &lt;code&gt;(1,7)&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;Doing some research, I concluded that the handling of a properly initiated Image
token was being handled properly.  However, with a failed Image token sequence,
the &lt;code&gt;!&lt;/code&gt; character followed by any other character than the &lt;code&gt;[&lt;/code&gt; character, the
&lt;code&gt;!&lt;/code&gt; character was being emitted, but the column number’s delta wasn’t being set.
Adding the line&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;inline_response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delta_column_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;at the end of the &lt;code&gt;__handle_inline_image_link_start_character&lt;/code&gt; function solved that
issue.&lt;/p&gt;
&lt;h3 id="issue-2-a-simple-adjustment"&gt;Issue 2: A Simple Adjustment&lt;a class="headerlink" href="#issue-2-a-simple-adjustment" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The second of those issues was more of a nitpick that an actual issue.  In the
tokenization for
&lt;a href="https://github.github.com/gfm/#example-183"&gt;example 183&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the first line was tokenized as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "[atx(1,1):1:0:]",
        "[text(1,3):\a \a\x03\a:]",
        "[link:shortcut:/url:::::Foo:::::]",
        "[text(1,4):Foo: ]",
        "[end-link:::False]",
        "[end-atx:::False]",
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having a lot of experience sight reading serializations for all the tokens, the
information in the Text token leapt out at me right away.  In that token, the extra
data associated with the token is composed by adding the &lt;code&gt;self.token_text&lt;/code&gt; field,
the &lt;code&gt;:&lt;/code&gt; character, and the &lt;code&gt;self.extracted_whitespace&lt;/code&gt;.  Based on the above
tokenization, that meant that the text sequence &lt;code&gt;\a \a\x03\a&lt;/code&gt; was being considered
as text instead of whitespace.&lt;/p&gt;
&lt;p&gt;To understand why I thought this is wrong requires an understanding of the
existence of that character sequence.  The &lt;code&gt;\a&lt;/code&gt; sequence is used to denote that
a sequence of characters in the original Markdown document was interpreted and
replaced with another sequence of characters.  The &lt;code&gt;\x03&lt;/code&gt; character within the
second half of that sequence means that the &lt;code&gt;{space}&lt;/code&gt; character in the first part
of the sequence is being replaced with the empty string.  Basically, to properly
represent the space between the &lt;code&gt;#&lt;/code&gt; character denoting the Atx Heading element
and the &lt;code&gt;[&lt;/code&gt; that starts the Link element, I needed to add a space character that
would not appear in any HTML transformation.&lt;/p&gt;
&lt;p&gt;And here is where the nitpicking comes in.  When I originally added that sequence
when working on the Markdown transformer, it made sense to me to assign it to
the token’s &lt;code&gt;self.text_token&lt;/code&gt; field.  But since then, I have grown to think of
that sequence as being more extracted whitespace than token text.  To resolve
that, I decided to move the call to generate the replacement text from the
&lt;code&gt;self.token_text&lt;/code&gt; field to the &lt;code&gt;self.extracted_whitespace&lt;/code&gt; field.  It wasn’t
a big move, but it was something that I thought was the right thing to do.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this batch of work wasn’t as laborious as last week’s work, the effort required
to make sure it was correct was equal to or exceeding last week’s work.  I knew that
if I made any mistakes last week, they would be caught when I implemented the
consistency checks.  Well, these were the consistency checks that would capture
any such issues that slipped through.&lt;/p&gt;
&lt;p&gt;I am both happy and proud that I am coming to the end of implementing the consistency
checks.  It has been a long 3 month voyage since I decided that consistency checks
were the best way to ensure that the quality that I wanted in the PyMarkdown project
was maintained.  And while there were times that I questioned if I made the right
decision in dedicating this large block of time to this aspect of the project, I was
confident that I had made the right decision.&lt;/p&gt;
&lt;p&gt;But looking ahead to what I needed to do after the consistency checks, I saw a
fair number of items in the issues list that would need researching and possibly
fixing.  While I could start to release the project without them, I didn’t feel
comfortable doing that.  I wanted to give the project the best chance it could to
make a first impression, and then move from there.  And that would mean more work
up front.  So while I was happy that the consistency check work was coming to an
end, there seemed to be a deep pool of issues that would need to be research… and
I wasn’t sure how much I was looking forward to that.&lt;/p&gt;
&lt;p&gt;I still believe that adding the consistency checks was the right move.  Of that
I am still certain.  Instead of a feeling that I have the right code in place to
do the Markdown transformations, I have hard, solid checks that verify the results
of each and every scenario test.  It also gave me the interesting bit of information
that the scenario tests did not include any cases where the Atx Heading token and the
SetExt Heading token were followed by anything other than a Text token.  Something
interesting to follow up on later.&lt;/p&gt;
&lt;p&gt;To me, adding more of those checks for the inline
tokens was just another solid step forward in quality.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed the hardest inline token (Text token) and the easiest inline tokens
(Emphasis tokens), it was time to buckle down and get the remaining tokens done.  If
I was lucky, the foundational work that I had already completed would make completing
those tokens easy.  If I was unlucky, there would be a whole selection of edge cases
that I needed to account for.  Realistically, I was expecting something square in the
middle between those two scenarios.  The next batch worth of work would answer that
question!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:noted"&gt;
&lt;p&gt;This has been noted in the issue’s list, and I am hoping to look at it soon. &lt;a class="footnote-backref" href="#fnref:noted" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:processing"&gt;
&lt;p&gt;That is, after removing any special characters and leaving the original text used to create those special characters. &lt;a class="footnote-backref" href="#fnref:processing" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Starting to Add Line/Column Numbers For Inline Tokens</title><link href="https://jackdewinter.github.io/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/" rel="alternate"></link><published>2020-09-07T00:00:00-07:00</published><updated>2020-09-07T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-09-07:/2020/09/07/markdown-linter-starting-to-add-linecolumn-numbers-for-inline-tokens/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/31/markdown-linter-adding-consistency-to-token-heights/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying the height of all block
tokens.  In this article, with all the block tokens now properly covered, I
start to add proper support for line and column numbers for the text inline tokens
and the …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/31/markdown-linter-adding-consistency-to-token-heights/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying the height of all block
tokens.  In this article, with all the block tokens now properly covered, I
start to add proper support for line and column numbers for the text inline tokens
and the emphasis inline tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last article:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To properly verify any of the inline tokens, the tokens around it needed to be verified to give that token a solid foundation. Without those other tokens as a foundation, any attempt at verifying inline tokens would be shaky at best.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With that foundation now firmly in place, it was then time for me to start adding the
line/column numbers to the inline tokens.&lt;/p&gt;
&lt;p&gt;The scope of what I was about to start was not lost on me.  From the outset, I knew
that adding the line/column numbers to the Text tokens was going to be expensive.
Starting with the obvious, the Text tokens are the default “capture-all” for anything
Markdown that does not firmly fall under another token’s purview.  That alone meant
there were going to be a fair number of scenarios in which Text tokens were present.
Add to
that number the various forms of text that the token contains, and each form’s
way of dealing with the Text tokens within their bounds.  Also, as I wanted
to have a good gauge on how hard it was going to be to add the other inline tokens,
I added support for Emphasis tokens to the worklist.&lt;/p&gt;
&lt;p&gt;I was clear about the scope of this change with myself from the outset.  It was going to
be a long trek to complete all this work in one week.  I did contemplate updating the
consistency checks to accommodate the changes to the inline tokens, but discretion got
the better part of me.  This work was going to be tough enough on its own, no need to
add some extra tasks to the list.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/7eb893cf1b7c815666946661b790b956fa87278d"&gt;29 Aug 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="framing-a-big-problem-in-a-better-light"&gt;Framing a Big Problem in a Better Light&lt;a class="headerlink" href="#framing-a-big-problem-in-a-better-light" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before starting with this monumental task, I wanted to take a step back and really
understand the task and its intricacies.  When I
started looking at the sheer depth of this task, I will admit I was a bit scared at
first.
The work this task requires is daunting.  Doing a simple search over the project’s
scenario tests, I found 1577 instances of a Text token in a scenario test and 161
instances of Emphasis Start tokens in a scenario test.  That meant between the Text
tokens and both Emphasis Start and Emphasis End tokens, I was looking at 1899 instances
that needed to be changed and manually verified.  That was indeed overwhelming.&lt;/p&gt;
&lt;p&gt;This is where my experience with test automation came in handy.  I took a breath and
started to look for
&lt;a href="https://en.wikipedia.org/wiki/Equivalence_partitioning"&gt;equivalence partitions&lt;/a&gt;
that I could use.  While the number of discrete instances of Text tokens and Emphasis
tokens were facts that
I could not change, I decided to apply equivalence partitioning and reduce the effective
number of instances down to a more manageable number.&lt;/p&gt;
&lt;h3 id="how-does-that-work"&gt;How Does That Work?&lt;a class="headerlink" href="#how-does-that-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let me take a small sample function that is in the &lt;code&gt;ParserHelper&lt;/code&gt; class,
the &lt;code&gt;is_character_at_index&lt;/code&gt; function.  This function is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_character_at_index&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;index_in_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_character&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;index_in_string&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;source_string&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_in_string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;valid_character&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function is simple in that given a large variation on the parameters, it will
simply return a &lt;code&gt;True&lt;/code&gt; response or a &lt;code&gt;False&lt;/code&gt; response.&lt;sup id="fnref:mostlyTrue"&gt;&lt;a class="footnote-ref" href="#fn:mostlyTrue"&gt;1&lt;/a&gt;&lt;/sup&gt;  While the number of
variations are largely finite&lt;sup id="fnref:largeFinite"&gt;&lt;a class="footnote-ref" href="#fn:largeFinite"&gt;2&lt;/a&gt;&lt;/sup&gt;, they do fall into a number of
categories.  Starting with
the &lt;code&gt;index_in_string&lt;/code&gt; argument, those groups are: less than 0, equal to 0,
greater than 0
and less then &lt;code&gt;len(source_string)&lt;/code&gt;, equal to &lt;code&gt;len(source_string)&lt;/code&gt;, and greater than
&lt;code&gt;len(source_string)&lt;/code&gt;.  Of those groups, only if the &lt;code&gt;index_in_string&lt;/code&gt; argument is in
the &lt;code&gt;equal to 0&lt;/code&gt; group or the &lt;code&gt;greater than 0 and less then len(source_string)&lt;/code&gt; group do
I need to check to see if the character at the specified index is equivalent to the
argument &lt;code&gt;valid_character&lt;/code&gt;.  As the value to compare against is a single character, the
only two groups for that part of the comparison are that it matches that single
character or it does not.&lt;/p&gt;
&lt;p&gt;Based on this information, I can use those groups as equivalence partitions or
equivalence groups or  to partition the data to test into 7 distinct test groups.  The
first 3
equivalence groups are the ones that cause the first comparison to fail: &lt;code&gt;less than 0&lt;/code&gt;,
&lt;code&gt;equal to len(source_string)&lt;/code&gt;, and &lt;code&gt;greater than len(source_string)&lt;/code&gt;.  For this group,
the negative group, a simple test with one value in each group is required.  For the
other 2 tests, the positive group, in addition to the comparison to get it into one of
the 5 groups, one test is required where the index specifies the
a character matching the &lt;code&gt;valid_character&lt;/code&gt; argument, and one where it does not match.
In all, 3 tests in the first group, and 2 sets of 2 tests in the second group, for a
grand total of 7 tests.&lt;/p&gt;
&lt;p&gt;This works well because it reduces the scope of the testing to a manageable number.
Given the &lt;code&gt;less than 0&lt;/code&gt; group, it does not matter if the &lt;code&gt;index_in_string&lt;/code&gt; argument is
&lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;-2&lt;/code&gt;, or any other negative number.  They all fit into that group and they all
evoke the same behavior: they cause the expression to be evaluated as &lt;code&gt;False&lt;/code&gt;.
By applying this process to many testing problems, it can quickly break down the
problem from an unmanageable number of possibilities down to a smaller number of more
easily handled cases.&lt;/p&gt;
&lt;h3 id="how-does-that-apply-to-this-work"&gt;How Does That Apply to This Work?&lt;a class="headerlink" href="#how-does-that-apply-to-this-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;No matter how it is viewed, having to change the serialization of 1577 instances of a
Text token is a big job.  That part of the work I cannot change.  However, I can make
the manual validation part of the changes more efficient by applying equivalence
classes to those changes.  While I was not sure at the onset what those classes were
going to be, I was confident that I could work out those groups would be one-by-one.&lt;/p&gt;
&lt;p&gt;But it was still a big task, just not as big.  Looking back at my notes, I have a
scribble that says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;~40 variations for text, ~10 for emphasis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I believe that was a note to myself to boost my confidence by estimating how many
equivalence classes that I believed I would get the tests down to.  As I wrote this
article and looked at that scribble, for a second, I was back at the point in time when
I wrote that down.  Like an echo, I vaguely remembered the feeling of optimism that
washed over me when I wrote those numbers down.  While I am not 100% certain of what I
was thinking at the time, I am confident that it was something like:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1600 validations is insane!  On the other hand, 40 is okay.  I can do 40.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At that moment, it was not about whether those numbers were accurate, just that I had
confidence that those numbers were in the general vicinity.  While having to validate
each of
approximately 1600 variations of Text tokens filled me with dread, having to validate
approximately 40 variations of those same Text tokens and approximately 10 variations
of Emphasis tokens was something I had confidence that I could easily handle.&lt;/p&gt;
&lt;h2 id="updating-the-text-token"&gt;Updating the Text Token&lt;a class="headerlink" href="#updating-the-text-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before I was ready to start with the Text tokens, I needed to get ready.
Not a lot of work, but some solid foundational stuff to make the rest of the
processing go easier.&lt;/p&gt;
&lt;h3 id="getting-ready"&gt;Getting Ready&lt;a class="headerlink" href="#getting-ready" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;My main drive for updating the Text token to support line/column numbers was never
about the small stuff.  It was that boring work, stuff was easy to do and quickly
finished, that I wanted to get out of the way.  Adding the ability
to pass in either a &lt;code&gt;position_marker&lt;/code&gt; argument or the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt;
arguments?  Done.  Making sure they got copied along with the other information when
the &lt;code&gt;create_copy&lt;/code&gt; function was called? Done.  Changing the &lt;code&gt;InlineRequest&lt;/code&gt; and
&lt;code&gt;InlineResponse&lt;/code&gt; classes to handle line numbers and column numbers?  Done.  If my
memory and notes are accurate, those changes were all completed in the first half-hour
that I used to work on these changes.&lt;/p&gt;
&lt;p&gt;Then,
to ensure things were setup to verify the consistency of the changes in
the future, I made some changes to the
&lt;code&gt;verify_line_and_column_numbers.py&lt;/code&gt; module. While I knew I was going to write the actual
validations in a separate task, I wanted to make sure that I had a good view of what
inline tokens were going to be handed off to the future consistency validators.
To accomplish this, I added two sets of print statements: one as part of the
&lt;code&gt;__verify_token_height&lt;/code&gt; function and one at the end of the
&lt;code&gt;verify_line_and_column_numbers&lt;/code&gt; function.  My plan here was to not only set myself
up for the inline consistency checks to come, but to be able to see what the group
of inline tokens to be processed was, to allow me to plan future sets of equivalence
classes.&lt;/p&gt;
&lt;p&gt;With that setup work done, it was on to the actual classes.&lt;/p&gt;
&lt;h3 id="starting-with-the-paragraph-tests"&gt;Starting with the Paragraph Tests&lt;a class="headerlink" href="#starting-with-the-paragraph-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With that foundational work completed, I decided to start with the tests in the
&lt;code&gt;test_markdown_paragraph_blocks.py&lt;/code&gt; module.  Since the Paragraph Block tokens are the
default containers for Text tokens, I figured that this was the best bet to get started
with some of the simple stuff.  That bet paid off with the first equivalence class,
a Text token following a Paragraph token.&lt;/p&gt;
&lt;p&gt;If I had to point out the simplest case of a Text element in a Markdown document, I
would definitely point to an example similar to
&lt;a href="https://github.github.com/gfm/#example-189"&gt;example 189&lt;/a&gt;.
Despite its high index number, to me this is the simplest example of all Markdown
documents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;aaa&lt;/span&gt;

&lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Simply speaking, it is two paragraphs separated by a single newline.  While it is true
that a single line of text would be simpler, to me, that is not a realistic example of
a Markdown document.  To me, a document means multiple paragraphs of text that
conveys some information.  From experience, it is very hard to convey anything except
the most basic forms of
information in a single paragraph.  Also, as a realistic example, example 189 shows how
you can separate two paragraphs in a Markdown document.  As such, I consider this the
root example.&lt;/p&gt;
&lt;p&gt;As this was the root example to me, it also contained the first and root equivalence
class: a Text token
contained as the first token after a Paragraph token.  While there are numerous
variations of this equivalence class, for me this is the base class itself.  And as I
looked through the code on how to isolate this equivalence class, I came to an
interesting observation. It should have been an obvious observation, but it took me a
bit to work through from “huh?” to obvious.  I forgot that equivalence classes deal with
input and output, but that source code rarely follows those same patterns.&lt;/p&gt;
&lt;h3 id="this-is-a-good-thing"&gt;This Is A Good Thing&lt;a class="headerlink" href="#this-is-a-good-thing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I started to look for the source code behind my first equivalence class, I found
that it was hard to isolate the source code to just that equivalence class.  But as
I looked at the source code more, that made sense.  One reason that it made sense was
that if the cases were isolated based on equivalence class, it would mean that there
was a lot of duplicated code in the project.  Another reason was that such separation
would force distinct paths through the source code that would not be natural from any
other viewpoint than that of equivalence classes.&lt;/p&gt;
&lt;p&gt;The way the project was designed was to have an initial parsing phase to get all the raw
information together, then a coalesce phase to combine any text tokens where possible,
and finally an inline parse phase to handle the inline tokens.  Dragging any artificial
grouping of output across those phases seemed very counter-productive to me.  But
I still needed to figure things out.  It was time for a bit of a regroup.&lt;/p&gt;
&lt;h3 id="rethinking-my-approach"&gt;Rethinking My Approach&lt;a class="headerlink" href="#rethinking-my-approach" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After performing a global search for &lt;code&gt;TextMarkdownToken(&lt;/code&gt; on the project, I was rewarded
with a small number of occurrences of a &lt;code&gt;TextMarkdownToken&lt;/code&gt; being created within the
project.  This was good because it meant the number of actual changes that I would
need to make was small, and hopefully each change would carry over multiple equivalence
classes.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;__handle_fenced_code_block&lt;/code&gt; function and the &lt;code&gt;__handle_html_block&lt;/code&gt; function
(through the &lt;code&gt;check_normal_html_block_end&lt;/code&gt; function) were
both responsible for handling the additional Text tokens as part of container
processing, so they were the first to be changed.  In addition, the
&lt;code&gt;parse_indented_code_block&lt;/code&gt; function, the &lt;code&gt;parse_atx_headings&lt;/code&gt; function, and the
&lt;code&gt;parse_paragraph&lt;/code&gt; functions all included the creation of new instances of the
&lt;code&gt;TextMarkdownToken&lt;/code&gt;.  Making those changes took care of all cases where the
Parsing Processor created Text tokens.  From there, a quick check confirmed that the
Coalescing Processor only modified existing Text tokens and did not create any new
ones.&lt;/p&gt;
&lt;p&gt;After a bit of double checking to make sure I did not miss anything, I acknowledged
that the preparation work was done, and it was now onto inline processing.&lt;/p&gt;
&lt;h3 id="how-the-inline-processing-works"&gt;How The Inline Processing Works&lt;a class="headerlink" href="#how-the-inline-processing-works" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When the Inline Processor starts, it loops through all the tokens, explicitly looking
for Text tokens, as they are the only tokens that can contain inline sequences.  Once
such a Text token is found, a further check is done to make sure that the Text token
is within a Paragraph element or a SetExt Heading element (the only two block elements
in which inline tokens are allowed) before proceeding with
the actual processing of the Text Token.&lt;/p&gt;
&lt;p&gt;For any readers that have not been following along on the project’s journey, let me
provide a bit of a recap on how that processing works.  Back in the article
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/"&gt;on starting inline processing&lt;/a&gt;,
I go through the algorithm that I use in the inline processor:&lt;sup id="fnref:hidden"&gt;&lt;a class="footnote-ref" href="#fn:hidden"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set the &lt;em&gt;start point&lt;/em&gt; to the beginning of the string&lt;/li&gt;
&lt;li&gt;look from the &lt;em&gt;start point&lt;/em&gt; for a new &lt;em&gt;interesting sequence&lt;/em&gt;&lt;ul&gt;
&lt;li&gt;if none is found&lt;ul&gt;
&lt;li&gt;emit the rest of the line from the &lt;em&gt;start point&lt;/em&gt; and exit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;if one is found&lt;ul&gt;
&lt;li&gt;emit the text from the &lt;em&gt;start point&lt;/em&gt; to the start of the &lt;em&gt;interesting sequence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;handle the current &lt;em&gt;interesting sequence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;update the &lt;em&gt;start point&lt;/em&gt; to the end of the &lt;em&gt;interesting sequence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;go back to the top&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the Text token perspective, the important parts of that algorithm are
the &lt;code&gt;emit the rest of the line&lt;/code&gt; part and the &lt;code&gt;emit the text from...&lt;/code&gt; part.  When most
of the other parts
of the algorithm emit their own token&lt;sup id="fnref:twoExceptions"&gt;&lt;a class="footnote-ref" href="#fn:twoExceptions"&gt;4&lt;/a&gt;&lt;/sup&gt;, a check it made to see what
text has been “emitted” before that point.  Then a new Text token is created with
that emitted text, followed by the newly created token that represents the &lt;em&gt;interesting
sequence&lt;/em&gt;, followed by the algorithm looks for the next &lt;em&gt;interesting sequence&lt;/em&gt; to deal
with.&lt;/p&gt;
&lt;p&gt;In the end, there were only 4 places where I had to change the creation of the
Text tokens to provide the line/column number information.  In all, there were only
9 places in the project where I had to change the creation of the Text token.
Far from being lulled into thinking the hard work was done, I figured it would be
in the updating of the scenario tests that things would get interesting.  And I was
not disappointed!&lt;/p&gt;
&lt;h3 id="scenarios"&gt;Scenarios&lt;a class="headerlink" href="#scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the code changes made to the Inline Processor, it was time to focus on the
scenario tests and getting their data changed and manually validated.  Using the
command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -k test_paragraph_blocks
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I executed each of the paragraph specific scenario tests, looking for the expected
failures in each test that contains a Text token.  Except for three tests,
each of these tests were simple cases of the base equivalence class, which meant that
they were quickly updated and verified.  Of those three tests, two new equivalence
classes emerged: the first Text token within an Indented Code Block token, and a Text
token following a Hard Break token.&lt;/p&gt;
&lt;p&gt;The scenario test for
&lt;a href="https://github.github.com/gfm/#example-195"&gt;example 195&lt;/a&gt;
is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which was properly parsed into new equivalence class of an Indented Code Block token
containing a single Text token and a normal Paragraph token containing a single Text
token.  As code blocks
do not contain any inline processing and no extra inline processing was specified, this
was an easy validation of that new equivalence class.  Quick, easy, done.&lt;/p&gt;
&lt;p&gt;The other failing scenario test, the test for
&lt;a href="https://github.github.com/gfm/#example-196"&gt;example 196&lt;/a&gt;
is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;aaa&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;bbb&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the sequence &lt;code&gt;{space}&lt;/code&gt; was replaced with actual space characters.  I replaced
the tokens with what I thought was their proper line/column numbers and was surprised
to find out that the tests were still failing.
As I started
to work through the research on why this was happening, I came to an interesting
conclusion.  I was not going to get away from handling the other inline tokens after
all.&lt;/p&gt;
&lt;h3 id="the-truth-always-wins"&gt;The Truth Always Wins&lt;a class="headerlink" href="#the-truth-always-wins" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Based on the above Markdown, the tokens that were generated for that scenario test were
a Text Token, a Hard Line Break token, and another Text Token.  The first Text token
was fine, I had that covered, and the Hard Line Break token was not what we were
focusing on, so the fact that it did not have a line/column number associated with it
was fine.  But that left the second Text token in a bit of a conundrum.  Based on the
code at that time, the line/column number was &lt;code&gt;1,4&lt;/code&gt;, which based on the existing logic
was correct.  But from a validation point of view it was incorrect: it should be &lt;code&gt;2,1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It took me a bit to realize that if I was going to change each Text token, I would at
least have to partially handle the other inline tokens.  In this case, unless
I added some code that understood the Hard Line Break token, the source code would
correctly state that the line/column number was &lt;code&gt;1,4&lt;/code&gt;.  To be clear, it is not that
the line/column number of &lt;code&gt;1,4&lt;/code&gt; is actually correct, but according to the information
that the algorithm has, that is the correct value to compute for that token. So,
while I did not have to output the line/column number for the other inline tokens
yet, I at least had to figure out what change that token was
going to impart to the stream of inline tokens in that group.&lt;/p&gt;
&lt;h3 id="and-it-happened-with-the-most-complicated-inline-token"&gt;And It Happened with The Most Complicated Inline Token&lt;a class="headerlink" href="#and-it-happened-with-the-most-complicated-inline-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Hard Line Break token just happened to be the token I needed to figure out.  And
it would end up being the most
difficult inline token to figure out the new line/column number for.  One reason was
that, for whatever reason, I placed the newline for the Hard Line Break token with the
following
Text token, and not the Hard Line Break token itself.&lt;sup id="fnref:yesIDid"&gt;&lt;a class="footnote-ref" href="#fn:yesIDid"&gt;5&lt;/a&gt;&lt;/sup&gt;  This meant that
to properly deal with that token, I needed to reduce the vertical height of the
following Text token by 1, as the Hard Line Break token had already increased the
line number. The other reason for it being complicated is that the proper setting of
the column
number relied on checking with the owning Paragraph token, grabbing any leading space
for that next line from that token.&lt;/p&gt;
&lt;p&gt;All in all, in took a bit of work, but not too much before all the tests in that
scenario test group were passing.  While I knew there were 10s of hundreds more changes
to make, I knew I could do this.  Yeah, it would be slow, but if I just kept my
focus on the task at hand, I could do this.&lt;/p&gt;
&lt;h3 id="lather-rinse-repeat"&gt;Lather-Rinse-Repeat&lt;a class="headerlink" href="#lather-rinse-repeat" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I could go through each of the other equivalence classes that I discovered and
processed, I will leave that for a future article where I talk about the inline
consistency checks.  It was enough of a brutal and time-consuming process that I will not make it more so by talking about it.  Each time, I literally picked a new section of
scenario tests, replaced the &lt;code&gt;test_paragraph_blocks&lt;/code&gt; in the command line with the
prefix for another group of
tests and ran it again.  With the results of that test run, I picked off one of the
failing tests, correcting the line/column number for the Text tokens, and running
the tests again to repeat the process.  As I went, I manually validated each
test’s changes, and I rechecked my results as I staged the changes into the project’s
GitHub repository.&lt;/p&gt;
&lt;p&gt;A good example of this process was the next group of tests that I tackled: the Hard
Line Block group.  The
first couple of tests were a rehash of what I had already done, so determining the
proper line/column numbers for those tests were easy, and quickly verified.  That
left tests that included Emphasis tokens and Text tokens within Atx Heading tokens.
I just buckled down and followed at the same process as documented before, adjusting
as I went.&lt;/p&gt;
&lt;p&gt;Yes, it was slow, but it was also good.  While it dragged on, I was getting predictable
results with the application of my process.  In my mind, I had confidence that it was
no longer a matter of “um… around 1600 tokens? how am I going to…”.  I was making
that transition to “how can I get these done more efficiently and reduce my time on
each test without sacrificing quality?”&lt;/p&gt;
&lt;h2 id="updating-the-emphasis-token"&gt;Updating the Emphasis Token&lt;a class="headerlink" href="#updating-the-emphasis-token" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Compared to the work required to change the Text token, updating the Emphasis token
to include line/column numbers was trivial.  As the work had already been done to
determine the width to apply to the start and end tokens, the main change was to pass
the line/column number information to the constructor of the EmphasisMarkdownToken
and the EndMarkdownToken.&lt;/p&gt;
&lt;p&gt;With that change in place, I started running the scenario tests in the emphasis group
and only had to make one small change.  In the cases where the end Emphasis token
were completely consumed, everything was fine.  But in the cases where an end Emphasis
token were partially consumed, the column number was off by one.  That took a bit
of puzzling, but after some thinking, the answer leapt out at me.  I will not kid you
though, without me scribbling down the various cases and working through the scenarios,
it would have taken me a lot longer.&lt;/p&gt;
&lt;p&gt;For the start and end Emphasis tokens, the Inline Processor creates a Special Text token
that contains either the &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; character and the number of those characters found.
Because emphasis is processed from the inside out&lt;sup id="fnref:empExample"&gt;&lt;a class="footnote-ref" href="#fn:empExample"&gt;6&lt;/a&gt;&lt;/sup&gt;, the emphasis characters
taken from those Special Text tokens occur at the end of the Special Text token for the
start Emphasis token and the beginning for the end Emphasis token.  As a result of that,
the start Emphasis token’s column number needed to be adjusted by the number of
characters consumed, to ensure it pointed at the right location.  Once that adjusted
was added, the remaining scenario tests passed.&lt;/p&gt;
&lt;p&gt;While I was not sure if the other inline tokens would be as easy as the Emphasis
tokens, I was hopeful.  And in a long project, that is a good thing!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I start to write these sections in my articles, I always refer to my notes and try
to put my mind back into the frame of mind I was in at that time.  While there are
sparse notes here and there about this section of work, there is really only one of
those notes that properly sums up the work:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Phew!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While there were times during that slog that I did not think it would ever end, I was
adamant that I was going to get through it and complete it.  In my mind, it was not
a question of confidence, it was a question of endurance.  My change algorithm was
simple enough, and I had confidence that the validation part of that algorithm was
solid.  It was just a matter of working through what seemed to be a mind-numbing number
of changes until they were all done.&lt;/p&gt;
&lt;p&gt;But I persisted and got through it.  And while I believe it was the right decision
to only focus on the Text token and the Emphasis tokens, in hindsight, it might have
been okay to add the other inline tokens at the same time.  With all the work to
make sure their space was properly accounted for, I believe that most of the work that I
have left with those tokens is to plug in the calculated line/column numbers into the
inline tokens themselves, changing the serialized text, and writing the consistency
checks.  Be it as it may, unless I messed up a calculation, the hard part of making
sure the calculations work has already been done.&lt;/p&gt;
&lt;p&gt;On the technical debt point of view, I am a bit worried, but not too much.  The list
of things to check in the issues list is a bit larger than I like it, but there are
some future ideas and a lot of double-check reminders on there.  At the very least,
I am sure I can start to make short work of a lot of those issues, or properly
prioritize them for later, whichever is best for that issue.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the Text tokens and the Emphasis tokens out of the way, I decided that it was
better that I add the consistency checks for those tokens before progressing forward.
After having to do a fair amount of work to support “bypassing” those tokens to properly
calculate the line/column number of any following Text token, I had a feeling it would
come in handy if I moved it up the priority list a bit.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:mostlyTrue"&gt;
&lt;p&gt;This function makes simple assumptions that the &lt;code&gt;source_string&lt;/code&gt; argument is a string of any length, the &lt;code&gt;index_in_string&lt;/code&gt; argument is an integer, and the &lt;code&gt;valid_character&lt;/code&gt; argument is a string of length 1.  Because the argument names are explicit enough and their usage is within a predefined scope, I decided to not verify the type of value for each.  As such, the statement that the function will either return &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; assumes that those assumptions are followed. &lt;a class="footnote-backref" href="#fnref:mostlyTrue" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:largeFinite"&gt;
&lt;p&gt;For more information, &lt;a href="https://en.wikipedia.org/wiki/History_of_large_numbers"&gt;see Wikipedia&lt;/a&gt;.  The short answer to this is that I would start with the first argument containing an empty string, for a count of 1.  Then I would move on to a string with 1 character, and have to populate that string with every viable Unicode character.  Moving on to strings with 2 characters, I would need to take every 1 character string, and repeat that same process with the second character.  Repeating this process, the number of variations on possible strings is not infinite, but mathematically it is called a large finite number, or largely finite. &lt;a class="footnote-backref" href="#fnref:largeFinite" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:hidden"&gt;
&lt;p&gt;Looking back at it myself, it is a bit hidden, but it is in the section on &lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/#code-spans"&gt;code spans&lt;/a&gt; in the fourth paragraph. &lt;a class="footnote-backref" href="#fnref:hidden" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:twoExceptions"&gt;
&lt;p&gt;The two exceptions to this are the handling of the backslash sequence and the character entity sequence, both which add to the text that is being accumulated. &lt;a class="footnote-backref" href="#fnref:twoExceptions" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:yesIDid"&gt;
&lt;p&gt;Yes, I did add an item to the issues list for this. &lt;a class="footnote-backref" href="#fnref:yesIDid" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:empExample"&gt;
&lt;p&gt;For a good example of this, look at &lt;a href="https://github.github.com/gfm/#example-422"&gt;example 422&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:empExample" title="Jump back to footnote 6 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Consistency to Token Heights</title><link href="https://jackdewinter.github.io/2020/08/31/markdown-linter-adding-consistency-to-token-heights/" rel="alternate"></link><published>2020-08-31T00:00:00-07:00</published><updated>2020-08-31T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-31:/2020/08/31/markdown-linter-adding-consistency-to-token-heights/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying for the second half of the
container block tokens: the Block Quote tokens.  In this article, I fill out the
line/column number consistency checks by adding support for determining and verifying
the height of …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/"&gt;last article&lt;/a&gt;,
I took care of completing the consistency checks by verifying for the second half of the
container block tokens: the Block Quote tokens.  In this article, I fill out the
line/column number consistency checks by adding support for determining and verifying
the height of all block tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From a high-level point of view, I believe that the project is coming together nicely.
Each of the examples in the base
&lt;a href="https://github.github.com/gfm/"&gt;GFM specification&lt;/a&gt;
have been tested, and their proscribed HTML output verified.  The consistency check that
verifies that that Markdown tokens contain the correct information is also in place,
covering all existing tokens.  What was left was a bit of unfinished business with
the consistency checks to verify those same tokens.  Two parts of that check were left:
verifying the token height and verifying the inline tokens.&lt;/p&gt;
&lt;p&gt;I had always intended the verification of inline tokens to be the final verification.
That was always immediately clear to me.  To properly verify any of the inline
tokens, the tokens around it needed to be verified to give that token a solid
foundation.  Without those other tokens as a foundation, any attempt at verifying
inline tokens would be shaky at best. It only made sense for me to start working on
the verification of token heights before verifying the inline tokens.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4ae90e7b0a6e242f4364ec8bb4fe667d9d024580"&gt;15 Aug 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/3fe81f2d4ffa65f1fb2d7818cab739e9e8b20470"&gt;19 Aug 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="looking-back-at-last-weeks-issue"&gt;Looking Back at Last Week’s Issue&lt;a class="headerlink" href="#looking-back-at-last-weeks-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After finishing the work on last week’s article, I took it easy for a few days,
working on the project when I could, but not pushing to hard.  As someone who uses
his brain heavily in both his professional capacity and his personal capacity, it was a
bit of a wakeup call for me.  When I saw the end of the project getting closer and
closer, I started to put in extra effort towards the project, thinking that I could get
there faster.  This normally would not be a bad thing. But to achieve that extra effort,
I diverted some of my energy away from the energy that I normally use to take care of
myself.  I did not really think about it before I started doing it, it just happened.&lt;/p&gt;
&lt;p&gt;While the result was me taking an extra day to complete the article, it could have
been worse.  From an article
point of view, I needed to rework 2-3 sections, but it was not too bad.  From a personal
point of view, if I had continued to push myself, I believe it would have multiplied
the time needed to recover substantially. I forgot that taking care of yourself and
your mental well-being is very important, especially in times of crisis.  In normal
times, I might have been able to make that trade off work, but currently, I do not
believe it is a viable option for me.  I just do not have tons of extra energy to spare.
Like it or not, those are just the times we are living in right now.&lt;/p&gt;
&lt;p&gt;And that is okay.  It is taking me a bit to accept that, but I am working on it.
What is important to me is this project and writing about it… all about it.  Not
just the rosy stuff you read in other blogs, but the actual problems I encountered
and how I approached them.  At that includes problems like these.&lt;/p&gt;
&lt;h2 id="getting-ready-for-the-changes"&gt;Getting Ready for the Changes&lt;a class="headerlink" href="#getting-ready-for-the-changes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Knowing that I was going to be making a lot of changes to the verification logic for
line/column numbers, I wanted to prepare for that work by moving that code into its own
module.  Having seen this feature organization work well for the Markdown transformer
and the HTML transformer, I figured that moving the line/column verification code into
its own
module was an easy choice.  Further increasing the benefit of that choice was the fact
that I was going to add more logic to the code.  Keeping all that logic in one place
just made a lot of sense to me.&lt;/p&gt;
&lt;p&gt;The movement of the code was a pretty painless process, will all functions that
handle the verification
of line/column numbers being moved into the &lt;code&gt;verify_line_and_column_numbers.py&lt;/code&gt; module.
Once moved, any functions that did not need to be public were prefixed with &lt;code&gt;__&lt;/code&gt; and
their invocations were also changed to add the &lt;code&gt;__&lt;/code&gt; prefix.  Having a good set of
scenario tests added to the ease of this change, as I was able to verify that the
code was still working properly at each stage of the change.&lt;/p&gt;
&lt;p&gt;With the new module created, it was time to add to that new module.&lt;/p&gt;
&lt;h2 id="verifying-the-height-of-tokens"&gt;Verifying the Height of Tokens&lt;a class="headerlink" href="#verifying-the-height-of-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As with any of the consistency checks, the verification of the token height started as
a very small and compact function.  At the beginning, the &lt;code&gt;__verify_token_height&lt;/code&gt;
function had 2 parameters: &lt;code&gt;current_token&lt;/code&gt; and &lt;code&gt;last_token&lt;/code&gt;.  Knowing that I had the
SetExt Heading token to process, I encapsulated that logic within that function,
calling the &lt;code&gt;__validate_block_token_height&lt;/code&gt; function to do the heavy lifting.  This
encapsulation allowed me to replace the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;column_number&lt;/code&gt; variables
used by the other tokens with the &lt;code&gt;original_line_number&lt;/code&gt; and &lt;code&gt;original_column_number&lt;/code&gt;
variables used by the SetExt Heading token.&lt;/p&gt;
&lt;p&gt;That verification function, the &lt;code&gt;__verify_token_height&lt;/code&gt; function, needed to be called
from 2 locations: after the &lt;code&gt;__validate_new_line&lt;/code&gt; was called and at the end of
the normal processing.  The call after the &lt;code&gt;__validate_new_line&lt;/code&gt; function was called
ensured that the height of any 2 block tokens not on the same line was calculated. If
the 2 tokens were on the same line, one of them was a container block
token, and they would always be on the same line.  As such, I could just focus on the
tokens on different lines without losing missing anything.  The call at the end of
processing would ensure that the height of the final block would also be verified.&lt;/p&gt;
&lt;p&gt;It was a good start.  With all the little stuff out of the way, it was on to
the heavy lifting part of the change.&lt;/p&gt;
&lt;h3 id="doing-the-heavy-lifting"&gt;Doing the Heavy Lifting&lt;a class="headerlink" href="#doing-the-heavy-lifting" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;__validate_block_token_height&lt;/code&gt; function was always intended to be a function that
needed to know about every block level token.  From the initial design for this change,
I figured that it was best to have one big function that could be
refactored later, than to have duplicate code in separate handler functions.  As I have
had good success with that pattern so far, I decided to use it again here.&lt;/p&gt;
&lt;p&gt;Like my other uses of the pattern, I started off the function with a large
&lt;code&gt;if-elif-else&lt;/code&gt; statement containing all the leaf block token names, one to each
&lt;code&gt;if&lt;/code&gt; statement.  Each &lt;code&gt;if&lt;/code&gt; statement contained a single line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and a final:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Token "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" not supported."&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Just like before, I had a plan.  I started running tests in groups
based on their name.  So to start, I used the command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest -k test_paragraph_blocks_
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to run all the tests that dealt with paragraph blocks.  If I hit a type of leaf block
that I had not worked on yet, the &lt;code&gt;assert False&lt;/code&gt; triggered with the line number
indicating which token type failed.  If I hit a type of block that I was not expecting,
the &lt;code&gt;assert False&lt;/code&gt; in the final &lt;code&gt;else&lt;/code&gt; would be triggered, letting me know which
token I missed.&lt;/p&gt;
&lt;p&gt;And it was a lot of
&lt;a href="https://en.wikipedia.org/wiki/Lather,_rinse,_repeat"&gt;lather-rinse-repeat&lt;/a&gt;.
I ran the tests over and over again using the above command line.  If any tests failed,
I picked either the first test or the last test and examined why the test failed.  If
it was the first time that I was dealing with that specific token, I coded a good guess
as to what the height formula
should be.  Otherwise, I examined the existing formula, and tried a variation of the
code that would handle the new case.  Once all the tests for a given group were
passing, I picked another group.  This repeated until all the scenario tests in
the project were passing.&lt;/p&gt;
&lt;p&gt;For the most part, that seemingly endless processing loop worked.  But as in any
project, there were things that needed to be handled separately.&lt;/p&gt;
&lt;h3 id="counting-newlines"&gt;Counting Newlines&lt;a class="headerlink" href="#counting-newlines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Shortly into the changes, I figured out that I needed a simple helper function to
calculate the
number of newline characters in each string.  Based on my observations, I was going
to need to count a different set of newline characters for most of the tokens.  Rather
than implementing the algorithm multiple times, it made sense to put it into one
function and in one location.&lt;/p&gt;
&lt;p&gt;After a couple of tries, I ended up with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_examine&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;original_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_examine&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;removed_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_to_examine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;original_length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;removed_length&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I forget where I encountered this pattern initially, but it was a useful one to
remember. While it does include the possibly expensive creation of a new string, the
algorithm itself is simple.
The number of a given characters in a string is the difference between the original
length of the string and length of that same string with all that specific character
replaced with an empty string.&lt;/p&gt;
&lt;p&gt;Say for example I need to know how many &lt;code&gt;a&lt;/code&gt; characters are in the string
&lt;code&gt;maybe a good day to die&lt;/code&gt;, which has a length of 23.  If I remove all the &lt;code&gt;a&lt;/code&gt;
characters, I am left with the string &lt;code&gt;mybe  good dy to die&lt;/code&gt; which has a length of 20.
Subtracting the second result from the first result leaves a value of 3, the number of
&lt;code&gt;a&lt;/code&gt; characters in the string.&lt;/p&gt;
&lt;p&gt;For Paragraph tokens, the use of this function was simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;token_height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as it was for Indented Code Block tokens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;token_height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indented_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For Link Reference Definitions, it was even more useful:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;token_height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_name_debug&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_destination_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title_raw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;__count_newlines_in_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;link_title_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After dealing with those tokens, there were a handful of other tokens
that were easily handled by very simple calculations.  After those tokens
were handled, there were only two troublesome tokens left: the HTML Block token and the
Fenced Code Block token.&lt;/p&gt;
&lt;h3 id="leaf-block-stacks-and-tracking-tokens"&gt;Leaf Block Stacks and Tracking Tokens&lt;a class="headerlink" href="#leaf-block-stacks-and-tracking-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To properly process the height of those two troublesome tokens, a pair of concepts were
introduced almost at the same time.  I tried splitting these two concepts into their
own sections, but I found each attempt to do that complicated by their dependencies on
each other.&lt;/p&gt;
&lt;p&gt;The first of those concepts was the ability to track the leaf block that was currently
active at any point.  The primary driver for this concept was to provide context to the
tokens that
occurred within the HTML Block element and the Fenced Code Block element.  As these
two block elements handle their own text parsing, I needed to avoid any “extra”
checking that
occurred within these blocks.  After trying 4 or 5 other alternatives, the
tried-and-true block stack was easily the best, and most reliable, solution.&lt;/p&gt;
&lt;p&gt;The second concept was closely tied to the first concept and dealt with properly
tracking the right tokens.  To finish the handling of the HTML Block element and the
Fenced Code Block element, I needed to make sure that the concept of the “last” token
was correct.  To get that working properly, I added code to check the stack and only
set the new “remembered” token variable if that was not set.&lt;/p&gt;
&lt;h3 id="how-did-this-work"&gt;How Did This work?&lt;a class="headerlink" href="#how-did-this-work" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Unless there was anything to do with HTML Block elements or
Fenced Code Block elements, this code was not invoked.  Except for the 4 block
tokens that do not have close tokens (Blank Line, New List Item, Link Reference
Definition, and Thematic Break), any start token was added to the stack.  When
an end token was encountered, if the name of that end token matched the top
token on the stack, that top element was removed.  Simple stack management.  After
a test revealed that I had forgot to add one of those 4 block tokens to the “do not
stack” list, the stack worked flawlessly.&lt;/p&gt;
&lt;p&gt;The tracking of the tokens to avoid duplication worked as well.
When one of the two special blocks were encountered, the stack logic would add them
to the stack.  Once added, the algorithm assumed that the handling of the HTML Block
tokens and Fenced Code Block token would handle any encapsulated tokens and did not
track any of those encapsulated tokens.  When the end of the block occurred, it was
popped off the stack and the normal processing occurred.  There were a couple of
small issues at the start, but after they were cleaned up, it was smooth sailing after
that.&lt;/p&gt;
&lt;h3 id="why-did-they-need-special-processing"&gt;Why Did They Need Special Processing?&lt;a class="headerlink" href="#why-did-they-need-special-processing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Although I tried a number of different options, the only thing that worked for
determining the height of these two special block tokens was a brute-force iteration of
all the
inline tokens.  While there were other tokens that persisted information on how many
newlines were contained within their Leaf Block, these two Leaf Block tokens did
not.  Without that information, the only option left was to iterate through each of the
encapsulated inline tokens, counting newline characters as I went.  But with those
tokens already counted, I needed to avoid counting them a second time.&lt;/p&gt;
&lt;p&gt;It was not a great solution, but it was the one that I ended up with.  Up to this
point in the project, there was no reason to change how those two Leaf Blocks stored
(or did not store) any newline, it just was not a problem.  While it was not a
great solution, at this stage it was an efficient solution.  But to check to see if
I could do it better, I created a new item in the issues list, and moved on.&lt;/p&gt;
&lt;h2 id="there-was-one-additional-thing"&gt;There Was One Additional Thing&lt;a class="headerlink" href="#there-was-one-additional-thing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I finished up my work validating the Fenced Code Block token heights, there was one
scenario test that snuck up and surprised me:
&lt;a href="https://github.github.com/gfm/#example-97"&gt;example 97&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`````&lt;/span&gt;

&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This example, and the ones around it, show how an open block is closed when the
container block that owns it is closed or when the end of the document is reached.
While everything else was working properly with this example, the token’s line
height was off by one.  After double checking the math for the consistency check
and for the existing tokens, I confirmed that it was an off-by-one error. Given that
error and the section that the example was in, the next step was an easy one: craft an
example that included the end of the Fenced Code Block element:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`````&lt;/span&gt;

&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="o"&gt;`````&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running that test, it immediately worked, which meant only one thing to me: the
algorothm needs to know if the end token was forced.&lt;/p&gt;
&lt;h3 id="determining-if-a-token-is-forced"&gt;Determining If A Token Is Forced&lt;a class="headerlink" href="#determining-if-a-token-is-forced" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Right away, I was aware that determining if the end token was forced was not going
to be an easy task.  I immediately figured out one approach but dismissed it as too
costly.  But as I spent hours looking for any other approach that worked, I was coming
up empty with each attempt.  I found some partial solutions, but nothing that worked
in all required cases.  In the end, it was that costly approach that I returned to
as my only solution.&lt;/p&gt;
&lt;p&gt;What was that solution?  Costly as it was, that solution was to add a field to
every end token that indicates whether it was asked to be closed or forced close.
Why was it costly?  A quick scan of the scenario tests revealed almost 200 instances
of an end token… for only the scenario tests starting with &lt;code&gt;test_markdown_a&lt;/code&gt; and
&lt;code&gt;test_markdown_b&lt;/code&gt;.  Extrapolating from that sample, I believed that it would
realistically mean changing between 1250 and 1750 end tokens throughout all the
examples.&lt;/p&gt;
&lt;p&gt;It was not a decision that I made lightly, but with no other viable options, I
started to embrace it.  Making the change was the easy part.  Before the &lt;code&gt;was_forced&lt;/code&gt;
field was added to the &lt;code&gt;EndMarkdownToken&lt;/code&gt; class, the &lt;code&gt;compose_data_field&lt;/code&gt; function
looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;compose_data_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once the &lt;code&gt;was_forced&lt;/code&gt; field was added, it changed into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;compose_data_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_end_data&lt;/span&gt;
        &lt;span class="n"&gt;display_data&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;":"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;was_forced&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;display_data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If this looks like I snuck something extra in, it is because I did.  Given the number
of changes that I was going to make, I wanted to ensure that I could efficiently make
those
changes and verify them.  While having optional parts of the token serialization left
out was
more compact, it did make the serialization harder to read.  I figured that if I was
making a thorough change like this, being explicit with each of the fields would
reduce my chances of getting one of the serializations wrong.  Instead of asking myself
“what was the default value of the second and third fields”, I just added those fields
and ensured they were serialized.&lt;/p&gt;
&lt;p&gt;Basically, I gambled.  The cost of making the change to the token’s serialization was
cheap.  It would be in the verification of that change where most of the expense would
come.  And my bet was that serializing all fields explicitly would make that
verification easier and faster.&lt;/p&gt;
&lt;h2 id="was-it-worth-it"&gt;Was It Worth It?&lt;a class="headerlink" href="#was-it-worth-it" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If anyone would have asked me that question at the start of that process, I would
have
&lt;a href="https://idioms.thefreedictionary.com/hemmed+and+hawed"&gt;hemmed and hawed&lt;/a&gt;,
giving an answer that would be uncertain at best.  But by the time I had finished
the first group of scenario tests, that answer was easily becoming a more solid “Yes!”.&lt;/p&gt;
&lt;p&gt;Was it painful?  Yes!  I purposefully did not keep track of how many changes I had
completed and how many I had left to go.  I felt that keeping track of that number
would be discouraging and focusing my mind on something other than the obvious thing:
this was the right change to do.  I was aware this was going to take a while, and
as the hours ticked by, that was hammered home multiple times.  By the time I
got to the end of this process, it took 4 days and many long hours to complete.&lt;/p&gt;
&lt;p&gt;But, in my eyes, it was worth every step of it.  As this change touched on every
scenario test, I needed to manually verify each scenario test before
going on to the next test.  And while I had test automation in peace, I had not
manually gone through each of the tests and verified for myself if the tokens
looked correct.  For me, I found peace in having inspected the tests for myself,
knowing that the consistency checks were providing me with the same results as
my manual verification.&lt;/p&gt;
&lt;p&gt;Does that mean I want to do it again?  Not really.  But would I do it if I felt that
I needed to?  In a heartbeat.  In terms of confidence,
this was me doing a final read of my article before publishing it.  This was me
running the Static Code Analysis against my code one more time just to make sure
that I did not miss anything.  This was me looking over the changes I am about to
commit to the repository before I submit the commit.  It is easy to argue that
each of those actions is more emotional than logical, but that is the point.&lt;/p&gt;
&lt;p&gt;Sometimes, it is just logical to do an action for a positive emotional reaction.
And that is okay too.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I know I will only get one chance to make a good impression with this project, so
I want to make that impression a good one.  If I want to provide a good impression by
having a good linter as the outcome for this project, I will need to test as many of the
combinations of Markdown elements with each other as possible, in as many circumstances
as possible.  From the beginning of the project, a simple calculation made it clear that
the scope of testing required would be difficult if I was lucky.  If I was not lucky,
that hopeful guess of difficult would grow by at least 2 orders of magnitude.&lt;/p&gt;
&lt;p&gt;But even given that prediction that testing everything would be very difficult, I
wanted to give the project the best chance to succeed.  The best way that I know of
doing that is to fully commit to making the right changes to solve the problems
properly.  For the first set of changes, this meant working with what I had, as it
was only the token height calculation that needed that logic.  For the the second set of
changes it meant changing all the tokens, because there really was not any alternative.&lt;/p&gt;
&lt;p&gt;In a strange way, both sets of changes brought me peace, increasing my confidence
about the project.  In the grand scheme of things, the iterative calculations for the
height of the two Leaf Block tokens was not too expensive, and it is localized to that
one module.  Ammortizing the cost of those calculations over all the Leaf Block tokens
makes it even less expensive.  From that point of view, those changes were definitely
cost effective in my eyes.&lt;/p&gt;
&lt;p&gt;And while people can say I am pedantic and a perfectionist, I somewhat liked spending
that time going through each scenario and verifying it.  Before that review, I had
a lot of trust in those consistency checks, but there was always a question of whether
I had missed something important.  With the existing checks in place and a
manual review of those scenario tests, the chances of any major issues being left
are drastically reduced.&lt;/p&gt;
&lt;p&gt;I will never say that any piece of software has zero bugs in it, but I do know that
I feel that I am eliminating many of the paths for bugs to form in this project.&lt;/p&gt;
&lt;p&gt;And that I am confident about!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After completing the token height verification for block tokens, it was time to start
working on the line/column numbers for the inline tokens.  I was not sure how much of a
chore it would be, but it would be gratifying to get them done!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry><entry><title>Markdown Linter - Adding Consistency to Block Quotes</title><link href="https://jackdewinter.github.io/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/" rel="alternate"></link><published>2020-08-25T00:00:00-07:00</published><updated>2020-08-25T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-08-25:/2020/08/25/markdown-linter-adding-consistency-to-block-quotes/</id><summary type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I took care of completing the Markdown transformer checks for one half of the container
block tokens: the List Block tokens.  In this article, I tackle both the line/column
number consistency checks and the Markdown transformer checks for the Block Quote
tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In my
&lt;a href="https://jackdewinter.github.io/2020/08/17/markdown-linter-adding-lists-to-the-markdown-transformer/"&gt;last article&lt;/a&gt;,
I took care of completing the Markdown transformer checks for one half of the container
block tokens: the List Block tokens.  In this article, I tackle both the line/column
number consistency checks and the Markdown transformer checks for the Block Quote
tokens.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the implementation of list tokens went easier than I thought it would, I
remained cautiously optimistic about adding consistency check support for Block Quote
tokens.  During the initial development of the line/column number checks, I noticed
that the Block Quote tokens did not keep any information about removed data.  After
having completed the List Block token support, I knew that it would be pivotal to
get that right.  And that meant more work.  A lot of nitpicking work.&lt;/p&gt;
&lt;p&gt;To add the consistency checks, I was going to have to accomplish 3 things: capture the
removed line start text, use that information to validate the line/column numbers, and
then write the Markdown transformations for it.  The last two items were the easy part,
those parts I had confidence I could complete.  It was the capturing of removed checks
that I was not confident about.  And the capturing of text was the change that I needed
to tackle first.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is the Audience for This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/255bfce0efab68c0d76ca8d04b03017ba40e6223"&gt;12 Aug 2020&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/08da2e04c355e0a3bd016e20afce3102696a8107"&gt;14 Aug 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="lets-talk-about-the-obvious"&gt;Let’s Talk About the Obvious&lt;a class="headerlink" href="#lets-talk-about-the-obvious" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I am generally very disciplined when it comes to writing my blog.  I keep notes when I
am writing the code, curating those notes into an outline on the
Thursday to Saturday before I post my article.  If I am lucky enough, I will start
the actual writing of my article on
Saturday night, but most often I start writing it early Sunday morning.  This allows
me to take my time to enjoy my Sunday while ending up with a solid version of the
article by Sunday night.  Then, on Monday night, I take that article and add
extra code samples and do some wordsmithing to form the article into its final form.  It
may not be the way others write their articles, but it is a process that works
for me.&lt;/p&gt;
&lt;p&gt;Until this week that is.  Everything was on track until Monday, when I started my edits
with a headache that I just could not ditch.  But process is process, so I started doing
those edits, pushing on until a couple of hours later.  At that point, I looked at
what I was doing and went… huh?  I started looking at my edits and tried to figure
things out, using even more edits to fix any problems I encountered.  Far from making
things better, I was making them worse.  But I would not see that until later.&lt;/p&gt;
&lt;p&gt;It was a while later when I finally stopped and locked my computer.  Above all else,
this was the best thing that I did in that entire situation.  It took me a
while, but I stopped.  However, by that point, a certain amount of damage
was already done.  I had written some things twice and other things not at all. In
some cases, I had sentences that looking at them later, I wonder if I had written them
while drunk.  I knew I could recover from that position, but it would require a clear
head, some extra time, and some hard work.  And it was not going to happen that night.
I came to the realization that I was not going to be able to meet my usual posting
deadline of Monday night.&lt;/p&gt;
&lt;p&gt;At first, I was angry with myself.  Many weeks of not missing a posting deadline and
now I had a bad record.  “I always post on Monday nights, except for…”  Argh!
But after thinking about the purpose of my blog, to educate and help others, I
started to find peace with it.  None of us is perfect, and we all need to take care
of ourselves.  Me included.  My health versus my article’s deadline.  I needed to
take that extra day and get better before finishing… er… unfinishing and then
refinishing the editing.&lt;/p&gt;
&lt;h2 id="capturing-the-leading-block-quote-text"&gt;Capturing the Leading Block Quote Text&lt;a class="headerlink" href="#capturing-the-leading-block-quote-text" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In its simplest form, the handling of container block elements and their tokens is a
relatively easy concept. Every line of a Markdown document enclosed within a container
block element is usually prefaced with one or more characters that denote the presence
of that container element.  For Block Quotes these are character sequences with the
&lt;code&gt;&amp;gt;&lt;/code&gt; character and an optional whitespace, and for Lists these are whitespaces.  To make
the processing of those contained lines easier, at the start of the project I took some
up-front time to ensure that
the container block element processing is independent of the leaf block element
processing.  As such, I was able to work on that leaf block processing independently of
container block processing.&lt;/p&gt;
&lt;p&gt;When I was doing the initial research for
&lt;a href="https://jackdewinter.github.io/2020/06/29/markdown-linter-rabbit-hole-3-trying-to-dig-myself-out/#keeping-the-scope-small"&gt;container block support&lt;/a&gt;,
I started with List tokens.  I quickly wrote a proof of concept for the line/column
number check and was happy to find that I had already placed the required information
in the token.  However, after using the same process with Block Quote tokens, it was
evident that I had missed the mark with them.  Unlike the List tokens, none of the
required
information was placed within the Block Quote tokens.  At that time, after having
gone down a
&lt;a href="https://jackdewinter.github.io/2020/06/15/markdown-linter-rabbit-hole-1-adding-consistency-checks/"&gt;rabbit hole for a bit&lt;/a&gt;,
I wisely decided to wait until later to implement that.   Well, that time was now and
I knew it was going to take some work to add it.&lt;/p&gt;
&lt;h3 id="addressing-the-issue"&gt;Addressing the Issue&lt;a class="headerlink" href="#addressing-the-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like the work I did for List Block tokens, the Block Quote stack token needed a
change to support the &lt;code&gt;matching_markdown_token&lt;/code&gt; field.  This field is pivotal to
inform the processor of the latest markdown token that is containing other tokens.
But to properly use this field, it would take a bit of disassembly and reassembly.
Before this change, the code to add the necessary tokens to the two relevant stacks
were:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BlockQuoteStackToken&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;container_level_tokens&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;BlockQuoteMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adjusted_position_marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Two different tokens and two different stacks, with nothing between them.  With this new
functionality in place, that code needed some slight changes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;new_markdown_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BlockQuoteMarkdownToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adjusted_position_marker&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;container_level_tokens&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_markdown_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;BlockQuoteStackToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_markdown_token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of two distinct tokens, there was now a stack token that included a reference
to the Markdown token that it represented.  &lt;/p&gt;
&lt;p&gt;With that field properly initialized, the &lt;code&gt;add_leading_spaces&lt;/code&gt; function was then added
to make use of that new field.  It is
a simple function that adds any extracted text (usually whitespace) to its
field, separating any new text from the existing text using a newline character.
The function itself is very boring.  The interesting part about the function would be in
locating where that function needed to be called from and using it properly.&lt;/p&gt;
&lt;h3 id="the-first-one-is-almost-always-easy"&gt;The First One Is Almost Always Easy&lt;a class="headerlink" href="#the-first-one-is-almost-always-easy" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first location was obvious: within the &lt;code&gt;__handle_block_quote_section&lt;/code&gt; function
of the &lt;code&gt;BlockQuoteProcessor&lt;/code&gt; class.  This is where the bulk of the processing of
Bulk Quote elements and their effects go through.  In there is an easy to find block of
code that records the number of characters removed and resets the string to exclude
those characters:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;line_to_parse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
            &lt;span class="n"&gt;removed_chars_at_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That block of code was slightly modified to record that removed text and place it into
its own variable:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;removed_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;LOGGER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;line_to_parse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
            &lt;span class="n"&gt;removed_chars_at_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the removed text in hand, the code just needed to know which token to associate the
removed text with. As the code processes Block Quote elements, it was reasonable to
assume that the most relevant Block Quote stack token is the last one on the stack.
That stack token was easily found with a simple for loop:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;found_stack_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;stack_index&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="o"&gt;...&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stack_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_block_quote&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;found_stack_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stack_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the extracted text and the ‘top’ stack token, the only thing that was left to
do was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;found_stack_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matching_markdown_token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_leading_spaces&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;removed_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Almost right away, I was off to a good start on extracting the leading spaces for the
Block Quote token and storing them.&lt;/p&gt;
&lt;h3 id="locating-the-next-issue"&gt;Locating the Next Issue&lt;a class="headerlink" href="#locating-the-next-issue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After those changes were in place, I ran the scenario tests again, seeing almost every
test that has a Block Quote token fail.  My heart dropped.  But after a second, I
realized that I wanted that to happen.  As I wanted to make sure each Block Quote token
was verified, I added the leading space data to the end of the string for the
&lt;code&gt;BlockQuoteMarkdownToken&lt;/code&gt; class, separated from the rest with the &lt;code&gt;:&lt;/code&gt; character.  If
things worked properly, that meant every Block Quote token would, at the very least,
now include an extra &lt;code&gt;:&lt;/code&gt; character.  Every serialized Block Quote token was now “wrong”,
so every Block Quote scenario test should fail.  Good!&lt;/p&gt;
&lt;p&gt;Working through each case was decently fast, with a solid methodical process in place:
look at
the results, find the next failing test, and manually determine what change needed to
be made to the Block Quote token.  After making that change to the test data, I would
then re-run that specific scenario test, and check for token differences.&lt;/p&gt;
&lt;p&gt;It was by using this process that I found the next issue: missing leading whitespace.
In some cases, the leading text that was extracted was preceded by one of more
whitespaces. Those whitespaces were stuffed into the &lt;code&gt;extracted_whitespace&lt;/code&gt; variable
and then ignored after that.  The resolution to that issue was
simple.  Instead of only adding the leading space to the &lt;code&gt;removed_text&lt;/code&gt; variable,
the contents of that &lt;code&gt;extracted_whitespace&lt;/code&gt; needed to be added to the variable, as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;removed_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;position_marker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index_number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running the tests again, a new block of tests started passing.&lt;/p&gt;
&lt;h3 id="and-next-blank-lines"&gt;And Next… Blank Lines&lt;a class="headerlink" href="#and-next-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As more and more of the Block Quote scenario tests were changed and started passing,
there were a handful of tests that were failing that I left for later.  When I got
to the end of those tests, I went back and started to look at those failing tests
one-by-one.&lt;/p&gt;
&lt;p&gt;The first group of failures that I examined were ones in which there was a Blank
Line element contained within a Block Quote. A good example of this is
&lt;a href="https://github.github.com/gfm/#example-222"&gt;example 222&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In these cases, the parsing was
correct, but the newly added &lt;code&gt;add_leading_spaces&lt;/code&gt; function was not being called.  The
outcome
was that the number of newlines contained within the owning Block Quote token did
not match the number of lines within the Block Quote element itself.  To ensure
that those two values lined up, the &lt;code&gt;add_leading_spaces&lt;/code&gt; function was called with
an empty string, thereby evening up those values.&lt;/p&gt;
&lt;p&gt;Running the scenario tests again, all the scenario tests explicitly for Block Quotes
were passing.  I then ran the scenario tests again, checking to make sure that the
scenario tests with Block Quotes and Blank Lines passed. While the new changes were
now passing, there were still a handful of tests to work on.&lt;/p&gt;
&lt;h3 id="and-finally-html-blocks"&gt;And Finally, HTML Blocks&lt;a class="headerlink" href="#and-finally-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having run the scenario tests again, the only tests that were not passing were
scenario tests that included Block Quotes and HTML blocks.  Doing some research into
the issue, I quickly found
that it looked like the same issue with the Blank Line elements, just with HTML blocks.
This issue was uncovered through one of my additional tests, “cov_2” used to increase
coverage on the various forms of HTML start and end tags:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/hrx&lt;/span&gt;
&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x-table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like the previous issue with Blank Line tokens, the number of new lines were not lining
up between the two sources.  Once again, calling the &lt;code&gt;add_leading_spaces&lt;/code&gt; function
with an empty string in these cases solved the issue.&lt;/p&gt;
&lt;h3 id="closing-out-the-token-changes"&gt;Closing Out the Token Changes&lt;a class="headerlink" href="#closing-out-the-token-changes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After those changes has been completed, it was obvious that all the scenario tests were
passing.  Just to be sure, I manually went through each of the scenarios and verified
the newly changed tokens.  As I have said before, maybe I am paranoid, but if I was
depending on those results, I figured an extra pass or two would not hurt.&lt;/p&gt;
&lt;p&gt;It just felt good to get these changes completed.  I had a high degree of confidence
that I was able to find most of these issues, but an even higher degree of confidence
that the remaining work would flush out anything that I missed.  It was with those
positive thoughts in my head that I started working on the consistency checks.&lt;/p&gt;
&lt;h2 id="validating-the-line-numbers-and-column-numbers"&gt;Validating the Line Numbers and Column Numbers&lt;a class="headerlink" href="#validating-the-line-numbers-and-column-numbers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With that confidence, I started working on the consistency checks for line numbers
and column numbers.  The first step in doing this was removing a couple of lines
of code that prevented the consistency checks from firing if one of the tokens was
a Block Quote token.  It was useful when I did not have anything in place, but now
it would just get in the way.&lt;/p&gt;
&lt;p&gt;After that change, tests predictably started failing, but I was ready for them.  From
the work
that I had just completed, I figured that I would have to follow a similar path in
implementing the consistency check.  Therefore, the first thing I did to help with
the consistency check is to reset the &lt;code&gt;leading_text_index&lt;/code&gt; field of the
&lt;code&gt;BlockQuoteMarkdownToken&lt;/code&gt; instance to 0 when it is encountered.  This made sure that
the tracking of the leading spaces would always start with the first entry.&lt;/p&gt;
&lt;p&gt;With that done, the code needed to take advantage of that was easy to write.
When a token exists on a new line, it’s indent must be determined by tracking the
size of the removed text and adding that measurement to the column number.  Based
on the previous work, this becomes trivially easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;split_leading_spaces&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leading_spaces&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;init_ws&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;split_leading_spaces&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;top_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leading_text_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, grab the top Block Quote token, split it into lines, and use the
&lt;code&gt;leading_text_index&lt;/code&gt; value of that topmost token to grab the right leading space.&lt;/p&gt;
&lt;p&gt;From there, the new work mirrored the work that I did in preparing the tokens.  When a
Blank Line token is encountered, that index is incremented.  For each line of
text within an HTML block, that index is incremented.  And in addition, that
&lt;code&gt;leading_text_index&lt;/code&gt; field needed to be tweaked at the end of HTML blocks,
Atx Heading blocks, and Paragraph blocks, which was something I figured might
come up.  Just some simple cases where a bit of extra finessing was needed.&lt;/p&gt;
&lt;p&gt;To be clear, I was not 100% percent sure that this would happen, but I was hoping that
it would.  To me it made sense that if I needed to add code to track the leading
spaces that were removed, any consistency check would need to follow that same path
to verify the information.  And as to the extra tweak for the end tokens, I was
confident that it was a solid change, and was not worried about that deviation from
the previous work.&lt;/p&gt;
&lt;h2 id="writing-the-block-quote-markdown-transformations"&gt;Writing the Block Quote Markdown Transformations&lt;a class="headerlink" href="#writing-the-block-quote-markdown-transformations" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given the work I had just completed to get to this point, it was obvious to me that
I was going to have to do a lot of fiddling with spaces to get the transformations
correct.  To make that job a bit easier, I decided for the moment to eliminate any
Markdown documents which contained both Block Quote elements and List elements.
I would get back to these quickly, but at that moment, it was just too much.&lt;/p&gt;
&lt;p&gt;The processing of the start and end of the Block Quote elements were simple,
largely mimicking the work I did for the List elements.  When a Block Quote token
was processed, it created a copy of itself and added that copy to the top of the
&lt;code&gt;container_token_stack&lt;/code&gt; list.  From there, the leading space were retrieved from
their storage in the token and added to the sequence to be emitted.  The end
of the Block Quote element was even easier, returning an empty string after removing
the top token off the &lt;code&gt;container_token_stack&lt;/code&gt; list.  The work I had previously done
on setting up the leading spaces was really paying off.&lt;/p&gt;
&lt;p&gt;With the work to recognize and process the actual tokens taken care of, the main
task ahead of me was to add and populate the &lt;code&gt;__perform_container_post_processing_block_quote&lt;/code&gt; function.  Like how List
Block tokens were handled in the
&lt;code&gt;__perform_container_post_processing_lists&lt;/code&gt; function, this new function was used
to handle the newline processing for text enclosed within Block Quote elements.
After having completed all this other work, that work was relatively simple to do.
With all the individual token processing already
performed, this function just needed to focus on detecting newline characters.
For each of these characters encountered, the top Block Quote token would be
used to determine the current &lt;code&gt;leading_text_index&lt;/code&gt; to start with.  With each
newline encountered, the current split value would be used, incrementing the
&lt;code&gt;leading_text_index&lt;/code&gt; value afterwards.  This pretty much worked flawlessly out
of the box.&lt;/p&gt;
&lt;h3 id="as-i-was-cleaning-up"&gt;As I was cleaning up&lt;a class="headerlink" href="#as-i-was-cleaning-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;An interesting issue came up as I was generating these transformations.
For some reason, I had missed some cases involving Block Quote elements that
contained Fenced Code Block elements.  With the Markdown transformer now rehydrating
the Markdown, it was obvious that things were missing.  It did not take me long to
figure out that the Fenced Code Blocks were missing their Block Quote leading
characters.  This was found for
&lt;a href="https://github.github.com/gfm/#example-98"&gt;example 98&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;aaa&lt;/span&gt;

&lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the transformer tried to rehydrate the document, it rehydrated that Markdown
text without the leading &lt;code&gt;&amp;gt;&lt;/code&gt; sequence before the text &lt;code&gt;aaa&lt;/code&gt;.  Having just gone
through that research for other elements, I was quick to spot it and realize where
the issue was.  A couple of quick changes, and that change was passing!&lt;/p&gt;
&lt;h3 id="along-the-way"&gt;Along the Way&lt;a class="headerlink" href="#along-the-way" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;And to hammer home the point that this consistency checking is good, it found some
issues along the way.&lt;/p&gt;
&lt;p&gt;The first one was an interesting issue where the starting whitespace for one
transformation was missing.  And it was such a weird case.  It was an Atx Heading
element that contained a Shortcut Link element as its only text, separated from the Atx
Heading character ( &lt;code&gt;#&lt;/code&gt; ) by the mandatory single space. That is really important.  Two
space it was okay with, but the one space, nope! Due to the way that
it was parsed, that spaces were missing and not accounted for.  The fix to this was
to add that starting whitespace as a new token containing that removed text, but with
a twist.  That twist was to use the &lt;code&gt;create_replace_with_nothing_marker&lt;/code&gt; function to
add that text as itself for the Markdown transformer, but keep it as removed for the
HTML transformer.  With both transformers appeased, it was on to the next issue.&lt;/p&gt;
&lt;p&gt;The second issue that I uncovered was that, in rare cases, the leading spaces for
certain lines were missing.  After doing some digging, it only appeared to be lines
that did not have any block quote prefix characters removed from the line.  So
after adding a new &lt;code&gt;__adjust_paragraph_for_block_quotes&lt;/code&gt; function to the
&lt;code&gt;LeafBlockProcessor&lt;/code&gt; and wiring it into the &lt;code&gt;parse_paragraph&lt;/code&gt; function, the debug
confirmed that it was only those few cases where that was an issue.&lt;/p&gt;
&lt;h2 id="and-of-course-some-cleanup"&gt;And Of Course, Some Cleanup&lt;a class="headerlink" href="#and-of-course-some-cleanup" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It would not be a proper week of coding if I did not do some cleanup.  In this case,
the cleanup was simple: relocating the line/column number logic to its own
module.  One of the things that made the Markdown transformations easy to deal with
is that those transformations are in their own &lt;code&gt;TransformToMarkdown&lt;/code&gt; class.
That worked well.  The
line/column number checks were in with some other validation code in the &lt;code&gt;utils.py&lt;/code&gt;
module.  That worked… well… okay?&lt;/p&gt;
&lt;p&gt;When I started with the consistency checks, they were new, and keeping all that code
in the &lt;code&gt;utils.py&lt;/code&gt; module made sense.  But as the amount of code in the module grew, I
never took the time to to some refactoring.  As such, the module developed two
responsibilities. The first was to be the location for all the &lt;code&gt;assert_*&lt;/code&gt; functions
and the &lt;code&gt;write_temporary_configuration&lt;/code&gt; functions.  Those are all the functions that are
called directly from the tests, mostly in the final Assert stage of the test.  The
second was to house the logic for the line/column number consistency checks.&lt;/p&gt;
&lt;p&gt;It just seemed logical, now that that part of the code was stable and well-tested, to
take that second responsibility and put it into its own module. I created the
&lt;code&gt;verify_line_and_column_numbers.py&lt;/code&gt; module and started moving the functions into it,
with the &lt;code&gt;verify_line_and_column_numbers&lt;/code&gt; function being the main entry point for
the module.  It just seemed cleaner and more compact.  One module, one responsibility.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The dominant part of my experience at the current moment is one of humility and
patience.  Yes, it is Tuesday night. And after a little over 3 hours of extra work,
I have finally recovered the article to where it was at this time last night. I
do feel an impulse to be hard on myself about this delay, but I also am working
hard to remember to be patient with myself.  This is one time where I am missing a
deadline, and it probably will not be the last.&lt;/p&gt;
&lt;p&gt;The humility that I am trying to practice is in understanding that I cannot do
everything all the time.  I know that sounds like it should be an obvious thing to
know, but I think we all forget it from time to time.  I was so focused on making
sure that I met my deadline, that I neglected to have a conversation with myself
on whether that was the right choice.  But it was not a large rabbit hole,
just a small one that I was able to easily recover from.&lt;/p&gt;
&lt;p&gt;Focusing more on the actual work that I accomplished, I was buoyed.  I was long
worried about how hard it would be to implement the consistency checks for Block
Quote tokens.  Having completed that work, I now am trying to figure out why I was
worried.  Trying to figure it out now, I would guess I would focus on what it took
to complete that work with lists.  That work was very nitpicky because it contained a
lot of “empty” whitespace, if I am remembering it clearly.  From the effort that it
took to deal with that, I can see how I might have thought it would have taken the same
effort for Block Quote tokens.&lt;/p&gt;
&lt;p&gt;But it did not.  The work I had done in that area on List tokens forced me to get things
set up to make List token processing easier, which I believe Block Quotes benefited
from.  Regardless, I was glad that I could close the books on the Block Quote tokens
and their consistency checks.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With all the block token consistency checks now taken care of, there was a bit of clean
up to do with determining the height of each block token.  While I initially thought
that it would be easy, it did not turn out that way.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category><category term="core linter"></category></entry></feed>